var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/dotenv/package.json
var require_package = __commonJS({
  "node_modules/dotenv/package.json"(exports2, module2) {
    module2.exports = {
      name: "dotenv",
      version: "16.0.3",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          require: "./lib/main.js",
          types: "./lib/main.d.ts",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        "lint-readme": "standard-markdown",
        pretest: "npm run lint && npm run dts-check",
        test: "tap tests/*.js --100 -Rspec",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@types/node": "^17.0.9",
        decache: "^4.6.1",
        dtslint: "^3.7.0",
        sinon: "^12.0.1",
        standard: "^16.0.4",
        "standard-markdown": "^7.1.0",
        "standard-version": "^9.3.2",
        tap: "^15.1.6",
        tar: "^6.1.11",
        typescript: "^4.5.4"
      },
      engines: {
        node: ">=12"
      }
    };
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports2, module2) {
    var fs2 = require("fs");
    var path = require("path");
    var os = require("os");
    var packageJson = require_package();
    var version = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _log(message) {
      console.log(`[dotenv@${version}][DEBUG] ${message}`);
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function config(options) {
      let dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (options) {
        if (options.path != null) {
          dotenvPath = _resolveHome(options.path);
        }
        if (options.encoding != null) {
          encoding = options.encoding;
        }
      }
      try {
        const parsed = DotenvModule.parse(fs2.readFileSync(dotenvPath, { encoding }));
        Object.keys(parsed).forEach(function(key) {
          if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
            process.env[key] = parsed[key];
          } else {
            if (override === true) {
              process.env[key] = parsed[key];
            }
            if (debug) {
              if (override === true) {
                _log(`"${key}" is already defined in \`process.env\` and WAS overwritten`);
              } else {
                _log(`"${key}" is already defined in \`process.env\` and was NOT overwritten`);
              }
            }
          }
        });
        return { parsed };
      } catch (e) {
        if (debug) {
          _log(`Failed to load ${dotenvPath} ${e.message}`);
        }
        return { error: e };
      }
    }
    var DotenvModule = {
      config,
      parse
    };
    module2.exports.config = DotenvModule.config;
    module2.exports.parse = DotenvModule.parse;
    module2.exports = DotenvModule;
  }
});

// node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.push(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.push(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol")
    name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m)
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
      __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle2(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle2(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle2(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle2(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle2(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
var extendStatics, __assign, __createBinding, __setModuleDefault;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
  }
});

// node_modules/discord-api-types/gateway/common.js
var require_common = __commonJS({
  "node_modules/discord-api-types/gateway/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/gateway/v10.js
var require_v10 = __commonJS({
  "node_modules/discord-api-types/gateway/v10.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GatewayDispatchEvents = exports2.GatewayIntentBits = exports2.GatewayCloseCodes = exports2.GatewayOpcodes = exports2.GatewayVersion = void 0;
    __exportStar2(require_common(), exports2);
    exports2.GatewayVersion = "10";
    var GatewayOpcodes;
    (function(GatewayOpcodes2) {
      GatewayOpcodes2[GatewayOpcodes2["Dispatch"] = 0] = "Dispatch";
      GatewayOpcodes2[GatewayOpcodes2["Heartbeat"] = 1] = "Heartbeat";
      GatewayOpcodes2[GatewayOpcodes2["Identify"] = 2] = "Identify";
      GatewayOpcodes2[GatewayOpcodes2["PresenceUpdate"] = 3] = "PresenceUpdate";
      GatewayOpcodes2[GatewayOpcodes2["VoiceStateUpdate"] = 4] = "VoiceStateUpdate";
      GatewayOpcodes2[GatewayOpcodes2["Resume"] = 6] = "Resume";
      GatewayOpcodes2[GatewayOpcodes2["Reconnect"] = 7] = "Reconnect";
      GatewayOpcodes2[GatewayOpcodes2["RequestGuildMembers"] = 8] = "RequestGuildMembers";
      GatewayOpcodes2[GatewayOpcodes2["InvalidSession"] = 9] = "InvalidSession";
      GatewayOpcodes2[GatewayOpcodes2["Hello"] = 10] = "Hello";
      GatewayOpcodes2[GatewayOpcodes2["HeartbeatAck"] = 11] = "HeartbeatAck";
    })(GatewayOpcodes = exports2.GatewayOpcodes || (exports2.GatewayOpcodes = {}));
    var GatewayCloseCodes;
    (function(GatewayCloseCodes2) {
      GatewayCloseCodes2[GatewayCloseCodes2["UnknownError"] = 4e3] = "UnknownError";
      GatewayCloseCodes2[GatewayCloseCodes2["UnknownOpcode"] = 4001] = "UnknownOpcode";
      GatewayCloseCodes2[GatewayCloseCodes2["DecodeError"] = 4002] = "DecodeError";
      GatewayCloseCodes2[GatewayCloseCodes2["NotAuthenticated"] = 4003] = "NotAuthenticated";
      GatewayCloseCodes2[GatewayCloseCodes2["AuthenticationFailed"] = 4004] = "AuthenticationFailed";
      GatewayCloseCodes2[GatewayCloseCodes2["AlreadyAuthenticated"] = 4005] = "AlreadyAuthenticated";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidSeq"] = 4007] = "InvalidSeq";
      GatewayCloseCodes2[GatewayCloseCodes2["RateLimited"] = 4008] = "RateLimited";
      GatewayCloseCodes2[GatewayCloseCodes2["SessionTimedOut"] = 4009] = "SessionTimedOut";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidShard"] = 4010] = "InvalidShard";
      GatewayCloseCodes2[GatewayCloseCodes2["ShardingRequired"] = 4011] = "ShardingRequired";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidAPIVersion"] = 4012] = "InvalidAPIVersion";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidIntents"] = 4013] = "InvalidIntents";
      GatewayCloseCodes2[GatewayCloseCodes2["DisallowedIntents"] = 4014] = "DisallowedIntents";
    })(GatewayCloseCodes = exports2.GatewayCloseCodes || (exports2.GatewayCloseCodes = {}));
    var GatewayIntentBits2;
    (function(GatewayIntentBits3) {
      GatewayIntentBits3[GatewayIntentBits3["Guilds"] = 1] = "Guilds";
      GatewayIntentBits3[GatewayIntentBits3["GuildMembers"] = 2] = "GuildMembers";
      GatewayIntentBits3[GatewayIntentBits3["GuildModeration"] = 4] = "GuildModeration";
      GatewayIntentBits3[GatewayIntentBits3["GuildBans"] = 4] = "GuildBans";
      GatewayIntentBits3[GatewayIntentBits3["GuildEmojisAndStickers"] = 8] = "GuildEmojisAndStickers";
      GatewayIntentBits3[GatewayIntentBits3["GuildIntegrations"] = 16] = "GuildIntegrations";
      GatewayIntentBits3[GatewayIntentBits3["GuildWebhooks"] = 32] = "GuildWebhooks";
      GatewayIntentBits3[GatewayIntentBits3["GuildInvites"] = 64] = "GuildInvites";
      GatewayIntentBits3[GatewayIntentBits3["GuildVoiceStates"] = 128] = "GuildVoiceStates";
      GatewayIntentBits3[GatewayIntentBits3["GuildPresences"] = 256] = "GuildPresences";
      GatewayIntentBits3[GatewayIntentBits3["GuildMessages"] = 512] = "GuildMessages";
      GatewayIntentBits3[GatewayIntentBits3["GuildMessageReactions"] = 1024] = "GuildMessageReactions";
      GatewayIntentBits3[GatewayIntentBits3["GuildMessageTyping"] = 2048] = "GuildMessageTyping";
      GatewayIntentBits3[GatewayIntentBits3["DirectMessages"] = 4096] = "DirectMessages";
      GatewayIntentBits3[GatewayIntentBits3["DirectMessageReactions"] = 8192] = "DirectMessageReactions";
      GatewayIntentBits3[GatewayIntentBits3["DirectMessageTyping"] = 16384] = "DirectMessageTyping";
      GatewayIntentBits3[GatewayIntentBits3["MessageContent"] = 32768] = "MessageContent";
      GatewayIntentBits3[GatewayIntentBits3["GuildScheduledEvents"] = 65536] = "GuildScheduledEvents";
      GatewayIntentBits3[GatewayIntentBits3["AutoModerationConfiguration"] = 1048576] = "AutoModerationConfiguration";
      GatewayIntentBits3[GatewayIntentBits3["AutoModerationExecution"] = 2097152] = "AutoModerationExecution";
    })(GatewayIntentBits2 = exports2.GatewayIntentBits || (exports2.GatewayIntentBits = {}));
    var GatewayDispatchEvents;
    (function(GatewayDispatchEvents2) {
      GatewayDispatchEvents2["ApplicationCommandPermissionsUpdate"] = "APPLICATION_COMMAND_PERMISSIONS_UPDATE";
      GatewayDispatchEvents2["ChannelCreate"] = "CHANNEL_CREATE";
      GatewayDispatchEvents2["ChannelDelete"] = "CHANNEL_DELETE";
      GatewayDispatchEvents2["ChannelPinsUpdate"] = "CHANNEL_PINS_UPDATE";
      GatewayDispatchEvents2["ChannelUpdate"] = "CHANNEL_UPDATE";
      GatewayDispatchEvents2["GuildBanAdd"] = "GUILD_BAN_ADD";
      GatewayDispatchEvents2["GuildBanRemove"] = "GUILD_BAN_REMOVE";
      GatewayDispatchEvents2["GuildCreate"] = "GUILD_CREATE";
      GatewayDispatchEvents2["GuildDelete"] = "GUILD_DELETE";
      GatewayDispatchEvents2["GuildEmojisUpdate"] = "GUILD_EMOJIS_UPDATE";
      GatewayDispatchEvents2["GuildIntegrationsUpdate"] = "GUILD_INTEGRATIONS_UPDATE";
      GatewayDispatchEvents2["GuildMemberAdd"] = "GUILD_MEMBER_ADD";
      GatewayDispatchEvents2["GuildMemberRemove"] = "GUILD_MEMBER_REMOVE";
      GatewayDispatchEvents2["GuildMembersChunk"] = "GUILD_MEMBERS_CHUNK";
      GatewayDispatchEvents2["GuildMemberUpdate"] = "GUILD_MEMBER_UPDATE";
      GatewayDispatchEvents2["GuildRoleCreate"] = "GUILD_ROLE_CREATE";
      GatewayDispatchEvents2["GuildRoleDelete"] = "GUILD_ROLE_DELETE";
      GatewayDispatchEvents2["GuildRoleUpdate"] = "GUILD_ROLE_UPDATE";
      GatewayDispatchEvents2["GuildStickersUpdate"] = "GUILD_STICKERS_UPDATE";
      GatewayDispatchEvents2["GuildUpdate"] = "GUILD_UPDATE";
      GatewayDispatchEvents2["IntegrationCreate"] = "INTEGRATION_CREATE";
      GatewayDispatchEvents2["IntegrationDelete"] = "INTEGRATION_DELETE";
      GatewayDispatchEvents2["IntegrationUpdate"] = "INTEGRATION_UPDATE";
      GatewayDispatchEvents2["InteractionCreate"] = "INTERACTION_CREATE";
      GatewayDispatchEvents2["InviteCreate"] = "INVITE_CREATE";
      GatewayDispatchEvents2["InviteDelete"] = "INVITE_DELETE";
      GatewayDispatchEvents2["MessageCreate"] = "MESSAGE_CREATE";
      GatewayDispatchEvents2["MessageDelete"] = "MESSAGE_DELETE";
      GatewayDispatchEvents2["MessageDeleteBulk"] = "MESSAGE_DELETE_BULK";
      GatewayDispatchEvents2["MessageReactionAdd"] = "MESSAGE_REACTION_ADD";
      GatewayDispatchEvents2["MessageReactionRemove"] = "MESSAGE_REACTION_REMOVE";
      GatewayDispatchEvents2["MessageReactionRemoveAll"] = "MESSAGE_REACTION_REMOVE_ALL";
      GatewayDispatchEvents2["MessageReactionRemoveEmoji"] = "MESSAGE_REACTION_REMOVE_EMOJI";
      GatewayDispatchEvents2["MessageUpdate"] = "MESSAGE_UPDATE";
      GatewayDispatchEvents2["PresenceUpdate"] = "PRESENCE_UPDATE";
      GatewayDispatchEvents2["StageInstanceCreate"] = "STAGE_INSTANCE_CREATE";
      GatewayDispatchEvents2["StageInstanceDelete"] = "STAGE_INSTANCE_DELETE";
      GatewayDispatchEvents2["StageInstanceUpdate"] = "STAGE_INSTANCE_UPDATE";
      GatewayDispatchEvents2["Ready"] = "READY";
      GatewayDispatchEvents2["Resumed"] = "RESUMED";
      GatewayDispatchEvents2["ThreadCreate"] = "THREAD_CREATE";
      GatewayDispatchEvents2["ThreadDelete"] = "THREAD_DELETE";
      GatewayDispatchEvents2["ThreadListSync"] = "THREAD_LIST_SYNC";
      GatewayDispatchEvents2["ThreadMembersUpdate"] = "THREAD_MEMBERS_UPDATE";
      GatewayDispatchEvents2["ThreadMemberUpdate"] = "THREAD_MEMBER_UPDATE";
      GatewayDispatchEvents2["ThreadUpdate"] = "THREAD_UPDATE";
      GatewayDispatchEvents2["TypingStart"] = "TYPING_START";
      GatewayDispatchEvents2["UserUpdate"] = "USER_UPDATE";
      GatewayDispatchEvents2["VoiceServerUpdate"] = "VOICE_SERVER_UPDATE";
      GatewayDispatchEvents2["VoiceStateUpdate"] = "VOICE_STATE_UPDATE";
      GatewayDispatchEvents2["WebhooksUpdate"] = "WEBHOOKS_UPDATE";
      GatewayDispatchEvents2["GuildScheduledEventCreate"] = "GUILD_SCHEDULED_EVENT_CREATE";
      GatewayDispatchEvents2["GuildScheduledEventUpdate"] = "GUILD_SCHEDULED_EVENT_UPDATE";
      GatewayDispatchEvents2["GuildScheduledEventDelete"] = "GUILD_SCHEDULED_EVENT_DELETE";
      GatewayDispatchEvents2["GuildScheduledEventUserAdd"] = "GUILD_SCHEDULED_EVENT_USER_ADD";
      GatewayDispatchEvents2["GuildScheduledEventUserRemove"] = "GUILD_SCHEDULED_EVENT_USER_REMOVE";
      GatewayDispatchEvents2["AutoModerationRuleCreate"] = "AUTO_MODERATION_RULE_CREATE";
      GatewayDispatchEvents2["AutoModerationRuleUpdate"] = "AUTO_MODERATION_RULE_UPDATE";
      GatewayDispatchEvents2["AutoModerationRuleDelete"] = "AUTO_MODERATION_RULE_DELETE";
      GatewayDispatchEvents2["AutoModerationActionExecution"] = "AUTO_MODERATION_ACTION_EXECUTION";
      GatewayDispatchEvents2["GuildAuditLogEntryCreate"] = "GUILD_AUDIT_LOG_ENTRY_CREATE";
    })(GatewayDispatchEvents = exports2.GatewayDispatchEvents || (exports2.GatewayDispatchEvents = {}));
  }
});

// node_modules/discord-api-types/globals.js
var require_globals = __commonJS({
  "node_modules/discord-api-types/globals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FormattingPatterns = void 0;
    exports2.FormattingPatterns = {
      /**
       * Regular expression for matching a user mention, strictly without a nickname
       *
       * The `id` group property is present on the `exec` result of this expression
       */
      User: /<@(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a user mention, strictly with a nickname
       *
       * The `id` group property is present on the `exec` result of this expression
       * @deprecated Passing `!` in user mentions is no longer necessary / supported, and future message contents won't have it
       */
      UserWithNickname: /<@!(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a user mention, with or without a nickname
       *
       * The `id` group property is present on the `exec` result of this expression
       * @deprecated Passing `!` in user mentions is no longer necessary / supported, and future message contents won't have it
       */
      UserWithOptionalNickname: /<@!?(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a channel mention
       *
       * The `id` group property is present on the `exec` result of this expression
       */
      Channel: /<#(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a role mention
       *
       * The `id` group property is present on the `exec` result of this expression
       */
      Role: /<@&(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a application command mention
       *
       * The `fullName` (possibly including `name`, `subcommandOrGroup` and `subcommand`) and `id` group properties are present on the `exec` result of this expression
       */
      SlashCommand: /<\/(?<fullName>(?<name>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32})(?: (?<subcommandOrGroup>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?(?: (?<subcommand>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?):(?<id>\d{17,20})>/u,
      /**
       * Regular expression for matching a custom emoji, either static or animated
       *
       * The `animated`, `name` and `id` group properties are present on the `exec` result of this expression
       */
      Emoji: /<(?<animated>a)?:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching strictly an animated custom emoji
       *
       * The `animated`, `name` and `id` group properties are present on the `exec` result of this expression
       */
      AnimatedEmoji: /<(?<animated>a):(?<name>\w{2,32}):(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching strictly a static custom emoji
       *
       * The `name` and `id` group properties are present on the `exec` result of this expression
       */
      StaticEmoji: /<:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a timestamp, either default or custom styled
       *
       * The `timestamp` and `style` group properties are present on the `exec` result of this expression
       */
      Timestamp: /<t:(?<timestamp>-?\d{1,13})(:(?<style>[tTdDfFR]))?>/,
      /**
       * Regular expression for matching strictly default styled timestamps
       *
       * The `timestamp` group property is present on the `exec` result of this expression
       */
      DefaultStyledTimestamp: /<t:(?<timestamp>-?\d{1,13})>/,
      /**
       * Regular expression for matching strictly custom styled timestamps
       *
       * The `timestamp` and `style` group properties are present on the `exec` result of this expression
       */
      StyledTimestamp: /<t:(?<timestamp>-?\d{1,13}):(?<style>[tTdDfFR])>/
    };
    Object.freeze(exports2.FormattingPatterns);
  }
});

// node_modules/discord-api-types/payloads/common.js
var require_common2 = __commonJS({
  "node_modules/discord-api-types/payloads/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PermissionFlagsBits = void 0;
    exports2.PermissionFlagsBits = {
      CreateInstantInvite: 1n << 0n,
      KickMembers: 1n << 1n,
      BanMembers: 1n << 2n,
      Administrator: 1n << 3n,
      ManageChannels: 1n << 4n,
      ManageGuild: 1n << 5n,
      AddReactions: 1n << 6n,
      ViewAuditLog: 1n << 7n,
      PrioritySpeaker: 1n << 8n,
      Stream: 1n << 9n,
      ViewChannel: 1n << 10n,
      SendMessages: 1n << 11n,
      SendTTSMessages: 1n << 12n,
      ManageMessages: 1n << 13n,
      EmbedLinks: 1n << 14n,
      AttachFiles: 1n << 15n,
      ReadMessageHistory: 1n << 16n,
      MentionEveryone: 1n << 17n,
      UseExternalEmojis: 1n << 18n,
      ViewGuildInsights: 1n << 19n,
      Connect: 1n << 20n,
      Speak: 1n << 21n,
      MuteMembers: 1n << 22n,
      DeafenMembers: 1n << 23n,
      MoveMembers: 1n << 24n,
      UseVAD: 1n << 25n,
      ChangeNickname: 1n << 26n,
      ManageNicknames: 1n << 27n,
      ManageRoles: 1n << 28n,
      ManageWebhooks: 1n << 29n,
      ManageEmojisAndStickers: 1n << 30n,
      UseApplicationCommands: 1n << 31n,
      RequestToSpeak: 1n << 32n,
      ManageEvents: 1n << 33n,
      ManageThreads: 1n << 34n,
      CreatePublicThreads: 1n << 35n,
      CreatePrivateThreads: 1n << 36n,
      UseExternalStickers: 1n << 37n,
      SendMessagesInThreads: 1n << 38n,
      UseEmbeddedActivities: 1n << 39n,
      ModerateMembers: 1n << 40n
    };
    Object.freeze(exports2.PermissionFlagsBits);
  }
});

// node_modules/discord-api-types/payloads/v10/application.js
var require_application = __commonJS({
  "node_modules/discord-api-types/payloads/v10/application.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationRoleConnectionMetadataType = exports2.ApplicationFlags = void 0;
    var ApplicationFlags;
    (function(ApplicationFlags2) {
      ApplicationFlags2[ApplicationFlags2["EmbeddedReleased"] = 2] = "EmbeddedReleased";
      ApplicationFlags2[ApplicationFlags2["ManagedEmoji"] = 4] = "ManagedEmoji";
      ApplicationFlags2[ApplicationFlags2["EmbeddedIAP"] = 8] = "EmbeddedIAP";
      ApplicationFlags2[ApplicationFlags2["GroupDMCreate"] = 16] = "GroupDMCreate";
      ApplicationFlags2[ApplicationFlags2["ApplicationAutoModerationRuleCreateBadge"] = 64] = "ApplicationAutoModerationRuleCreateBadge";
      ApplicationFlags2[ApplicationFlags2["RPCHasConnected"] = 2048] = "RPCHasConnected";
      ApplicationFlags2[ApplicationFlags2["GatewayPresence"] = 4096] = "GatewayPresence";
      ApplicationFlags2[ApplicationFlags2["GatewayPresenceLimited"] = 8192] = "GatewayPresenceLimited";
      ApplicationFlags2[ApplicationFlags2["GatewayGuildMembers"] = 16384] = "GatewayGuildMembers";
      ApplicationFlags2[ApplicationFlags2["GatewayGuildMembersLimited"] = 32768] = "GatewayGuildMembersLimited";
      ApplicationFlags2[ApplicationFlags2["VerificationPendingGuildLimit"] = 65536] = "VerificationPendingGuildLimit";
      ApplicationFlags2[ApplicationFlags2["Embedded"] = 131072] = "Embedded";
      ApplicationFlags2[ApplicationFlags2["GatewayMessageContent"] = 262144] = "GatewayMessageContent";
      ApplicationFlags2[ApplicationFlags2["GatewayMessageContentLimited"] = 524288] = "GatewayMessageContentLimited";
      ApplicationFlags2[ApplicationFlags2["EmbeddedFirstParty"] = 1048576] = "EmbeddedFirstParty";
      ApplicationFlags2[ApplicationFlags2["ApplicationCommandBadge"] = 8388608] = "ApplicationCommandBadge";
    })(ApplicationFlags = exports2.ApplicationFlags || (exports2.ApplicationFlags = {}));
    var ApplicationRoleConnectionMetadataType;
    (function(ApplicationRoleConnectionMetadataType2) {
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerLessThanOrEqual"] = 1] = "IntegerLessThanOrEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerGreaterThanOrEqual"] = 2] = "IntegerGreaterThanOrEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerEqual"] = 3] = "IntegerEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerNotEqual"] = 4] = "IntegerNotEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeLessThanOrEqual"] = 5] = "DatetimeLessThanOrEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeGreaterThanOrEqual"] = 6] = "DatetimeGreaterThanOrEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanEqual"] = 7] = "BooleanEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanNotEqual"] = 8] = "BooleanNotEqual";
    })(ApplicationRoleConnectionMetadataType = exports2.ApplicationRoleConnectionMetadataType || (exports2.ApplicationRoleConnectionMetadataType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/auditLog.js
var require_auditLog = __commonJS({
  "node_modules/discord-api-types/payloads/v10/auditLog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuditLogOptionsType = exports2.AuditLogEvent = void 0;
    var AuditLogEvent;
    (function(AuditLogEvent2) {
      AuditLogEvent2[AuditLogEvent2["GuildUpdate"] = 1] = "GuildUpdate";
      AuditLogEvent2[AuditLogEvent2["ChannelCreate"] = 10] = "ChannelCreate";
      AuditLogEvent2[AuditLogEvent2["ChannelUpdate"] = 11] = "ChannelUpdate";
      AuditLogEvent2[AuditLogEvent2["ChannelDelete"] = 12] = "ChannelDelete";
      AuditLogEvent2[AuditLogEvent2["ChannelOverwriteCreate"] = 13] = "ChannelOverwriteCreate";
      AuditLogEvent2[AuditLogEvent2["ChannelOverwriteUpdate"] = 14] = "ChannelOverwriteUpdate";
      AuditLogEvent2[AuditLogEvent2["ChannelOverwriteDelete"] = 15] = "ChannelOverwriteDelete";
      AuditLogEvent2[AuditLogEvent2["MemberKick"] = 20] = "MemberKick";
      AuditLogEvent2[AuditLogEvent2["MemberPrune"] = 21] = "MemberPrune";
      AuditLogEvent2[AuditLogEvent2["MemberBanAdd"] = 22] = "MemberBanAdd";
      AuditLogEvent2[AuditLogEvent2["MemberBanRemove"] = 23] = "MemberBanRemove";
      AuditLogEvent2[AuditLogEvent2["MemberUpdate"] = 24] = "MemberUpdate";
      AuditLogEvent2[AuditLogEvent2["MemberRoleUpdate"] = 25] = "MemberRoleUpdate";
      AuditLogEvent2[AuditLogEvent2["MemberMove"] = 26] = "MemberMove";
      AuditLogEvent2[AuditLogEvent2["MemberDisconnect"] = 27] = "MemberDisconnect";
      AuditLogEvent2[AuditLogEvent2["BotAdd"] = 28] = "BotAdd";
      AuditLogEvent2[AuditLogEvent2["RoleCreate"] = 30] = "RoleCreate";
      AuditLogEvent2[AuditLogEvent2["RoleUpdate"] = 31] = "RoleUpdate";
      AuditLogEvent2[AuditLogEvent2["RoleDelete"] = 32] = "RoleDelete";
      AuditLogEvent2[AuditLogEvent2["InviteCreate"] = 40] = "InviteCreate";
      AuditLogEvent2[AuditLogEvent2["InviteUpdate"] = 41] = "InviteUpdate";
      AuditLogEvent2[AuditLogEvent2["InviteDelete"] = 42] = "InviteDelete";
      AuditLogEvent2[AuditLogEvent2["WebhookCreate"] = 50] = "WebhookCreate";
      AuditLogEvent2[AuditLogEvent2["WebhookUpdate"] = 51] = "WebhookUpdate";
      AuditLogEvent2[AuditLogEvent2["WebhookDelete"] = 52] = "WebhookDelete";
      AuditLogEvent2[AuditLogEvent2["EmojiCreate"] = 60] = "EmojiCreate";
      AuditLogEvent2[AuditLogEvent2["EmojiUpdate"] = 61] = "EmojiUpdate";
      AuditLogEvent2[AuditLogEvent2["EmojiDelete"] = 62] = "EmojiDelete";
      AuditLogEvent2[AuditLogEvent2["MessageDelete"] = 72] = "MessageDelete";
      AuditLogEvent2[AuditLogEvent2["MessageBulkDelete"] = 73] = "MessageBulkDelete";
      AuditLogEvent2[AuditLogEvent2["MessagePin"] = 74] = "MessagePin";
      AuditLogEvent2[AuditLogEvent2["MessageUnpin"] = 75] = "MessageUnpin";
      AuditLogEvent2[AuditLogEvent2["IntegrationCreate"] = 80] = "IntegrationCreate";
      AuditLogEvent2[AuditLogEvent2["IntegrationUpdate"] = 81] = "IntegrationUpdate";
      AuditLogEvent2[AuditLogEvent2["IntegrationDelete"] = 82] = "IntegrationDelete";
      AuditLogEvent2[AuditLogEvent2["StageInstanceCreate"] = 83] = "StageInstanceCreate";
      AuditLogEvent2[AuditLogEvent2["StageInstanceUpdate"] = 84] = "StageInstanceUpdate";
      AuditLogEvent2[AuditLogEvent2["StageInstanceDelete"] = 85] = "StageInstanceDelete";
      AuditLogEvent2[AuditLogEvent2["StickerCreate"] = 90] = "StickerCreate";
      AuditLogEvent2[AuditLogEvent2["StickerUpdate"] = 91] = "StickerUpdate";
      AuditLogEvent2[AuditLogEvent2["StickerDelete"] = 92] = "StickerDelete";
      AuditLogEvent2[AuditLogEvent2["GuildScheduledEventCreate"] = 100] = "GuildScheduledEventCreate";
      AuditLogEvent2[AuditLogEvent2["GuildScheduledEventUpdate"] = 101] = "GuildScheduledEventUpdate";
      AuditLogEvent2[AuditLogEvent2["GuildScheduledEventDelete"] = 102] = "GuildScheduledEventDelete";
      AuditLogEvent2[AuditLogEvent2["ThreadCreate"] = 110] = "ThreadCreate";
      AuditLogEvent2[AuditLogEvent2["ThreadUpdate"] = 111] = "ThreadUpdate";
      AuditLogEvent2[AuditLogEvent2["ThreadDelete"] = 112] = "ThreadDelete";
      AuditLogEvent2[AuditLogEvent2["ApplicationCommandPermissionUpdate"] = 121] = "ApplicationCommandPermissionUpdate";
      AuditLogEvent2[AuditLogEvent2["AutoModerationRuleCreate"] = 140] = "AutoModerationRuleCreate";
      AuditLogEvent2[AuditLogEvent2["AutoModerationRuleUpdate"] = 141] = "AutoModerationRuleUpdate";
      AuditLogEvent2[AuditLogEvent2["AutoModerationRuleDelete"] = 142] = "AutoModerationRuleDelete";
      AuditLogEvent2[AuditLogEvent2["AutoModerationBlockMessage"] = 143] = "AutoModerationBlockMessage";
      AuditLogEvent2[AuditLogEvent2["AutoModerationFlagToChannel"] = 144] = "AutoModerationFlagToChannel";
      AuditLogEvent2[AuditLogEvent2["AutoModerationUserCommunicationDisabled"] = 145] = "AutoModerationUserCommunicationDisabled";
    })(AuditLogEvent = exports2.AuditLogEvent || (exports2.AuditLogEvent = {}));
    var AuditLogOptionsType;
    (function(AuditLogOptionsType2) {
      AuditLogOptionsType2["Role"] = "0";
      AuditLogOptionsType2["Member"] = "1";
    })(AuditLogOptionsType = exports2.AuditLogOptionsType || (exports2.AuditLogOptionsType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/autoModeration.js
var require_autoModeration = __commonJS({
  "node_modules/discord-api-types/payloads/v10/autoModeration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AutoModerationActionType = exports2.AutoModerationRuleEventType = exports2.AutoModerationRuleKeywordPresetType = exports2.AutoModerationRuleTriggerType = void 0;
    var AutoModerationRuleTriggerType;
    (function(AutoModerationRuleTriggerType2) {
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Keyword"] = 1] = "Keyword";
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Spam"] = 3] = "Spam";
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["KeywordPreset"] = 4] = "KeywordPreset";
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["MentionSpam"] = 5] = "MentionSpam";
    })(AutoModerationRuleTriggerType = exports2.AutoModerationRuleTriggerType || (exports2.AutoModerationRuleTriggerType = {}));
    var AutoModerationRuleKeywordPresetType;
    (function(AutoModerationRuleKeywordPresetType2) {
      AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Profanity"] = 1] = "Profanity";
      AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["SexualContent"] = 2] = "SexualContent";
      AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Slurs"] = 3] = "Slurs";
    })(AutoModerationRuleKeywordPresetType = exports2.AutoModerationRuleKeywordPresetType || (exports2.AutoModerationRuleKeywordPresetType = {}));
    var AutoModerationRuleEventType;
    (function(AutoModerationRuleEventType2) {
      AutoModerationRuleEventType2[AutoModerationRuleEventType2["MessageSend"] = 1] = "MessageSend";
    })(AutoModerationRuleEventType = exports2.AutoModerationRuleEventType || (exports2.AutoModerationRuleEventType = {}));
    var AutoModerationActionType;
    (function(AutoModerationActionType2) {
      AutoModerationActionType2[AutoModerationActionType2["BlockMessage"] = 1] = "BlockMessage";
      AutoModerationActionType2[AutoModerationActionType2["SendAlertMessage"] = 2] = "SendAlertMessage";
      AutoModerationActionType2[AutoModerationActionType2["Timeout"] = 3] = "Timeout";
    })(AutoModerationActionType = exports2.AutoModerationActionType || (exports2.AutoModerationActionType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/channel.js
var require_channel = __commonJS({
  "node_modules/discord-api-types/payloads/v10/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelFlags = exports2.TextInputStyle = exports2.ButtonStyle = exports2.ComponentType = exports2.AllowedMentionsTypes = exports2.EmbedType = exports2.ThreadMemberFlags = exports2.ThreadAutoArchiveDuration = exports2.OverwriteType = exports2.MessageFlags = exports2.MessageActivityType = exports2.MessageType = exports2.VideoQualityMode = exports2.ChannelType = exports2.ForumLayoutType = exports2.SortOrderType = void 0;
    var SortOrderType;
    (function(SortOrderType2) {
      SortOrderType2[SortOrderType2["LatestActivity"] = 0] = "LatestActivity";
      SortOrderType2[SortOrderType2["CreationDate"] = 1] = "CreationDate";
    })(SortOrderType = exports2.SortOrderType || (exports2.SortOrderType = {}));
    var ForumLayoutType;
    (function(ForumLayoutType2) {
      ForumLayoutType2[ForumLayoutType2["NotSet"] = 0] = "NotSet";
      ForumLayoutType2[ForumLayoutType2["ListView"] = 1] = "ListView";
      ForumLayoutType2[ForumLayoutType2["GalleryView"] = 2] = "GalleryView";
    })(ForumLayoutType = exports2.ForumLayoutType || (exports2.ForumLayoutType = {}));
    var ChannelType;
    (function(ChannelType2) {
      ChannelType2[ChannelType2["GuildText"] = 0] = "GuildText";
      ChannelType2[ChannelType2["DM"] = 1] = "DM";
      ChannelType2[ChannelType2["GuildVoice"] = 2] = "GuildVoice";
      ChannelType2[ChannelType2["GroupDM"] = 3] = "GroupDM";
      ChannelType2[ChannelType2["GuildCategory"] = 4] = "GuildCategory";
      ChannelType2[ChannelType2["GuildAnnouncement"] = 5] = "GuildAnnouncement";
      ChannelType2[ChannelType2["AnnouncementThread"] = 10] = "AnnouncementThread";
      ChannelType2[ChannelType2["PublicThread"] = 11] = "PublicThread";
      ChannelType2[ChannelType2["PrivateThread"] = 12] = "PrivateThread";
      ChannelType2[ChannelType2["GuildStageVoice"] = 13] = "GuildStageVoice";
      ChannelType2[ChannelType2["GuildDirectory"] = 14] = "GuildDirectory";
      ChannelType2[ChannelType2["GuildForum"] = 15] = "GuildForum";
      ChannelType2[ChannelType2["GuildNews"] = 5] = "GuildNews";
      ChannelType2[ChannelType2["GuildNewsThread"] = 10] = "GuildNewsThread";
      ChannelType2[ChannelType2["GuildPublicThread"] = 11] = "GuildPublicThread";
      ChannelType2[ChannelType2["GuildPrivateThread"] = 12] = "GuildPrivateThread";
    })(ChannelType = exports2.ChannelType || (exports2.ChannelType = {}));
    var VideoQualityMode;
    (function(VideoQualityMode2) {
      VideoQualityMode2[VideoQualityMode2["Auto"] = 1] = "Auto";
      VideoQualityMode2[VideoQualityMode2["Full"] = 2] = "Full";
    })(VideoQualityMode = exports2.VideoQualityMode || (exports2.VideoQualityMode = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2[MessageType2["Default"] = 0] = "Default";
      MessageType2[MessageType2["RecipientAdd"] = 1] = "RecipientAdd";
      MessageType2[MessageType2["RecipientRemove"] = 2] = "RecipientRemove";
      MessageType2[MessageType2["Call"] = 3] = "Call";
      MessageType2[MessageType2["ChannelNameChange"] = 4] = "ChannelNameChange";
      MessageType2[MessageType2["ChannelIconChange"] = 5] = "ChannelIconChange";
      MessageType2[MessageType2["ChannelPinnedMessage"] = 6] = "ChannelPinnedMessage";
      MessageType2[MessageType2["UserJoin"] = 7] = "UserJoin";
      MessageType2[MessageType2["GuildBoost"] = 8] = "GuildBoost";
      MessageType2[MessageType2["GuildBoostTier1"] = 9] = "GuildBoostTier1";
      MessageType2[MessageType2["GuildBoostTier2"] = 10] = "GuildBoostTier2";
      MessageType2[MessageType2["GuildBoostTier3"] = 11] = "GuildBoostTier3";
      MessageType2[MessageType2["ChannelFollowAdd"] = 12] = "ChannelFollowAdd";
      MessageType2[MessageType2["GuildDiscoveryDisqualified"] = 14] = "GuildDiscoveryDisqualified";
      MessageType2[MessageType2["GuildDiscoveryRequalified"] = 15] = "GuildDiscoveryRequalified";
      MessageType2[MessageType2["GuildDiscoveryGracePeriodInitialWarning"] = 16] = "GuildDiscoveryGracePeriodInitialWarning";
      MessageType2[MessageType2["GuildDiscoveryGracePeriodFinalWarning"] = 17] = "GuildDiscoveryGracePeriodFinalWarning";
      MessageType2[MessageType2["ThreadCreated"] = 18] = "ThreadCreated";
      MessageType2[MessageType2["Reply"] = 19] = "Reply";
      MessageType2[MessageType2["ChatInputCommand"] = 20] = "ChatInputCommand";
      MessageType2[MessageType2["ThreadStarterMessage"] = 21] = "ThreadStarterMessage";
      MessageType2[MessageType2["GuildInviteReminder"] = 22] = "GuildInviteReminder";
      MessageType2[MessageType2["ContextMenuCommand"] = 23] = "ContextMenuCommand";
      MessageType2[MessageType2["AutoModerationAction"] = 24] = "AutoModerationAction";
      MessageType2[MessageType2["RoleSubscriptionPurchase"] = 25] = "RoleSubscriptionPurchase";
      MessageType2[MessageType2["InteractionPremiumUpsell"] = 26] = "InteractionPremiumUpsell";
      MessageType2[MessageType2["StageStart"] = 27] = "StageStart";
      MessageType2[MessageType2["StageEnd"] = 28] = "StageEnd";
      MessageType2[MessageType2["StageSpeaker"] = 29] = "StageSpeaker";
      MessageType2[MessageType2["StageRaiseHand"] = 30] = "StageRaiseHand";
      MessageType2[MessageType2["StageTopic"] = 31] = "StageTopic";
      MessageType2[MessageType2["GuildApplicationPremiumSubscription"] = 32] = "GuildApplicationPremiumSubscription";
    })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
    var MessageActivityType;
    (function(MessageActivityType2) {
      MessageActivityType2[MessageActivityType2["Join"] = 1] = "Join";
      MessageActivityType2[MessageActivityType2["Spectate"] = 2] = "Spectate";
      MessageActivityType2[MessageActivityType2["Listen"] = 3] = "Listen";
      MessageActivityType2[MessageActivityType2["JoinRequest"] = 5] = "JoinRequest";
    })(MessageActivityType = exports2.MessageActivityType || (exports2.MessageActivityType = {}));
    var MessageFlags;
    (function(MessageFlags2) {
      MessageFlags2[MessageFlags2["Crossposted"] = 1] = "Crossposted";
      MessageFlags2[MessageFlags2["IsCrosspost"] = 2] = "IsCrosspost";
      MessageFlags2[MessageFlags2["SuppressEmbeds"] = 4] = "SuppressEmbeds";
      MessageFlags2[MessageFlags2["SourceMessageDeleted"] = 8] = "SourceMessageDeleted";
      MessageFlags2[MessageFlags2["Urgent"] = 16] = "Urgent";
      MessageFlags2[MessageFlags2["HasThread"] = 32] = "HasThread";
      MessageFlags2[MessageFlags2["Ephemeral"] = 64] = "Ephemeral";
      MessageFlags2[MessageFlags2["Loading"] = 128] = "Loading";
      MessageFlags2[MessageFlags2["FailedToMentionSomeRolesInThread"] = 256] = "FailedToMentionSomeRolesInThread";
      MessageFlags2[MessageFlags2["ShouldShowLinkNotDiscordWarning"] = 1024] = "ShouldShowLinkNotDiscordWarning";
      MessageFlags2[MessageFlags2["SuppressNotifications"] = 4096] = "SuppressNotifications";
      MessageFlags2[MessageFlags2["IsVoiceMessage"] = 8192] = "IsVoiceMessage";
    })(MessageFlags = exports2.MessageFlags || (exports2.MessageFlags = {}));
    var OverwriteType;
    (function(OverwriteType2) {
      OverwriteType2[OverwriteType2["Role"] = 0] = "Role";
      OverwriteType2[OverwriteType2["Member"] = 1] = "Member";
    })(OverwriteType = exports2.OverwriteType || (exports2.OverwriteType = {}));
    var ThreadAutoArchiveDuration;
    (function(ThreadAutoArchiveDuration2) {
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneHour"] = 60] = "OneHour";
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneDay"] = 1440] = "OneDay";
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["ThreeDays"] = 4320] = "ThreeDays";
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneWeek"] = 10080] = "OneWeek";
    })(ThreadAutoArchiveDuration = exports2.ThreadAutoArchiveDuration || (exports2.ThreadAutoArchiveDuration = {}));
    var ThreadMemberFlags;
    (function(ThreadMemberFlags2) {
      ThreadMemberFlags2[ThreadMemberFlags2["HasInteracted"] = 1] = "HasInteracted";
      ThreadMemberFlags2[ThreadMemberFlags2["AllMessages"] = 2] = "AllMessages";
      ThreadMemberFlags2[ThreadMemberFlags2["OnlyMentions"] = 4] = "OnlyMentions";
      ThreadMemberFlags2[ThreadMemberFlags2["NoMessages"] = 8] = "NoMessages";
    })(ThreadMemberFlags = exports2.ThreadMemberFlags || (exports2.ThreadMemberFlags = {}));
    var EmbedType;
    (function(EmbedType2) {
      EmbedType2["Rich"] = "rich";
      EmbedType2["Image"] = "image";
      EmbedType2["Video"] = "video";
      EmbedType2["GIFV"] = "gifv";
      EmbedType2["Article"] = "article";
      EmbedType2["Link"] = "link";
      EmbedType2["AutoModerationMessage"] = "auto_moderation_message";
    })(EmbedType = exports2.EmbedType || (exports2.EmbedType = {}));
    var AllowedMentionsTypes;
    (function(AllowedMentionsTypes2) {
      AllowedMentionsTypes2["Everyone"] = "everyone";
      AllowedMentionsTypes2["Role"] = "roles";
      AllowedMentionsTypes2["User"] = "users";
    })(AllowedMentionsTypes = exports2.AllowedMentionsTypes || (exports2.AllowedMentionsTypes = {}));
    var ComponentType;
    (function(ComponentType2) {
      ComponentType2[ComponentType2["ActionRow"] = 1] = "ActionRow";
      ComponentType2[ComponentType2["Button"] = 2] = "Button";
      ComponentType2[ComponentType2["StringSelect"] = 3] = "StringSelect";
      ComponentType2[ComponentType2["TextInput"] = 4] = "TextInput";
      ComponentType2[ComponentType2["UserSelect"] = 5] = "UserSelect";
      ComponentType2[ComponentType2["RoleSelect"] = 6] = "RoleSelect";
      ComponentType2[ComponentType2["MentionableSelect"] = 7] = "MentionableSelect";
      ComponentType2[ComponentType2["ChannelSelect"] = 8] = "ChannelSelect";
      ComponentType2[ComponentType2["SelectMenu"] = 3] = "SelectMenu";
    })(ComponentType = exports2.ComponentType || (exports2.ComponentType = {}));
    var ButtonStyle;
    (function(ButtonStyle2) {
      ButtonStyle2[ButtonStyle2["Primary"] = 1] = "Primary";
      ButtonStyle2[ButtonStyle2["Secondary"] = 2] = "Secondary";
      ButtonStyle2[ButtonStyle2["Success"] = 3] = "Success";
      ButtonStyle2[ButtonStyle2["Danger"] = 4] = "Danger";
      ButtonStyle2[ButtonStyle2["Link"] = 5] = "Link";
    })(ButtonStyle = exports2.ButtonStyle || (exports2.ButtonStyle = {}));
    var TextInputStyle;
    (function(TextInputStyle2) {
      TextInputStyle2[TextInputStyle2["Short"] = 1] = "Short";
      TextInputStyle2[TextInputStyle2["Paragraph"] = 2] = "Paragraph";
    })(TextInputStyle = exports2.TextInputStyle || (exports2.TextInputStyle = {}));
    var ChannelFlags;
    (function(ChannelFlags2) {
      ChannelFlags2[ChannelFlags2["GuildFeedRemoved"] = 1] = "GuildFeedRemoved";
      ChannelFlags2[ChannelFlags2["Pinned"] = 2] = "Pinned";
      ChannelFlags2[ChannelFlags2["ActiveChannelsRemoved"] = 4] = "ActiveChannelsRemoved";
      ChannelFlags2[ChannelFlags2["RequireTag"] = 16] = "RequireTag";
      ChannelFlags2[ChannelFlags2["IsSpam"] = 32] = "IsSpam";
      ChannelFlags2[ChannelFlags2["IsGuildResourceChannel"] = 128] = "IsGuildResourceChannel";
      ChannelFlags2[ChannelFlags2["ClydeAI"] = 256] = "ClydeAI";
      ChannelFlags2[ChannelFlags2["IsScheduledForDeletion"] = 512] = "IsScheduledForDeletion";
    })(ChannelFlags = exports2.ChannelFlags || (exports2.ChannelFlags = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/emoji.js
var require_emoji = __commonJS({
  "node_modules/discord-api-types/payloads/v10/emoji.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/gateway.js
var require_gateway = __commonJS({
  "node_modules/discord-api-types/payloads/v10/gateway.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActivityFlags = exports2.ActivityType = exports2.ActivityPlatform = exports2.PresenceUpdateStatus = void 0;
    var PresenceUpdateStatus;
    (function(PresenceUpdateStatus2) {
      PresenceUpdateStatus2["Online"] = "online";
      PresenceUpdateStatus2["DoNotDisturb"] = "dnd";
      PresenceUpdateStatus2["Idle"] = "idle";
      PresenceUpdateStatus2["Invisible"] = "invisible";
      PresenceUpdateStatus2["Offline"] = "offline";
    })(PresenceUpdateStatus = exports2.PresenceUpdateStatus || (exports2.PresenceUpdateStatus = {}));
    var ActivityPlatform;
    (function(ActivityPlatform2) {
      ActivityPlatform2["Desktop"] = "desktop";
      ActivityPlatform2["Xbox"] = "xbox";
      ActivityPlatform2["Samsung"] = "samsung";
      ActivityPlatform2["IOS"] = "ios";
      ActivityPlatform2["Android"] = "android";
      ActivityPlatform2["Embedded"] = "embedded";
      ActivityPlatform2["PS4"] = "ps4";
      ActivityPlatform2["PS5"] = "ps5";
    })(ActivityPlatform = exports2.ActivityPlatform || (exports2.ActivityPlatform = {}));
    var ActivityType;
    (function(ActivityType2) {
      ActivityType2[ActivityType2["Playing"] = 0] = "Playing";
      ActivityType2[ActivityType2["Streaming"] = 1] = "Streaming";
      ActivityType2[ActivityType2["Listening"] = 2] = "Listening";
      ActivityType2[ActivityType2["Watching"] = 3] = "Watching";
      ActivityType2[ActivityType2["Custom"] = 4] = "Custom";
      ActivityType2[ActivityType2["Competing"] = 5] = "Competing";
    })(ActivityType = exports2.ActivityType || (exports2.ActivityType = {}));
    var ActivityFlags;
    (function(ActivityFlags2) {
      ActivityFlags2[ActivityFlags2["Instance"] = 1] = "Instance";
      ActivityFlags2[ActivityFlags2["Join"] = 2] = "Join";
      ActivityFlags2[ActivityFlags2["Spectate"] = 4] = "Spectate";
      ActivityFlags2[ActivityFlags2["JoinRequest"] = 8] = "JoinRequest";
      ActivityFlags2[ActivityFlags2["Sync"] = 16] = "Sync";
      ActivityFlags2[ActivityFlags2["Play"] = 32] = "Play";
      ActivityFlags2[ActivityFlags2["PartyPrivacyFriends"] = 64] = "PartyPrivacyFriends";
      ActivityFlags2[ActivityFlags2["PartyPrivacyVoiceChannel"] = 128] = "PartyPrivacyVoiceChannel";
      ActivityFlags2[ActivityFlags2["Embedded"] = 256] = "Embedded";
    })(ActivityFlags = exports2.ActivityFlags || (exports2.ActivityFlags = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/guild.js
var require_guild = __commonJS({
  "node_modules/discord-api-types/payloads/v10/guild.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MembershipScreeningFieldType = exports2.GuildWidgetStyle = exports2.IntegrationExpireBehavior = exports2.GuildMemberFlags = exports2.GuildFeature = exports2.GuildSystemChannelFlags = exports2.GuildHubType = exports2.GuildPremiumTier = exports2.GuildVerificationLevel = exports2.GuildNSFWLevel = exports2.GuildMFALevel = exports2.GuildExplicitContentFilter = exports2.GuildDefaultMessageNotifications = void 0;
    var GuildDefaultMessageNotifications;
    (function(GuildDefaultMessageNotifications2) {
      GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["AllMessages"] = 0] = "AllMessages";
      GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["OnlyMentions"] = 1] = "OnlyMentions";
    })(GuildDefaultMessageNotifications = exports2.GuildDefaultMessageNotifications || (exports2.GuildDefaultMessageNotifications = {}));
    var GuildExplicitContentFilter;
    (function(GuildExplicitContentFilter2) {
      GuildExplicitContentFilter2[GuildExplicitContentFilter2["Disabled"] = 0] = "Disabled";
      GuildExplicitContentFilter2[GuildExplicitContentFilter2["MembersWithoutRoles"] = 1] = "MembersWithoutRoles";
      GuildExplicitContentFilter2[GuildExplicitContentFilter2["AllMembers"] = 2] = "AllMembers";
    })(GuildExplicitContentFilter = exports2.GuildExplicitContentFilter || (exports2.GuildExplicitContentFilter = {}));
    var GuildMFALevel;
    (function(GuildMFALevel2) {
      GuildMFALevel2[GuildMFALevel2["None"] = 0] = "None";
      GuildMFALevel2[GuildMFALevel2["Elevated"] = 1] = "Elevated";
    })(GuildMFALevel = exports2.GuildMFALevel || (exports2.GuildMFALevel = {}));
    var GuildNSFWLevel;
    (function(GuildNSFWLevel2) {
      GuildNSFWLevel2[GuildNSFWLevel2["Default"] = 0] = "Default";
      GuildNSFWLevel2[GuildNSFWLevel2["Explicit"] = 1] = "Explicit";
      GuildNSFWLevel2[GuildNSFWLevel2["Safe"] = 2] = "Safe";
      GuildNSFWLevel2[GuildNSFWLevel2["AgeRestricted"] = 3] = "AgeRestricted";
    })(GuildNSFWLevel = exports2.GuildNSFWLevel || (exports2.GuildNSFWLevel = {}));
    var GuildVerificationLevel;
    (function(GuildVerificationLevel2) {
      GuildVerificationLevel2[GuildVerificationLevel2["None"] = 0] = "None";
      GuildVerificationLevel2[GuildVerificationLevel2["Low"] = 1] = "Low";
      GuildVerificationLevel2[GuildVerificationLevel2["Medium"] = 2] = "Medium";
      GuildVerificationLevel2[GuildVerificationLevel2["High"] = 3] = "High";
      GuildVerificationLevel2[GuildVerificationLevel2["VeryHigh"] = 4] = "VeryHigh";
    })(GuildVerificationLevel = exports2.GuildVerificationLevel || (exports2.GuildVerificationLevel = {}));
    var GuildPremiumTier;
    (function(GuildPremiumTier2) {
      GuildPremiumTier2[GuildPremiumTier2["None"] = 0] = "None";
      GuildPremiumTier2[GuildPremiumTier2["Tier1"] = 1] = "Tier1";
      GuildPremiumTier2[GuildPremiumTier2["Tier2"] = 2] = "Tier2";
      GuildPremiumTier2[GuildPremiumTier2["Tier3"] = 3] = "Tier3";
    })(GuildPremiumTier = exports2.GuildPremiumTier || (exports2.GuildPremiumTier = {}));
    var GuildHubType;
    (function(GuildHubType2) {
      GuildHubType2[GuildHubType2["Default"] = 0] = "Default";
      GuildHubType2[GuildHubType2["HighSchool"] = 1] = "HighSchool";
      GuildHubType2[GuildHubType2["College"] = 2] = "College";
    })(GuildHubType = exports2.GuildHubType || (exports2.GuildHubType = {}));
    var GuildSystemChannelFlags;
    (function(GuildSystemChannelFlags2) {
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotifications"] = 1] = "SuppressJoinNotifications";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressPremiumSubscriptions"] = 2] = "SuppressPremiumSubscriptions";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressGuildReminderNotifications"] = 4] = "SuppressGuildReminderNotifications";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotificationReplies"] = 8] = "SuppressJoinNotificationReplies";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressRoleSubscriptionPurchaseNotifications"] = 16] = "SuppressRoleSubscriptionPurchaseNotifications";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressRoleSubscriptionPurchaseNotificationReplies"] = 32] = "SuppressRoleSubscriptionPurchaseNotificationReplies";
    })(GuildSystemChannelFlags = exports2.GuildSystemChannelFlags || (exports2.GuildSystemChannelFlags = {}));
    var GuildFeature;
    (function(GuildFeature2) {
      GuildFeature2["AnimatedBanner"] = "ANIMATED_BANNER";
      GuildFeature2["AnimatedIcon"] = "ANIMATED_ICON";
      GuildFeature2["ApplicationCommandPermissionsV2"] = "APPLICATION_COMMAND_PERMISSIONS_V2";
      GuildFeature2["AutoModeration"] = "AUTO_MODERATION";
      GuildFeature2["Banner"] = "BANNER";
      GuildFeature2["Community"] = "COMMUNITY";
      GuildFeature2["CreatorMonetizableProvisional"] = "CREATOR_MONETIZABLE_PROVISIONAL";
      GuildFeature2["CreatorStorePage"] = "CREATOR_STORE_PAGE";
      GuildFeature2["DeveloperSupportServer"] = "DEVELOPER_SUPPORT_SERVER";
      GuildFeature2["Discoverable"] = "DISCOVERABLE";
      GuildFeature2["Featurable"] = "FEATURABLE";
      GuildFeature2["HasDirectoryEntry"] = "HAS_DIRECTORY_ENTRY";
      GuildFeature2["Hub"] = "HUB";
      GuildFeature2["InvitesDisabled"] = "INVITES_DISABLED";
      GuildFeature2["InviteSplash"] = "INVITE_SPLASH";
      GuildFeature2["LinkedToHub"] = "LINKED_TO_HUB";
      GuildFeature2["MemberVerificationGateEnabled"] = "MEMBER_VERIFICATION_GATE_ENABLED";
      GuildFeature2["MonetizationEnabled"] = "MONETIZATION_ENABLED";
      GuildFeature2["MoreStickers"] = "MORE_STICKERS";
      GuildFeature2["News"] = "NEWS";
      GuildFeature2["Partnered"] = "PARTNERED";
      GuildFeature2["PreviewEnabled"] = "PREVIEW_ENABLED";
      GuildFeature2["PrivateThreads"] = "PRIVATE_THREADS";
      GuildFeature2["RelayEnabled"] = "RELAY_ENABLED";
      GuildFeature2["RoleIcons"] = "ROLE_ICONS";
      GuildFeature2["RoleSubscriptionsAvailableForPurchase"] = "ROLE_SUBSCRIPTIONS_AVAILABLE_FOR_PURCHASE";
      GuildFeature2["RoleSubscriptionsEnabled"] = "ROLE_SUBSCRIPTIONS_ENABLED";
      GuildFeature2["TicketedEventsEnabled"] = "TICKETED_EVENTS_ENABLED";
      GuildFeature2["VanityURL"] = "VANITY_URL";
      GuildFeature2["Verified"] = "VERIFIED";
      GuildFeature2["VIPRegions"] = "VIP_REGIONS";
      GuildFeature2["WelcomeScreenEnabled"] = "WELCOME_SCREEN_ENABLED";
    })(GuildFeature = exports2.GuildFeature || (exports2.GuildFeature = {}));
    var GuildMemberFlags;
    (function(GuildMemberFlags2) {
      GuildMemberFlags2[GuildMemberFlags2["DidRejoin"] = 1] = "DidRejoin";
      GuildMemberFlags2[GuildMemberFlags2["CompletedOnboarding"] = 2] = "CompletedOnboarding";
      GuildMemberFlags2[GuildMemberFlags2["BypassesVerification"] = 4] = "BypassesVerification";
      GuildMemberFlags2[GuildMemberFlags2["StartedOnboarding"] = 8] = "StartedOnboarding";
      GuildMemberFlags2[GuildMemberFlags2["StartedHomeActions"] = 32] = "StartedHomeActions";
      GuildMemberFlags2[GuildMemberFlags2["CompletedHomeActions"] = 64] = "CompletedHomeActions";
      GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedUsernameOrGuildNickname"] = 128] = "AutomodQuarantinedUsernameOrGuildNickname";
      GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedBio"] = 256] = "AutomodQuarantinedBio";
    })(GuildMemberFlags = exports2.GuildMemberFlags || (exports2.GuildMemberFlags = {}));
    var IntegrationExpireBehavior;
    (function(IntegrationExpireBehavior2) {
      IntegrationExpireBehavior2[IntegrationExpireBehavior2["RemoveRole"] = 0] = "RemoveRole";
      IntegrationExpireBehavior2[IntegrationExpireBehavior2["Kick"] = 1] = "Kick";
    })(IntegrationExpireBehavior = exports2.IntegrationExpireBehavior || (exports2.IntegrationExpireBehavior = {}));
    var GuildWidgetStyle;
    (function(GuildWidgetStyle2) {
      GuildWidgetStyle2["Shield"] = "shield";
      GuildWidgetStyle2["Banner1"] = "banner1";
      GuildWidgetStyle2["Banner2"] = "banner2";
      GuildWidgetStyle2["Banner3"] = "banner3";
      GuildWidgetStyle2["Banner4"] = "banner4";
    })(GuildWidgetStyle = exports2.GuildWidgetStyle || (exports2.GuildWidgetStyle = {}));
    var MembershipScreeningFieldType;
    (function(MembershipScreeningFieldType2) {
      MembershipScreeningFieldType2["Terms"] = "TERMS";
    })(MembershipScreeningFieldType = exports2.MembershipScreeningFieldType || (exports2.MembershipScreeningFieldType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/guildScheduledEvent.js
var require_guildScheduledEvent = __commonJS({
  "node_modules/discord-api-types/payloads/v10/guildScheduledEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GuildScheduledEventPrivacyLevel = exports2.GuildScheduledEventStatus = exports2.GuildScheduledEventEntityType = void 0;
    var GuildScheduledEventEntityType;
    (function(GuildScheduledEventEntityType2) {
      GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["StageInstance"] = 1] = "StageInstance";
      GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["Voice"] = 2] = "Voice";
      GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["External"] = 3] = "External";
    })(GuildScheduledEventEntityType = exports2.GuildScheduledEventEntityType || (exports2.GuildScheduledEventEntityType = {}));
    var GuildScheduledEventStatus;
    (function(GuildScheduledEventStatus2) {
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Scheduled"] = 1] = "Scheduled";
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Active"] = 2] = "Active";
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Completed"] = 3] = "Completed";
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Canceled"] = 4] = "Canceled";
    })(GuildScheduledEventStatus = exports2.GuildScheduledEventStatus || (exports2.GuildScheduledEventStatus = {}));
    var GuildScheduledEventPrivacyLevel;
    (function(GuildScheduledEventPrivacyLevel2) {
      GuildScheduledEventPrivacyLevel2[GuildScheduledEventPrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
    })(GuildScheduledEventPrivacyLevel = exports2.GuildScheduledEventPrivacyLevel || (exports2.GuildScheduledEventPrivacyLevel = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/attachment.js
var require_attachment = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/attachment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/base.js
var require_base = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/boolean.js
var require_boolean = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/boolean.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/channel.js
var require_channel2 = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/integer.js
var require_integer = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/integer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/mentionable.js
var require_mentionable = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/mentionable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/number.js
var require_number = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/number.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/role.js
var require_role = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/role.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/shared.js
var require_shared = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/shared.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationCommandOptionType = void 0;
    var ApplicationCommandOptionType;
    (function(ApplicationCommandOptionType2) {
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Subcommand"] = 1] = "Subcommand";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["SubcommandGroup"] = 2] = "SubcommandGroup";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["String"] = 3] = "String";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Integer"] = 4] = "Integer";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Boolean"] = 5] = "Boolean";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["User"] = 6] = "User";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Channel"] = 7] = "Channel";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Role"] = 8] = "Role";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Mentionable"] = 9] = "Mentionable";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Number"] = 10] = "Number";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Attachment"] = 11] = "Attachment";
    })(ApplicationCommandOptionType = exports2.ApplicationCommandOptionType || (exports2.ApplicationCommandOptionType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/string.js
var require_string = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommand.js
var require_subcommand = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommand.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommandGroup.js
var require_subcommandGroup = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommandGroup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/user.js
var require_user = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/user.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/chatInput.js
var require_chatInput = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/chatInput.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_attachment(), exports2);
    __exportStar2(require_base(), exports2);
    __exportStar2(require_boolean(), exports2);
    __exportStar2(require_channel2(), exports2);
    __exportStar2(require_integer(), exports2);
    __exportStar2(require_mentionable(), exports2);
    __exportStar2(require_number(), exports2);
    __exportStar2(require_role(), exports2);
    __exportStar2(require_shared(), exports2);
    __exportStar2(require_string(), exports2);
    __exportStar2(require_subcommand(), exports2);
    __exportStar2(require_subcommandGroup(), exports2);
    __exportStar2(require_user(), exports2);
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/contextMenu.js
var require_contextMenu = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/contextMenu.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/permissions.js
var require_permissions = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/permissions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.APIApplicationCommandPermissionsConstant = exports2.ApplicationCommandPermissionType = void 0;
    var ApplicationCommandPermissionType;
    (function(ApplicationCommandPermissionType2) {
      ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Role"] = 1] = "Role";
      ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["User"] = 2] = "User";
      ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Channel"] = 3] = "Channel";
    })(ApplicationCommandPermissionType = exports2.ApplicationCommandPermissionType || (exports2.ApplicationCommandPermissionType = {}));
    exports2.APIApplicationCommandPermissionsConstant = {
      Everyone: (guildId) => String(guildId),
      AllChannels: (guildId) => String(BigInt(guildId) - 1n)
    };
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/applicationCommands.js
var require_applicationCommands = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/applicationCommands.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationCommandType = void 0;
    __exportStar2(require_chatInput(), exports2);
    __exportStar2(require_contextMenu(), exports2);
    __exportStar2(require_permissions(), exports2);
    var ApplicationCommandType;
    (function(ApplicationCommandType2) {
      ApplicationCommandType2[ApplicationCommandType2["ChatInput"] = 1] = "ChatInput";
      ApplicationCommandType2[ApplicationCommandType2["User"] = 2] = "User";
      ApplicationCommandType2[ApplicationCommandType2["Message"] = 3] = "Message";
    })(ApplicationCommandType = exports2.ApplicationCommandType || (exports2.ApplicationCommandType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/autocomplete.js
var require_autocomplete = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/autocomplete.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/base.js
var require_base2 = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/messageComponents.js
var require_messageComponents = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/messageComponents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/modalSubmit.js
var require_modalSubmit = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/modalSubmit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/ping.js
var require_ping = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/ping.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/responses.js
var require_responses = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/responses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InteractionResponseType = exports2.InteractionType = void 0;
    var InteractionType;
    (function(InteractionType2) {
      InteractionType2[InteractionType2["Ping"] = 1] = "Ping";
      InteractionType2[InteractionType2["ApplicationCommand"] = 2] = "ApplicationCommand";
      InteractionType2[InteractionType2["MessageComponent"] = 3] = "MessageComponent";
      InteractionType2[InteractionType2["ApplicationCommandAutocomplete"] = 4] = "ApplicationCommandAutocomplete";
      InteractionType2[InteractionType2["ModalSubmit"] = 5] = "ModalSubmit";
    })(InteractionType = exports2.InteractionType || (exports2.InteractionType = {}));
    var InteractionResponseType;
    (function(InteractionResponseType2) {
      InteractionResponseType2[InteractionResponseType2["Pong"] = 1] = "Pong";
      InteractionResponseType2[InteractionResponseType2["ChannelMessageWithSource"] = 4] = "ChannelMessageWithSource";
      InteractionResponseType2[InteractionResponseType2["DeferredChannelMessageWithSource"] = 5] = "DeferredChannelMessageWithSource";
      InteractionResponseType2[InteractionResponseType2["DeferredMessageUpdate"] = 6] = "DeferredMessageUpdate";
      InteractionResponseType2[InteractionResponseType2["UpdateMessage"] = 7] = "UpdateMessage";
      InteractionResponseType2[InteractionResponseType2["ApplicationCommandAutocompleteResult"] = 8] = "ApplicationCommandAutocompleteResult";
      InteractionResponseType2[InteractionResponseType2["Modal"] = 9] = "Modal";
    })(InteractionResponseType = exports2.InteractionResponseType || (exports2.InteractionResponseType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/interactions.js
var require_interactions = __commonJS({
  "node_modules/discord-api-types/payloads/v10/interactions.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_applicationCommands(), exports2);
    __exportStar2(require_autocomplete(), exports2);
    __exportStar2(require_base2(), exports2);
    __exportStar2(require_messageComponents(), exports2);
    __exportStar2(require_modalSubmit(), exports2);
    __exportStar2(require_ping(), exports2);
    __exportStar2(require_responses(), exports2);
  }
});

// node_modules/discord-api-types/payloads/v10/invite.js
var require_invite = __commonJS({
  "node_modules/discord-api-types/payloads/v10/invite.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InviteTargetType = void 0;
    var InviteTargetType;
    (function(InviteTargetType2) {
      InviteTargetType2[InviteTargetType2["Stream"] = 1] = "Stream";
      InviteTargetType2[InviteTargetType2["EmbeddedApplication"] = 2] = "EmbeddedApplication";
    })(InviteTargetType = exports2.InviteTargetType || (exports2.InviteTargetType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/oauth2.js
var require_oauth2 = __commonJS({
  "node_modules/discord-api-types/payloads/v10/oauth2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OAuth2Scopes = void 0;
    var OAuth2Scopes2;
    (function(OAuth2Scopes3) {
      OAuth2Scopes3["Bot"] = "bot";
      OAuth2Scopes3["Connections"] = "connections";
      OAuth2Scopes3["DMChannelsRead"] = "dm_channels.read";
      OAuth2Scopes3["Email"] = "email";
      OAuth2Scopes3["Identify"] = "identify";
      OAuth2Scopes3["Guilds"] = "guilds";
      OAuth2Scopes3["GuildsJoin"] = "guilds.join";
      OAuth2Scopes3["GuildsMembersRead"] = "guilds.members.read";
      OAuth2Scopes3["GroupDMJoins"] = "gdm.join";
      OAuth2Scopes3["MessagesRead"] = "messages.read";
      OAuth2Scopes3["RoleConnectionsWrite"] = "role_connections.write";
      OAuth2Scopes3["RPC"] = "rpc";
      OAuth2Scopes3["RPCNotificationsRead"] = "rpc.notifications.read";
      OAuth2Scopes3["WebhookIncoming"] = "webhook.incoming";
      OAuth2Scopes3["Voice"] = "voice";
      OAuth2Scopes3["ApplicationsBuildsUpload"] = "applications.builds.upload";
      OAuth2Scopes3["ApplicationsBuildsRead"] = "applications.builds.read";
      OAuth2Scopes3["ApplicationsStoreUpdate"] = "applications.store.update";
      OAuth2Scopes3["ApplicationsEntitlements"] = "applications.entitlements";
      OAuth2Scopes3["RelationshipsRead"] = "relationships.read";
      OAuth2Scopes3["ActivitiesRead"] = "activities.read";
      OAuth2Scopes3["ActivitiesWrite"] = "activities.write";
      OAuth2Scopes3["ApplicationsCommands"] = "applications.commands";
      OAuth2Scopes3["ApplicationsCommandsUpdate"] = "applications.commands.update";
      OAuth2Scopes3["ApplicationCommandsPermissionsUpdate"] = "applications.commands.permissions.update";
    })(OAuth2Scopes2 = exports2.OAuth2Scopes || (exports2.OAuth2Scopes = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/permissions.js
var require_permissions2 = __commonJS({
  "node_modules/discord-api-types/payloads/v10/permissions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/stageInstance.js
var require_stageInstance = __commonJS({
  "node_modules/discord-api-types/payloads/v10/stageInstance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StageInstancePrivacyLevel = void 0;
    var StageInstancePrivacyLevel;
    (function(StageInstancePrivacyLevel2) {
      StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["Public"] = 1] = "Public";
      StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
    })(StageInstancePrivacyLevel = exports2.StageInstancePrivacyLevel || (exports2.StageInstancePrivacyLevel = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/sticker.js
var require_sticker = __commonJS({
  "node_modules/discord-api-types/payloads/v10/sticker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StickerFormatType = exports2.StickerType = void 0;
    var StickerType;
    (function(StickerType2) {
      StickerType2[StickerType2["Standard"] = 1] = "Standard";
      StickerType2[StickerType2["Guild"] = 2] = "Guild";
    })(StickerType = exports2.StickerType || (exports2.StickerType = {}));
    var StickerFormatType;
    (function(StickerFormatType2) {
      StickerFormatType2[StickerFormatType2["PNG"] = 1] = "PNG";
      StickerFormatType2[StickerFormatType2["APNG"] = 2] = "APNG";
      StickerFormatType2[StickerFormatType2["Lottie"] = 3] = "Lottie";
      StickerFormatType2[StickerFormatType2["GIF"] = 4] = "GIF";
    })(StickerFormatType = exports2.StickerFormatType || (exports2.StickerFormatType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/teams.js
var require_teams = __commonJS({
  "node_modules/discord-api-types/payloads/v10/teams.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TeamMemberMembershipState = void 0;
    var TeamMemberMembershipState;
    (function(TeamMemberMembershipState2) {
      TeamMemberMembershipState2[TeamMemberMembershipState2["Invited"] = 1] = "Invited";
      TeamMemberMembershipState2[TeamMemberMembershipState2["Accepted"] = 2] = "Accepted";
    })(TeamMemberMembershipState = exports2.TeamMemberMembershipState || (exports2.TeamMemberMembershipState = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/template.js
var require_template = __commonJS({
  "node_modules/discord-api-types/payloads/v10/template.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/user.js
var require_user2 = __commonJS({
  "node_modules/discord-api-types/payloads/v10/user.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionVisibility = exports2.ConnectionService = exports2.UserPremiumType = exports2.UserFlags = void 0;
    var UserFlags;
    (function(UserFlags2) {
      UserFlags2[UserFlags2["Staff"] = 1] = "Staff";
      UserFlags2[UserFlags2["Partner"] = 2] = "Partner";
      UserFlags2[UserFlags2["Hypesquad"] = 4] = "Hypesquad";
      UserFlags2[UserFlags2["BugHunterLevel1"] = 8] = "BugHunterLevel1";
      UserFlags2[UserFlags2["MFASMS"] = 16] = "MFASMS";
      UserFlags2[UserFlags2["PremiumPromoDismissed"] = 32] = "PremiumPromoDismissed";
      UserFlags2[UserFlags2["HypeSquadOnlineHouse1"] = 64] = "HypeSquadOnlineHouse1";
      UserFlags2[UserFlags2["HypeSquadOnlineHouse2"] = 128] = "HypeSquadOnlineHouse2";
      UserFlags2[UserFlags2["HypeSquadOnlineHouse3"] = 256] = "HypeSquadOnlineHouse3";
      UserFlags2[UserFlags2["PremiumEarlySupporter"] = 512] = "PremiumEarlySupporter";
      UserFlags2[UserFlags2["TeamPseudoUser"] = 1024] = "TeamPseudoUser";
      UserFlags2[UserFlags2["HasUnreadUrgentMessages"] = 8192] = "HasUnreadUrgentMessages";
      UserFlags2[UserFlags2["BugHunterLevel2"] = 16384] = "BugHunterLevel2";
      UserFlags2[UserFlags2["VerifiedBot"] = 65536] = "VerifiedBot";
      UserFlags2[UserFlags2["VerifiedDeveloper"] = 131072] = "VerifiedDeveloper";
      UserFlags2[UserFlags2["CertifiedModerator"] = 262144] = "CertifiedModerator";
      UserFlags2[UserFlags2["BotHTTPInteractions"] = 524288] = "BotHTTPInteractions";
      UserFlags2[UserFlags2["Spammer"] = 1048576] = "Spammer";
      UserFlags2[UserFlags2["DisablePremium"] = 2097152] = "DisablePremium";
      UserFlags2[UserFlags2["ActiveDeveloper"] = 4194304] = "ActiveDeveloper";
      UserFlags2[UserFlags2["Quarantined"] = 17592186044416] = "Quarantined";
      UserFlags2[UserFlags2["Collaborator"] = 1125899906842624] = "Collaborator";
      UserFlags2[UserFlags2["RestrictedCollaborator"] = 2251799813685248] = "RestrictedCollaborator";
    })(UserFlags = exports2.UserFlags || (exports2.UserFlags = {}));
    var UserPremiumType;
    (function(UserPremiumType2) {
      UserPremiumType2[UserPremiumType2["None"] = 0] = "None";
      UserPremiumType2[UserPremiumType2["NitroClassic"] = 1] = "NitroClassic";
      UserPremiumType2[UserPremiumType2["Nitro"] = 2] = "Nitro";
      UserPremiumType2[UserPremiumType2["NitroBasic"] = 3] = "NitroBasic";
    })(UserPremiumType = exports2.UserPremiumType || (exports2.UserPremiumType = {}));
    var ConnectionService;
    (function(ConnectionService2) {
      ConnectionService2["BattleNet"] = "battlenet";
      ConnectionService2["eBay"] = "ebay";
      ConnectionService2["EpicGames"] = "epicgames";
      ConnectionService2["Facebook"] = "facebook";
      ConnectionService2["GitHub"] = "github";
      ConnectionService2["Instagram"] = "instagram";
      ConnectionService2["LeagueOfLegends"] = "leagueoflegends";
      ConnectionService2["PayPal"] = "paypal";
      ConnectionService2["PlayStationNetwork"] = "playstation";
      ConnectionService2["Reddit"] = "reddit";
      ConnectionService2["RiotGames"] = "riotgames";
      ConnectionService2["Spotify"] = "spotify";
      ConnectionService2["Skype"] = "skype";
      ConnectionService2["Steam"] = "steam";
      ConnectionService2["TikTok"] = "tiktok";
      ConnectionService2["Twitch"] = "twitch";
      ConnectionService2["Twitter"] = "twitter";
      ConnectionService2["Xbox"] = "xbox";
      ConnectionService2["YouTube"] = "youtube";
    })(ConnectionService = exports2.ConnectionService || (exports2.ConnectionService = {}));
    var ConnectionVisibility;
    (function(ConnectionVisibility2) {
      ConnectionVisibility2[ConnectionVisibility2["None"] = 0] = "None";
      ConnectionVisibility2[ConnectionVisibility2["Everyone"] = 1] = "Everyone";
    })(ConnectionVisibility = exports2.ConnectionVisibility || (exports2.ConnectionVisibility = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/voice.js
var require_voice = __commonJS({
  "node_modules/discord-api-types/payloads/v10/voice.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/webhook.js
var require_webhook = __commonJS({
  "node_modules/discord-api-types/payloads/v10/webhook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebhookType = void 0;
    var WebhookType;
    (function(WebhookType2) {
      WebhookType2[WebhookType2["Incoming"] = 1] = "Incoming";
      WebhookType2[WebhookType2["ChannelFollower"] = 2] = "ChannelFollower";
      WebhookType2[WebhookType2["Application"] = 3] = "Application";
    })(WebhookType = exports2.WebhookType || (exports2.WebhookType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/index.js
var require_v102 = __commonJS({
  "node_modules/discord-api-types/payloads/v10/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_common2(), exports2);
    __exportStar2(require_application(), exports2);
    __exportStar2(require_auditLog(), exports2);
    __exportStar2(require_autoModeration(), exports2);
    __exportStar2(require_channel(), exports2);
    __exportStar2(require_emoji(), exports2);
    __exportStar2(require_gateway(), exports2);
    __exportStar2(require_guild(), exports2);
    __exportStar2(require_guildScheduledEvent(), exports2);
    __exportStar2(require_interactions(), exports2);
    __exportStar2(require_invite(), exports2);
    __exportStar2(require_oauth2(), exports2);
    __exportStar2(require_permissions2(), exports2);
    __exportStar2(require_stageInstance(), exports2);
    __exportStar2(require_sticker(), exports2);
    __exportStar2(require_teams(), exports2);
    __exportStar2(require_template(), exports2);
    __exportStar2(require_user2(), exports2);
    __exportStar2(require_voice(), exports2);
    __exportStar2(require_webhook(), exports2);
  }
});

// node_modules/discord-api-types/rest/common.js
var require_common3 = __commonJS({
  "node_modules/discord-api-types/rest/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Locale = exports2.RESTJSONErrorCodes = void 0;
    var RESTJSONErrorCodes;
    (function(RESTJSONErrorCodes2) {
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GeneralError"] = 0] = "GeneralError";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownAccount"] = 10001] = "UnknownAccount";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplication"] = 10002] = "UnknownApplication";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownChannel"] = 10003] = "UnknownChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuild"] = 10004] = "UnknownGuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownIntegration"] = 10005] = "UnknownIntegration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInvite"] = 10006] = "UnknownInvite";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMember"] = 10007] = "UnknownMember";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMessage"] = 10008] = "UnknownMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPermissionOverwrite"] = 10009] = "UnknownPermissionOverwrite";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownProvider"] = 10010] = "UnknownProvider";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRole"] = 10011] = "UnknownRole";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownToken"] = 10012] = "UnknownToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownUser"] = 10013] = "UnknownUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEmoji"] = 10014] = "UnknownEmoji";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhook"] = 10015] = "UnknownWebhook";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhookService"] = 10016] = "UnknownWebhookService";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSession"] = 10020] = "UnknownSession";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBan"] = 10026] = "UnknownBan";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSKU"] = 10027] = "UnknownSKU";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreListing"] = 10028] = "UnknownStoreListing";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEntitlement"] = 10029] = "UnknownEntitlement";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBuild"] = 10030] = "UnknownBuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownLobby"] = 10031] = "UnknownLobby";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBranch"] = 10032] = "UnknownBranch";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreDirectoryLayout"] = 10033] = "UnknownStoreDirectoryLayout";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRedistributable"] = 10036] = "UnknownRedistributable";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGiftCode"] = 10038] = "UnknownGiftCode";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStream"] = 10049] = "UnknownStream";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPremiumServerSubscribeCooldown"] = 10050] = "UnknownPremiumServerSubscribeCooldown";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildTemplate"] = 10057] = "UnknownGuildTemplate";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownDiscoverableServerCategory"] = 10059] = "UnknownDiscoverableServerCategory";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSticker"] = 10060] = "UnknownSticker";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInteraction"] = 10062] = "UnknownInteraction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommand"] = 10063] = "UnknownApplicationCommand";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownVoiceState"] = 10065] = "UnknownVoiceState";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommandPermissions"] = 10066] = "UnknownApplicationCommandPermissions";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStageInstance"] = 10067] = "UnknownStageInstance";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildMemberVerificationForm"] = 10068] = "UnknownGuildMemberVerificationForm";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildWelcomeScreen"] = 10069] = "UnknownGuildWelcomeScreen";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEvent"] = 10070] = "UnknownGuildScheduledEvent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEventUser"] = 10071] = "UnknownGuildScheduledEventUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownTag"] = 10087] = "UnknownTag";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["BotsCannotUseThisEndpoint"] = 20001] = "BotsCannotUseThisEndpoint";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyBotsCanUseThisEndpoint"] = 20002] = "OnlyBotsCanUseThisEndpoint";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ExplicitContentCannotBeSentToTheDesiredRecipient"] = 20009] = "ExplicitContentCannotBeSentToTheDesiredRecipient";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["NotAuthorizedToPerformThisActionOnThisApplication"] = 20012] = "NotAuthorizedToPerformThisActionOnThisApplication";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ActionCannotBePerformedDueToSlowmodeRateLimit"] = 20016] = "ActionCannotBePerformedDueToSlowmodeRateLimit";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheMazeIsntMeantForYou"] = 20017] = "TheMazeIsntMeantForYou";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyTheOwnerOfThisAccountCanPerformThisAction"] = 20018] = "OnlyTheOwnerOfThisAccountCanPerformThisAction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["AnnouncementEditLimitExceeded"] = 20022] = "AnnouncementEditLimitExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnderMinimumAge"] = 20024] = "UnderMinimumAge";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelSendRateLimit"] = 20028] = "ChannelSendRateLimit";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerSendRateLimit"] = 20029] = "ServerSendRateLimit";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords"] = 20031] = "StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildPremiumSubscriptionLevelTooLow"] = 20035] = "GuildPremiumSubscriptionLevelTooLow";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildsReached"] = 30001] = "MaximumNumberOfGuildsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfFriendsReached"] = 30002] = "MaximumNumberOfFriendsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinsReachedForTheChannel"] = 30003] = "MaximumNumberOfPinsReachedForTheChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfRecipientsReached"] = 30004] = "MaximumNumberOfRecipientsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildRolesReached"] = 30005] = "MaximumNumberOfGuildRolesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksReached"] = 30007] = "MaximumNumberOfWebhooksReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEmojisReached"] = 30008] = "MaximumNumberOfEmojisReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfReactionsReached"] = 30010] = "MaximumNumberOfReactionsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGroupDMsReached"] = 30011] = "MaximumNumberOfGroupDMsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildChannelsReached"] = 30013] = "MaximumNumberOfGuildChannelsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAttachmentsInAMessageReached"] = 30015] = "MaximumNumberOfAttachmentsInAMessageReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfInvitesReached"] = 30016] = "MaximumNumberOfInvitesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAnimatedEmojisReached"] = 30018] = "MaximumNumberOfAnimatedEmojisReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerMembersReached"] = 30019] = "MaximumNumberOfServerMembersReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerCategoriesReached"] = 30030] = "MaximumNumberOfServerCategoriesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildAlreadyHasTemplate"] = 30031] = "GuildAlreadyHasTemplate";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfApplicationCommandsReached"] = 30032] = "MaximumNumberOfApplicationCommandsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumThreadParticipantsReached"] = 30033] = "MaximumThreadParticipantsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumDailyApplicationCommandCreatesReached"] = 30034] = "MaximumDailyApplicationCommandCreatesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfNonGuildMemberBansHasBeenExceeded"] = 30035] = "MaximumNumberOfNonGuildMemberBansHasBeenExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfBanFetchesHasBeenReached"] = 30037] = "MaximumNumberOfBanFetchesHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfUncompletedGuildScheduledEventsReached"] = 30038] = "MaximumNumberOfUncompletedGuildScheduledEventsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfStickersReached"] = 30039] = "MaximumNumberOfStickersReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPruneRequestsHasBeenReached"] = 30040] = "MaximumNumberOfPruneRequestsHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached"] = 30042] = "MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEditsToMessagesOlderThanOneHourReached"] = 30046] = "MaximumNumberOfEditsToMessagesOlderThanOneHourReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinnedThreadsInForumHasBeenReached"] = 30047] = "MaximumNumberOfPinnedThreadsInForumHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfTagsInForumHasBeenReached"] = 30048] = "MaximumNumberOfTagsInForumHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["BitrateIsTooHighForChannelOfThisType"] = 30052] = "BitrateIsTooHighForChannelOfThisType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPremiumEmojisReached"] = 30056] = "MaximumNumberOfPremiumEmojisReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksPerGuildReached"] = 30058] = "MaximumNumberOfWebhooksPerGuildReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfChannelPermissionOverwritesReached"] = 30060] = "MaximumNumberOfChannelPermissionOverwritesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheChannelsForThisGuildAreTooLarge"] = 30061] = "TheChannelsForThisGuildAreTooLarge";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["Unauthorized"] = 40001] = "Unauthorized";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["VerifyYourAccount"] = 40002] = "VerifyYourAccount";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OpeningDirectMessagesTooFast"] = 40003] = "OpeningDirectMessagesTooFast";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["SendMessagesHasBeenTemporarilyDisabled"] = 40004] = "SendMessagesHasBeenTemporarilyDisabled";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestEntityTooLarge"] = 40005] = "RequestEntityTooLarge";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FeatureTemporarilyDisabledServerSide"] = 40006] = "FeatureTemporarilyDisabledServerSide";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UserBannedFromThisGuild"] = 40007] = "UserBannedFromThisGuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ConnectionHasBeenRevoked"] = 40012] = "ConnectionHasBeenRevoked";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TargetUserIsNotConnectedToVoice"] = 40032] = "TargetUserIsNotConnectedToVoice";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThisMessageWasAlreadyCrossposted"] = 40033] = "ThisMessageWasAlreadyCrossposted";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationCommandWithThatNameAlreadyExists"] = 40041] = "ApplicationCommandWithThatNameAlreadyExists";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationInteractionFailedToSend"] = 40043] = "ApplicationInteractionFailedToSend";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAMessageInAForumChannel"] = 40058] = "CannotSendAMessageInAForumChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InteractionHasAlreadyBeenAcknowledged"] = 40060] = "InteractionHasAlreadyBeenAcknowledged";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagNamesMustBeUnique"] = 40061] = "TagNamesMustBeUnique";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServiceResourceIsBeingRateLimited"] = 40062] = "ServiceResourceIsBeingRateLimited";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThereAreNoTagsAvailableThatCanBeSetByNonModerators"] = 40066] = "ThereAreNoTagsAvailableThatCanBeSetByNonModerators";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagRequiredToCreateAForumPostInThisChannel"] = 40067] = "TagRequiredToCreateAForumPostInThisChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingAccess"] = 50001] = "MissingAccess";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAccountType"] = 50002] = "InvalidAccountType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnDMChannel"] = 50003] = "CannotExecuteActionOnDMChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildWidgetDisabled"] = 50004] = "GuildWidgetDisabled";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditMessageAuthoredByAnotherUser"] = 50005] = "CannotEditMessageAuthoredByAnotherUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAnEmptyMessage"] = 50006] = "CannotSendAnEmptyMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesToThisUser"] = 50007] = "CannotSendMessagesToThisUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesInNonTextChannel"] = 50008] = "CannotSendMessagesInNonTextChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelVerificationLevelTooHighForYouToGainAccess"] = 50009] = "ChannelVerificationLevelTooHighForYouToGainAccess";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationDoesNotHaveBot"] = 50010] = "OAuth2ApplicationDoesNotHaveBot";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationLimitReached"] = 50011] = "OAuth2ApplicationLimitReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2State"] = 50012] = "InvalidOAuth2State";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingPermissions"] = 50013] = "MissingPermissions";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidToken"] = 50014] = "InvalidToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoteWasTooLong"] = 50015] = "NoteWasTooLong";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedTooFewOrTooManyMessagesToDelete"] = 50016] = "ProvidedTooFewOrTooManyMessagesToDelete";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMFALevel"] = 50017] = "InvalidMFALevel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageCanOnlyBePinnedInTheChannelItWasSentIn"] = 50019] = "MessageCanOnlyBePinnedInTheChannelItWasSentIn";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteCodeInvalidOrTaken"] = 50020] = "InviteCodeInvalidOrTaken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnSystemMessage"] = 50021] = "CannotExecuteActionOnSystemMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnThisChannelType"] = 50024] = "CannotExecuteActionOnThisChannelType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2AccessToken"] = 50025] = "InvalidOAuth2AccessToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingRequiredOAuth2Scope"] = 50026] = "MissingRequiredOAuth2Scope";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidWebhookToken"] = 50027] = "InvalidWebhookToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRole"] = 50028] = "InvalidRole";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRecipients"] = 50033] = "InvalidRecipients";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OneOfTheMessagesProvidedWasTooOldForBulkDelete"] = 50034] = "OneOfTheMessagesProvidedWasTooOldForBulkDelete";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFormBodyOrContentType"] = 50035] = "InvalidFormBodyOrContentType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteAcceptedToGuildWithoutTheBotBeingIn"] = 50036] = "InviteAcceptedToGuildWithoutTheBotBeingIn";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActivityAction"] = 50039] = "InvalidActivityAction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAPIVersion"] = 50041] = "InvalidAPIVersion";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FileUploadedExceedsMaximumSize"] = 50045] = "FileUploadedExceedsMaximumSize";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFileUploaded"] = 50046] = "InvalidFileUploaded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSelfRedeemThisGift"] = 50054] = "CannotSelfRedeemThisGift";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidGuild"] = 50055] = "InvalidGuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRequestOrigin"] = 50067] = "InvalidRequestOrigin";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMessageType"] = 50068] = "InvalidMessageType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["PaymentSourceRequiredToRedeemGift"] = 50070] = "PaymentSourceRequiredToRedeemGift";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotModifyASystemWebhook"] = 50073] = "CannotModifyASystemWebhook";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteChannelRequiredForCommunityGuilds"] = 50074] = "CannotDeleteChannelRequiredForCommunityGuilds";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditStickersWithinMessage"] = 50080] = "CannotEditStickersWithinMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidStickerSent"] = 50081] = "InvalidStickerSent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActionOnArchivedThread"] = 50083] = "InvalidActionOnArchivedThread";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidThreadNotificationSettings"] = 50084] = "InvalidThreadNotificationSettings";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ParameterEarlierThanCreation"] = 50085] = "ParameterEarlierThanCreation";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CommunityServerChannelsMustBeTextChannels"] = 50086] = "CommunityServerChannelsMustBeTextChannels";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor"] = 50091] = "TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNotAvailableInYourLocation"] = 50095] = "ServerNotAvailableInYourLocation";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMonetizationEnabledToPerformThisAction"] = 50097] = "ServerNeedsMonetizationEnabledToPerformThisAction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMoreBoostsToPerformThisAction"] = 50101] = "ServerNeedsMoreBoostsToPerformThisAction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestBodyContainsInvalidJSON"] = 50109] = "RequestBodyContainsInvalidJSON";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnershipCannotBeMovedToABotUser"] = 50132] = "OwnershipCannotBeMovedToABotUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToResizeAssetBelowTheMinimumSize"] = 50138] = "FailedToResizeAssetBelowTheMinimumSize";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji"] = 50144] = "CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotConvertBetweenPremiumEmojiAndNormalEmoji"] = 50145] = "CannotConvertBetweenPremiumEmojiAndNormalEmoji";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedFileNotFound"] = 50146] = "UploadedFileNotFound";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteGuildSubscriptionIntegration"] = 50163] = "CannotDeleteGuildSubscriptionIntegration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouDoNotHavePermissionToSendThisSticker"] = 50600] = "YouDoNotHavePermissionToSendThisSticker";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TwoFactorAuthenticationIsRequired"] = 60003] = "TwoFactorAuthenticationIsRequired";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoUsersWithDiscordTagExist"] = 80004] = "NoUsersWithDiscordTagExist";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ReactionWasBlocked"] = 90001] = "ReactionWasBlocked";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationNotYetAvailable"] = 110001] = "ApplicationNotYetAvailable";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["APIResourceOverloaded"] = 13e4] = "APIResourceOverloaded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheStageIsAlreadyOpen"] = 150006] = "TheStageIsAlreadyOpen";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotReplyWithoutPermissionToReadMessageHistory"] = 160002] = "CannotReplyWithoutPermissionToReadMessageHistory";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadAlreadyCreatedForMessage"] = 160004] = "ThreadAlreadyCreatedForMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadLocked"] = 160005] = "ThreadLocked";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveThreads"] = 160006] = "MaximumActiveThreads";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveAnnouncementThreads"] = 160007] = "MaximumActiveAnnouncementThreads";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidJSONForUploadedLottieFile"] = 170001] = "InvalidJSONForUploadedLottieFile";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedLottiesCannotContainRasterizedImages"] = 170002] = "UploadedLottiesCannotContainRasterizedImages";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerMaximumFramerateExceeded"] = 170003] = "StickerMaximumFramerateExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFrameCountExceedsMaximumOf1000Frames"] = 170004] = "StickerFrameCountExceedsMaximumOf1000Frames";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["LottieAnimationMaximumDimensionsExceeded"] = 170005] = "LottieAnimationMaximumDimensionsExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFramerateIsTooSmallOrTooLarge"] = 170006] = "StickerFramerateIsTooSmallOrTooLarge";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerAnimationDurationExceedsMaximumOf5Seconds"] = 170007] = "StickerAnimationDurationExceedsMaximumOf5Seconds";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateAFinishedEvent"] = 18e4] = "CannotUpdateAFinishedEvent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToCreateStageNeededForStageEvent"] = 180002] = "FailedToCreateStageNeededForStageEvent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageWasBlockedByAutomaticModeration"] = 2e5] = "MessageWasBlockedByAutomaticModeration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TitleWasBlockedByAutomaticModeration"] = 200001] = "TitleWasBlockedByAutomaticModeration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId"] = 220001] = "WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId"] = 220002] = "WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksCanOnlyCreateThreadsInForumChannels"] = 220003] = "WebhooksCanOnlyCreateThreadsInForumChannels";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhookServicesCannotBeUsedInForumChannels"] = 220004] = "WebhookServicesCannotBeUsedInForumChannels";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageBlockedByHarmfulLinksFilter"] = 24e4] = "MessageBlockedByHarmfulLinksFilter";
    })(RESTJSONErrorCodes = exports2.RESTJSONErrorCodes || (exports2.RESTJSONErrorCodes = {}));
    var Locale;
    (function(Locale2) {
      Locale2["Indonesian"] = "id";
      Locale2["EnglishUS"] = "en-US";
      Locale2["EnglishGB"] = "en-GB";
      Locale2["Bulgarian"] = "bg";
      Locale2["ChineseCN"] = "zh-CN";
      Locale2["ChineseTW"] = "zh-TW";
      Locale2["Croatian"] = "hr";
      Locale2["Czech"] = "cs";
      Locale2["Danish"] = "da";
      Locale2["Dutch"] = "nl";
      Locale2["Finnish"] = "fi";
      Locale2["French"] = "fr";
      Locale2["German"] = "de";
      Locale2["Greek"] = "el";
      Locale2["Hindi"] = "hi";
      Locale2["Hungarian"] = "hu";
      Locale2["Italian"] = "it";
      Locale2["Japanese"] = "ja";
      Locale2["Korean"] = "ko";
      Locale2["Lithuanian"] = "lt";
      Locale2["Norwegian"] = "no";
      Locale2["Polish"] = "pl";
      Locale2["PortugueseBR"] = "pt-BR";
      Locale2["Romanian"] = "ro";
      Locale2["Russian"] = "ru";
      Locale2["SpanishES"] = "es-ES";
      Locale2["Swedish"] = "sv-SE";
      Locale2["Thai"] = "th";
      Locale2["Turkish"] = "tr";
      Locale2["Ukrainian"] = "uk";
      Locale2["Vietnamese"] = "vi";
    })(Locale = exports2.Locale || (exports2.Locale = {}));
  }
});

// node_modules/discord-api-types/rest/v10/application.js
var require_application2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/application.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/auditLog.js
var require_auditLog2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/auditLog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/autoModeration.js
var require_autoModeration2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/autoModeration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/channel.js
var require_channel3 = __commonJS({
  "node_modules/discord-api-types/rest/v10/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/emoji.js
var require_emoji2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/emoji.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/gateway.js
var require_gateway2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/gateway.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/guild.js
var require_guild2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/guild.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/guildScheduledEvent.js
var require_guildScheduledEvent2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/guildScheduledEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/interactions.js
var require_interactions2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/interactions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/invite.js
var require_invite2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/invite.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/oauth2.js
var require_oauth22 = __commonJS({
  "node_modules/discord-api-types/rest/v10/oauth2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/stageInstance.js
var require_stageInstance2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/stageInstance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/sticker.js
var require_sticker2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/sticker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/template.js
var require_template2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/template.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/user.js
var require_user3 = __commonJS({
  "node_modules/discord-api-types/rest/v10/user.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/voice.js
var require_voice2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/voice.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/webhook.js
var require_webhook2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/webhook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/index.js
var require_v103 = __commonJS({
  "node_modules/discord-api-types/rest/v10/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OAuth2Routes = exports2.RouteBases = exports2.ImageFormat = exports2.CDNRoutes = exports2.StickerPackApplicationId = exports2.Routes = exports2.APIVersion = void 0;
    __exportStar2(require_common3(), exports2);
    __exportStar2(require_application2(), exports2);
    __exportStar2(require_auditLog2(), exports2);
    __exportStar2(require_autoModeration2(), exports2);
    __exportStar2(require_channel3(), exports2);
    __exportStar2(require_emoji2(), exports2);
    __exportStar2(require_gateway2(), exports2);
    __exportStar2(require_guild2(), exports2);
    __exportStar2(require_guildScheduledEvent2(), exports2);
    __exportStar2(require_interactions2(), exports2);
    __exportStar2(require_invite2(), exports2);
    __exportStar2(require_oauth22(), exports2);
    __exportStar2(require_stageInstance2(), exports2);
    __exportStar2(require_sticker2(), exports2);
    __exportStar2(require_template2(), exports2);
    __exportStar2(require_user3(), exports2);
    __exportStar2(require_voice2(), exports2);
    __exportStar2(require_webhook2(), exports2);
    exports2.APIVersion = "10";
    exports2.Routes = {
      /**
       * Route for:
       * - GET `/applications/{application.id}/role-connections/metadata`
       * - PUT `/applications/{application.id}/role-connections/metadata`
       */
      applicationRoleConnectionMetadata(applicationId) {
        return `/applications/${applicationId}/role-connections/metadata`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/auto-moderation/rules`
       * - POST `/guilds/{guild.id}/auto-moderation/rules`
       */
      guildAutoModerationRules(guildId) {
        return `/guilds/${guildId}/auto-moderation/rules`;
      },
      /**
       * Routes for:
       * - GET    `/guilds/{guild.id}/auto-moderation/rules/{rule.id}`
       * - PATCH  `/guilds/{guild.id}/auto-moderation/rules/{rule.id}`
       * - DELETE `/guilds/{guild.id}/auto-moderation/rules/{rule.id}`
       */
      guildAutoModerationRule(guildId, ruleId) {
        return `/guilds/${guildId}/auto-moderation/rules/${ruleId}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/audit-logs`
       */
      guildAuditLog(guildId) {
        return `/guilds/${guildId}/audit-logs`;
      },
      /**
       * Route for:
       * - GET    `/channels/{channel.id}`
       * - PATCH  `/channels/{channel.id}`
       * - DELETE `/channels/{channel.id}`
       */
      channel(channelId) {
        return `/channels/${channelId}`;
      },
      /**
       * Route for:
       * - GET  `/channels/{channel.id}/messages`
       * - POST `/channels/{channel.id}/messages`
       */
      channelMessages(channelId) {
        return `/channels/${channelId}/messages`;
      },
      /**
       * Route for:
       * - GET    `/channels/{channel.id}/messages/{message.id}`
       * - PATCH  `/channels/{channel.id}/messages/{message.id}`
       * - DELETE `/channels/{channel.id}/messages/{message.id}`
       */
      channelMessage(channelId, messageId) {
        return `/channels/${channelId}/messages/${messageId}`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/messages/{message.id}/crosspost`
       */
      channelMessageCrosspost(channelId, messageId) {
        return `/channels/${channelId}/messages/${messageId}/crosspost`;
      },
      /**
       * Route for:
       * - PUT    `/channels/{channel.id}/messages/{message.id}/reactions/{emoji}/@me`
       * - DELETE `/channels/{channel.id}/messages/{message.id}/reactions/{emoji}/@me`
       *
       * **Note**: You need to URL encode the emoji yourself
       */
      channelMessageOwnReaction(channelId, messageId, emoji) {
        return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/@me`;
      },
      /**
       * Route for:
       * - DELETE `/channels/{channel.id}/messages/{message.id}/reactions/{emoji}/{user.id}`
       *
       * **Note**: You need to URL encode the emoji yourself
       */
      channelMessageUserReaction(channelId, messageId, emoji, userId) {
        return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/${userId}`;
      },
      /**
       * Route for:
       * - GET    `/channels/{channel.id}/messages/{message.id}/reactions/{emoji}`
       * - DELETE `/channels/{channel.id}/messages/{message.id}/reactions/{emoji}`
       *
       * **Note**: You need to URL encode the emoji yourself
       */
      channelMessageReaction(channelId, messageId, emoji) {
        return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}`;
      },
      /**
       * Route for:
       * - DELETE `/channels/{channel.id}/messages/{message.id}/reactions`
       */
      channelMessageAllReactions(channelId, messageId) {
        return `/channels/${channelId}/messages/${messageId}/reactions`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/messages/bulk-delete`
       */
      channelBulkDelete(channelId) {
        return `/channels/${channelId}/messages/bulk-delete`;
      },
      /**
       * Route for:
       * - PUT    `/channels/{channel.id}/permissions/{overwrite.id}`
       * - DELETE `/channels/{channel.id}/permissions/{overwrite.id}`
       */
      channelPermission(channelId, overwriteId) {
        return `/channels/${channelId}/permissions/${overwriteId}`;
      },
      /**
       * Route for:
       * - GET  `/channels/{channel.id}/invites`
       * - POST `/channels/{channel.id}/invites`
       */
      channelInvites(channelId) {
        return `/channels/${channelId}/invites`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/followers`
       */
      channelFollowers(channelId) {
        return `/channels/${channelId}/followers`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/typing`
       */
      channelTyping(channelId) {
        return `/channels/${channelId}/typing`;
      },
      /**
       * Route for:
       * - GET `/channels/{channel.id}/pins`
       */
      channelPins(channelId) {
        return `/channels/${channelId}/pins`;
      },
      /**
       * Route for:
       * - PUT    `/channels/{channel.id}/pins/{message.id}`
       * - DELETE `/channels/{channel.id}/pins/{message.id}`
       */
      channelPin(channelId, messageId) {
        return `/channels/${channelId}/pins/${messageId}`;
      },
      /**
       * Route for:
       * - PUT    `/channels/{channel.id}/recipients/{user.id}`
       * - DELETE `/channels/{channel.id}/recipients/{user.id}`
       */
      channelRecipient(channelId, userId) {
        return `/channels/${channelId}/recipients/${userId}`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/emojis`
       * - POST `/guilds/{guild.id}/emojis`
       */
      guildEmojis(guildId) {
        return `/guilds/${guildId}/emojis`;
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}/emojis/{emoji.id}`
       * - PATCH  `/guilds/{guild.id}/emojis/{emoji.id}`
       * - DELETE `/guilds/{guild.id}/emojis/{emoji.id}`
       */
      guildEmoji(guildId, emojiId) {
        return `/guilds/${guildId}/emojis/${emojiId}`;
      },
      /**
       * Route for:
       * - POST `/guilds`
       */
      guilds() {
        return "/guilds";
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}`
       * - PATCH  `/guilds/{guild.id}`
       * - DELETE `/guilds/{guild.id}`
       */
      guild(guildId) {
        return `/guilds/${guildId}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/preview`
       */
      guildPreview(guildId) {
        return `/guilds/${guildId}/preview`;
      },
      /**
       * Route for:
       * - GET   `/guilds/{guild.id}/channels`
       * - POST  `/guilds/{guild.id}/channels`
       * - PATCH `/guilds/{guild.id}/channels`
       */
      guildChannels(guildId) {
        return `/guilds/${guildId}/channels`;
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}/members/{user.id}`
       * - PUT    `/guilds/{guild.id}/members/{user.id}`
       * - PATCH  `/guilds/{guild.id}/members/@me`
       * - PATCH  `/guilds/{guild.id}/members/{user.id}`
       * - DELETE `/guilds/{guild.id}/members/{user.id}`
       */
      guildMember(guildId, userId = "@me") {
        return `/guilds/${guildId}/members/${userId}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/members`
       */
      guildMembers(guildId) {
        return `/guilds/${guildId}/members`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/members/search`
       */
      guildMembersSearch(guildId) {
        return `/guilds/${guildId}/members/search`;
      },
      /**
       * Route for:
       * - PATCH `/guilds/{guild.id}/members/@me/nick`
       * @deprecated Use {@link Routes.guildMember} instead.
       */
      guildCurrentMemberNickname(guildId) {
        return `/guilds/${guildId}/members/@me/nick`;
      },
      /**
       * Route for:
       * - PUT    `/guilds/{guild.id}/members/{user.id}/roles/{role.id}`
       * - DELETE `/guilds/{guild.id}/members/{user.id}/roles/{role.id}`
       */
      guildMemberRole(guildId, memberId, roleId) {
        return `/guilds/${guildId}/members/${memberId}/roles/${roleId}`;
      },
      /**
       * Route for:
       * - POST `/guilds/{guild.id}/mfa`
       */
      guildMFA(guildId) {
        return `/guilds/${guildId}/mfa`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/bans`
       */
      guildBans(guildId) {
        return `/guilds/${guildId}/bans`;
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}/bans/{user.id}`
       * - PUT    `/guilds/{guild.id}/bans/{user.id}`
       * - DELETE `/guilds/{guild.id}/bans/{user.id}`
       */
      guildBan(guildId, userId) {
        return `/guilds/${guildId}/bans/${userId}`;
      },
      /**
       * Route for:
       * - GET   `/guilds/{guild.id}/roles`
       * - POST  `/guilds/{guild.id}/roles`
       * - PATCH `/guilds/{guild.id}/roles`
       */
      guildRoles(guildId) {
        return `/guilds/${guildId}/roles`;
      },
      /**
       * Route for:
       * - PATCH  `/guilds/{guild.id}/roles/{role.id}`
       * - DELETE `/guilds/{guild.id}/roles/{role.id}`
       */
      guildRole(guildId, roleId) {
        return `/guilds/${guildId}/roles/${roleId}`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/prune`
       * - POST `/guilds/{guild.id}/prune`
       */
      guildPrune(guildId) {
        return `/guilds/${guildId}/prune`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/regions`
       */
      guildVoiceRegions(guildId) {
        return `/guilds/${guildId}/regions`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/invites`
       */
      guildInvites(guildId) {
        return `/guilds/${guildId}/invites`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/integrations`
       */
      guildIntegrations(guildId) {
        return `/guilds/${guildId}/integrations`;
      },
      /**
       * Route for:
       * - DELETE `/guilds/{guild.id}/integrations/{integration.id}`
       */
      guildIntegration(guildId, integrationId) {
        return `/guilds/${guildId}/integrations/${integrationId}`;
      },
      /**
       * Route for:
       * - GET   `/guilds/{guild.id}/widget`
       * - PATCH `/guilds/{guild.id}/widget`
       */
      guildWidgetSettings(guildId) {
        return `/guilds/${guildId}/widget`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/widget.json`
       */
      guildWidgetJSON(guildId) {
        return `/guilds/${guildId}/widget.json`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/vanity-url`
       */
      guildVanityUrl(guildId) {
        return `/guilds/${guildId}/vanity-url`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/widget.png`
       */
      guildWidgetImage(guildId) {
        return `/guilds/${guildId}/widget.png`;
      },
      /**
       * Route for:
       * - GET    `/invites/{invite.code}`
       * - DELETE `/invites/{invite.code}`
       */
      invite(code) {
        return `/invites/${code}`;
      },
      /**
       * Route for:
       * - GET  `/guilds/templates/{template.code}`
       * - POST `/guilds/templates/{template.code}`
       */
      template(code) {
        return `/guilds/templates/${code}`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/templates`
       * - POST `/guilds/{guild.id}/templates`
       */
      guildTemplates(guildId) {
        return `/guilds/${guildId}/templates`;
      },
      /**
       * Route for:
       * - PUT    `/guilds/{guild.id}/templates/{template.code}`
       * - PATCH  `/guilds/{guild.id}/templates/{template.code}`
       * - DELETE `/guilds/{guild.id}/templates/{template.code}`
       */
      guildTemplate(guildId, code) {
        return `/guilds/${guildId}/templates/${code}`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/threads`
       * - POST `/channels/{channel.id}/messages/{message.id}/threads`
       */
      threads(parentId, messageId) {
        const parts = ["", "channels", parentId];
        if (messageId)
          parts.push("messages", messageId);
        parts.push("threads");
        return parts.join("/");
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/threads/active`
       */
      guildActiveThreads(guildId) {
        return `/guilds/${guildId}/threads/active`;
      },
      /**
       * Route for:
       * - GET `/channels/{channel.id}/threads/archived/public`
       * - GET `/channels/{channel.id}/threads/archived/private`
       */
      channelThreads(channelId, archivedStatus) {
        return `/channels/${channelId}/threads/archived/${archivedStatus}`;
      },
      /**
       * Route for:
       * - GET `/channels/{channel.id}/users/@me/threads/archived/prviate`
       */
      channelJoinedArchivedThreads(channelId) {
        return `/channels/${channelId}/users/@me/threads/archived/private`;
      },
      /**
       * Route for:
       * - GET    `/channels/{thread.id}/thread-members`
       * - GET    `/channels/{thread.id}/thread-members/{user.id}`
       * - PUT    `/channels/{thread.id}/thread-members/@me`
       * - PUT    `/channels/{thread.id}/thread-members/{user.id}`
       * - DELETE `/channels/{thread.id}/thread-members/@me`
       * - DELETE `/channels/{thread.id}/thread-members/{user.id}`
       */
      threadMembers(threadId, userId) {
        const parts = ["", "channels", threadId, "thread-members"];
        if (userId)
          parts.push(userId);
        return parts.join("/");
      },
      /**
       * Route for:
       * - GET   `/users/@me`
       * - GET   `/users/{user.id}`
       * - PATCH `/users/@me`
       *
       * @param [userId='@me'] The user ID, defaulted to `@me`
       */
      user(userId = "@me") {
        return `/users/${userId}`;
      },
      /**
       * Route for:
       * - GET `/users/@me/applications/{application.id}/role-connection`
       * - PUT `/users/@me/applications/{application.id}/role-connection`
       */
      userApplicationRoleConnection(applicationId) {
        return `/users/@me/applications/${applicationId}/role-connection`;
      },
      /**
       * Route for:
       * - GET `/users/@me/guilds`
       */
      userGuilds() {
        return `/users/@me/guilds`;
      },
      /**
       * Route for:
       * - GET `/users/@me/guilds/{guild.id}/member`
       */
      userGuildMember(guildId) {
        return `/users/@me/guilds/${guildId}/member`;
      },
      /**
       * Route for:
       * - DELETE `/users/@me/guilds/{guild.id}`
       */
      userGuild(guildId) {
        return `/users/@me/guilds/${guildId}`;
      },
      /**
       * Route for:
       * - POST `/users/@me/channels`
       */
      userChannels() {
        return `/users/@me/channels`;
      },
      /**
       * Route for:
       * - GET `/users/@me/connections`
       */
      userConnections() {
        return `/users/@me/connections`;
      },
      /**
       * Route for:
       * - GET `/voice/regions`
       */
      voiceRegions() {
        return `/voice/regions`;
      },
      /**
       * Route for:
       * - GET  `/channels/{channel.id}/webhooks`
       * - POST `/channels/{channel.id}/webhooks`
       */
      channelWebhooks(channelId) {
        return `/channels/${channelId}/webhooks`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/webhooks`
       */
      guildWebhooks(guildId) {
        return `/guilds/${guildId}/webhooks`;
      },
      /**
       * Route for:
       * - GET    `/webhooks/{webhook.id}`
       * - GET    `/webhooks/{webhook.id}/{webhook.token}`
       * - PATCH  `/webhooks/{webhook.id}`
       * - PATCH  `/webhooks/{webhook.id}/{webhook.token}`
       * - DELETE `/webhooks/{webhook.id}`
       * - DELETE `/webhooks/{webhook.id}/{webhook.token}`
       * - POST   `/webhooks/{webhook.id}/{webhook.token}`
       *
       * - POST   `/webhooks/{application.id}/{interaction.token}`
       */
      webhook(webhookId, webhookToken) {
        const parts = ["", "webhooks", webhookId];
        if (webhookToken)
          parts.push(webhookToken);
        return parts.join("/");
      },
      /**
       * Route for:
       * - GET    `/webhooks/{webhook.id}/{webhook.token}/messages/@original`
       * - GET    `/webhooks/{webhook.id}/{webhook.token}/messages/{message.id}`
       * - PATCH  `/webhooks/{webhook.id}/{webhook.token}/messages/@original`
       * - PATCH  `/webhooks/{webhook.id}/{webhook.token}/messages/{message.id}`
       * - DELETE `/webhooks/{webhook.id}/{webhook.token}/messages/@original`
       * - DELETE `/webhooks/{webhook.id}/{webhook.token}/messages/{message.id}`
       *
       * - PATCH  `/webhooks/{application.id}/{interaction.token}/messages/@original`
       * - PATCH  `/webhooks/{application.id}/{interaction.token}/messages/{message.id}`
       * - DELETE `/webhooks/{application.id}/{interaction.token}/messages/{message.id}`
       *
       * @param [messageId='@original'] The message ID to change, defaulted to `@original`
       */
      webhookMessage(webhookId, webhookToken, messageId = "@original") {
        return `/webhooks/${webhookId}/${webhookToken}/messages/${messageId}`;
      },
      /**
       * Route for:
       * - POST `/webhooks/{webhook.id}/{webhook.token}/github`
       * - POST `/webhooks/{webhook.id}/{webhook.token}/slack`
       */
      webhookPlatform(webhookId, webhookToken, platform) {
        return `/webhooks/${webhookId}/${webhookToken}/${platform}`;
      },
      /**
       * Route for:
       * - GET `/gateway`
       */
      gateway() {
        return `/gateway`;
      },
      /**
       * Route for:
       * - GET `/gateway/bot`
       */
      gatewayBot() {
        return `/gateway/bot`;
      },
      /**
       * Route for:
       * - GET `/oauth2/applications/@me`
       */
      oauth2CurrentApplication() {
        return `/oauth2/applications/@me`;
      },
      /**
       * Route for:
       * - GET `/oauth2/@me`
       */
      oauth2CurrentAuthorization() {
        return `/oauth2/@me`;
      },
      /**
       * Route for:
       * - GET `/oauth2/authorize`
       */
      oauth2Authorization() {
        return `/oauth2/authorize`;
      },
      /**
       * Route for:
       * - POST `/oauth2/token`
       */
      oauth2TokenExchange() {
        return `/oauth2/token`;
      },
      /**
       * Route for:
       * - POST `/oauth2/token/revoke`
       */
      oauth2TokenRevocation() {
        return `/oauth2/token/revoke`;
      },
      /**
       * Route for:
       * - GET  `/applications/{application.id}/commands`
       * - PUT  `/applications/{application.id}/commands`
       * - POST `/applications/{application.id}/commands`
       */
      applicationCommands(applicationId) {
        return `/applications/${applicationId}/commands`;
      },
      /**
       * Route for:
       * - GET    `/applications/{application.id}/commands/{command.id}`
       * - PATCH  `/applications/{application.id}/commands/{command.id}`
       * - DELETE `/applications/{application.id}/commands/{command.id}`
       */
      applicationCommand(applicationId, commandId) {
        return `/applications/${applicationId}/commands/${commandId}`;
      },
      /**
       * Route for:
       * - GET  `/applications/{application.id}/guilds/{guild.id}/commands`
       * - PUT  `/applications/{application.id}/guilds/{guild.id}/commands`
       * - POST `/applications/{application.id}/guilds/{guild.id}/commands`
       */
      applicationGuildCommands(applicationId, guildId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands`;
      },
      /**
       * Route for:
       * - GET    `/applications/{application.id}/guilds/{guild.id}/commands/{command.id}`
       * - PATCH  `/applications/{application.id}/guilds/{guild.id}/commands/{command.id}`
       * - DELETE `/applications/{application.id}/guilds/{guild.id}/commands/{command.id}`
       */
      applicationGuildCommand(applicationId, guildId, commandId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}`;
      },
      /**
       * Route for:
       * - POST `/interactions/{interaction.id}/{interaction.token}/callback`
       */
      interactionCallback(interactionId, interactionToken) {
        return `/interactions/${interactionId}/${interactionToken}/callback`;
      },
      /**
       * Route for:
       * - GET   `/guilds/{guild.id}/member-verification`
       * - PATCH `/guilds/{guild.id}/member-verification`
       */
      guildMemberVerification(guildId) {
        return `/guilds/${guildId}/member-verification`;
      },
      /**
       * Route for:
       * - PATCH `/guilds/{guild.id}/voice-states/@me`
       * - PATCH `/guilds/{guild.id}/voice-states/{user.id}`
       */
      guildVoiceState(guildId, userId = "@me") {
        return `/guilds/${guildId}/voice-states/${userId}`;
      },
      /**
       * Route for:
       * - GET `/applications/{application.id}/guilds/{guild.id}/commands/permissions`
       * - PUT `/applications/{application.id}/guilds/{guild.id}/commands/permissions`
       */
      guildApplicationCommandsPermissions(applicationId, guildId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands/permissions`;
      },
      /**
       * Route for:
       * - GET `/applications/{application.id}/guilds/{guild.id}/commands/{command.id}/permissions`
       * - PUT `/applications/{application.id}/guilds/{guild.id}/commands/{command.id}/permissions`
       */
      applicationCommandPermissions(applicationId, guildId, commandId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}/permissions`;
      },
      /**
       * Route for:
       * - GET   `/guilds/{guild.id}/welcome-screen`
       * - PATCH `/guilds/{guild.id}/welcome-screen`
       */
      guildWelcomeScreen(guildId) {
        return `/guilds/${guildId}/welcome-screen`;
      },
      /**
       * Route for:
       * - POST `/stage-instances`
       */
      stageInstances() {
        return `/stage-instances`;
      },
      /**
       * Route for:
       * - GET `/stage-instances/{channel.id}`
       * - PATCH `/stage-instances/{channel.id}`
       * - DELETE `/stage-instances/{channel.id}`
       */
      stageInstance(channelId) {
        return `/stage-instances/${channelId}`;
      },
      /**
       * Route for:
       * - GET `/stickers/{sticker.id}`
       */
      sticker(stickerId) {
        return `/stickers/${stickerId}`;
      },
      /**
       * Route for:
       * - GET `/sticker-packs`
       */
      nitroStickerPacks() {
        return "/sticker-packs";
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/stickers`
       * - POST `/guilds/{guild.id}/stickers`
       */
      guildStickers(guildId) {
        return `/guilds/${guildId}/stickers`;
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}/stickers/{sticker.id}`
       * - PATCH  `/guilds/{guild.id}/stickers/{sticker.id}`
       * - DELETE `/guilds/{guild.id}/stickers/{sticker.id}`
       */
      guildSticker(guildId, stickerId) {
        return `/guilds/${guildId}/stickers/${stickerId}`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/scheduled-events`
       * - POST `/guilds/{guild.id}/scheduled-events`
       */
      guildScheduledEvents(guildId) {
        return `/guilds/${guildId}/scheduled-events`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/scheduled-events/{guildScheduledEvent.id}`
       * - PATCH `/guilds/{guild.id}/scheduled-events/{guildScheduledEvent.id}`
       * - DELETE `/guilds/{guild.id}/scheduled-events/{guildScheduledEvent.id}`
       */
      guildScheduledEvent(guildId, guildScheduledEventId) {
        return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/scheduled-events/{guildScheduledEvent.id}/users`
       */
      guildScheduledEventUsers(guildId, guildScheduledEventId) {
        return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}/users`;
      }
    };
    exports2.StickerPackApplicationId = "710982414301790216";
    exports2.CDNRoutes = {
      /**
       * Route for:
       * - GET `/emojis/{emoji.id}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      emoji(emojiId, format2) {
        return `/emojis/${emojiId}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/icons/{guild.id}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      guildIcon(guildId, guildIcon, format2) {
        return `icons/${guildId}/${guildIcon}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/splashes/{guild.id}/{guild.splash}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      guildSplash(guildId, guildSplash, format2) {
        return `/splashes/${guildId}/${guildSplash}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/discovery-splashes/{guild.id}/{guild.discovery_splash}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      guildDiscoverySplash(guildId, guildDiscoverySplash, format2) {
        return `/discovery-splashes/${guildId}/${guildDiscoverySplash}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/banners/{guild.id}/{guild.banner}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      guildBanner(guildId, guildBanner, format2) {
        return `/banners/${guildId}/${guildBanner}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/banners/{user.id}/{user.banner}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      userBanner(userId, userBanner, format2) {
        return `/banners/${userId}/${userBanner}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/embed/avatars/{user.discriminator % 5}.png`
       *
       * The `userDiscriminator` parameter should be the user discriminator modulo 5 (e.g. 1337 % 5 = 2)
       *
       * This route supports the extension: PNG
       */
      defaultUserAvatar(userDiscriminator) {
        return `/embed/avatars/${userDiscriminator}.png`;
      },
      /**
       * Route for:
       * - GET `/avatars/{user.id}/{user.avatar}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      userAvatar(userId, userAvatar, format2) {
        return `/avatars/${userId}/${userAvatar}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/users/{user.id}/{guild_member.avatar}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      guildMemberAvatar(guildId, userId, memberAvatar, format2) {
        return `/guilds/${guildId}/users/${userId}/avatars/${memberAvatar}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/app-icons/{application.id}/{application.icon}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      applicationIcon(applicationId, applicationIcon, format2) {
        return `/app-icons/${applicationId}/${applicationIcon}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/app-icons/{application.id}/{application.cover_image}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      applicationCover(applicationId, applicationCoverImage, format2) {
        return `/app-icons/${applicationId}/${applicationCoverImage}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/app-assets/{application.id}/{application.asset_id}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      applicationAsset(applicationId, applicationAssetId, format2) {
        return `/app-assets/${applicationId}/${applicationAssetId}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/app-assets/{application.id}/achievements/{achievement.id}/icons/{achievement.icon}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      achievementIcon(applicationId, achievementId, achievementIconHash, format2) {
        return `/app-assets/${applicationId}/achievements/${achievementId}/icons/${achievementIconHash}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/app-assets/710982414301790216/store/{sticker_pack.banner.asset_id}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      stickerPackBanner(stickerPackBannerAssetId, format2) {
        return `/app-assets/${exports2.StickerPackApplicationId}/store/${stickerPackBannerAssetId}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/app-assets/${application.id}/store/${asset.id}.{png|jpeg|webp}}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      storePageAsset(applicationId, assetId) {
        return `/app-assets/${applicationId}/store/${assetId}.png`;
      },
      /**
       * Route for:
       * - GET `team-icons/{team.id}/{team.icon}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      teamIcon(teamId, teamIcon, format2) {
        return `/team-icons/${teamId}/${teamIcon}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/stickers/{sticker.id}.{png|json}`
       *
       * This route supports the extensions: PNG, Lottie, GIF
       */
      sticker(stickerId, format2) {
        return `/stickers/${stickerId}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/role-icons/{role.id}/{role.icon}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      roleIcon(roleId, roleIcon, format2) {
        return `/role-icons/${roleId}/${roleIcon}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/guild-events/{guild_scheduled_event.id}/{guild_scheduled_event.image}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      guildScheduledEventCover(guildScheduledEventId, guildScheduledEventCoverImage, format2) {
        return `/guild-events/${guildScheduledEventId}/${guildScheduledEventCoverImage}.${format2}`;
      },
      /**
       * Route for:
       * - GET `/guilds/${guild.id}/users/${user.id}/banners/${guild_member.banner}.{png|jpeg|webp|gif}`
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      guildMemberBanner(guildId, userId, guildMemberBanner, format2) {
        return `/guilds/${guildId}/users/${userId}/banners/${guildMemberBanner}.${format2}`;
      }
    };
    var ImageFormat;
    (function(ImageFormat2) {
      ImageFormat2["JPEG"] = "jpeg";
      ImageFormat2["PNG"] = "png";
      ImageFormat2["WebP"] = "webp";
      ImageFormat2["GIF"] = "gif";
      ImageFormat2["Lottie"] = "json";
    })(ImageFormat = exports2.ImageFormat || (exports2.ImageFormat = {}));
    exports2.RouteBases = {
      api: `https://discord.com/api/v${exports2.APIVersion}`,
      cdn: "https://cdn.discordapp.com",
      invite: "https://discord.gg",
      template: "https://discord.new",
      gift: "https://discord.gift",
      scheduledEvent: "https://discord.com/events"
    };
    Object.freeze(exports2.RouteBases);
    exports2.OAuth2Routes = {
      authorizationURL: `${exports2.RouteBases.api}${exports2.Routes.oauth2Authorization()}`,
      tokenURL: `${exports2.RouteBases.api}${exports2.Routes.oauth2TokenExchange()}`,
      /**
       * See https://tools.ietf.org/html/rfc7009
       */
      tokenRevocationURL: `${exports2.RouteBases.api}${exports2.Routes.oauth2TokenRevocation()}`
    };
    Object.freeze(exports2.OAuth2Routes);
  }
});

// node_modules/discord-api-types/rpc/common.js
var require_common4 = __commonJS({
  "node_modules/discord-api-types/rpc/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RPCCloseEventCodes = exports2.RPCErrorCodes = void 0;
    var RPCErrorCodes;
    (function(RPCErrorCodes2) {
      RPCErrorCodes2[RPCErrorCodes2["UnknownError"] = 1e3] = "UnknownError";
      RPCErrorCodes2[RPCErrorCodes2["InvalidPayload"] = 4e3] = "InvalidPayload";
      RPCErrorCodes2[RPCErrorCodes2["InvalidCommand"] = 4002] = "InvalidCommand";
      RPCErrorCodes2[RPCErrorCodes2["InvalidGuild"] = 4003] = "InvalidGuild";
      RPCErrorCodes2[RPCErrorCodes2["InvalidEvent"] = 4004] = "InvalidEvent";
      RPCErrorCodes2[RPCErrorCodes2["InvalidChannel"] = 4005] = "InvalidChannel";
      RPCErrorCodes2[RPCErrorCodes2["InvalidPermissions"] = 4006] = "InvalidPermissions";
      RPCErrorCodes2[RPCErrorCodes2["InvalidClientId"] = 4007] = "InvalidClientId";
      RPCErrorCodes2[RPCErrorCodes2["InvalidOrigin"] = 4008] = "InvalidOrigin";
      RPCErrorCodes2[RPCErrorCodes2["InvalidToken"] = 4009] = "InvalidToken";
      RPCErrorCodes2[RPCErrorCodes2["InvalidUser"] = 4010] = "InvalidUser";
      RPCErrorCodes2[RPCErrorCodes2["OAuth2Error"] = 5e3] = "OAuth2Error";
      RPCErrorCodes2[RPCErrorCodes2["SelectChannelTimedOut"] = 5001] = "SelectChannelTimedOut";
      RPCErrorCodes2[RPCErrorCodes2["GetGuildTimedOut"] = 5002] = "GetGuildTimedOut";
      RPCErrorCodes2[RPCErrorCodes2["SelectVoiceForceRequired"] = 5003] = "SelectVoiceForceRequired";
      RPCErrorCodes2[RPCErrorCodes2["CaptureShortcutAlreadyListening"] = 5004] = "CaptureShortcutAlreadyListening";
    })(RPCErrorCodes = exports2.RPCErrorCodes || (exports2.RPCErrorCodes = {}));
    var RPCCloseEventCodes;
    (function(RPCCloseEventCodes2) {
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidClientId"] = 4e3] = "InvalidClientId";
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidOrigin"] = 4001] = "InvalidOrigin";
      RPCCloseEventCodes2[RPCCloseEventCodes2["RateLimited"] = 4002] = "RateLimited";
      RPCCloseEventCodes2[RPCCloseEventCodes2["TokenRevoked"] = 4003] = "TokenRevoked";
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidVersion"] = 4004] = "InvalidVersion";
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidEncoding"] = 4005] = "InvalidEncoding";
    })(RPCCloseEventCodes = exports2.RPCCloseEventCodes || (exports2.RPCCloseEventCodes = {}));
  }
});

// node_modules/discord-api-types/rpc/v10.js
var require_v104 = __commonJS({
  "node_modules/discord-api-types/rpc/v10.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_common4(), exports2);
  }
});

// node_modules/discord-api-types/utils/v10.js
var require_v105 = __commonJS({
  "node_modules/discord-api-types/utils/v10.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isContextMenuApplicationCommandInteraction = exports2.isChatInputApplicationCommandInteraction = exports2.isMessageComponentSelectMenuInteraction = exports2.isMessageComponentButtonInteraction = exports2.isMessageComponentInteraction = exports2.isInteractionButton = exports2.isLinkButton = exports2.isMessageComponentGuildInteraction = exports2.isMessageComponentDMInteraction = exports2.isApplicationCommandGuildInteraction = exports2.isApplicationCommandDMInteraction = exports2.isGuildInteraction = exports2.isDMInteraction = void 0;
    var index_1 = require_v102();
    function isDMInteraction(interaction) {
      return Reflect.has(interaction, "user");
    }
    exports2.isDMInteraction = isDMInteraction;
    function isGuildInteraction(interaction) {
      return Reflect.has(interaction, "guild_id");
    }
    exports2.isGuildInteraction = isGuildInteraction;
    function isApplicationCommandDMInteraction(interaction) {
      return isDMInteraction(interaction);
    }
    exports2.isApplicationCommandDMInteraction = isApplicationCommandDMInteraction;
    function isApplicationCommandGuildInteraction(interaction) {
      return isGuildInteraction(interaction);
    }
    exports2.isApplicationCommandGuildInteraction = isApplicationCommandGuildInteraction;
    function isMessageComponentDMInteraction(interaction) {
      return isDMInteraction(interaction);
    }
    exports2.isMessageComponentDMInteraction = isMessageComponentDMInteraction;
    function isMessageComponentGuildInteraction(interaction) {
      return isGuildInteraction(interaction);
    }
    exports2.isMessageComponentGuildInteraction = isMessageComponentGuildInteraction;
    function isLinkButton(component) {
      return component.style === index_1.ButtonStyle.Link;
    }
    exports2.isLinkButton = isLinkButton;
    function isInteractionButton(component) {
      return component.style !== index_1.ButtonStyle.Link;
    }
    exports2.isInteractionButton = isInteractionButton;
    function isMessageComponentInteraction(interaction) {
      return interaction.type === index_1.InteractionType.MessageComponent;
    }
    exports2.isMessageComponentInteraction = isMessageComponentInteraction;
    function isMessageComponentButtonInteraction(interaction) {
      return interaction.data.component_type === index_1.ComponentType.Button;
    }
    exports2.isMessageComponentButtonInteraction = isMessageComponentButtonInteraction;
    function isMessageComponentSelectMenuInteraction(interaction) {
      return [
        index_1.ComponentType.StringSelect,
        index_1.ComponentType.UserSelect,
        index_1.ComponentType.RoleSelect,
        index_1.ComponentType.MentionableSelect,
        index_1.ComponentType.ChannelSelect
      ].includes(interaction.data.component_type);
    }
    exports2.isMessageComponentSelectMenuInteraction = isMessageComponentSelectMenuInteraction;
    function isChatInputApplicationCommandInteraction(interaction) {
      return interaction.data.type === index_1.ApplicationCommandType.ChatInput;
    }
    exports2.isChatInputApplicationCommandInteraction = isChatInputApplicationCommandInteraction;
    function isContextMenuApplicationCommandInteraction(interaction) {
      return interaction.data.type === index_1.ApplicationCommandType.Message || interaction.data.type === index_1.ApplicationCommandType.User;
    }
    exports2.isContextMenuApplicationCommandInteraction = isContextMenuApplicationCommandInteraction;
  }
});

// node_modules/discord-api-types/v10.js
var require_v106 = __commonJS({
  "node_modules/discord-api-types/v10.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Utils = void 0;
    __exportStar2(require_v10(), exports2);
    __exportStar2(require_globals(), exports2);
    __exportStar2(require_v102(), exports2);
    __exportStar2(require_v103(), exports2);
    __exportStar2(require_v104(), exports2);
    exports2.Utils = require_v105();
  }
});

// node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
  "node_modules/undici/lib/core/symbols.js"(exports2, module2) {
    module2.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kHeadersList: Symbol("headers list"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kLocalAddress: Symbol("local address"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol.for("nodejs.stream.destroyed"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelinig"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kInterceptors: Symbol("dispatch interceptors"),
      kMaxResponseSize: Symbol("max response size")
    };
  }
});

// node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({
  "node_modules/undici/lib/core/errors.js"(exports2, module2) {
    "use strict";
    var UndiciError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ConnectTimeoutError);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, HeadersTimeoutError);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, HeadersOverflowError);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, BodyTimeoutError);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var ResponseStatusCodeError = class extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        Error.captureStackTrace(this, ResponseStatusCodeError);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InvalidArgumentError);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InvalidReturnValueError);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var RequestAbortedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, RequestAbortedError);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InformationalError);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, RequestContentLengthMismatchError);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ResponseContentLengthMismatchError);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ClientDestroyedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ClientDestroyedError);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ClientClosedError);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class extends UndiciError {
      constructor(message, socket) {
        super(message);
        Error.captureStackTrace(this, SocketError);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class extends Error {
      constructor(message, code, data) {
        super(message);
        Error.captureStackTrace(this, HTTPParserError);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    var ResponseExceededMaxSizeError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ResponseExceededMaxSizeError);
        this.name = "ResponseExceededMaxSizeError";
        this.message = message || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    };
    module2.exports = {
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError
    };
  }
});

// node_modules/undici/lib/core/util.js
var require_util = __commonJS({
  "node_modules/undici/lib/core/util.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { kDestroyed, kBodyUsed } = require_symbols();
    var { IncomingMessage } = require("http");
    var stream4 = require("stream");
    var net = require("net");
    var { InvalidArgumentError } = require_errors();
    var { Blob: Blob2 } = require("buffer");
    var nodeUtil = require("util");
    var { stringify } = require("querystring");
    var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
    function nop() {
    }
    function isStream2(obj) {
      return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
    }
    function isBlobLike(object) {
      return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
    function buildURL2(url2, queryParams) {
      if (url2.includes("?") || url2.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify(queryParams);
      if (stringified) {
        url2 += "?" + stringified;
      }
      return url2;
    }
    function parseURL(url2) {
      if (typeof url2 === "string") {
        url2 = new URL(url2);
        if (!/^https?:/.test(url2.origin || url2.protocol)) {
          throw new InvalidArgumentError("invalid protocol");
        }
        return url2;
      }
      if (!url2 || typeof url2 !== "object") {
        throw new InvalidArgumentError("invalid url");
      }
      if (url2.port != null && url2.port !== "" && !Number.isFinite(parseInt(url2.port))) {
        throw new InvalidArgumentError("invalid port");
      }
      if (url2.path != null && typeof url2.path !== "string") {
        throw new InvalidArgumentError("invalid path");
      }
      if (url2.pathname != null && typeof url2.pathname !== "string") {
        throw new InvalidArgumentError("invalid pathname");
      }
      if (url2.hostname != null && typeof url2.hostname !== "string") {
        throw new InvalidArgumentError("invalid hostname");
      }
      if (url2.origin != null && typeof url2.origin !== "string") {
        throw new InvalidArgumentError("invalid origin");
      }
      if (!/^https?:/.test(url2.origin || url2.protocol)) {
        throw new InvalidArgumentError("invalid protocol");
      }
      if (!(url2 instanceof URL)) {
        const port = url2.port != null ? url2.port : url2.protocol === "https:" ? 443 : 80;
        let origin = url2.origin != null ? url2.origin : `${url2.protocol}//${url2.hostname}:${port}`;
        let path = url2.path != null ? url2.path : `${url2.pathname || ""}${url2.search || ""}`;
        if (origin.endsWith("/")) {
          origin = origin.substring(0, origin.length - 1);
        }
        if (path && !path.startsWith("/")) {
          path = `/${path}`;
        }
        url2 = new URL(origin + path);
      }
      return url2;
    }
    function parseOrigin(url2) {
      url2 = parseURL(url2);
      if (url2.pathname !== "/" || url2.search || url2.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url2;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert(idx2 !== -1);
        return host.substr(1, idx2 - 1);
      }
      const idx = host.indexOf(":");
      if (idx === -1)
        return host;
      return host.substr(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert.strictEqual(typeof host, "string");
      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream2(body)) {
        const state = body._readableState;
        return state && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer2(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(stream5) {
      return !stream5 || !!(stream5.destroyed || stream5[kDestroyed]);
    }
    function isReadableAborted(stream5) {
      const state = stream5 && stream5._readableState;
      return isDestroyed(stream5) && state && !state.endEmitted;
    }
    function destroy(stream5, err) {
      if (!isStream2(stream5) || isDestroyed(stream5)) {
        return;
      }
      if (typeof stream5.destroy === "function") {
        if (Object.getPrototypeOf(stream5).constructor === IncomingMessage) {
          stream5.socket = null;
        }
        stream5.destroy(err);
      } else if (err) {
        process.nextTick((stream6, err2) => {
          stream6.emit("error", err2);
        }, stream5, err);
      }
      if (stream5.destroyed !== true) {
        stream5[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function parseHeaders(headers, obj = {}) {
      for (let i = 0; i < headers.length; i += 2) {
        const key = headers[i].toString().toLowerCase();
        let val = obj[key];
        const encoding = key.length === 19 && key === "content-disposition" ? "latin1" : "utf8";
        if (!val) {
          if (Array.isArray(headers[i + 1])) {
            obj[key] = headers[i + 1];
          } else {
            obj[key] = headers[i + 1].toString(encoding);
          }
        } else {
          if (!Array.isArray(val)) {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString(encoding));
        }
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      const ret = [];
      for (let n = 0; n < headers.length; n += 2) {
        const key = headers[n + 0].toString();
        const encoding = key.length === 19 && key.toLowerCase() === "content-disposition" ? "latin1" : "utf8";
        const val = headers[n + 1].toString(encoding);
        ret.push(key, val);
      }
      return ret;
    }
    function isBuffer2(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream4.isDisturbed ? stream4.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
    }
    function isErrored(body) {
      return !!(body && (stream4.isErrored ? stream4.isErrored(body) : /state: 'errored'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function isReadable(body) {
      return !!(body && (stream4.isReadable ? stream4.isReadable(body) : /state: 'readable'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    var ReadableStream;
    function ReadableStreamFrom(iterable) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      if (ReadableStream.from) {
        return ReadableStream.from(iterable);
      }
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              controller.enqueue(new Uint8Array(buf));
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          }
        },
        0
      );
    }
    function isFormDataLike(object) {
      return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
    }
    function throwIfAborted(signal) {
      if (!signal) {
        return;
      }
      if (typeof signal.throwIfAborted === "function") {
        signal.throwIfAborted();
      } else {
        if (signal.aborted) {
          const err = new Error("The operation was aborted");
          err.name = "AbortError";
          throw err;
        }
      }
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    module2.exports = {
      kEnumerableProperty,
      nop,
      isDisturbed,
      isErrored,
      isReadable,
      toUSVString: nodeUtil.toUSVString || ((val) => `${val}`),
      isReadableAborted,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream: isStream2,
      isIterable,
      isAsyncIterable,
      isDestroyed,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer: isBuffer2,
      validateHandler,
      getSocketInfo,
      isFormDataLike,
      buildURL: buildURL2,
      throwIfAborted,
      nodeMajor,
      nodeMinor,
      nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13
    };
  }
});

// node_modules/undici/lib/timers.js
var require_timers = __commonJS({
  "node_modules/undici/lib/timers.js"(exports2, module2) {
    "use strict";
    var fastNow = Date.now();
    var fastNowTimeout;
    var fastTimers = [];
    function onTimeout() {
      fastNow = Date.now();
      let len = fastTimers.length;
      let idx = 0;
      while (idx < len) {
        const timer = fastTimers[idx];
        if (timer.state === 0) {
          timer.state = fastNow + timer.delay;
        } else if (timer.state > 0 && fastNow >= timer.state) {
          timer.state = -1;
          timer.callback(timer.opaque);
        }
        if (timer.state === -1) {
          timer.state = -2;
          if (idx !== len - 1) {
            fastTimers[idx] = fastTimers.pop();
          } else {
            fastTimers.pop();
          }
          len -= 1;
        } else {
          idx += 1;
        }
      }
      if (fastTimers.length > 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (fastNowTimeout && fastNowTimeout.refresh) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTimeout, 1e3);
        if (fastNowTimeout.unref) {
          fastNowTimeout.unref();
        }
      }
    }
    var Timeout = class {
      constructor(callback, delay, opaque) {
        this.callback = callback;
        this.delay = delay;
        this.opaque = opaque;
        this.state = -2;
        this.refresh();
      }
      refresh() {
        if (this.state === -2) {
          fastTimers.push(this);
          if (!fastNowTimeout || fastTimers.length === 1) {
            refreshTimeout();
          }
        }
        this.state = 0;
      }
      clear() {
        this.state = -1;
      }
    };
    module2.exports = {
      setTimeout(callback, delay, opaque) {
        return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
      },
      clearTimeout(timeout) {
        if (timeout instanceof Timeout) {
          timeout.clear();
        } else {
          clearTimeout(timeout);
        }
      }
    };
  }
});

// node_modules/busboy/lib/utils.js
var require_utils = __commonJS({
  "node_modules/busboy/lib/utils.js"(exports2, module2) {
    "use strict";
    function parseContentType(str) {
      if (str.length === 0)
        return;
      const params = /* @__PURE__ */ Object.create(null);
      let i = 0;
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code !== 47 || i === 0)
            return;
          break;
        }
      }
      if (i === str.length)
        return;
      const type = str.slice(0, i).toLowerCase();
      const subtypeStart = ++i;
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (i === subtypeStart)
            return;
          if (parseContentTypeParams(str, i, params) === void 0)
            return;
          break;
        }
      }
      if (i === subtypeStart)
        return;
      const subtype = str.slice(subtypeStart, i).toLowerCase();
      return { type, subtype, params };
    }
    function parseContentTypeParams(str, i, params) {
      while (i < str.length) {
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code !== 32 && code !== 9)
            break;
        }
        if (i === str.length)
          break;
        if (str.charCodeAt(i++) !== 59)
          return;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code !== 32 && code !== 9)
            break;
        }
        if (i === str.length)
          return;
        let name;
        const nameStart = i;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            if (code !== 61)
              return;
            break;
          }
        }
        if (i === str.length)
          return;
        name = str.slice(nameStart, i);
        ++i;
        if (i === str.length)
          return;
        let value = "";
        let valueStart;
        if (str.charCodeAt(i) === 34) {
          valueStart = ++i;
          let escaping = false;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (code === 92) {
              if (escaping) {
                valueStart = i;
                escaping = false;
              } else {
                value += str.slice(valueStart, i);
                escaping = true;
              }
              continue;
            }
            if (code === 34) {
              if (escaping) {
                valueStart = i;
                escaping = false;
                continue;
              }
              value += str.slice(valueStart, i);
              break;
            }
            if (escaping) {
              valueStart = i - 1;
              escaping = false;
            }
            if (QDTEXT[code] !== 1)
              return;
          }
          if (i === str.length)
            return;
          ++i;
        } else {
          valueStart = i;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
              if (i === valueStart)
                return;
              break;
            }
          }
          value = str.slice(valueStart, i);
        }
        name = name.toLowerCase();
        if (params[name] === void 0)
          params[name] = value;
      }
      return params;
    }
    function parseDisposition(str, defDecoder) {
      if (str.length === 0)
        return;
      const params = /* @__PURE__ */ Object.create(null);
      let i = 0;
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (parseDispositionParams(str, i, params, defDecoder) === void 0)
            return;
          break;
        }
      }
      const type = str.slice(0, i).toLowerCase();
      return { type, params };
    }
    function parseDispositionParams(str, i, params, defDecoder) {
      while (i < str.length) {
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code !== 32 && code !== 9)
            break;
        }
        if (i === str.length)
          break;
        if (str.charCodeAt(i++) !== 59)
          return;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code !== 32 && code !== 9)
            break;
        }
        if (i === str.length)
          return;
        let name;
        const nameStart = i;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            if (code === 61)
              break;
            return;
          }
        }
        if (i === str.length)
          return;
        let value = "";
        let valueStart;
        let charset;
        name = str.slice(nameStart, i);
        if (name.charCodeAt(name.length - 1) === 42) {
          const charsetStart = ++i;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (CHARSET[code] !== 1) {
              if (code !== 39)
                return;
              break;
            }
          }
          if (i === str.length)
            return;
          charset = str.slice(charsetStart, i);
          ++i;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (code === 39)
              break;
          }
          if (i === str.length)
            return;
          ++i;
          if (i === str.length)
            return;
          valueStart = i;
          let encode3 = 0;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (EXTENDED_VALUE[code] !== 1) {
              if (code === 37) {
                let hexUpper;
                let hexLower;
                if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                  const byteVal = (hexUpper << 4) + hexLower;
                  value += str.slice(valueStart, i);
                  value += String.fromCharCode(byteVal);
                  i += 2;
                  valueStart = i + 1;
                  if (byteVal >= 128)
                    encode3 = 2;
                  else if (encode3 === 0)
                    encode3 = 1;
                  continue;
                }
                return;
              }
              break;
            }
          }
          value += str.slice(valueStart, i);
          value = convertToUTF8(value, charset, encode3);
          if (value === void 0)
            return;
        } else {
          ++i;
          if (i === str.length)
            return;
          if (str.charCodeAt(i) === 34) {
            valueStart = ++i;
            let escaping = false;
            for (; i < str.length; ++i) {
              const code = str.charCodeAt(i);
              if (code === 92) {
                if (escaping) {
                  valueStart = i;
                  escaping = false;
                } else {
                  value += str.slice(valueStart, i);
                  escaping = true;
                }
                continue;
              }
              if (code === 34) {
                if (escaping) {
                  valueStart = i;
                  escaping = false;
                  continue;
                }
                value += str.slice(valueStart, i);
                break;
              }
              if (escaping) {
                valueStart = i - 1;
                escaping = false;
              }
              if (QDTEXT[code] !== 1)
                return;
            }
            if (i === str.length)
              return;
            ++i;
          } else {
            valueStart = i;
            for (; i < str.length; ++i) {
              const code = str.charCodeAt(i);
              if (TOKEN[code] !== 1) {
                if (i === valueStart)
                  return;
                break;
              }
            }
            value = str.slice(valueStart, i);
          }
          value = defDecoder(value, 2);
          if (value === void 0)
            return;
        }
        name = name.toLowerCase();
        if (params[name] === void 0)
          params[name] = value;
      }
      return params;
    }
    function getDecoder(charset) {
      let lc;
      while (true) {
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii":
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc === void 0) {
              lc = true;
              charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
      }
    }
    var decoders = {
      utf8: (data, hint) => {
        if (data.length === 0)
          return "";
        if (typeof data === "string") {
          if (hint < 2)
            return data;
          data = Buffer.from(data, "latin1");
        }
        return data.utf8Slice(0, data.length);
      },
      latin1: (data, hint) => {
        if (data.length === 0)
          return "";
        if (typeof data === "string")
          return data;
        return data.latin1Slice(0, data.length);
      },
      utf16le: (data, hint) => {
        if (data.length === 0)
          return "";
        if (typeof data === "string")
          data = Buffer.from(data, "latin1");
        return data.ucs2Slice(0, data.length);
      },
      base64: (data, hint) => {
        if (data.length === 0)
          return "";
        if (typeof data === "string")
          data = Buffer.from(data, "latin1");
        return data.base64Slice(0, data.length);
      },
      other: (data, hint) => {
        if (data.length === 0)
          return "";
        if (typeof data === "string")
          data = Buffer.from(data, "latin1");
        try {
          const decoder = new TextDecoder(exports2);
          return decoder.decode(data);
        } catch {
        }
      }
    };
    function convertToUTF8(data, charset, hint) {
      const decode = getDecoder(charset);
      if (decode)
        return decode(data, hint);
    }
    function basename(path) {
      if (typeof path !== "string")
        return "";
      for (let i = path.length - 1; i >= 0; --i) {
        switch (path.charCodeAt(i)) {
          case 47:
          case 92:
            path = path.slice(i + 1);
            return path === ".." || path === "." ? "" : path;
        }
      }
      return path === ".." || path === "." ? "" : path;
    }
    var TOKEN = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    var QDTEXT = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1
    ];
    var CHARSET = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    var EXTENDED_VALUE = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    var HEX_VALUES = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    module2.exports = {
      basename,
      convertToUTF8,
      getDecoder,
      parseContentType,
      parseDisposition
    };
  }
});

// node_modules/streamsearch/lib/sbmh.js
var require_sbmh = __commonJS({
  "node_modules/streamsearch/lib/sbmh.js"(exports2, module2) {
    "use strict";
    function memcmp(buf1, pos1, buf2, pos2, num) {
      for (let i = 0; i < num; ++i) {
        if (buf1[pos1 + i] !== buf2[pos2 + i])
          return false;
      }
      return true;
    }
    var SBMH = class {
      constructor(needle, cb) {
        if (typeof cb !== "function")
          throw new Error("Missing match callback");
        if (typeof needle === "string")
          needle = Buffer.from(needle);
        else if (!Buffer.isBuffer(needle))
          throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
        const needleLen = needle.length;
        this.maxMatches = Infinity;
        this.matches = 0;
        this._cb = cb;
        this._lookbehindSize = 0;
        this._needle = needle;
        this._bufPos = 0;
        this._lookbehind = Buffer.allocUnsafe(needleLen);
        this._occ = [
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen
        ];
        if (needleLen > 1) {
          for (let i = 0; i < needleLen - 1; ++i)
            this._occ[needle[i]] = needleLen - 1 - i;
        }
      }
      reset() {
        this.matches = 0;
        this._lookbehindSize = 0;
        this._bufPos = 0;
      }
      push(chunk, pos) {
        let result;
        if (!Buffer.isBuffer(chunk))
          chunk = Buffer.from(chunk, "latin1");
        const chunkLen = chunk.length;
        this._bufPos = pos || 0;
        while (result !== chunkLen && this.matches < this.maxMatches)
          result = feed(this, chunk);
        return result;
      }
      destroy() {
        const lbSize = this._lookbehindSize;
        if (lbSize)
          this._cb(false, this._lookbehind, 0, lbSize, false);
        this.reset();
      }
    };
    function feed(self2, data) {
      const len = data.length;
      const needle = self2._needle;
      const needleLen = needle.length;
      let pos = -self2._lookbehindSize;
      const lastNeedleCharPos = needleLen - 1;
      const lastNeedleChar = needle[lastNeedleCharPos];
      const end = len - needleLen;
      const occ = self2._occ;
      const lookbehind = self2._lookbehind;
      if (pos < 0) {
        while (pos < 0 && pos <= end) {
          const nextPos = pos + lastNeedleCharPos;
          const ch = nextPos < 0 ? lookbehind[self2._lookbehindSize + nextPos] : data[nextPos];
          if (ch === lastNeedleChar && matchNeedle(self2, data, pos, lastNeedleCharPos)) {
            self2._lookbehindSize = 0;
            ++self2.matches;
            if (pos > -self2._lookbehindSize)
              self2._cb(true, lookbehind, 0, self2._lookbehindSize + pos, false);
            else
              self2._cb(true, void 0, 0, 0, true);
            return self2._bufPos = pos + needleLen;
          }
          pos += occ[ch];
        }
        while (pos < 0 && !matchNeedle(self2, data, pos, len - pos))
          ++pos;
        if (pos < 0) {
          const bytesToCutOff = self2._lookbehindSize + pos;
          if (bytesToCutOff > 0) {
            self2._cb(false, lookbehind, 0, bytesToCutOff, false);
          }
          self2._lookbehindSize -= bytesToCutOff;
          lookbehind.copy(lookbehind, 0, bytesToCutOff, self2._lookbehindSize);
          lookbehind.set(data, self2._lookbehindSize);
          self2._lookbehindSize += len;
          self2._bufPos = len;
          return len;
        }
        self2._cb(false, lookbehind, 0, self2._lookbehindSize, false);
        self2._lookbehindSize = 0;
      }
      pos += self2._bufPos;
      const firstNeedleChar = needle[0];
      while (pos <= end) {
        const ch = data[pos + lastNeedleCharPos];
        if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
          ++self2.matches;
          if (pos > 0)
            self2._cb(true, data, self2._bufPos, pos, true);
          else
            self2._cb(true, void 0, 0, 0, true);
          return self2._bufPos = pos + needleLen;
        }
        pos += occ[ch];
      }
      while (pos < len) {
        if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
          ++pos;
          continue;
        }
        data.copy(lookbehind, 0, pos, len);
        self2._lookbehindSize = len - pos;
        break;
      }
      if (pos > 0)
        self2._cb(false, data, self2._bufPos, pos < len ? pos : len, true);
      self2._bufPos = len;
      return len;
    }
    function matchNeedle(self2, data, pos, len) {
      const lb = self2._lookbehind;
      const lbSize = self2._lookbehindSize;
      const needle = self2._needle;
      for (let i = 0; i < len; ++i, ++pos) {
        const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
        if (ch !== needle[i])
          return false;
      }
      return true;
    }
    module2.exports = SBMH;
  }
});

// node_modules/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  "node_modules/busboy/lib/types/multipart.js"(exports2, module2) {
    "use strict";
    var { Readable: Readable2, Writable } = require("stream");
    var StreamSearch = require_sbmh();
    var {
      basename,
      convertToUTF8,
      getDecoder,
      parseContentType,
      parseDisposition
    } = require_utils();
    var BUF_CRLF = Buffer.from("\r\n");
    var BUF_CR = Buffer.from("\r");
    var BUF_DASH = Buffer.from("-");
    function noop2() {
    }
    var MAX_HEADER_PAIRS = 2e3;
    var MAX_HEADER_SIZE = 16 * 1024;
    var HPARSER_NAME = 0;
    var HPARSER_PRE_OWS = 1;
    var HPARSER_VALUE = 2;
    var HeaderParser = class {
      constructor(cb) {
        this.header = /* @__PURE__ */ Object.create(null);
        this.pairCount = 0;
        this.byteCount = 0;
        this.state = HPARSER_NAME;
        this.name = "";
        this.value = "";
        this.crlf = 0;
        this.cb = cb;
      }
      reset() {
        this.header = /* @__PURE__ */ Object.create(null);
        this.pairCount = 0;
        this.byteCount = 0;
        this.state = HPARSER_NAME;
        this.name = "";
        this.value = "";
        this.crlf = 0;
      }
      push(chunk, pos, end) {
        let start = pos;
        while (pos < end) {
          switch (this.state) {
            case HPARSER_NAME: {
              let done = false;
              for (; pos < end; ++pos) {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (TOKEN[code] !== 1) {
                  if (code !== 58)
                    return -1;
                  this.name += chunk.latin1Slice(start, pos);
                  if (this.name.length === 0)
                    return -1;
                  ++pos;
                  done = true;
                  this.state = HPARSER_PRE_OWS;
                  break;
                }
              }
              if (!done) {
                this.name += chunk.latin1Slice(start, pos);
                break;
              }
            }
            case HPARSER_PRE_OWS: {
              let done = false;
              for (; pos < end; ++pos) {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (code !== 32 && code !== 9) {
                  start = pos;
                  done = true;
                  this.state = HPARSER_VALUE;
                  break;
                }
              }
              if (!done)
                break;
            }
            case HPARSER_VALUE:
              switch (this.crlf) {
                case 0:
                  for (; pos < end; ++pos) {
                    if (this.byteCount === MAX_HEADER_SIZE)
                      return -1;
                    ++this.byteCount;
                    const code = chunk[pos];
                    if (FIELD_VCHAR[code] !== 1) {
                      if (code !== 13)
                        return -1;
                      ++this.crlf;
                      break;
                    }
                  }
                  this.value += chunk.latin1Slice(start, pos++);
                  break;
                case 1:
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  if (chunk[pos++] !== 10)
                    return -1;
                  ++this.crlf;
                  break;
                case 2: {
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  const code = chunk[pos];
                  if (code === 32 || code === 9) {
                    start = pos;
                    this.crlf = 0;
                  } else {
                    if (++this.pairCount < MAX_HEADER_PAIRS) {
                      this.name = this.name.toLowerCase();
                      if (this.header[this.name] === void 0)
                        this.header[this.name] = [this.value];
                      else
                        this.header[this.name].push(this.value);
                    }
                    if (code === 13) {
                      ++this.crlf;
                      ++pos;
                    } else {
                      start = pos;
                      this.crlf = 0;
                      this.state = HPARSER_NAME;
                      this.name = "";
                      this.value = "";
                    }
                  }
                  break;
                }
                case 3: {
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  if (chunk[pos++] !== 10)
                    return -1;
                  const header = this.header;
                  this.reset();
                  this.cb(header);
                  return pos;
                }
              }
              break;
          }
        }
        return pos;
      }
    };
    var FileStream = class extends Readable2 {
      constructor(opts, owner) {
        super(opts);
        this.truncated = false;
        this._readcb = null;
        this.once("end", () => {
          this._read();
          if (--owner._fileEndsLeft === 0 && owner._finalcb) {
            const cb = owner._finalcb;
            owner._finalcb = null;
            process.nextTick(cb);
          }
        });
      }
      _read(n) {
        const cb = this._readcb;
        if (cb) {
          this._readcb = null;
          cb();
        }
      }
    };
    var ignoreData = {
      push: (chunk, pos) => {
      },
      destroy: () => {
      }
    };
    function callAndUnsetCb(self2, err) {
      const cb = self2._writecb;
      self2._writecb = null;
      if (err)
        self2.destroy(err);
      else if (cb)
        cb();
    }
    function nullDecoder(val, hint) {
      return val;
    }
    var Multipart = class extends Writable {
      constructor(cfg) {
        const streamOpts = {
          autoDestroy: true,
          emitClose: true,
          highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
        };
        super(streamOpts);
        if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string")
          throw new Error("Multipart: Boundary not found");
        const boundary = cfg.conType.params.boundary;
        const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
        const defCharset = cfg.defCharset || "utf8";
        const preservePath = cfg.preservePath;
        const fileOpts = {
          autoDestroy: true,
          emitClose: true,
          highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : void 0
        };
        const limits = cfg.limits;
        const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
        const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
        const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
        const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
        const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
        let parts = -1;
        let fields = 0;
        let files = 0;
        let skipPart = false;
        this._fileEndsLeft = 0;
        this._fileStream = void 0;
        this._complete = false;
        let fileSize = 0;
        let field;
        let fieldSize = 0;
        let partCharset;
        let partEncoding;
        let partType;
        let partName;
        let partTruncated = false;
        let hitFilesLimit = false;
        let hitFieldsLimit = false;
        this._hparser = null;
        const hparser = new HeaderParser((header) => {
          this._hparser = null;
          skipPart = false;
          partType = "text/plain";
          partCharset = defCharset;
          partEncoding = "7bit";
          partName = void 0;
          partTruncated = false;
          let filename;
          if (!header["content-disposition"]) {
            skipPart = true;
            return;
          }
          const disp = parseDisposition(
            header["content-disposition"][0],
            paramDecoder
          );
          if (!disp || disp.type !== "form-data") {
            skipPart = true;
            return;
          }
          if (disp.params) {
            if (disp.params.name)
              partName = disp.params.name;
            if (disp.params["filename*"])
              filename = disp.params["filename*"];
            else if (disp.params.filename)
              filename = disp.params.filename;
            if (filename !== void 0 && !preservePath)
              filename = basename(filename);
          }
          if (header["content-type"]) {
            const conType = parseContentType(header["content-type"][0]);
            if (conType) {
              partType = `${conType.type}/${conType.subtype}`;
              if (conType.params && typeof conType.params.charset === "string")
                partCharset = conType.params.charset.toLowerCase();
            }
          }
          if (header["content-transfer-encoding"])
            partEncoding = header["content-transfer-encoding"][0].toLowerCase();
          if (partType === "application/octet-stream" || filename !== void 0) {
            if (files === filesLimit) {
              if (!hitFilesLimit) {
                hitFilesLimit = true;
                this.emit("filesLimit");
              }
              skipPart = true;
              return;
            }
            ++files;
            if (this.listenerCount("file") === 0) {
              skipPart = true;
              return;
            }
            fileSize = 0;
            this._fileStream = new FileStream(fileOpts, this);
            ++this._fileEndsLeft;
            this.emit(
              "file",
              partName,
              this._fileStream,
              {
                filename,
                encoding: partEncoding,
                mimeType: partType
              }
            );
          } else {
            if (fields === fieldsLimit) {
              if (!hitFieldsLimit) {
                hitFieldsLimit = true;
                this.emit("fieldsLimit");
              }
              skipPart = true;
              return;
            }
            ++fields;
            if (this.listenerCount("field") === 0) {
              skipPart = true;
              return;
            }
            field = [];
            fieldSize = 0;
          }
        });
        let matchPostBoundary = 0;
        const ssCb = (isMatch, data, start, end, isDataSafe) => {
          retrydata:
            while (data) {
              if (this._hparser !== null) {
                const ret = this._hparser.push(data, start, end);
                if (ret === -1) {
                  this._hparser = null;
                  hparser.reset();
                  this.emit("error", new Error("Malformed part header"));
                  break;
                }
                start = ret;
              }
              if (start === end)
                break;
              if (matchPostBoundary !== 0) {
                if (matchPostBoundary === 1) {
                  switch (data[start]) {
                    case 45:
                      matchPostBoundary = 2;
                      ++start;
                      break;
                    case 13:
                      matchPostBoundary = 3;
                      ++start;
                      break;
                    default:
                      matchPostBoundary = 0;
                  }
                  if (start === end)
                    return;
                }
                if (matchPostBoundary === 2) {
                  matchPostBoundary = 0;
                  if (data[start] === 45) {
                    this._complete = true;
                    this._bparser = ignoreData;
                    return;
                  }
                  const writecb = this._writecb;
                  this._writecb = noop2;
                  ssCb(false, BUF_DASH, 0, 1, false);
                  this._writecb = writecb;
                } else if (matchPostBoundary === 3) {
                  matchPostBoundary = 0;
                  if (data[start] === 10) {
                    ++start;
                    if (parts >= partsLimit)
                      break;
                    this._hparser = hparser;
                    if (start === end)
                      break;
                    continue retrydata;
                  } else {
                    const writecb = this._writecb;
                    this._writecb = noop2;
                    ssCb(false, BUF_CR, 0, 1, false);
                    this._writecb = writecb;
                  }
                }
              }
              if (!skipPart) {
                if (this._fileStream) {
                  let chunk;
                  const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
                  if (!isDataSafe) {
                    chunk = Buffer.allocUnsafe(actualLen);
                    data.copy(chunk, 0, start, start + actualLen);
                  } else {
                    chunk = data.slice(start, start + actualLen);
                  }
                  fileSize += chunk.length;
                  if (fileSize === fileSizeLimit) {
                    if (chunk.length > 0)
                      this._fileStream.push(chunk);
                    this._fileStream.emit("limit");
                    this._fileStream.truncated = true;
                    skipPart = true;
                  } else if (!this._fileStream.push(chunk)) {
                    if (this._writecb)
                      this._fileStream._readcb = this._writecb;
                    this._writecb = null;
                  }
                } else if (field !== void 0) {
                  let chunk;
                  const actualLen = Math.min(
                    end - start,
                    fieldSizeLimit - fieldSize
                  );
                  if (!isDataSafe) {
                    chunk = Buffer.allocUnsafe(actualLen);
                    data.copy(chunk, 0, start, start + actualLen);
                  } else {
                    chunk = data.slice(start, start + actualLen);
                  }
                  fieldSize += actualLen;
                  field.push(chunk);
                  if (fieldSize === fieldSizeLimit) {
                    skipPart = true;
                    partTruncated = true;
                  }
                }
              }
              break;
            }
          if (isMatch) {
            matchPostBoundary = 1;
            if (this._fileStream) {
              this._fileStream.push(null);
              this._fileStream = null;
            } else if (field !== void 0) {
              let data2;
              switch (field.length) {
                case 0:
                  data2 = "";
                  break;
                case 1:
                  data2 = convertToUTF8(field[0], partCharset, 0);
                  break;
                default:
                  data2 = convertToUTF8(
                    Buffer.concat(field, fieldSize),
                    partCharset,
                    0
                  );
              }
              field = void 0;
              fieldSize = 0;
              this.emit(
                "field",
                partName,
                data2,
                {
                  nameTruncated: false,
                  valueTruncated: partTruncated,
                  encoding: partEncoding,
                  mimeType: partType
                }
              );
            }
            if (++parts === partsLimit)
              this.emit("partsLimit");
          }
        };
        this._bparser = new StreamSearch(`\r
--${boundary}`, ssCb);
        this._writecb = null;
        this._finalcb = null;
        this.write(BUF_CRLF);
      }
      static detect(conType) {
        return conType.type === "multipart" && conType.subtype === "form-data";
      }
      _write(chunk, enc, cb) {
        this._writecb = cb;
        this._bparser.push(chunk, 0);
        if (this._writecb)
          callAndUnsetCb(this);
      }
      _destroy(err, cb) {
        this._hparser = null;
        this._bparser = ignoreData;
        if (!err)
          err = checkEndState(this);
        const fileStream = this._fileStream;
        if (fileStream) {
          this._fileStream = null;
          fileStream.destroy(err);
        }
        cb(err);
      }
      _final(cb) {
        this._bparser.destroy();
        if (!this._complete)
          return cb(new Error("Unexpected end of form"));
        if (this._fileEndsLeft)
          this._finalcb = finalcb.bind(null, this, cb);
        else
          finalcb(this, cb);
      }
    };
    function finalcb(self2, cb, err) {
      if (err)
        return cb(err);
      err = checkEndState(self2);
      cb(err);
    }
    function checkEndState(self2) {
      if (self2._hparser)
        return new Error("Malformed part header");
      const fileStream = self2._fileStream;
      if (fileStream) {
        self2._fileStream = null;
        fileStream.destroy(new Error("Unexpected end of file"));
      }
      if (!self2._complete)
        return new Error("Unexpected end of form");
    }
    var TOKEN = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    var FIELD_VCHAR = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1
    ];
    module2.exports = Multipart;
  }
});

// node_modules/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/busboy/lib/types/urlencoded.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var { getDecoder } = require_utils();
    var URLEncoded = class extends Writable {
      constructor(cfg) {
        const streamOpts = {
          autoDestroy: true,
          emitClose: true,
          highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
        };
        super(streamOpts);
        let charset = cfg.defCharset || "utf8";
        if (cfg.conType.params && typeof cfg.conType.params.charset === "string")
          charset = cfg.conType.params.charset;
        this.charset = charset;
        const limits = cfg.limits;
        this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
        this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
        this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
        this._inKey = true;
        this._keyTrunc = false;
        this._valTrunc = false;
        this._bytesKey = 0;
        this._bytesVal = 0;
        this._fields = 0;
        this._key = "";
        this._val = "";
        this._byte = -2;
        this._lastPos = 0;
        this._encode = 0;
        this._decoder = getDecoder(charset);
      }
      static detect(conType) {
        return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
      }
      _write(chunk, enc, cb) {
        if (this._fields >= this.fieldsLimit)
          return cb();
        let i = 0;
        const len = chunk.length;
        this._lastPos = 0;
        if (this._byte !== -2) {
          i = readPctEnc(this, chunk, i, len);
          if (i === -1)
            return cb(new Error("Malformed urlencoded form"));
          if (i >= len)
            return cb();
          if (this._inKey)
            ++this._bytesKey;
          else
            ++this._bytesVal;
        }
        main:
          while (i < len) {
            if (this._inKey) {
              i = skipKeyBytes(this, chunk, i, len);
              while (i < len) {
                switch (chunk[i]) {
                  case 61:
                    if (this._lastPos < i)
                      this._key += chunk.latin1Slice(this._lastPos, i);
                    this._lastPos = ++i;
                    this._key = this._decoder(this._key, this._encode);
                    this._encode = 0;
                    this._inKey = false;
                    continue main;
                  case 38:
                    if (this._lastPos < i)
                      this._key += chunk.latin1Slice(this._lastPos, i);
                    this._lastPos = ++i;
                    this._key = this._decoder(this._key, this._encode);
                    this._encode = 0;
                    if (this._bytesKey > 0) {
                      this.emit(
                        "field",
                        this._key,
                        "",
                        {
                          nameTruncated: this._keyTrunc,
                          valueTruncated: false,
                          encoding: this.charset,
                          mimeType: "text/plain"
                        }
                      );
                    }
                    this._key = "";
                    this._val = "";
                    this._keyTrunc = false;
                    this._valTrunc = false;
                    this._bytesKey = 0;
                    this._bytesVal = 0;
                    if (++this._fields >= this.fieldsLimit) {
                      this.emit("fieldsLimit");
                      return cb();
                    }
                    continue;
                  case 43:
                    if (this._lastPos < i)
                      this._key += chunk.latin1Slice(this._lastPos, i);
                    this._key += " ";
                    this._lastPos = i + 1;
                    break;
                  case 37:
                    if (this._encode === 0)
                      this._encode = 1;
                    if (this._lastPos < i)
                      this._key += chunk.latin1Slice(this._lastPos, i);
                    this._lastPos = i + 1;
                    this._byte = -1;
                    i = readPctEnc(this, chunk, i + 1, len);
                    if (i === -1)
                      return cb(new Error("Malformed urlencoded form"));
                    if (i >= len)
                      return cb();
                    ++this._bytesKey;
                    i = skipKeyBytes(this, chunk, i, len);
                    continue;
                }
                ++i;
                ++this._bytesKey;
                i = skipKeyBytes(this, chunk, i, len);
              }
              if (this._lastPos < i)
                this._key += chunk.latin1Slice(this._lastPos, i);
            } else {
              i = skipValBytes(this, chunk, i, len);
              while (i < len) {
                switch (chunk[i]) {
                  case 38:
                    if (this._lastPos < i)
                      this._val += chunk.latin1Slice(this._lastPos, i);
                    this._lastPos = ++i;
                    this._inKey = true;
                    this._val = this._decoder(this._val, this._encode);
                    this._encode = 0;
                    if (this._bytesKey > 0 || this._bytesVal > 0) {
                      this.emit(
                        "field",
                        this._key,
                        this._val,
                        {
                          nameTruncated: this._keyTrunc,
                          valueTruncated: this._valTrunc,
                          encoding: this.charset,
                          mimeType: "text/plain"
                        }
                      );
                    }
                    this._key = "";
                    this._val = "";
                    this._keyTrunc = false;
                    this._valTrunc = false;
                    this._bytesKey = 0;
                    this._bytesVal = 0;
                    if (++this._fields >= this.fieldsLimit) {
                      this.emit("fieldsLimit");
                      return cb();
                    }
                    continue main;
                  case 43:
                    if (this._lastPos < i)
                      this._val += chunk.latin1Slice(this._lastPos, i);
                    this._val += " ";
                    this._lastPos = i + 1;
                    break;
                  case 37:
                    if (this._encode === 0)
                      this._encode = 1;
                    if (this._lastPos < i)
                      this._val += chunk.latin1Slice(this._lastPos, i);
                    this._lastPos = i + 1;
                    this._byte = -1;
                    i = readPctEnc(this, chunk, i + 1, len);
                    if (i === -1)
                      return cb(new Error("Malformed urlencoded form"));
                    if (i >= len)
                      return cb();
                    ++this._bytesVal;
                    i = skipValBytes(this, chunk, i, len);
                    continue;
                }
                ++i;
                ++this._bytesVal;
                i = skipValBytes(this, chunk, i, len);
              }
              if (this._lastPos < i)
                this._val += chunk.latin1Slice(this._lastPos, i);
            }
          }
        cb();
      }
      _final(cb) {
        if (this._byte !== -2)
          return cb(new Error("Malformed urlencoded form"));
        if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
          if (this._inKey)
            this._key = this._decoder(this._key, this._encode);
          else
            this._val = this._decoder(this._val, this._encode);
          this.emit(
            "field",
            this._key,
            this._val,
            {
              nameTruncated: this._keyTrunc,
              valueTruncated: this._valTrunc,
              encoding: this.charset,
              mimeType: "text/plain"
            }
          );
        }
        cb();
      }
    };
    function readPctEnc(self2, chunk, pos, len) {
      if (pos >= len)
        return len;
      if (self2._byte === -1) {
        const hexUpper = HEX_VALUES[chunk[pos++]];
        if (hexUpper === -1)
          return -1;
        if (hexUpper >= 8)
          self2._encode = 2;
        if (pos < len) {
          const hexLower = HEX_VALUES[chunk[pos++]];
          if (hexLower === -1)
            return -1;
          if (self2._inKey)
            self2._key += String.fromCharCode((hexUpper << 4) + hexLower);
          else
            self2._val += String.fromCharCode((hexUpper << 4) + hexLower);
          self2._byte = -2;
          self2._lastPos = pos;
        } else {
          self2._byte = hexUpper;
        }
      } else {
        const hexLower = HEX_VALUES[chunk[pos++]];
        if (hexLower === -1)
          return -1;
        if (self2._inKey)
          self2._key += String.fromCharCode((self2._byte << 4) + hexLower);
        else
          self2._val += String.fromCharCode((self2._byte << 4) + hexLower);
        self2._byte = -2;
        self2._lastPos = pos;
      }
      return pos;
    }
    function skipKeyBytes(self2, chunk, pos, len) {
      if (self2._bytesKey > self2.fieldNameSizeLimit) {
        if (!self2._keyTrunc) {
          if (self2._lastPos < pos)
            self2._key += chunk.latin1Slice(self2._lastPos, pos - 1);
        }
        self2._keyTrunc = true;
        for (; pos < len; ++pos) {
          const code = chunk[pos];
          if (code === 61 || code === 38)
            break;
          ++self2._bytesKey;
        }
        self2._lastPos = pos;
      }
      return pos;
    }
    function skipValBytes(self2, chunk, pos, len) {
      if (self2._bytesVal > self2.fieldSizeLimit) {
        if (!self2._valTrunc) {
          if (self2._lastPos < pos)
            self2._val += chunk.latin1Slice(self2._lastPos, pos - 1);
        }
        self2._valTrunc = true;
        for (; pos < len; ++pos) {
          if (chunk[pos] === 38)
            break;
          ++self2._bytesVal;
        }
        self2._lastPos = pos;
      }
      return pos;
    }
    var HEX_VALUES = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    module2.exports = URLEncoded;
  }
});

// node_modules/busboy/lib/index.js
var require_lib = __commonJS({
  "node_modules/busboy/lib/index.js"(exports2, module2) {
    "use strict";
    var { parseContentType } = require_utils();
    function getInstance(cfg) {
      const headers = cfg.headers;
      const conType = parseContentType(headers["content-type"]);
      if (!conType)
        throw new Error("Malformed content type");
      for (const type of TYPES) {
        const matched = type.detect(conType);
        if (!matched)
          continue;
        const instanceCfg = {
          limits: cfg.limits,
          headers,
          conType,
          highWaterMark: void 0,
          fileHwm: void 0,
          defCharset: void 0,
          defParamCharset: void 0,
          preservePath: false
        };
        if (cfg.highWaterMark)
          instanceCfg.highWaterMark = cfg.highWaterMark;
        if (cfg.fileHwm)
          instanceCfg.fileHwm = cfg.fileHwm;
        instanceCfg.defCharset = cfg.defCharset;
        instanceCfg.defParamCharset = cfg.defParamCharset;
        instanceCfg.preservePath = cfg.preservePath;
        return new type(instanceCfg);
      }
      throw new Error(`Unsupported content type: ${headers["content-type"]}`);
    }
    var TYPES = [
      require_multipart(),
      require_urlencoded()
    ].filter(function(typemod) {
      return typeof typemod.detect === "function";
    });
    module2.exports = (cfg) => {
      if (typeof cfg !== "object" || cfg === null)
        cfg = {};
      if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
        throw new Error("Missing Content-Type");
      }
      return getInstance(cfg);
    };
  }
});

// node_modules/undici/lib/fetch/constants.js
var require_constants = __commonJS({
  "node_modules/undici/lib/fetch/constants.js"(exports2, module2) {
    "use strict";
    var { MessageChannel, receiveMessageOnPort } = require("worker_threads");
    var corsSafeListedMethods = ["GET", "HEAD", "POST"];
    var nullBodyStatus = [101, 204, 205, 304];
    var redirectStatus = [301, 302, 303, 307, 308];
    var badPorts = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080"
    ];
    var referrerPolicy = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ];
    var requestRedirect = ["follow", "manual", "error"];
    var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
    var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
    var requestCredentials = ["omit", "same-origin", "include"];
    var requestCache = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ];
    var requestBodyHeader = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type"
    ];
    var requestDuplex = [
      "half"
    ];
    var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
    var subresource = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ];
    var DOMException = globalThis.DOMException ?? (() => {
      try {
        atob("~");
      } catch (err) {
        return Object.getPrototypeOf(err).constructor;
      }
    })();
    var channel;
    var structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
    // structuredClone was added in v17.0.0, but fetch supports v16.8
    function structuredClone2(value, options = void 0) {
      if (arguments.length === 0) {
        throw new TypeError("missing argument");
      }
      if (!channel) {
        channel = new MessageChannel();
      }
      channel.port1.unref();
      channel.port2.unref();
      channel.port1.postMessage(value, options?.transfer);
      return receiveMessageOnPort(channel.port2).message;
    };
    module2.exports = {
      DOMException,
      structuredClone,
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex
    };
  }
});

// node_modules/undici/lib/fetch/global.js
var require_global = __commonJS({
  "node_modules/undici/lib/fetch/global.js"(exports2, module2) {
    "use strict";
    var globalOrigin = Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin !== void 0 && typeof newOrigin !== "string" && !(newOrigin instanceof URL)) {
        throw new Error("Invalid base url");
      }
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS({
  "node_modules/undici/lib/fetch/util.js"(exports2, module2) {
    "use strict";
    var { redirectStatus, badPorts, referrerPolicy: referrerPolicyTokens } = require_constants();
    var { getGlobalOrigin } = require_global();
    var { performance: performance2 } = require("perf_hooks");
    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
    var assert = require("assert");
    var { isUint8Array } = require("util/types");
    var crypto;
    try {
      crypto = require("crypto");
    } catch {
    }
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatus.includes(response.status)) {
        return null;
      }
      let location = response.headersList.get("location");
      if (location !== null && isValidHeaderValue(location)) {
        location = new URL(location, responseURL(response));
      }
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      const url2 = requestCurrentURL(request);
      if (/^https?:/.test(url2.protocol) && badPorts.includes(url2.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike(object) {
      return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (!(c === 9 || // HTAB
        c >= 32 && c <= 126 || // SP / VCHAR
        c >= 128 && c <= 255)) {
          return false;
        }
      }
      return true;
    }
    function isTokenChar(c) {
      return !(c >= 127 || c <= 32 || c === "(" || c === ")" || c === "<" || c === ">" || c === "@" || c === "," || c === ";" || c === ":" || c === "\\" || c === '"' || c === "/" || c === "[" || c === "]" || c === "?" || c === "=" || c === "{" || c === "}");
    }
    function isValidHTTPToken(characters) {
      if (!characters || typeof characters !== "string") {
        return false;
      }
      for (let i = 0; i < characters.length; ++i) {
        const c = characters.charCodeAt(i);
        if (c > 127 || !isTokenChar(c)) {
          return false;
        }
      }
      return true;
    }
    function isValidHeaderName2(potentialValue) {
      if (potentialValue.length === 0) {
        return false;
      }
      return isValidHTTPToken(potentialValue);
    }
    function isValidHeaderValue(potentialValue) {
      if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) {
        return false;
      }
      if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
        return false;
      }
      return true;
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      const { headersList } = actualResponse;
      const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
      let policy = "";
      if (policyHeader.length > 0) {
        for (let i = policyHeader.length; i !== 0; i--) {
          const token = policyHeader[i - 1].trim();
          if (referrerPolicyTokens.includes(token)) {
            policy = token;
            break;
          }
        }
      }
      if (policy !== "") {
        request.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (request.responseTainting === "cors" || request.mode === "websocket") {
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      } else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (/^https:/.test(request.origin) && !/^https:/.test(requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          default:
        }
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      }
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return performance2.now();
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: "strict-origin-when-cross-origin"
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy
      };
    }
    function determineRequestsReferrer(request) {
      const policy = request.referrerPolicy;
      assert(policy);
      let referrerSource = null;
      if (request.referrer === "client") {
        const globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === "null") {
          return "no-referrer";
        }
        referrerSource = new URL(globalOrigin);
      } else if (request.referrer instanceof URL) {
        referrerSource = request.referrer;
      }
      let referrerURL = stripURLForReferrer(referrerSource);
      const referrerOrigin = stripURLForReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      const areSameOrigin = sameOrigin(request, referrerURL);
      const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
      switch (policy) {
        case "origin":
          return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerURL;
        case "same-origin":
          return areSameOrigin ? referrerOrigin : "no-referrer";
        case "origin-when-cross-origin":
          return areSameOrigin ? referrerURL : referrerOrigin;
        case "strict-origin-when-cross-origin": {
          const currentURL = requestCurrentURL(request);
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "strict-origin":
        case "no-referrer-when-downgrade":
        default:
          return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
      }
    }
    function stripURLForReferrer(url2, originOnly) {
      assert(url2 instanceof URL);
      if (url2.protocol === "file:" || url2.protocol === "about:" || url2.protocol === "blank:") {
        return "no-referrer";
      }
      url2.username = "";
      url2.password = "";
      url2.hash = "";
      if (originOnly) {
        url2.pathname = "";
        url2.search = "";
      }
      return url2;
    }
    function isURLPotentiallyTrustworthy(url2) {
      if (!(url2 instanceof URL)) {
        return false;
      }
      if (url2.href === "about:blank" || url2.href === "about:srcdoc") {
        return true;
      }
      if (url2.protocol === "data:")
        return true;
      if (url2.protocol === "file:")
        return true;
      return isOriginPotentiallyTrustworthy(url2.origin);
      function isOriginPotentiallyTrustworthy(origin) {
        if (origin == null || origin === "null")
          return false;
        const originAsURL = new URL(origin);
        if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
          return true;
        }
        if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
          return true;
        }
        return false;
      }
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata") {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));
      const strongest = list[0].algo;
      const metadata = list.filter((item) => item.algo === strongest);
      for (const item of metadata) {
        const algorithm = item.algo;
        const expectedValue = item.hash;
        const actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue === expectedValue) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\x21-\x7e]?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty = true;
      const supportedHashes = crypto.getHashes();
      for (const token of metadata.split(" ")) {
        empty = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo;
        if (supportedHashes.includes(algorithm.toLowerCase())) {
          result.push(parsedToken.groups);
        }
      }
      if (empty === true) {
        return "no metadata";
      }
      return result;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
    }
    function sameOrigin(A, B) {
      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
      });
      return { promise, resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    function normalizeMethod(method) {
      return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError("Value is not JSON serializable");
      }
      assert(typeof result === "string");
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function makeIterator(iterator, name, kind) {
      const object = {
        index: 0,
        kind,
        target: iterator
      };
      const i = {
        next() {
          if (Object.getPrototypeOf(this) !== i) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name} Iterator.`
            );
          }
          const { index, kind: kind2, target } = object;
          const values = target();
          const len = values.length;
          if (index >= len) {
            return { value: void 0, done: true };
          }
          const pair = values[index];
          object.index = index + 1;
          return iteratorResult(pair, kind2);
        },
        // The class string of an iterator prototype object for a given interface is the
        // result of concatenating the identifier of the interface and the string " Iterator".
        [Symbol.toStringTag]: `${name} Iterator`
      };
      Object.setPrototypeOf(i, esIteratorPrototype);
      return Object.setPrototypeOf({}, i);
    }
    function iteratorResult(pair, kind) {
      let result;
      switch (kind) {
        case "key": {
          result = pair[0];
          break;
        }
        case "value": {
          result = pair[1];
          break;
        }
        case "key+value": {
          result = pair;
          break;
        }
      }
      return { value: result, done: false };
    }
    function fullyReadBody(body, processBody, processBodyError) {
      const successSteps = (bytes) => queueMicrotask(() => processBody(bytes));
      const errorSteps = (error) => queueMicrotask(() => processBodyError(error));
      let reader;
      try {
        reader = body.stream.getReader();
      } catch (e) {
        errorSteps(e);
        return;
      }
      readAllBytes(reader, successSteps, errorSteps);
    }
    var ReadableStream = globalThis.ReadableStream;
    function isReadableStreamLike(stream4) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      return stream4 instanceof ReadableStream || stream4[Symbol.toStringTag] === "ReadableStream" && typeof stream4.tee === "function";
    }
    var MAXIMUM_ARGUMENT_LENGTH = 65535;
    function isomorphicDecode(input) {
      if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
        return String.fromCharCode(...input);
      }
      return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
    }
    function readableStreamClose(controller) {
      try {
        controller.close();
      } catch (err) {
        if (!err.message.includes("Controller is already closed")) {
          throw err;
        }
      }
    }
    function isomorphicEncode(input) {
      for (let i = 0; i < input.length; i++) {
        assert(input.charCodeAt(i) <= 255);
      }
      return input;
    }
    async function readAllBytes(reader, successSteps, failureSteps) {
      const bytes = [];
      let byteLength = 0;
      while (true) {
        let done;
        let chunk;
        try {
          ({ done, value: chunk } = await reader.read());
        } catch (e) {
          failureSteps(e);
          return;
        }
        if (done) {
          successSteps(Buffer.concat(bytes, byteLength));
          return;
        }
        if (!isUint8Array(chunk)) {
          failureSteps(new TypeError("Received non-Uint8Array chunk"));
          return;
        }
        bytes.push(chunk);
        byteLength += chunk.length;
      }
    }
    var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
    module2.exports = {
      isAborted,
      isCancelled,
      createDeferredPromise,
      ReadableStreamFrom,
      toUSVString,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      makeIterator,
      isValidHeaderName: isValidHeaderName2,
      isValidHeaderValue,
      hasOwn,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      isReadableStreamLike,
      readableStreamClose,
      isomorphicEncode,
      isomorphicDecode
    };
  }
});

// node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/undici/lib/fetch/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kUrl: Symbol("url"),
      kHeaders: Symbol("headers"),
      kSignal: Symbol("signal"),
      kState: Symbol("state"),
      kGuard: Symbol("guard"),
      kRealm: Symbol("realm"),
      kHeadersCaseInsensitive: Symbol("headers case insensitive")
    };
  }
});

// node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({
  "node_modules/undici/lib/fetch/webidl.js"(exports2, module2) {
    "use strict";
    var { types } = require("util");
    var { hasOwn, toUSVString } = require_util2();
    var webidl = {};
    webidl.converters = {};
    webidl.util = {};
    webidl.errors = {};
    webidl.errors.exception = function(message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(context) {
      const plural = context.types.length === 1 ? "" : " one of";
      const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
      return webidl.errors.exception({
        header: context.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context) {
      return webidl.errors.exception({
        header: context.prefix,
        message: `"${context.value}" is an invalid ${context.type}.`
      });
    };
    webidl.brandCheck = function(V, I, opts = void 0) {
      if (opts?.strict !== false && !(V instanceof I)) {
        throw new TypeError("Illegal invocation");
      } else {
        return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
      }
    };
    webidl.argumentLengthCheck = function({ length }, min, ctx) {
      if (length < min) {
        throw webidl.errors.exception({
          message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
          ...ctx
        });
      }
    };
    webidl.util.Type = function(V) {
      switch (typeof V) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object": {
          if (V === null) {
            return "Null";
          }
          return "Object";
        }
      }
    };
    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
      let upperBound;
      let lowerBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        if (signedness === "unsigned") {
          lowerBound = 0;
        } else {
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = Math.pow(-2, bitLength) - 1;
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      let x = Number(V);
      if (x === 0) {
        x = 0;
      }
      if (opts.enforceRange === true) {
        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${V} to an integer.`
          });
        }
        x = webidl.util.IntegerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
          });
        }
        return x;
      }
      if (!Number.isNaN(x) && opts.clamp === true) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        if (Math.floor(x) % 2 === 0) {
          x = Math.floor(x);
        } else {
          x = Math.ceil(x);
        }
        return x;
      }
      if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      x = webidl.util.IntegerPart(x);
      x = x % Math.pow(2, bitLength);
      if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
        return x - Math.pow(2, bitLength);
      }
      return x;
    };
    webidl.util.IntegerPart = function(n) {
      const r = Math.floor(Math.abs(n));
      if (n < 0) {
        return -1 * r;
      }
      return r;
    };
    webidl.sequenceConverter = function(converter) {
      return (V) => {
        if (webidl.util.Type(V) !== "Object") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: `Value of type ${webidl.util.Type(V)} is not an Object.`
          });
        }
        const method = V?.[Symbol.iterator]?.();
        const seq = [];
        if (method === void 0 || typeof method.next !== "function") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: "Object is not an iterator."
          });
        }
        while (true) {
          const { done, value } = method.next();
          if (done) {
            break;
          }
          seq.push(converter(value));
        }
        return seq;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (O) => {
        if (webidl.util.Type(O) !== "Object") {
          throw webidl.errors.exception({
            header: "Record",
            message: `Value of type ${webidl.util.Type(O)} is not an Object.`
          });
        }
        const result = {};
        if (!types.isProxy(O)) {
          const keys2 = Object.keys(O);
          for (const key of keys2) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
          return result;
        }
        const keys = Reflect.ownKeys(O);
        for (const key of keys) {
          const desc = Reflect.getOwnPropertyDescriptor(O, key);
          if (desc?.enumerable) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
        }
        return result;
      };
    };
    webidl.interfaceConverter = function(i) {
      return (V, opts = {}) => {
        if (opts.strict !== false && !(V instanceof i)) {
          throw webidl.errors.exception({
            header: i.name,
            message: `Expected ${V} to be an instance of ${i.name}.`
          });
        }
        return V;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary) => {
        const type = webidl.util.Type(dictionary);
        const dict = {};
        if (type === "Null" || type === "Undefined") {
          return dict;
        } else if (type !== "Object") {
          throw webidl.errors.exception({
            header: "Dictionary",
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (!hasOwn(dictionary, key)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `Missing required key "${key}".`
              });
            }
          }
          let value = dictionary[key];
          const hasDefault = hasOwn(options, "defaultValue");
          if (hasDefault && value !== null) {
            value = value ?? defaultValue;
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V) => {
        if (V === null) {
          return V;
        }
        return converter(V);
      };
    };
    webidl.converters.DOMString = function(V, opts = {}) {
      if (V === null && opts.legacyNullToEmptyString) {
        return "";
      }
      if (typeof V === "symbol") {
        throw new TypeError("Could not convert argument of type symbol to string.");
      }
      return String(V);
    };
    webidl.converters.ByteString = function(V) {
      const x = webidl.converters.DOMString(V);
      for (let index = 0; index < x.length; index++) {
        const charCode = x.charCodeAt(index);
        if (charCode > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${charCode} which is greater than 255.`
          );
        }
      }
      return x;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function(V) {
      const x = Boolean(V);
      return x;
    };
    webidl.converters.any = function(V) {
      return V;
    };
    webidl.converters["long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "signed");
      return x;
    };
    webidl.converters["unsigned long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "unsigned");
      return x;
    };
    webidl.converters["unsigned long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 32, "unsigned");
      return x;
    };
    webidl.converters["unsigned short"] = function(V, opts) {
      const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
      return x;
    };
    webidl.converters.ArrayBuffer = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
        throw webidl.errors.conversionFailed({
          prefix: `${V}`,
          argument: `${V}`,
          types: ["ArrayBuffer"]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.TypedArray = function(V, T, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
        throw webidl.errors.conversionFailed({
          prefix: `${T.name}`,
          argument: `${V}`,
          types: [T.name]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.DataView = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
        throw webidl.errors.exception({
          header: "DataView",
          message: "Object is not a DataView."
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.BufferSource = function(V, opts = {}) {
      if (types.isAnyArrayBuffer(V)) {
        return webidl.converters.ArrayBuffer(V, opts);
      }
      if (types.isTypedArray(V)) {
        return webidl.converters.TypedArray(V, V.constructor);
      }
      if (types.isDataView(V)) {
        return webidl.converters.DataView(V, opts);
      }
      throw new TypeError(`Could not convert ${V} to a BufferSource.`);
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    module2.exports = {
      webidl
    };
  }
});

// node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({
  "node_modules/undici/lib/fetch/dataURL.js"(exports2, module2) {
    var assert = require("assert");
    var { atob: atob2 } = require("buffer");
    var { isValidHTTPToken, isomorphicDecode } = require_util2();
    var encoder = new TextEncoder();
    var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-z0-9]+$/;
    var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
    var HTTP_QUOTED_STRING_TOKENS = /^(\u0009|\x{0020}-\x{007E}|\x{0080}-\x{00FF})+$/;
    function dataURLProcessor(dataURL) {
      assert(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePointsFast(
        ",",
        input,
        position
      );
      const mimeTypeLength = mimeType.length;
      mimeType = mimeType.replace(/^(\u0020)+|(\u0020)+$/g, "");
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = isomorphicDecode(body);
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url2, excludeFragment = false) {
      const href = url2.href;
      if (!excludeFragment) {
        return href;
      }
      const hash = href.lastIndexOf("#");
      if (hash === -1) {
        return href;
      }
      return href.slice(0, hash);
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input, position) {
      const idx = input.indexOf(char, position.position);
      const start = position.position;
      if (idx === -1) {
        position.position = input.length;
        return input.slice(start);
      }
      position.position = idx;
      return input.slice(start, position.position);
    }
    function stringPercentDecode(input) {
      const bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function percentDecode(input) {
      const output = [];
      for (let i = 0; i < input.length; i++) {
        const byte = input[i];
        if (byte !== 37) {
          output.push(byte);
        } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
          output.push(37);
        } else {
          const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
          const bytePoint = Number.parseInt(nextTwoBytes, 16);
          output.push(bytePoint);
          i += 2;
        }
      }
      return Uint8Array.from(output);
    }
    function parseMIMEType(input) {
      input = input.trim();
      const position = { position: 0 };
      const type = collectASequenceOfCodePointsFast(
        "/",
        input,
        position
      );
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
        return "failure";
      }
      if (position.position > input.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(
        ";",
        input,
        position
      );
      subtype = subtype.trimEnd();
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return "failure";
      }
      const mimeType = {
        type: type.toLowerCase(),
        subtype: subtype.toLowerCase(),
        /** @type {Map<string, string>} */
        parameters: /* @__PURE__ */ new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${type}/${subtype}`
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position > input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position, true);
          collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
        } else {
          parameterValue = collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
          parameterValue = parameterValue.trimEnd();
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && !HTTP_QUOTED_STRING_TOKENS.test(parameterValue) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
      if (data.length % 4 === 0) {
        data = data.replace(/=?=$/, "");
      }
      if (data.length % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data)) {
        return "failure";
      }
      const binary = atob2(data);
      const bytes = new Uint8Array(binary.length);
      for (let byte = 0; byte < binary.length; byte++) {
        bytes[byte] = binary.charCodeAt(byte);
      }
      return bytes;
    }
    function collectAnHTTPQuotedString(input, position, extractValue) {
      const positionStart = position.position;
      let value = "";
      assert(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input,
          position
        );
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert(mimeType !== "failure");
      const { type, subtype, parameters } = mimeType;
      let serialization = `${type}/${subtype}`;
      for (let [name, value] of parameters.entries()) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!isValidHTTPToken(value)) {
          value = value.replace(/(\\|")/g, "\\$1");
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    module2.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType
    };
  }
});

// node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({
  "node_modules/undici/lib/fetch/file.js"(exports2, module2) {
    "use strict";
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var { types } = require("util");
    var { kState } = require_symbols2();
    var { isBlobLike } = require_util2();
    var { webidl } = require_webidl();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var { kEnumerableProperty } = require_util();
    var File = class extends Blob2 {
      constructor(fileBits, fileName, options = {}) {
        webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
        fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
        fileName = webidl.converters.USVString(fileName);
        options = webidl.converters.FilePropertyBag(options);
        const n = fileName;
        let t = options.type;
        let d;
        substep: {
          if (t) {
            t = parseMIMEType(t);
            if (t === "failure") {
              t = "";
              break substep;
            }
            t = serializeAMimeType(t).toLowerCase();
          }
          d = options.lastModified;
        }
        super(processBlobParts(fileBits, options), { type: t });
        this[kState] = {
          name: n,
          lastModified: d,
          type: t
        };
      }
      get name() {
        webidl.brandCheck(this, File);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, File);
        return this[kState].lastModified;
      }
      get type() {
        webidl.brandCheck(this, File);
        return this[kState].type;
      }
    };
    var FileLike = class {
      constructor(blobLike, fileName, options = {}) {
        const n = fileName;
        const t = options.type;
        const d = options.lastModified ?? Date.now();
        this[kState] = {
          blobLike,
          name: n,
          type: t,
          lastModified: d
        };
      }
      stream(...args) {
        webidl.brandCheck(this, FileLike);
        return this[kState].blobLike.stream(...args);
      }
      arrayBuffer(...args) {
        webidl.brandCheck(this, FileLike);
        return this[kState].blobLike.arrayBuffer(...args);
      }
      slice(...args) {
        webidl.brandCheck(this, FileLike);
        return this[kState].blobLike.slice(...args);
      }
      text(...args) {
        webidl.brandCheck(this, FileLike);
        return this[kState].blobLike.text(...args);
      }
      get size() {
        webidl.brandCheck(this, FileLike);
        return this[kState].blobLike.size;
      }
      get type() {
        webidl.brandCheck(this, FileLike);
        return this[kState].blobLike.type;
      }
      get name() {
        webidl.brandCheck(this, FileLike);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, FileLike);
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    Object.defineProperties(File.prototype, {
      [Symbol.toStringTag]: {
        value: "File",
        configurable: true
      },
      name: kEnumerableProperty,
      lastModified: kEnumerableProperty
    });
    webidl.converters.Blob = webidl.interfaceConverter(Blob2);
    webidl.converters.BlobPart = function(V, opts) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V, opts);
        }
      }
      return webidl.converters.USVString(V, opts);
    };
    webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
      webidl.converters.BlobPart
    );
    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
      {
        key: "lastModified",
        converter: webidl.converters["long long"],
        get defaultValue() {
          return Date.now();
        }
      },
      {
        key: "type",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "endings",
        converter: (value) => {
          value = webidl.converters.DOMString(value);
          value = value.toLowerCase();
          if (value !== "native") {
            value = "transparent";
          }
          return value;
        },
        defaultValue: "transparent"
      }
    ]);
    function processBlobParts(parts, options) {
      const bytes = [];
      for (const element of parts) {
        if (typeof element === "string") {
          let s = element;
          if (options.endings === "native") {
            s = convertLineEndingsNative(s);
          }
          bytes.push(new TextEncoder().encode(s));
        } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
          if (!element.buffer) {
            bytes.push(new Uint8Array(element));
          } else {
            bytes.push(
              new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
            );
          }
        } else if (isBlobLike(element)) {
          bytes.push(element);
        }
      }
      return bytes;
    }
    function convertLineEndingsNative(s) {
      let nativeLineEnding = "\n";
      if (process.platform === "win32") {
        nativeLineEnding = "\r\n";
      }
      return s.replace(/\r?\n/g, nativeLineEnding);
    }
    function isFileLike(object) {
      return NativeFile && object instanceof NativeFile || object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
    }
    module2.exports = { File, FileLike, isFileLike };
  }
});

// node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({
  "node_modules/undici/lib/fetch/formdata.js"(exports2, module2) {
    "use strict";
    var { isBlobLike, toUSVString, makeIterator } = require_util2();
    var { kState } = require_symbols2();
    var { File: UndiciFile, FileLike, isFileLike } = require_file();
    var { webidl } = require_webidl();
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var File = NativeFile ?? UndiciFile;
    var FormData3 = class {
      constructor(form) {
        if (form !== void 0) {
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"]
          });
        }
        this[kState] = [];
      }
      append(name, value, filename = void 0) {
        webidl.brandCheck(this, FormData3);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        this[kState].push(entry);
      }
      delete(name) {
        webidl.brandCheck(this, FormData3);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
        name = webidl.converters.USVString(name);
        const next = [];
        for (const entry of this[kState]) {
          if (entry.name !== name) {
            next.push(entry);
          }
        }
        this[kState] = next;
      }
      get(name) {
        webidl.brandCheck(this, FormData3);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
        name = webidl.converters.USVString(name);
        const idx = this[kState].findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this[kState][idx].value;
      }
      getAll(name) {
        webidl.brandCheck(this, FormData3);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
        name = webidl.converters.USVString(name);
        return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(name) {
        webidl.brandCheck(this, FormData3);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
        name = webidl.converters.USVString(name);
        return this[kState].findIndex((entry) => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        webidl.brandCheck(this, FormData3);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? toUSVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        const idx = this[kState].findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this[kState] = [
            ...this[kState].slice(0, idx),
            entry,
            ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
          ];
        } else {
          this[kState].push(entry);
        }
      }
      entries() {
        webidl.brandCheck(this, FormData3);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key+value"
        );
      }
      keys() {
        webidl.brandCheck(this, FormData3);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, FormData3);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "value"
        );
      }
      /**
       * @param {(value: string, key: string, self: FormData) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, FormData3);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
    };
    FormData3.prototype[Symbol.iterator] = FormData3.prototype.entries;
    Object.defineProperties(FormData3.prototype, {
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: true
      }
    });
    function makeEntry(name, value, filename) {
      name = Buffer.from(name).toString("utf8");
      if (typeof value === "string") {
        value = Buffer.from(value).toString("utf8");
      } else {
        if (!isFileLike(value)) {
          value = value instanceof Blob2 ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
        }
        if (filename !== void 0) {
          const options = {
            type: value.type,
            lastModified: value.lastModified
          };
          value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([value], filename, options) : new FileLike(value, filename, options);
        }
      }
      return { name, value };
    }
    module2.exports = { FormData: FormData3 };
  }
});

// node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({
  "node_modules/undici/lib/fetch/body.js"(exports2, module2) {
    "use strict";
    var Busboy = require_lib();
    var util2 = require_util();
    var {
      ReadableStreamFrom,
      isBlobLike,
      isReadableStreamLike,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody
    } = require_util2();
    var { FormData: FormData3 } = require_formdata();
    var { kState } = require_symbols2();
    var { webidl } = require_webidl();
    var { DOMException, structuredClone } = require_constants();
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var { kBodyUsed } = require_symbols();
    var assert = require("assert");
    var { isErrored } = require_util();
    var { isUint8Array, isArrayBuffer: isArrayBuffer2 } = require("util/types");
    var { File: UndiciFile } = require_file();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var ReadableStream = globalThis.ReadableStream;
    var File = NativeFile ?? UndiciFile;
    function extractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      let stream4 = null;
      if (object instanceof ReadableStream) {
        stream4 = object;
      } else if (isBlobLike(object)) {
        stream4 = object.stream();
      } else {
        stream4 = new ReadableStream({
          async pull(controller) {
            controller.enqueue(
              typeof source === "string" ? new TextEncoder().encode(source) : source
            );
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {
          },
          type: void 0
        });
      }
      assert(isReadableStreamLike(stream4));
      let action = null;
      let source = null;
      let length = null;
      let type = null;
      if (typeof object === "string") {
        source = object;
        type = "text/plain;charset=UTF-8";
      } else if (object instanceof URLSearchParams) {
        source = object.toString();
        type = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer2(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (util2.isFormDataLike(object)) {
        const boundary = `----formdata-undici-${Math.random()}`.replace(".", "").slice(0, 32);
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        const enc = new TextEncoder();
        const blobParts = [];
        const rn = new Uint8Array([13, 10]);
        length = 0;
        for (const [name, value] of object) {
          if (typeof value === "string") {
            const chunk2 = enc.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            blobParts.push(chunk2);
            length += chunk2.byteLength;
          } else {
            const chunk2 = enc.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
            blobParts.push(chunk2, value, rn);
            length += chunk2.byteLength + value.size + rn.byteLength;
          }
        }
        const chunk = enc.encode(`--${boundary}--`);
        blobParts.push(chunk);
        length += chunk.byteLength;
        source = object;
        action = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };
        type = "multipart/form-data; boundary=" + boundary;
      } else if (isBlobLike(object)) {
        source = object;
        length = object.size;
        if (object.type) {
          type = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util2.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }
        stream4 = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
      }
      if (typeof source === "string" || util2.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream4 = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              if (!isErrored(stream4)) {
                controller.enqueue(new Uint8Array(value));
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: void 0
        });
      }
      const body = { stream: stream4, source, length };
      return [body, type];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      if (object instanceof ReadableStream) {
        assert(!util2.isDisturbed(object), "The body has already been consumed.");
        assert(!object.locked, "The stream is locked.");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(body) {
      const [out1, out2] = body.stream.tee();
      const out2Clone = structuredClone(out2, { transfer: [out2] });
      const [, finalClone] = out2Clone.tee();
      body.stream = out1;
      return {
        stream: finalClone,
        length: body.length,
        source: body.source
      };
    }
    async function* consumeBody(body) {
      if (body) {
        if (isUint8Array(body)) {
          yield body;
        } else {
          const stream4 = body.stream;
          if (util2.isDisturbed(stream4)) {
            throw new TypeError("The body has already been consumed.");
          }
          if (stream4.locked) {
            throw new TypeError("The stream is locked.");
          }
          stream4[kBodyUsed] = true;
          yield* stream4;
        }
      }
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(instance) {
      const methods = {
        blob() {
          return specConsumeBody(this, (bytes) => {
            let mimeType = bodyMimeType(this);
            if (mimeType === "failure") {
              mimeType = "";
            } else if (mimeType) {
              mimeType = serializeAMimeType(mimeType);
            }
            return new Blob2([bytes], { type: mimeType });
          }, instance);
        },
        arrayBuffer() {
          return specConsumeBody(this, (bytes) => {
            return new Uint8Array(bytes).buffer;
          }, instance);
        },
        text() {
          return specConsumeBody(this, utf8DecodeBytes, instance);
        },
        json() {
          return specConsumeBody(this, parseJSONFromBytes, instance);
        },
        async formData() {
          webidl.brandCheck(this, instance);
          throwIfAborted(this[kState]);
          const contentType = this.headers.get("Content-Type");
          if (/multipart\/form-data/.test(contentType)) {
            const headers = {};
            for (const [key, value] of this.headers)
              headers[key.toLowerCase()] = value;
            const responseFormData = new FormData3();
            let busboy;
            try {
              busboy = Busboy({
                headers,
                defParamCharset: "utf8"
              });
            } catch (err) {
              throw new DOMException(`${err}`, "AbortError");
            }
            busboy.on("field", (name, value) => {
              responseFormData.append(name, value);
            });
            busboy.on("file", (name, value, info) => {
              const { filename, encoding, mimeType } = info;
              const chunks = [];
              if (encoding === "base64" || encoding.toLowerCase() === "base64") {
                let base64chunk = "";
                value.on("data", (chunk) => {
                  base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                  const end = base64chunk.length - base64chunk.length % 4;
                  chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                  base64chunk = base64chunk.slice(end);
                });
                value.on("end", () => {
                  chunks.push(Buffer.from(base64chunk, "base64"));
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              } else {
                value.on("data", (chunk) => {
                  chunks.push(chunk);
                });
                value.on("end", () => {
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              }
            });
            const busboyResolve = new Promise((resolve, reject) => {
              busboy.on("finish", resolve);
              busboy.on("error", (err) => reject(new TypeError(err)));
            });
            if (this.body !== null)
              for await (const chunk of consumeBody(this[kState].body))
                busboy.write(chunk);
            busboy.end();
            await busboyResolve;
            return responseFormData;
          } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
            let entries;
            try {
              let text = "";
              const textDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                text += textDecoder.decode(chunk, { stream: true });
              }
              text += textDecoder.decode();
              entries = new URLSearchParams(text);
            } catch (err) {
              throw Object.assign(new TypeError(), { cause: err });
            }
            const formData = new FormData3();
            for (const [name, value] of entries) {
              formData.append(name, value);
            }
            return formData;
          } else {
            await Promise.resolve();
            throwIfAborted(this[kState]);
            throw webidl.errors.exception({
              header: `${instance.name}.formData`,
              message: "Could not parse content as FormData."
            });
          }
        }
      };
      return methods;
    }
    function mixinBody(prototype3) {
      Object.assign(prototype3.prototype, bodyMixinMethods(prototype3));
    }
    async function specConsumeBody(object, convertBytesToJSValue, instance) {
      webidl.brandCheck(object, instance);
      throwIfAborted(object[kState]);
      if (bodyUnusable(object[kState].body)) {
        throw new TypeError("Body is unusable");
      }
      const promise = createDeferredPromise();
      const errorSteps = (error) => promise.reject(error);
      const successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };
      if (object[kState].body == null) {
        successSteps(new Uint8Array());
        return promise.promise;
      }
      fullyReadBody(object[kState].body, successSteps, errorSteps);
      return promise.promise;
    }
    function bodyUnusable(body) {
      return body != null && (body.stream.locked || util2.isDisturbed(body.stream));
    }
    function utf8DecodeBytes(buffer) {
      if (buffer.length === 0) {
        return "";
      }
      if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
        buffer = buffer.subarray(3);
      }
      const output = new TextDecoder().decode(buffer);
      return output;
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(object) {
      const { headersList } = object[kState];
      const contentType = headersList.get("content-type");
      if (contentType === null) {
        return "failure";
      }
      return parseMIMEType(contentType);
    }
    module2.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody
    };
  }
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "node_modules/undici/lib/core/request.js"(exports2, module2) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors();
    var assert = require("assert");
    var util2 = require_util();
    var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = Symbol("handler");
    var channels = {};
    var extractBody;
    try {
      const diagnosticsChannel = require("diagnostics_channel");
      channels.create = diagnosticsChannel.channel("undici:request:create");
      channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
      channels.headers = diagnosticsChannel.channel("undici:request:headers");
      channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
      channels.error = diagnosticsChannel.channel("undici:request:error");
    } catch {
      channels.create = { hasSubscribers: false };
      channels.bodySent = { hasSubscribers: false };
      channels.headers = { hasSubscribers: false };
      channels.trailers = { hasSubscribers: false };
      channels.error = { hasSubscribers: false };
    }
    var Request = class {
      constructor(origin, {
        path,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        reset,
        throwOnError
      }, handler) {
        if (typeof path !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        } else if (invalidPathRegex.exec(path) !== null) {
          throw new InvalidArgumentError("invalid request path");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (tokenRegExp.exec(method) === null) {
          throw new InvalidArgumentError("invalid request method");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        if (reset != null && typeof reset !== "boolean") {
          throw new InvalidArgumentError("invalid reset");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.throwOnError = throwOnError === true;
        this.method = method;
        if (body == null) {
          this.body = null;
        } else if (util2.isStream(body)) {
          this.body = body;
        } else if (util2.isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (util2.isFormDataLike(body) || util2.isIterable(body) || util2.isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? util2.buildURL(path, query) : path;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking == null ? false : blocking;
        this.reset = reset == null ? null : reset;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = "";
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(this, key, headers[key]);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        if (util2.isFormDataLike(this.body)) {
          if (util2.nodeMajor < 16 || util2.nodeMajor === 16 && util2.nodeMinor < 8) {
            throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
          }
          if (!extractBody) {
            extractBody = require_body().extractBody;
          }
          const [bodyStream, contentType] = extractBody(body);
          if (this.contentType == null) {
            this.contentType = contentType;
            this.headers += `content-type: ${contentType}\r
`;
          }
          this.body = bodyStream.stream;
        } else if (util2.isBlobLike(body) && this.contentType == null && body.type) {
          this.contentType = body.type;
          this.headers += `content-type: ${body.type}\r
`;
        }
        util2.validateHandler(handler, method, upgrade);
        this.servername = util2.getServerName(this.host);
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent) {
          try {
            this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.onError(err);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
      }
      onConnect(abort) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onConnect(abort);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert(!this.aborted);
        assert(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
      }
      onData(chunk) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onData(chunk);
      }
      onUpgrade(statusCode, headers, socket) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        assert(!this.aborted);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        return this[kHandler].onComplete(trailers);
      }
      onError(error) {
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error);
      }
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
    };
    function processHeaderValue(key, val) {
      if (val && typeof val === "object") {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      val = val != null ? `${val}` : "";
      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      return `${key}: ${val}\r
`;
    }
    function processHeader(request, key, val) {
      if (val && (typeof val === "object" && !Array.isArray(val))) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
        if (headerCharRegex.exec(val) !== null) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
        request.host = val;
      } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
        request.contentType = val;
        request.headers += processHeaderValue(key, val);
      } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
        throw new InvalidArgumentError("invalid transfer-encoding header");
      } else if (key.length === 10 && key.toLowerCase() === "connection") {
        const value = typeof val === "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") {
          throw new InvalidArgumentError("invalid connection header");
        } else if (value === "close") {
          request.reset = true;
        }
      } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
        throw new InvalidArgumentError("invalid keep-alive header");
      } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
        throw new InvalidArgumentError("invalid upgrade header");
      } else if (key.length === 6 && key.toLowerCase() === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else if (tokenRegExp.exec(key) === null) {
        throw new InvalidArgumentError("invalid header key");
      } else {
        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            request.headers += processHeaderValue(key, val[i]);
          }
        } else {
          request.headers += processHeaderValue(key, val);
        }
      }
    }
    module2.exports = Request;
  }
});

// node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/undici/lib/dispatcher.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var Dispatcher = class extends EventEmitter2 {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
    };
    module2.exports = Dispatcher;
  }
});

// node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "node_modules/undici/lib/dispatcher-base.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors();
    var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
    var kDestroyed = Symbol("destroyed");
    var kClosed = Symbol("closed");
    var kOnDestroyed = Symbol("onDestroyed");
    var kOnClosed = Symbol("onClosed");
    var kInterceptedDispatch = Symbol("Intercepted Dispatch");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = [];
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      get interceptors() {
        return this[kInterceptors];
      }
      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i = newInterceptors.length - 1; i >= 0; i--) {
            const interceptor = this[kInterceptors][i];
            if (typeof interceptor !== "function") {
              throw new InvalidArgumentError("interceptor must be an function");
            }
          }
        }
        this[kInterceptors] = newInterceptors;
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? (
                /* istanbul ignore next: should never error */
                reject(err2)
              ) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0) {
          this[kInterceptedDispatch] = this[kDispatch];
          return this[kDispatch](opts, handler);
        }
        let dispatch = this[kDispatch].bind(this);
        for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
          dispatch = this[kInterceptors][i](dispatch);
        }
        this[kInterceptedDispatch] = dispatch;
        return dispatch(opts, handler);
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module2.exports = DispatcherBase;
  }
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "node_modules/undici/lib/core/connect.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var assert = require("assert");
    var util2 = require_util();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
    var tls;
    var SessionCache;
    if (global.FinalizationRegistry) {
      SessionCache = class WeakSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
          this._sessionRegistry = new global.FinalizationRegistry((key) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }
            const ref = this._sessionCache.get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this._sessionCache.delete(key);
            }
          });
        }
        get(sessionKey) {
          const ref = this._sessionCache.get(sessionKey);
          return ref ? ref.deref() : null;
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          this._sessionCache.set(sessionKey, new WeakRef(session));
          this._sessionRegistry.register(session, sessionKey);
        }
      };
    } else {
      SessionCache = class SimpleSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(sessionKey) {
          return this._sessionCache.get(sessionKey);
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          if (this._sessionCache.size >= this._maxCachedSessions) {
            const { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }
          this._sessionCache.set(sessionKey, session);
        }
      };
    }
    function buildConnector({ maxCachedSessions, socketPath, timeout, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options = { path: socketPath, ...opts };
      const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
      timeout = timeout == null ? 1e4 : timeout;
      return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = require("tls");
          }
          servername = servername || options.servername || util2.getServerName(host) || null;
          const sessionKey = servername || hostname;
          const session = sessionCache.get(sessionKey) || null;
          assert(sessionKey);
          socket = tls.connect({
            highWaterMark: 16384,
            // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            socket: httpSocket,
            // upgrade socket connection
            port: port || 443,
            host: hostname
          });
          socket.on("session", function(session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else {
          assert(!httpSocket, "httpSocket can only be sent on TLS update");
          socket = net.connect({
            highWaterMark: 64 * 1024,
            // Same as nodejs fs streams.
            ...options,
            localAddress,
            port: port || 80,
            host: hostname
          });
        }
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }
        const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err) {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err);
          }
        });
        return socket;
      };
    }
    function setupTimeout(onConnectTimeout2, timeout) {
      if (!timeout) {
        return () => {
        };
      }
      let s1 = null;
      let s2 = null;
      const timeoutId = setTimeout(() => {
        s1 = setImmediate(() => {
          if (process.platform === "win32") {
            s2 = setImmediate(() => onConnectTimeout2());
          } else {
            onConnectTimeout2();
          }
        });
      }, timeout);
      return () => {
        clearTimeout(timeoutId);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    }
    function onConnectTimeout(socket) {
      util2.destroy(socket, new ConnectTimeoutError());
    }
    module2.exports = buildConnector;
  }
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS({
  "node_modules/undici/lib/llhttp/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enumToMap = void 0;
    function enumToMap(obj) {
      const res = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === "number") {
          res[key] = value;
        }
      });
      return res;
    }
    exports2.enumToMap = enumToMap;
  }
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants2 = __commonJS({
  "node_modules/undici/lib/llhttp/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SPECIAL_HEADERS = exports2.HEADER_STATE = exports2.MINOR = exports2.MAJOR = exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS = exports2.TOKEN = exports2.STRICT_TOKEN = exports2.HEX = exports2.URL_CHAR = exports2.STRICT_URL_CHAR = exports2.USERINFO_CHARS = exports2.MARK = exports2.ALPHANUM = exports2.NUM = exports2.HEX_MAP = exports2.NUM_MAP = exports2.ALPHA = exports2.FINISH = exports2.H_METHOD_MAP = exports2.METHOD_MAP = exports2.METHODS_RTSP = exports2.METHODS_ICE = exports2.METHODS_HTTP = exports2.METHODS = exports2.LENIENT_FLAGS = exports2.FLAGS = exports2.TYPE = exports2.ERROR = void 0;
    var utils_1 = require_utils2();
    var ERROR;
    (function(ERROR2) {
      ERROR2[ERROR2["OK"] = 0] = "OK";
      ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
      ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
      ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
      ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
      ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
      ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
      ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
      ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
      ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
      ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
      ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
      ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
      ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
      ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
      ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
      ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
      ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
      ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
      ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
      ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
      ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
      ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
      ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
      ERROR2[ERROR2["USER"] = 24] = "USER";
    })(ERROR = exports2.ERROR || (exports2.ERROR = {}));
    var TYPE;
    (function(TYPE2) {
      TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
      TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
      TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
    })(TYPE = exports2.TYPE || (exports2.TYPE = {}));
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
      FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
      FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
      FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
      FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
      FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
      FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
      FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
      FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
    })(FLAGS = exports2.FLAGS || (exports2.FLAGS = {}));
    var LENIENT_FLAGS;
    (function(LENIENT_FLAGS2) {
      LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
      LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
      LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
    })(LENIENT_FLAGS = exports2.LENIENT_FLAGS || (exports2.LENIENT_FLAGS = {}));
    var METHODS;
    (function(METHODS2) {
      METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
      METHODS2[METHODS2["GET"] = 1] = "GET";
      METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
      METHODS2[METHODS2["POST"] = 3] = "POST";
      METHODS2[METHODS2["PUT"] = 4] = "PUT";
      METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
      METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
      METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
      METHODS2[METHODS2["COPY"] = 8] = "COPY";
      METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
      METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
      METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
      METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
      METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
      METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
      METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
      METHODS2[METHODS2["BIND"] = 16] = "BIND";
      METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
      METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
      METHODS2[METHODS2["ACL"] = 19] = "ACL";
      METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
      METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
      METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
      METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
      METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
      METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
      METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
      METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
      METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
      METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
      METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
      METHODS2[METHODS2["LINK"] = 31] = "LINK";
      METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
      METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
      METHODS2[METHODS2["PRI"] = 34] = "PRI";
      METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
      METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
      METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
      METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
      METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
      METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
      METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
      METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
      METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
      METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
      METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
    })(METHODS = exports2.METHODS || (exports2.METHODS = {}));
    exports2.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      METHODS.SOURCE
    ];
    exports2.METHODS_ICE = [
      METHODS.SOURCE
    ];
    exports2.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      // For AirPlay
      METHODS.GET,
      METHODS.POST
    ];
    exports2.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports2.H_METHOD_MAP = {};
    Object.keys(exports2.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports2.H_METHOD_MAP[key] = exports2.METHOD_MAP[key];
      }
    });
    var FINISH;
    (function(FINISH2) {
      FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
      FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
      FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
    })(FINISH = exports2.FINISH || (exports2.FINISH = {}));
    exports2.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports2.ALPHA.push(String.fromCharCode(i));
      exports2.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports2.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports2.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports2.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
    exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports2.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.URL_CHAR = exports2.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i = 128; i <= 255; i++) {
      exports2.URL_CHAR.push(i);
    }
    exports2.HEX = exports2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports2.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.TOKEN = exports2.STRICT_TOKEN.concat([" "]);
    exports2.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports2.HEADER_CHARS.push(i);
      }
    }
    exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c) => c !== 44);
    exports2.MAJOR = exports2.NUM_MAP;
    exports2.MINOR = exports2.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
      HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
      HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
      HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports2.HEADER_STATE || (exports2.HEADER_STATE = {}));
    exports2.SPECIAL_HEADERS = {
      "connection": HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": HEADER_STATE.UPGRADE
    };
  }
});

// node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({
  "node_modules/undici/lib/handler/RedirectHandler.js"(exports2, module2) {
    "use strict";
    var util2 = require_util();
    var { kBodyUsed } = require_symbols();
    var assert = require("assert");
    var { InvalidArgumentError } = require_errors();
    var EE = require("events");
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = Symbol("body");
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        util2.validateHandler(handler, opts.method, opts.upgrade);
        this.dispatch = dispatch;
        this.location = null;
        this.abort = null;
        this.opts = { ...opts, maxRedirections: 0 };
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util2.isStream(this.opts.body)) {
          if (util2.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util2.isIterable(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onConnect(abort) {
        this.abort = abort;
        this.handler.onConnect(abort, { history: this.history });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error) {
        this.handler.onError(error);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        this.location = this.history.length >= this.maxRedirections || util2.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          return this.handler.onHeaders(statusCode, headers, resume, statusText);
        }
        const { origin, pathname, search } = util2.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const path = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        this.opts.query = null;
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          this.opts.body = null;
        }
      }
      onData(chunk) {
        if (this.location) {
        } else {
          return this.handler.onData(chunk);
        }
      }
      onComplete(trailers) {
        if (this.location) {
          this.location = null;
          this.abort = null;
          this.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(trailers);
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(chunk);
        }
      }
    };
    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1) {
        return null;
      }
      for (let i = 0; i < headers.length; i += 2) {
        if (headers[i].toString().toLowerCase() === "location") {
          return headers[i + 1];
        }
      }
    }
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      return header.length === 4 && header.toString().toLowerCase() === "host" || removeContent && header.toString().toLowerCase().indexOf("content-") === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === "authorization" || unknownOrigin && header.length === 6 && header.toString().toLowerCase() === "cookie";
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        for (const key of Object.keys(headers)) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, headers[key]);
          }
        }
      } else {
        assert(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module2.exports = RedirectHandler;
  }
});

// node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({
  "node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports2, module2) {
    "use strict";
    var RedirectHandler = require_RedirectHandler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections } = opts;
          if (!maxRedirections) {
            return dispatch(opts, handler);
          }
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
          opts = { ...opts, maxRedirections: 0 };
          return dispatch(opts, redirectHandler);
        };
      };
    }
    module2.exports = createRedirectInterceptor;
  }
});

// node_modules/undici/lib/llhttp/llhttp.wasm.js
var require_llhttp_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp.wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMBBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCtnkAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQy4CAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDLgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMuAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMuAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL8gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARBCHENAAJAIARBgARxRQ0AAkAgAC0AKEEBRw0AIAAtAC1BCnENAEEFDwtBBA8LAkAgBEEgcQ0AAkAgAC0AKEEBRg0AIAAvATIiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQYgEcUGABEYNAiAEQShxRQ0CC0EADwtBAEEDIAApAyBQGyEFCyAFC10BAn9BACEBAkAgAC0AKEEBRg0AIAAvATIiAkGcf2pB5ABJDQAgAkHMAUYNACACQbACRg0AIAAvATAiAEHAAHENAEEBIQEgAEGIBHFBgARGDQAgAEEocUUhAQsgAQuiAQEDfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEDIAAvATAiBEECcUUNAQwCC0EAIQMgAC8BMCIEQQFxRQ0BC0EBIQMgAC0AKEEBRg0AIAAvATIiBUGcf2pB5ABJDQAgBUHMAUYNACAFQbACRg0AIARBwABxDQBBACEDIARBiARxQYAERg0AIARBKHFBAEchAwsgAEEAOwEwIABBADoALyADC5QBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQEgAC8BMCICQQJxRQ0BDAILQQAhASAALwEwIgJBAXFFDQELQQEhASAALQAoQQFGDQAgAC8BMiIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC1kAIABBGGpCADcDACAAQgA3AwAgAEE4akIANwMAIABBMGpCADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvc9wEDKH8DfgV/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8gASEQIAEhESABIRIgASETIAEhFCABIRUgASEWIAEhFyABIRggASEZIAEhGiABIRsgASEcIAEhHSABIR4gASEfIAEhICABISEgASEiIAEhIyABISQgASElIAEhJiABIScgASEoIAEhKQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIipBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AcsBygG4AckBuQHIAboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBANwBC0EAISoMxgELQQ4hKgzFAQtBDSEqDMQBC0EPISoMwwELQRAhKgzCAQtBEyEqDMEBC0EUISoMwAELQRUhKgy/AQtBFiEqDL4BC0EXISoMvQELQRghKgy8AQtBGSEqDLsBC0EaISoMugELQRshKgy5AQtBHCEqDLgBC0EIISoMtwELQR0hKgy2AQtBICEqDLUBC0EfISoMtAELQQchKgyzAQtBISEqDLIBC0EiISoMsQELQR4hKgywAQtBIyEqDK8BC0ESISoMrgELQREhKgytAQtBJCEqDKwBC0ElISoMqwELQSYhKgyqAQtBJyEqDKkBC0HDASEqDKgBC0EpISoMpwELQSshKgymAQtBLCEqDKUBC0EtISoMpAELQS4hKgyjAQtBLyEqDKIBC0HEASEqDKEBC0EwISoMoAELQTQhKgyfAQtBDCEqDJ4BC0ExISoMnQELQTIhKgycAQtBMyEqDJsBC0E5ISoMmgELQTUhKgyZAQtBxQEhKgyYAQtBCyEqDJcBC0E6ISoMlgELQTYhKgyVAQtBCiEqDJQBC0E3ISoMkwELQTghKgySAQtBPCEqDJEBC0E7ISoMkAELQT0hKgyPAQtBCSEqDI4BC0EoISoMjQELQT4hKgyMAQtBPyEqDIsBC0HAACEqDIoBC0HBACEqDIkBC0HCACEqDIgBC0HDACEqDIcBC0HEACEqDIYBC0HFACEqDIUBC0HGACEqDIQBC0EqISoMgwELQccAISoMggELQcgAISoMgQELQckAISoMgAELQcoAISoMfwtBywAhKgx+C0HNACEqDH0LQcwAISoMfAtBzgAhKgx7C0HPACEqDHoLQdAAISoMeQtB0QAhKgx4C0HSACEqDHcLQdMAISoMdgtB1AAhKgx1C0HWACEqDHQLQdUAISoMcwtBBiEqDHILQdcAISoMcQtBBSEqDHALQdgAISoMbwtBBCEqDG4LQdkAISoMbQtB2gAhKgxsC0HbACEqDGsLQdwAISoMagtBAyEqDGkLQd0AISoMaAtB3gAhKgxnC0HfACEqDGYLQeEAISoMZQtB4AAhKgxkC0HiACEqDGMLQeMAISoMYgtBAiEqDGELQeQAISoMYAtB5QAhKgxfC0HmACEqDF4LQecAISoMXQtB6AAhKgxcC0HpACEqDFsLQeoAISoMWgtB6wAhKgxZC0HsACEqDFgLQe0AISoMVwtB7gAhKgxWC0HvACEqDFULQfAAISoMVAtB8QAhKgxTC0HyACEqDFILQfMAISoMUQtB9AAhKgxQC0H1ACEqDE8LQfYAISoMTgtB9wAhKgxNC0H4ACEqDEwLQfkAISoMSwtB+gAhKgxKC0H7ACEqDEkLQfwAISoMSAtB/QAhKgxHC0H+ACEqDEYLQf8AISoMRQtBgAEhKgxEC0GBASEqDEMLQYIBISoMQgtBgwEhKgxBC0GEASEqDEALQYUBISoMPwtBhgEhKgw+C0GHASEqDD0LQYgBISoMPAtBiQEhKgw7C0GKASEqDDoLQYsBISoMOQtBjAEhKgw4C0GNASEqDDcLQY4BISoMNgtBjwEhKgw1C0GQASEqDDQLQZEBISoMMwtBkgEhKgwyC0GTASEqDDELQZQBISoMMAtBlQEhKgwvC0GWASEqDC4LQZcBISoMLQtBmAEhKgwsC0GZASEqDCsLQZoBISoMKgtBmwEhKgwpC0GcASEqDCgLQZ0BISoMJwtBngEhKgwmC0GfASEqDCULQaABISoMJAtBoQEhKgwjC0GiASEqDCILQaMBISoMIQtBpAEhKgwgC0GlASEqDB8LQaYBISoMHgtBpwEhKgwdC0GoASEqDBwLQakBISoMGwtBqgEhKgwaC0GrASEqDBkLQawBISoMGAtBrQEhKgwXC0GuASEqDBYLQQEhKgwVC0GvASEqDBQLQbABISoMEwtBsQEhKgwSC0GzASEqDBELQbIBISoMEAtBtAEhKgwPC0G1ASEqDA4LQbYBISoMDQtBtwEhKgwMC0G4ASEqDAsLQbkBISoMCgtBugEhKgwJC0G7ASEqDAgLQcYBISoMBwtBvAEhKgwGC0G9ASEqDAULQb4BISoMBAtBvwEhKgwDC0HAASEqDAILQcIBISoMAQtBwQEhKgsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgKg7HAQABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHh8gISMlKD9AQURFRkdISUpLTE1PUFFSU+MDV1lbXF1gYmVmZ2hpamtsbW9wcXJzdHV2d3h5ent8fX6AAYIBhQGGAYcBiQGLAYwBjQGOAY8BkAGRAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAeAB4QHiAeMB5AHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHxAfIB8wGZAqQCsgKEA4QDCyABIgQgAkcN8wFB3QEhKgyGBAsgASIqIAJHDd0BQcMBISoMhQQLIAEiASACRw2QAUH3ACEqDIQECyABIgEgAkcNhgFB7wAhKgyDBAsgASIBIAJHDX9B6gAhKgyCBAsgASIBIAJHDXtB6AAhKgyBBAsgASIBIAJHDXhB5gAhKgyABAsgASIBIAJHDRpBGCEqDP8DCyABIgEgAkcNFEESISoM/gMLIAEiASACRw1ZQcUAISoM/QMLIAEiASACRw1KQT8hKgz8AwsgASIBIAJHDUhBPCEqDPsDCyABIgEgAkcNQUExISoM+gMLIAAtAC5BAUYN8gMMhwILIAAgASIBIAIQwICAgABBAUcN5gEgAEIANwMgDOcBCyAAIAEiASACELSAgIAAIioN5wEgASEBDPsCCwJAIAEiASACRw0AQQYhKgz3AwsgACABQQFqIgEgAhC7gICAACIqDegBIAEhAQwxCyAAQgA3AyBBEiEqDNwDCyABIiogAkcNK0EdISoM9AMLAkAgASIBIAJGDQAgAUEBaiEBQRAhKgzbAwtBByEqDPMDCyAAQgAgACkDICIrIAIgASIqa60iLH0iLSAtICtWGzcDICArICxWIi5FDeUBQQghKgzyAwsCQCABIgEgAkYNACAAQYmAgIAANgIIIAAgATYCBCABIQFBFCEqDNkDC0EJISoM8QMLIAEhASAAKQMgUA3kASABIQEM+AILAkAgASIBIAJHDQBBCyEqDPADCyAAIAFBAWoiASACELaAgIAAIioN5QEgASEBDPgCCyAAIAEiASACELiAgIAAIioN5QEgASEBDPgCCyAAIAEiASACELiAgIAAIioN5gEgASEBDA0LIAAgASIBIAIQuoCAgAAiKg3nASABIQEM9gILAkAgASIBIAJHDQBBDyEqDOwDCyABLQAAIipBO0YNCCAqQQ1HDegBIAFBAWohAQz1AgsgACABIgEgAhC6gICAACIqDegBIAEhAQz4AgsDQAJAIAEtAABB8LWAgABqLQAAIipBAUYNACAqQQJHDesBIAAoAgQhKiAAQQA2AgQgACAqIAFBAWoiARC5gICAACIqDeoBIAEhAQz6AgsgAUEBaiIBIAJHDQALQRIhKgzpAwsgACABIgEgAhC6gICAACIqDekBIAEhAQwKCyABIgEgAkcNBkEbISoM5wMLAkAgASIBIAJHDQBBFiEqDOcDCyAAQYqAgIAANgIIIAAgATYCBCAAIAEgAhC4gICAACIqDeoBIAEhAUEgISoMzQMLAkAgASIBIAJGDQADQAJAIAEtAABB8LeAgABqLQAAIipBAkYNAAJAICpBf2oOBOUB7AEA6wHsAQsgAUEBaiEBQQghKgzPAwsgAUEBaiIBIAJHDQALQRUhKgzmAwtBFSEqDOUDCwNAAkAgAS0AAEHwuYCAAGotAAAiKkECRg0AICpBf2oOBN4B7AHgAesB7AELIAFBAWoiASACRw0AC0EYISoM5AMLAkAgASIBIAJGDQAgAEGLgICAADYCCCAAIAE2AgQgASEBQQchKgzLAwtBGSEqDOMDCyABQQFqIQEMAgsCQCABIi4gAkcNAEEaISoM4gMLIC4hAQJAIC4tAABBc2oOFOMC9AL0AvQC9AL0AvQC9AL0AvQC9AL0AvQC9AL0AvQC9AL0AvQCAPQCC0EAISogAEEANgIcIABBr4uAgAA2AhAgAEECNgIMIAAgLkEBajYCFAzhAwsCQCABLQAAIipBO0YNACAqQQ1HDegBIAFBAWohAQzrAgsgAUEBaiEBC0EiISoMxgMLAkAgASIqIAJHDQBBHCEqDN8DC0IAISsgKiEBICotAABBUGoON+cB5gEBAgMEBQYHCAAAAAAAAAAJCgsMDQ4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8QERITFAALQR4hKgzEAwtCAiErDOUBC0IDISsM5AELQgQhKwzjAQtCBSErDOIBC0IGISsM4QELQgchKwzgAQtCCCErDN8BC0IJISsM3gELQgohKwzdAQtCCyErDNwBC0IMISsM2wELQg0hKwzaAQtCDiErDNkBC0IPISsM2AELQgohKwzXAQtCCyErDNYBC0IMISsM1QELQg0hKwzUAQtCDiErDNMBC0IPISsM0gELQgAhKwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgKi0AAEFQag435QHkAQABAgMEBQYH5gHmAeYB5gHmAeYB5gEICQoLDA3mAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYBDg8QERIT5gELQgIhKwzkAQtCAyErDOMBC0IEISsM4gELQgUhKwzhAQtCBiErDOABC0IHISsM3wELQgghKwzeAQtCCSErDN0BC0IKISsM3AELQgshKwzbAQtCDCErDNoBC0INISsM2QELQg4hKwzYAQtCDyErDNcBC0IKISsM1gELQgshKwzVAQtCDCErDNQBC0INISsM0wELQg4hKwzSAQtCDyErDNEBCyAAQgAgACkDICIrIAIgASIqa60iLH0iLSAtICtWGzcDICArICxWIi5FDdIBQR8hKgzHAwsCQCABIgEgAkYNACAAQYmAgIAANgIIIAAgATYCBCABIQFBJCEqDK4DC0EgISoMxgMLIAAgASIqIAIQvoCAgABBf2oOBbYBAMsCAdEB0gELQREhKgyrAwsgAEEBOgAvICohAQzCAwsgASIBIAJHDdIBQSQhKgzCAwsgASInIAJHDR5BxgAhKgzBAwsgACABIgEgAhCygICAACIqDdQBIAEhAQy1AQsgASIqIAJHDSZB0AAhKgy/AwsCQCABIgEgAkcNAEEoISoMvwMLIABBADYCBCAAQYyAgIAANgIIIAAgASABELGAgIAAIioN0wEgASEBDNgBCwJAIAEiKiACRw0AQSkhKgy+AwsgKi0AACIBQSBGDRQgAUEJRw3TASAqQQFqIQEMFQsCQCABIgEgAkYNACABQQFqIQEMFwtBKiEqDLwDCwJAIAEiKiACRw0AQSshKgy8AwsCQCAqLQAAIgFBCUYNACABQSBHDdUBCyAALQAsQQhGDdMBICohAQyWAwsCQCABIgEgAkcNAEEsISoMuwMLIAEtAABBCkcN1QEgAUEBaiEBDM8CCyABIiggAkcN1QFBLyEqDLkDCwNAAkAgAS0AACIqQSBGDQACQCAqQXZqDgQA3AHcAQDaAQsgASEBDOIBCyABQQFqIgEgAkcNAAtBMSEqDLgDC0EyISogASIvIAJGDbcDIAIgL2sgACgCACIwaiExIC8hMiAwIQECQANAIDItAAAiLkEgciAuIC5Bv39qQf8BcUEaSRtB/wFxIAFB8LuAgABqLQAARw0BIAFBA0YNmwMgAUEBaiEBIDJBAWoiMiACRw0ACyAAIDE2AgAMuAMLIABBADYCACAyIQEM2QELQTMhKiABIi8gAkYNtgMgAiAvayAAKAIAIjBqITEgLyEyIDAhAQJAA0AgMi0AACIuQSByIC4gLkG/f2pB/wFxQRpJG0H/AXEgAUH0u4CAAGotAABHDQEgAUEIRg3bASABQQFqIQEgMkEBaiIyIAJHDQALIAAgMTYCAAy3AwsgAEEANgIAIDIhAQzYAQtBNCEqIAEiLyACRg21AyACIC9rIAAoAgAiMGohMSAvITIgMCEBAkADQCAyLQAAIi5BIHIgLiAuQb9/akH/AXFBGkkbQf8BcSABQdDCgIAAai0AAEcNASABQQVGDdsBIAFBAWohASAyQQFqIjIgAkcNAAsgACAxNgIADLYDCyAAQQA2AgAgMiEBDNcBCwJAIAEiASACRg0AA0ACQCABLQAAQYC+gIAAai0AACIqQQFGDQAgKkECRg0KIAEhAQzfAQsgAUEBaiIBIAJHDQALQTAhKgy1AwtBMCEqDLQDCwJAIAEiASACRg0AA0ACQCABLQAAIipBIEYNACAqQXZqDgTbAdwB3AHbAdwBCyABQQFqIgEgAkcNAAtBOCEqDLQDC0E4ISoMswMLA0ACQCABLQAAIipBIEYNACAqQQlHDQMLIAFBAWoiASACRw0AC0E8ISoMsgMLA0ACQCABLQAAIipBIEYNAAJAAkAgKkF2ag4E3AEBAdwBAAsgKkEsRg3dAQsgASEBDAQLIAFBAWoiASACRw0AC0E/ISoMsQMLIAEhAQzdAQtBwAAhKiABIjIgAkYNrwMgAiAyayAAKAIAIi9qITAgMiEuIC8hAQJAA0AgLi0AAEEgciABQYDAgIAAai0AAEcNASABQQZGDZUDIAFBAWohASAuQQFqIi4gAkcNAAsgACAwNgIADLADCyAAQQA2AgAgLiEBC0E2ISoMlQMLAkAgASIpIAJHDQBBwQAhKgyuAwsgAEGMgICAADYCCCAAICk2AgQgKSEBIAAtACxBf2oOBM0B1wHZAdsBjAMLIAFBAWohAQzMAQsCQCABIgEgAkYNAANAAkAgAS0AACIqQSByICogKkG/f2pB/wFxQRpJG0H/AXEiKkEJRg0AICpBIEYNAAJAAkACQAJAICpBnX9qDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQTEhKgyYAwsgAUEBaiEBQTIhKgyXAwsgAUEBaiEBQTMhKgyWAwsgASEBDNABCyABQQFqIgEgAkcNAAtBNSEqDKwDC0E1ISoMqwMLAkAgASIBIAJGDQADQAJAIAEtAABBgLyAgABqLQAAQQFGDQAgASEBDNUBCyABQQFqIgEgAkcNAAtBPSEqDKsDC0E9ISoMqgMLIAAgASIBIAIQsICAgAAiKg3YASABIQEMAQsgKkEBaiEBC0E8ISoMjgMLAkAgASIBIAJHDQBBwgAhKgynAwsCQANAAkAgAS0AAEF3ag4YAAKDA4MDiQODA4MDgwODA4MDgwODA4MDgwODA4MDgwODA4MDgwODA4MDgwMAgwMLIAFBAWoiASACRw0AC0HCACEqDKcDCyABQQFqIQEgAC0ALUEBcUUNvQEgASEBC0EsISoMjAMLIAEiASACRw3VAUHEACEqDKQDCwNAAkAgAS0AAEGQwICAAGotAABBAUYNACABIQEMvQILIAFBAWoiASACRw0AC0HFACEqDKMDCyAnLQAAIipBIEYNswEgKkE6Rw2IAyAAKAIEIQEgAEEANgIEIAAgASAnEK+AgIAAIgEN0gEgJ0EBaiEBDLkCC0HHACEqIAEiMiACRg2hAyACIDJrIAAoAgAiL2ohMCAyIScgLyEBAkADQCAnLQAAIi5BIHIgLiAuQb9/akH/AXFBGkkbQf8BcSABQZDCgIAAai0AAEcNiAMgAUEFRg0BIAFBAWohASAnQQFqIicgAkcNAAsgACAwNgIADKIDCyAAQQA2AgAgAEEBOgAsIDIgL2tBBmohAQyCAwtByAAhKiABIjIgAkYNoAMgAiAyayAAKAIAIi9qITAgMiEnIC8hAQJAA0AgJy0AACIuQSByIC4gLkG/f2pB/wFxQRpJG0H/AXEgAUGWwoCAAGotAABHDYcDIAFBCUYNASABQQFqIQEgJ0EBaiInIAJHDQALIAAgMDYCAAyhAwsgAEEANgIAIABBAjoALCAyIC9rQQpqIQEMgQMLAkAgASInIAJHDQBByQAhKgygAwsCQAJAICctAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZJ/ag4HAIcDhwOHA4cDhwMBhwMLICdBAWohAUE+ISoMhwMLICdBAWohAUE/ISoMhgMLQcoAISogASIyIAJGDZ4DIAIgMmsgACgCACIvaiEwIDIhJyAvIQEDQCAnLQAAIi5BIHIgLiAuQb9/akH/AXFBGkkbQf8BcSABQaDCgIAAai0AAEcNhAMgAUEBRg34AiABQQFqIQEgJ0EBaiInIAJHDQALIAAgMDYCAAyeAwtBywAhKiABIjIgAkYNnQMgAiAyayAAKAIAIi9qITAgMiEnIC8hAQJAA0AgJy0AACIuQSByIC4gLkG/f2pB/wFxQRpJG0H/AXEgAUGiwoCAAGotAABHDYQDIAFBDkYNASABQQFqIQEgJ0EBaiInIAJHDQALIAAgMDYCAAyeAwsgAEEANgIAIABBAToALCAyIC9rQQ9qIQEM/gILQcwAISogASIyIAJGDZwDIAIgMmsgACgCACIvaiEwIDIhJyAvIQECQANAICctAAAiLkEgciAuIC5Bv39qQf8BcUEaSRtB/wFxIAFBwMKAgABqLQAARw2DAyABQQ9GDQEgAUEBaiEBICdBAWoiJyACRw0ACyAAIDA2AgAMnQMLIABBADYCACAAQQM6ACwgMiAva0EQaiEBDP0CC0HNACEqIAEiMiACRg2bAyACIDJrIAAoAgAiL2ohMCAyIScgLyEBAkADQCAnLQAAIi5BIHIgLiAuQb9/akH/AXFBGkkbQf8BcSABQdDCgIAAai0AAEcNggMgAUEFRg0BIAFBAWohASAnQQFqIicgAkcNAAsgACAwNgIADJwDCyAAQQA2AgAgAEEEOgAsIDIgL2tBBmohAQz8AgsCQCABIicgAkcNAEHOACEqDJsDCwJAAkACQAJAICctAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZ1/ag4TAIQDhAOEA4QDhAOEA4QDhAOEA4QDhAOEAwGEA4QDhAMCA4QDCyAnQQFqIQFBwQAhKgyEAwsgJ0EBaiEBQcIAISoMgwMLICdBAWohAUHDACEqDIIDCyAnQQFqIQFBxAAhKgyBAwsCQCABIgEgAkYNACAAQY2AgIAANgIIIAAgATYCBCABIQFBxQAhKgyBAwtBzwAhKgyZAwsgKiEBAkACQCAqLQAAQXZqDgQBrgKuAgCuAgsgKkEBaiEBC0EnISoM/wILAkAgASIBIAJHDQBB0QAhKgyYAwsCQCABLQAAQSBGDQAgASEBDI0BCyABQQFqIQEgAC0ALUEBcUUNyQEgASEBDIwBCyABIgEgAkcNyQFB0gAhKgyWAwtB0wAhKiABIjIgAkYNlQMgAiAyayAAKAIAIi9qITAgMiEuIC8hAQJAA0AgLi0AACABQdbCgIAAai0AAEcNzwEgAUEBRg0BIAFBAWohASAuQQFqIi4gAkcNAAsgACAwNgIADJYDCyAAQQA2AgAgMiAva0ECaiEBDMkBCwJAIAEiASACRw0AQdUAISoMlQMLIAEtAABBCkcNzgEgAUEBaiEBDMkBCwJAIAEiASACRw0AQdYAISoMlAMLAkACQCABLQAAQXZqDgQAzwHPAQHPAQsgAUEBaiEBDMkBCyABQQFqIQFBygAhKgz6AgsgACABIgEgAhCugICAACIqDc0BIAEhAUHNACEqDPkCCyAALQApQSJGDYwDDKwCCwJAIAEiASACRw0AQdsAISoMkQMLQQAhLkEBITJBASEvQQAhKgJAAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgrWAdUBAAECAwQFBgjXAQtBAiEqDAYLQQMhKgwFC0EEISoMBAtBBSEqDAMLQQYhKgwCC0EHISoMAQtBCCEqC0EAITJBACEvQQAhLgzOAQtBCSEqQQEhLkEAITJBACEvDM0BCwJAIAEiASACRw0AQd0AISoMkAMLIAEtAABBLkcNzgEgAUEBaiEBDKwCCwJAIAEiASACRw0AQd8AISoMjwMLQQAhKgJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4K1wHWAQABAgMEBQYH2AELQQIhKgzWAQtBAyEqDNUBC0EEISoM1AELQQUhKgzTAQtBBiEqDNIBC0EHISoM0QELQQghKgzQAQtBCSEqDM8BCwJAIAEiASACRg0AIABBjoCAgAA2AgggACABNgIEIAEhAUHQACEqDPUCC0HgACEqDI0DC0HhACEqIAEiMiACRg2MAyACIDJrIAAoAgAiL2ohMCAyIQEgLyEuA0AgAS0AACAuQeLCgIAAai0AAEcN0QEgLkEDRg3QASAuQQFqIS4gAUEBaiIBIAJHDQALIAAgMDYCAAyMAwtB4gAhKiABIjIgAkYNiwMgAiAyayAAKAIAIi9qITAgMiEBIC8hLgNAIAEtAAAgLkHmwoCAAGotAABHDdABIC5BAkYN0gEgLkEBaiEuIAFBAWoiASACRw0ACyAAIDA2AgAMiwMLQeMAISogASIyIAJGDYoDIAIgMmsgACgCACIvaiEwIDIhASAvIS4DQCABLQAAIC5B6cKAgABqLQAARw3PASAuQQNGDdIBIC5BAWohLiABQQFqIgEgAkcNAAsgACAwNgIADIoDCwJAIAEiASACRw0AQeUAISoMigMLIAAgAUEBaiIBIAIQqICAgAAiKg3RASABIQFB1gAhKgzwAgsCQCABIgEgAkYNAANAAkAgAS0AACIqQSBGDQACQAJAAkAgKkG4f2oOCwAB0wHTAdMB0wHTAdMB0wHTAQLTAQsgAUEBaiEBQdIAISoM9AILIAFBAWohAUHTACEqDPMCCyABQQFqIQFB1AAhKgzyAgsgAUEBaiIBIAJHDQALQeQAISoMiQMLQeQAISoMiAMLA0ACQCABLQAAQfDCgIAAai0AACIqQQFGDQAgKkF+ag4D0wHUAdUB1gELIAFBAWoiASACRw0AC0HmACEqDIcDCwJAIAEiASACRg0AIAFBAWohAQwDC0HnACEqDIYDCwNAAkAgAS0AAEHwxICAAGotAAAiKkEBRg0AAkAgKkF+ag4E1gHXAdgBANkBCyABIQFB1wAhKgzuAgsgAUEBaiIBIAJHDQALQegAISoMhQMLAkAgASIBIAJHDQBB6QAhKgyFAwsCQCABLQAAIipBdmoOGrwB2QHZAb4B2QHZAdkB2QHZAdkB2QHZAdkB2QHZAdkB2QHZAdkB2QHZAdkBzgHZAdkBANcBCyABQQFqIQELQQYhKgzqAgsDQAJAIAEtAABB8MaAgABqLQAAQQFGDQAgASEBDKUCCyABQQFqIgEgAkcNAAtB6gAhKgyCAwsCQCABIgEgAkYNACABQQFqIQEMAwtB6wAhKgyBAwsCQCABIgEgAkcNAEHsACEqDIEDCyABQQFqIQEMAQsCQCABIgEgAkcNAEHtACEqDIADCyABQQFqIQELQQQhKgzlAgsCQCABIi4gAkcNAEHuACEqDP4CCyAuIQECQAJAAkAgLi0AAEHwyICAAGotAABBf2oOB9gB2QHaAQCjAgEC2wELIC5BAWohAQwKCyAuQQFqIQEM0QELQQAhKiAAQQA2AhwgAEGbkoCAADYCECAAQQc2AgwgACAuQQFqNgIUDP0CCwJAA0ACQCABLQAAQfDIgIAAai0AACIqQQRGDQACQAJAICpBf2oOB9YB1wHYAd0BAAQB3QELIAEhAUHaACEqDOcCCyABQQFqIQFB3AAhKgzmAgsgAUEBaiIBIAJHDQALQe8AISoM/QILIAFBAWohAQzPAQsCQCABIi4gAkcNAEHwACEqDPwCCyAuLQAAQS9HDdgBIC5BAWohAQwGCwJAIAEiLiACRw0AQfEAISoM+wILAkAgLi0AACIBQS9HDQAgLkEBaiEBQd0AISoM4gILIAFBdmoiAUEWSw3XAUEBIAF0QYmAgAJxRQ3XAQzSAgsCQCABIgEgAkYNACABQQFqIQFB3gAhKgzhAgtB8gAhKgz5AgsCQCABIi4gAkcNAEH0ACEqDPkCCyAuIQECQCAuLQAAQfDMgIAAai0AAEF/ag4D0QKbAgDYAQtB4QAhKgzfAgsCQCABIi4gAkYNAANAAkAgLi0AAEHwyoCAAGotAAAiAUEDRg0AAkAgAUF/ag4C0wIA2QELIC4hAUHfACEqDOECCyAuQQFqIi4gAkcNAAtB8wAhKgz4AgtB8wAhKgz3AgsCQCABIgEgAkYNACAAQY+AgIAANgIIIAAgATYCBCABIQFB4AAhKgzeAgtB9QAhKgz2AgsCQCABIgEgAkcNAEH2ACEqDPYCCyAAQY+AgIAANgIIIAAgATYCBCABIQELQQMhKgzbAgsDQCABLQAAQSBHDcsCIAFBAWoiASACRw0AC0H3ACEqDPMCCwJAIAEiASACRw0AQfgAISoM8wILIAEtAABBIEcN0gEgAUEBaiEBDPUBCyAAIAEiASACEKyAgIAAIioN0gEgASEBDJUCCwJAIAEiBCACRw0AQfoAISoM8QILIAQtAABBzABHDdUBIARBAWohAUETISoM0wELAkAgASIqIAJHDQBB+wAhKgzwAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQNAIAQtAAAgAUHwzoCAAGotAABHDdQBIAFBBUYN0gEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBB+wAhKgzvAgsCQCABIgQgAkcNAEH8ACEqDO8CCwJAAkAgBC0AAEG9f2oODADVAdUB1QHVAdUB1QHVAdUB1QHVAQHVAQsgBEEBaiEBQeYAISoM1gILIARBAWohAUHnACEqDNUCCwJAIAEiKiACRw0AQf0AISoM7gILIAIgKmsgACgCACIuaiEyICohBCAuIQECQANAIAQtAAAgAUHtz4CAAGotAABHDdMBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgMjYCAEH9ACEqDO4CCyAAQQA2AgAgKiAua0EDaiEBQRAhKgzQAQsCQCABIiogAkcNAEH+ACEqDO0CCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFB9s6AgABqLQAARw3SASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBB/gAhKgztAgsgAEEANgIAICogLmtBBmohAUEWISoMzwELAkAgASIqIAJHDQBB/wAhKgzsAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQJAA0AgBC0AACABQfzOgIAAai0AAEcN0QEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAyNgIAQf8AISoM7AILIABBADYCACAqIC5rQQRqIQFBBSEqDM4BCwJAIAEiBCACRw0AQYABISoM6wILIAQtAABB2QBHDc8BIARBAWohAUEIISoMzQELAkAgASIEIAJHDQBBgQEhKgzqAgsCQAJAIAQtAABBsn9qDgMA0AEB0AELIARBAWohAUHrACEqDNECCyAEQQFqIQFB7AAhKgzQAgsCQCABIgQgAkcNAEGCASEqDOkCCwJAAkAgBC0AAEG4f2oOCADPAc8BzwHPAc8BzwEBzwELIARBAWohAUHqACEqDNACCyAEQQFqIQFB7QAhKgzPAgsCQCABIi4gAkcNAEGDASEqDOgCCyACIC5rIAAoAgAiMmohKiAuIQQgMiEBAkADQCAELQAAIAFBgM+AgABqLQAARw3NASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICo2AgBBgwEhKgzoAgtBACEqIABBADYCACAuIDJrQQNqIQEMygELAkAgASIqIAJHDQBBhAEhKgznAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQJAA0AgBC0AACABQYPPgIAAai0AAEcNzAEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAyNgIAQYQBISoM5wILIABBADYCACAqIC5rQQVqIQFBIyEqDMkBCwJAIAEiBCACRw0AQYUBISoM5gILAkACQCAELQAAQbR/ag4IAMwBzAHMAcwBzAHMAQHMAQsgBEEBaiEBQe8AISoMzQILIARBAWohAUHwACEqDMwCCwJAIAEiBCACRw0AQYYBISoM5QILIAQtAABBxQBHDckBIARBAWohAQyKAgsCQCABIiogAkcNAEGHASEqDOQCCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFBiM+AgABqLQAARw3JASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBhwEhKgzkAgsgAEEANgIAICogLmtBBGohAUEtISoMxgELAkAgASIqIAJHDQBBiAEhKgzjAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQJAA0AgBC0AACABQdDPgIAAai0AAEcNyAEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAyNgIAQYgBISoM4wILIABBADYCACAqIC5rQQlqIQFBKSEqDMUBCwJAIAEiASACRw0AQYkBISoM4gILQQEhKiABLQAAQd8ARw3EASABQQFqIQEMiAILAkAgASIqIAJHDQBBigEhKgzhAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQNAIAQtAAAgAUGMz4CAAGotAABHDcUBIAFBAUYNtwIgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBigEhKgzgAgsCQCABIiogAkcNAEGLASEqDOACCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFBjs+AgABqLQAARw3FASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBiwEhKgzgAgsgAEEANgIAICogLmtBA2ohAUECISoMwgELAkAgASIqIAJHDQBBjAEhKgzfAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQJAA0AgBC0AACABQfDPgIAAai0AAEcNxAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAyNgIAQYwBISoM3wILIABBADYCACAqIC5rQQJqIQFBHyEqDMEBCwJAIAEiKiACRw0AQY0BISoM3gILIAIgKmsgACgCACIuaiEyICohBCAuIQECQANAIAQtAAAgAUHyz4CAAGotAABHDcMBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgMjYCAEGNASEqDN4CCyAAQQA2AgAgKiAua0ECaiEBQQkhKgzAAQsCQCABIgQgAkcNAEGOASEqDN0CCwJAAkAgBC0AAEG3f2oOBwDDAcMBwwHDAcMBAcMBCyAEQQFqIQFB+AAhKgzEAgsgBEEBaiEBQfkAISoMwwILAkAgASIqIAJHDQBBjwEhKgzcAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQJAA0AgBC0AACABQZHPgIAAai0AAEcNwQEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAyNgIAQY8BISoM3AILIABBADYCACAqIC5rQQZqIQFBGCEqDL4BCwJAIAEiKiACRw0AQZABISoM2wILIAIgKmsgACgCACIuaiEyICohBCAuIQECQANAIAQtAAAgAUGXz4CAAGotAABHDcABIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgMjYCAEGQASEqDNsCCyAAQQA2AgAgKiAua0EDaiEBQRchKgy9AQsCQCABIiogAkcNAEGRASEqDNoCCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFBms+AgABqLQAARw2/ASABQQZGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBkQEhKgzaAgsgAEEANgIAICogLmtBB2ohAUEVISoMvAELAkAgASIqIAJHDQBBkgEhKgzZAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQJAA0AgBC0AACABQaHPgIAAai0AAEcNvgEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAyNgIAQZIBISoM2QILIABBADYCACAqIC5rQQZqIQFBHiEqDLsBCwJAIAEiBCACRw0AQZMBISoM2AILIAQtAABBzABHDbwBIARBAWohAUEKISoMugELAkAgBCACRw0AQZQBISoM1wILAkACQCAELQAAQb9/ag4PAL0BvQG9Ab0BvQG9Ab0BvQG9Ab0BvQG9Ab0BAb0BCyAEQQFqIQFB/gAhKgy+AgsgBEEBaiEBQf8AISoMvQILAkAgBCACRw0AQZUBISoM1gILAkACQCAELQAAQb9/ag4DALwBAbwBCyAEQQFqIQFB/QAhKgy9AgsgBEEBaiEEQYABISoMvAILAkAgBSACRw0AQZYBISoM1QILIAIgBWsgACgCACIqaiEuIAUhBCAqIQECQANAIAQtAAAgAUGnz4CAAGotAABHDboBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEGWASEqDNUCCyAAQQA2AgAgBSAqa0ECaiEBQQshKgy3AQsCQCAEIAJHDQBBlwEhKgzUAgsCQAJAAkACQCAELQAAQVNqDiMAvAG8AbwBvAG8AbwBvAG8AbwBvAG8AbwBvAG8AbwBvAG8AbwBvAG8AbwBvAG8AQG8AbwBvAG8AbwBArwBvAG8AQO8AQsgBEEBaiEBQfsAISoMvQILIARBAWohAUH8ACEqDLwCCyAEQQFqIQRBgQEhKgy7AgsgBEEBaiEFQYIBISoMugILAkAgBiACRw0AQZgBISoM0wILIAIgBmsgACgCACIqaiEuIAYhBCAqIQECQANAIAQtAAAgAUGpz4CAAGotAABHDbgBIAFBBEYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEGYASEqDNMCCyAAQQA2AgAgBiAqa0EFaiEBQRkhKgy1AQsCQCAHIAJHDQBBmQEhKgzSAgsgAiAHayAAKAIAIi5qISogByEEIC4hAQJAA0AgBC0AACABQa7PgIAAai0AAEcNtwEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAqNgIAQZkBISoM0gILIABBADYCAEEGISogByAua0EGaiEBDLQBCwJAIAggAkcNAEGaASEqDNECCyACIAhrIAAoAgAiKmohLiAIIQQgKiEBAkADQCAELQAAIAFBtM+AgABqLQAARw22ASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBmgEhKgzRAgsgAEEANgIAIAggKmtBAmohAUEcISoMswELAkAgCSACRw0AQZsBISoM0AILIAIgCWsgACgCACIqaiEuIAkhBCAqIQECQANAIAQtAAAgAUG2z4CAAGotAABHDbUBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEGbASEqDNACCyAAQQA2AgAgCSAqa0ECaiEBQSchKgyyAQsCQCAEIAJHDQBBnAEhKgzPAgsCQAJAIAQtAABBrH9qDgIAAbUBCyAEQQFqIQhBhgEhKgy2AgsgBEEBaiEJQYcBISoMtQILAkAgCiACRw0AQZ0BISoMzgILIAIgCmsgACgCACIqaiEuIAohBCAqIQECQANAIAQtAAAgAUG4z4CAAGotAABHDbMBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEGdASEqDM4CCyAAQQA2AgAgCiAqa0ECaiEBQSYhKgywAQsCQCALIAJHDQBBngEhKgzNAgsgAiALayAAKAIAIipqIS4gCyEEICohAQJAA0AgBC0AACABQbrPgIAAai0AAEcNsgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQZ4BISoMzQILIABBADYCACALICprQQJqIQFBAyEqDK8BCwJAIAwgAkcNAEGfASEqDMwCCyACIAxrIAAoAgAiKmohLiAMIQQgKiEBAkADQCAELQAAIAFB7c+AgABqLQAARw2xASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBnwEhKgzMAgsgAEEANgIAIAwgKmtBA2ohAUEMISoMrgELAkAgDSACRw0AQaABISoMywILIAIgDWsgACgCACIqaiEuIA0hBCAqIQECQANAIAQtAAAgAUG8z4CAAGotAABHDbABIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEGgASEqDMsCCyAAQQA2AgAgDSAqa0EEaiEBQQ0hKgytAQsCQCAEIAJHDQBBoQEhKgzKAgsCQAJAIAQtAABBun9qDgsAsAGwAbABsAGwAbABsAGwAbABAbABCyAEQQFqIQxBiwEhKgyxAgsgBEEBaiENQYwBISoMsAILAkAgBCACRw0AQaIBISoMyQILIAQtAABB0ABHDa0BIARBAWohBAzwAQsCQCAEIAJHDQBBowEhKgzIAgsCQAJAIAQtAABBt39qDgcBrgGuAa4BrgGuAQCuAQsgBEEBaiEEQY4BISoMrwILIARBAWohAUEiISoMqgELAkAgDiACRw0AQaQBISoMxwILIAIgDmsgACgCACIqaiEuIA4hBCAqIQECQANAIAQtAAAgAUHAz4CAAGotAABHDawBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEGkASEqDMcCCyAAQQA2AgAgDiAqa0ECaiEBQR0hKgypAQsCQCAEIAJHDQBBpQEhKgzGAgsCQAJAIAQtAABBrn9qDgMArAEBrAELIARBAWohDkGQASEqDK0CCyAEQQFqIQFBBCEqDKgBCwJAIAQgAkcNAEGmASEqDMUCCwJAAkACQAJAAkAgBC0AAEG/f2oOFQCuAa4BrgGuAa4BrgGuAa4BrgGuAQGuAa4BAq4BrgEDrgGuAQSuAQsgBEEBaiEEQYgBISoMrwILIARBAWohCkGJASEqDK4CCyAEQQFqIQtBigEhKgytAgsgBEEBaiEEQY8BISoMrAILIARBAWohBEGRASEqDKsCCwJAIA8gAkcNAEGnASEqDMQCCyACIA9rIAAoAgAiKmohLiAPIQQgKiEBAkADQCAELQAAIAFB7c+AgABqLQAARw2pASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBpwEhKgzEAgsgAEEANgIAIA8gKmtBA2ohAUERISoMpgELAkAgECACRw0AQagBISoMwwILIAIgEGsgACgCACIqaiEuIBAhBCAqIQECQANAIAQtAAAgAUHCz4CAAGotAABHDagBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEGoASEqDMMCCyAAQQA2AgAgECAqa0EDaiEBQSwhKgylAQsCQCARIAJHDQBBqQEhKgzCAgsgAiARayAAKAIAIipqIS4gESEEICohAQJAA0AgBC0AACABQcXPgIAAai0AAEcNpwEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQakBISoMwgILIABBADYCACARICprQQVqIQFBKyEqDKQBCwJAIBIgAkcNAEGqASEqDMECCyACIBJrIAAoAgAiKmohLiASIQQgKiEBAkADQCAELQAAIAFBys+AgABqLQAARw2mASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBqgEhKgzBAgsgAEEANgIAIBIgKmtBA2ohAUEUISoMowELAkAgBCACRw0AQasBISoMwAILAkACQAJAAkAgBC0AAEG+f2oODwABAqgBqAGoAagBqAGoAagBqAGoAagBqAEDqAELIARBAWohD0GTASEqDKkCCyAEQQFqIRBBlAEhKgyoAgsgBEEBaiERQZUBISoMpwILIARBAWohEkGWASEqDKYCCwJAIAQgAkcNAEGsASEqDL8CCyAELQAAQcUARw2jASAEQQFqIQQM5wELAkAgEyACRw0AQa0BISoMvgILIAIgE2sgACgCACIqaiEuIBMhBCAqIQECQANAIAQtAAAgAUHNz4CAAGotAABHDaMBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEGtASEqDL4CCyAAQQA2AgAgEyAqa0EDaiEBQQ4hKgygAQsCQCAEIAJHDQBBrgEhKgy9AgsgBC0AAEHQAEcNoQEgBEEBaiEBQSUhKgyfAQsCQCAUIAJHDQBBrwEhKgy8AgsgAiAUayAAKAIAIipqIS4gFCEEICohAQJAA0AgBC0AACABQdDPgIAAai0AAEcNoQEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQa8BISoMvAILIABBADYCACAUICprQQlqIQFBKiEqDJ4BCwJAIAQgAkcNAEGwASEqDLsCCwJAAkAgBC0AAEGrf2oOCwChAaEBoQGhAaEBoQGhAaEBoQEBoQELIARBAWohBEGaASEqDKICCyAEQQFqIRRBmwEhKgyhAgsCQCAEIAJHDQBBsQEhKgy6AgsCQAJAIAQtAABBv39qDhQAoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABAaABCyAEQQFqIRNBmQEhKgyhAgsgBEEBaiEEQZwBISoMoAILAkAgFSACRw0AQbIBISoMuQILIAIgFWsgACgCACIqaiEuIBUhBCAqIQECQANAIAQtAAAgAUHZz4CAAGotAABHDZ4BIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEGyASEqDLkCCyAAQQA2AgAgFSAqa0EEaiEBQSEhKgybAQsCQCAWIAJHDQBBswEhKgy4AgsgAiAWayAAKAIAIipqIS4gFiEEICohAQJAA0AgBC0AACABQd3PgIAAai0AAEcNnQEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQbMBISoMuAILIABBADYCACAWICprQQdqIQFBGiEqDJoBCwJAIAQgAkcNAEG0ASEqDLcCCwJAAkACQCAELQAAQbt/ag4RAJ4BngGeAZ4BngGeAZ4BngGeAQGeAZ4BngGeAZ4BAp4BCyAEQQFqIQRBnQEhKgyfAgsgBEEBaiEVQZ4BISoMngILIARBAWohFkGfASEqDJ0CCwJAIBcgAkcNAEG1ASEqDLYCCyACIBdrIAAoAgAiKmohLiAXIQQgKiEBAkADQCAELQAAIAFB5M+AgABqLQAARw2bASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBtQEhKgy2AgsgAEEANgIAIBcgKmtBBmohAUEoISoMmAELAkAgGCACRw0AQbYBISoMtQILIAIgGGsgACgCACIqaiEuIBghBCAqIQECQANAIAQtAAAgAUHqz4CAAGotAABHDZoBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEG2ASEqDLUCCyAAQQA2AgAgGCAqa0EDaiEBQQchKgyXAQsCQCAEIAJHDQBBtwEhKgy0AgsCQAJAIAQtAABBu39qDg4AmgGaAZoBmgGaAZoBmgGaAZoBmgGaAZoBAZoBCyAEQQFqIRdBoQEhKgybAgsgBEEBaiEYQaIBISoMmgILAkAgGSACRw0AQbgBISoMswILIAIgGWsgACgCACIqaiEuIBkhBCAqIQECQANAIAQtAAAgAUHtz4CAAGotAABHDZgBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEG4ASEqDLMCCyAAQQA2AgAgGSAqa0EDaiEBQRIhKgyVAQsCQCAaIAJHDQBBuQEhKgyyAgsgAiAaayAAKAIAIipqIS4gGiEEICohAQJAA0AgBC0AACABQfDPgIAAai0AAEcNlwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQbkBISoMsgILIABBADYCACAaICprQQJqIQFBICEqDJQBCwJAIBsgAkcNAEG6ASEqDLECCyACIBtrIAAoAgAiKmohLiAbIQQgKiEBAkADQCAELQAAIAFB8s+AgABqLQAARw2WASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBugEhKgyxAgsgAEEANgIAIBsgKmtBAmohAUEPISoMkwELAkAgBCACRw0AQbsBISoMsAILAkACQCAELQAAQbd/ag4HAJYBlgGWAZYBlgEBlgELIARBAWohGkGlASEqDJcCCyAEQQFqIRtBpgEhKgyWAgsCQCAcIAJHDQBBvAEhKgyvAgsgAiAcayAAKAIAIipqIS4gHCEEICohAQJAA0AgBC0AACABQfTPgIAAai0AAEcNlAEgAUEHRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQbwBISoMrwILIABBADYCACAcICprQQhqIQFBGyEqDJEBCwJAIAQgAkcNAEG9ASEqDK4CCwJAAkACQCAELQAAQb5/ag4SAJUBlQGVAZUBlQGVAZUBlQGVAQGVAZUBlQGVAZUBlQEClQELIARBAWohGUGkASEqDJYCCyAEQQFqIQRBpwEhKgyVAgsgBEEBaiEcQagBISoMlAILAkAgBCACRw0AQb4BISoMrQILIAQtAABBzgBHDZEBIARBAWohBAzWAQsCQCAEIAJHDQBBvwEhKgysAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAELQAAQb9/ag4VAAECA6ABBAUGoAGgAaABBwgJCgugAQwNDg+gAQsgBEEBaiEBQegAISoMoQILIARBAWohAUHpACEqDKACCyAEQQFqIQFB7gAhKgyfAgsgBEEBaiEBQfIAISoMngILIARBAWohAUHzACEqDJ0CCyAEQQFqIQFB9gAhKgycAgsgBEEBaiEBQfcAISoMmwILIARBAWohAUH6ACEqDJoCCyAEQQFqIQRBgwEhKgyZAgsgBEEBaiEGQYQBISoMmAILIARBAWohB0GFASEqDJcCCyAEQQFqIQRBkgEhKgyWAgsgBEEBaiEEQZgBISoMlQILIARBAWohBEGgASEqDJQCCyAEQQFqIQRBowEhKgyTAgsgBEEBaiEEQaoBISoMkgILAkAgBCACRg0AIABBkICAgAA2AgggACAENgIEQasBISoMkgILQcABISoMqgILIAAgHSACEKqAgIAAIgENjwEgHSEBDF4LAkAgHiACRg0AIB5BAWohHQyRAQtBwgEhKgyoAgsDQAJAICotAABBdmoOBJABAACTAQALICpBAWoiKiACRw0AC0HDASEqDKcCCwJAIB8gAkYNACAAQZGAgIAANgIIIAAgHzYCBCAfIQFBASEqDI4CC0HEASEqDKYCCwJAIB8gAkcNAEHFASEqDKYCCwJAAkAgHy0AAEF2ag4EAdUB1QEA1QELIB9BAWohHgyRAQsgH0EBaiEdDI0BCwJAIB8gAkcNAEHGASEqDKUCCwJAAkAgHy0AAEF2ag4XAZMBkwEBkwGTAZMBkwGTAZMBkwGTAZMBkwGTAZMBkwGTAZMBkwGTAZMBAJMBCyAfQQFqIR8LQbABISoMiwILAkAgICACRw0AQcgBISoMpAILICAtAABBIEcNkQEgAEEAOwEyICBBAWohAUGzASEqDIoCCyABITICQANAIDIiHyACRg0BIB8tAABBUGpB/wFxIipBCk8N0wECQCAALwEyIi5BmTNLDQAgACAuQQpsIi47ATIgKkH//wNzIC5B/v8DcUkNACAfQQFqITIgACAuICpqIio7ATIgKkH//wNxQegHSQ0BCwtBACEqIABBADYCHCAAQcGJgIAANgIQIABBDTYCDCAAIB9BAWo2AhQMowILQccBISoMogILIAAgICACEK6AgIAAIipFDdEBICpBFUcNkAEgAEHIATYCHCAAICA2AhQgAEHJl4CAADYCECAAQRU2AgxBACEqDKECCwJAICEgAkcNAEHMASEqDKECC0EAIS5BASEyQQEhL0EAISoCQAJAAkACQAJAAkACQAJAAkAgIS0AAEFQag4KmgGZAQABAgMEBQYImwELQQIhKgwGC0EDISoMBQtBBCEqDAQLQQUhKgwDC0EGISoMAgtBByEqDAELQQghKgtBACEyQQAhL0EAIS4MkgELQQkhKkEBIS5BACEyQQAhLwyRAQsCQCAiIAJHDQBBzgEhKgygAgsgIi0AAEEuRw2SASAiQQFqISEM0QELAkAgIyACRw0AQdABISoMnwILQQAhKgJAAkACQAJAAkACQAJAAkAgIy0AAEFQag4KmwGaAQABAgMEBQYHnAELQQIhKgyaAQtBAyEqDJkBC0EEISoMmAELQQUhKgyXAQtBBiEqDJYBC0EHISoMlQELQQghKgyUAQtBCSEqDJMBCwJAICMgAkYNACAAQY6AgIAANgIIIAAgIzYCBEG3ASEqDIUCC0HRASEqDJ0CCwJAIAQgAkcNAEHSASEqDJ0CCyACIARrIAAoAgAiLmohMiAEISMgLiEqA0AgIy0AACAqQfzPgIAAai0AAEcNlAEgKkEERg3xASAqQQFqISogI0EBaiIjIAJHDQALIAAgMjYCAEHSASEqDJwCCyAAICQgAhCsgICAACIBDZMBICQhAQy/AQsCQCAlIAJHDQBB1AEhKgybAgsgAiAlayAAKAIAIiRqIS4gJSEEICQhKgNAIAQtAAAgKkGB0ICAAGotAABHDZUBICpBAUYNlAEgKkEBaiEqIARBAWoiBCACRw0ACyAAIC42AgBB1AEhKgyaAgsCQCAmIAJHDQBB1gEhKgyaAgsgAiAmayAAKAIAIiNqIS4gJiEEICMhKgNAIAQtAAAgKkGD0ICAAGotAABHDZQBICpBAkYNlgEgKkEBaiEqIARBAWoiBCACRw0ACyAAIC42AgBB1gEhKgyZAgsCQCAEIAJHDQBB1wEhKgyZAgsCQAJAIAQtAABBu39qDhAAlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAQGVAQsgBEEBaiElQbsBISoMgAILIARBAWohJkG8ASEqDP8BCwJAIAQgAkcNAEHYASEqDJgCCyAELQAAQcgARw2SASAEQQFqIQQMzAELAkAgBCACRg0AIABBkICAgAA2AgggACAENgIEQb4BISoM/gELQdkBISoMlgILAkAgBCACRw0AQdoBISoMlgILIAQtAABByABGDcsBIABBAToAKAzAAQsgAEECOgAvIAAgBCACEKaAgIAAIioNkwFBwgEhKgz7AQsgAC0AKEF/ag4CvgHAAb8BCwNAAkAgBC0AAEF2ag4EAJQBlAEAlAELIARBAWoiBCACRw0AC0HdASEqDJICCyAAQQA6AC8gAC0ALUEEcUUNiwILIABBADoALyAAQQE6ADQgASEBDJIBCyAqQRVGDeIBIABBADYCHCAAIAE2AhQgAEGnjoCAADYCECAAQRI2AgxBACEqDI8CCwJAIAAgKiACELSAgIAAIgENACAqIQEMiAILAkAgAUEVRw0AIABBAzYCHCAAICo2AhQgAEGwmICAADYCECAAQRU2AgxBACEqDI8CCyAAQQA2AhwgACAqNgIUIABBp46AgAA2AhAgAEESNgIMQQAhKgyOAgsgKkEVRg3eASAAQQA2AhwgACABNgIUIABB2o2AgAA2AhAgAEEUNgIMQQAhKgyNAgsgACgCBCEyIABBADYCBCAqICunaiIvIQEgACAyICogLyAuGyIqELWAgIAAIi5FDZMBIABBBzYCHCAAICo2AhQgACAuNgIMQQAhKgyMAgsgACAALwEwQYABcjsBMCABIQELQSohKgzxAQsgKkEVRg3ZASAAQQA2AhwgACABNgIUIABBg4yAgAA2AhAgAEETNgIMQQAhKgyJAgsgKkEVRg3XASAAQQA2AhwgACABNgIUIABBmo+AgAA2AhAgAEEiNgIMQQAhKgyIAgsgACgCBCEqIABBADYCBAJAIAAgKiABELeAgIAAIioNACABQQFqIQEMkwELIABBDDYCHCAAICo2AgwgACABQQFqNgIUQQAhKgyHAgsgKkEVRg3UASAAQQA2AhwgACABNgIUIABBmo+AgAA2AhAgAEEiNgIMQQAhKgyGAgsgACgCBCEqIABBADYCBAJAIAAgKiABELeAgIAAIioNACABQQFqIQEMkgELIABBDTYCHCAAICo2AgwgACABQQFqNgIUQQAhKgyFAgsgKkEVRg3RASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhKgyEAgsgACgCBCEqIABBADYCBAJAIAAgKiABELmAgIAAIioNACABQQFqIQEMkQELIABBDjYCHCAAICo2AgwgACABQQFqNgIUQQAhKgyDAgsgAEEANgIcIAAgATYCFCAAQcCVgIAANgIQIABBAjYCDEEAISoMggILICpBFUYNzQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAISoMgQILIABBEDYCHCAAIAE2AhQgACAqNgIMQQAhKgyAAgsgACgCBCEEIABBADYCBAJAIAAgBCABELmAgIAAIgQNACABQQFqIQEM+AELIABBETYCHCAAIAQ2AgwgACABQQFqNgIUQQAhKgz/AQsgKkEVRg3JASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhKgz+AQsgACgCBCEqIABBADYCBAJAIAAgKiABELmAgIAAIioNACABQQFqIQEMjgELIABBEzYCHCAAICo2AgwgACABQQFqNgIUQQAhKgz9AQsgACgCBCEEIABBADYCBAJAIAAgBCABELmAgIAAIgQNACABQQFqIQEM9AELIABBFDYCHCAAIAQ2AgwgACABQQFqNgIUQQAhKgz8AQsgKkEVRg3FASAAQQA2AhwgACABNgIUIABBmo+AgAA2AhAgAEEiNgIMQQAhKgz7AQsgACgCBCEqIABBADYCBAJAIAAgKiABELeAgIAAIioNACABQQFqIQEMjAELIABBFjYCHCAAICo2AgwgACABQQFqNgIUQQAhKgz6AQsgACgCBCEEIABBADYCBAJAIAAgBCABELeAgIAAIgQNACABQQFqIQEM8AELIABBFzYCHCAAIAQ2AgwgACABQQFqNgIUQQAhKgz5AQsgAEEANgIcIAAgATYCFCAAQc2TgIAANgIQIABBDDYCDEEAISoM+AELQgEhKwsgKkEBaiEBAkAgACkDICIsQv//////////D1YNACAAICxCBIYgK4Q3AyAgASEBDIoBCyAAQQA2AhwgACABNgIUIABBrYmAgAA2AhAgAEEMNgIMQQAhKgz2AQsgAEEANgIcIAAgKjYCFCAAQc2TgIAANgIQIABBDDYCDEEAISoM9QELIAAoAgQhMiAAQQA2AgQgKiArp2oiLyEBIAAgMiAqIC8gLhsiKhC1gICAACIuRQ15IABBBTYCHCAAICo2AhQgACAuNgIMQQAhKgz0AQsgAEEANgIcIAAgKjYCFCAAQaqcgIAANgIQIABBDzYCDEEAISoM8wELIAAgKiACELSAgIAAIgENASAqIQELQQ4hKgzYAQsCQCABQRVHDQAgAEECNgIcIAAgKjYCFCAAQbCYgIAANgIQIABBFTYCDEEAISoM8QELIABBADYCHCAAICo2AhQgAEGnjoCAADYCECAAQRI2AgxBACEqDPABCyABQQFqISoCQCAALwEwIgFBgAFxRQ0AAkAgACAqIAIQu4CAgAAiAQ0AICohAQx2CyABQRVHDcIBIABBBTYCHCAAICo2AhQgAEH5l4CAADYCECAAQRU2AgxBACEqDPABCwJAIAFBoARxQaAERw0AIAAtAC1BAnENACAAQQA2AhwgACAqNgIUIABBlpOAgAA2AhAgAEEENgIMQQAhKgzwAQsgACAqIAIQvYCAgAAaICohAQJAAkACQAJAAkAgACAqIAIQs4CAgAAOFgIBAAQEBAQEBAQEBAQEBAQEBAQEBAMECyAAQQE6AC4LIAAgAC8BMEHAAHI7ATAgKiEBC0EmISoM2AELIABBIzYCHCAAICo2AhQgAEGlloCAADYCECAAQRU2AgxBACEqDPABCyAAQQA2AhwgACAqNgIUIABB1YuAgAA2AhAgAEERNgIMQQAhKgzvAQsgAC0ALUEBcUUNAUHDASEqDNUBCwJAICcgAkYNAANAAkAgJy0AAEEgRg0AICchAQzRAQsgJ0EBaiInIAJHDQALQSUhKgzuAQtBJSEqDO0BCyAAKAIEIQEgAEEANgIEIAAgASAnEK+AgIAAIgFFDbUBIABBJjYCHCAAIAE2AgwgACAnQQFqNgIUQQAhKgzsAQsgKkEVRg2zASAAQQA2AhwgACABNgIUIABB/Y2AgAA2AhAgAEEdNgIMQQAhKgzrAQsgAEEnNgIcIAAgATYCFCAAICo2AgxBACEqDOoBCyAqIQFBASEuAkACQAJAAkACQAJAAkAgAC0ALEF+ag4HBgUFAwECAAULIAAgAC8BMEEIcjsBMAwDC0ECIS4MAQtBBCEuCyAAQQE6ACwgACAALwEwIC5yOwEwCyAqIQELQSshKgzRAQsgAEEANgIcIAAgKjYCFCAAQauSgIAANgIQIABBCzYCDEEAISoM6QELIABBADYCHCAAIAE2AhQgAEHhj4CAADYCECAAQQo2AgxBACEqDOgBCyAAQQA6ACwgKiEBDMIBCyAqIQFBASEuAkACQAJAAkACQCAALQAsQXtqDgQDAQIABQsgACAALwEwQQhyOwEwDAMLQQIhLgwBC0EEIS4LIABBAToALCAAIAAvATAgLnI7ATALICohAQtBKSEqDMwBCyAAQQA2AhwgACABNgIUIABB8JSAgAA2AhAgAEEDNgIMQQAhKgzkAQsCQCAoLQAAQQ1HDQAgACgCBCEBIABBADYCBAJAIAAgASAoELGAgIAAIgENACAoQQFqIQEMewsgAEEsNgIcIAAgATYCDCAAIChBAWo2AhRBACEqDOQBCyAALQAtQQFxRQ0BQcQBISoMygELAkAgKCACRw0AQS0hKgzjAQsCQAJAA0ACQCAoLQAAQXZqDgQCAAADAAsgKEEBaiIoIAJHDQALQS0hKgzkAQsgACgCBCEBIABBADYCBAJAIAAgASAoELGAgIAAIgENACAoIQEMegsgAEEsNgIcIAAgKDYCFCAAIAE2AgxBACEqDOMBCyAAKAIEIQEgAEEANgIEAkAgACABICgQsYCAgAAiAQ0AIChBAWohAQx5CyAAQSw2AhwgACABNgIMIAAgKEEBajYCFEEAISoM4gELIAAoAgQhASAAQQA2AgQgACABICgQsYCAgAAiAQ2oASAoIQEM1QELICpBLEcNASABQQFqISpBASEBAkACQAJAAkACQCAALQAsQXtqDgQDAQIEAAsgKiEBDAQLQQIhAQwBC0EEIQELIABBAToALCAAIAAvATAgAXI7ATAgKiEBDAELIAAgAC8BMEEIcjsBMCAqIQELQTkhKgzGAQsgAEEAOgAsIAEhAQtBNCEqDMQBCyAAQQA2AgAgLyAwa0EJaiEBQQUhKgy/AQsgAEEANgIAIC8gMGtBBmohAUEHISoMvgELIAAgAC8BMEEgcjsBMCABIQEMAgsgACgCBCEEIABBADYCBAJAIAAgBCABELGAgIAAIgQNACABIQEMzAELIABBNzYCHCAAIAE2AhQgACAENgIMQQAhKgzZAQsgAEEIOgAsIAEhAQtBMCEqDL4BCwJAIAAtAChBAUYNACABIQEMBAsgAC0ALUEIcUUNmQEgASEBDAMLIAAtADBBIHENmgFBxQEhKgy8AQsCQCApIAJGDQACQANAAkAgKS0AAEFQaiIBQf8BcUEKSQ0AICkhAUE1ISoMvwELIAApAyAiK0KZs+bMmbPmzBlWDQEgACArQgp+Iis3AyAgKyABrSIsQn+FQoB+hFYNASAAICsgLEL/AYN8NwMgIClBAWoiKSACRw0AC0E5ISoM1gELIAAoAgQhBCAAQQA2AgQgACAEIClBAWoiARCxgICAACIEDZsBIAEhAQzIAQtBOSEqDNQBCwJAIAAvATAiAUEIcUUNACAALQAoQQFHDQAgAC0ALUEIcUUNlgELIAAgAUH3+wNxQYAEcjsBMCApIQELQTchKgy5AQsgACAALwEwQRByOwEwDK4BCyAqQRVGDZEBIABBADYCHCAAIAE2AhQgAEHwjoCAADYCECAAQRw2AgxBACEqDNABCyAAQcMANgIcIAAgATYCDCAAICdBAWo2AhRBACEqDM8BCwJAIAEtAABBOkcNACAAKAIEISogAEEANgIEAkAgACAqIAEQr4CAgAAiKg0AIAFBAWohAQxnCyAAQcMANgIcIAAgKjYCDCAAIAFBAWo2AhRBACEqDM8BCyAAQQA2AhwgACABNgIUIABBsZGAgAA2AhAgAEEKNgIMQQAhKgzOAQsgAEEANgIcIAAgATYCFCAAQaCZgIAANgIQIABBHjYCDEEAISoMzQELIAFBAWohAQsgAEGAEjsBKiAAIAEgAhCogICAACIqDQEgASEBC0HHACEqDLEBCyAqQRVHDYkBIABB0QA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhKgzJAQsgACgCBCEqIABBADYCBAJAIAAgKiABEKeAgIAAIioNACABIQEMYgsgAEHSADYCHCAAIAE2AhQgACAqNgIMQQAhKgzIAQsgAEEANgIcIAAgLjYCFCAAQcGogIAANgIQIABBBzYCDCAAQQA2AgBBACEqDMcBCyAAKAIEISogAEEANgIEAkAgACAqIAEQp4CAgAAiKg0AIAEhAQxhCyAAQdMANgIcIAAgATYCFCAAICo2AgxBACEqDMYBC0EAISogAEEANgIcIAAgATYCFCAAQYCRgIAANgIQIABBCTYCDAzFAQsgKkEVRg2DASAAQQA2AhwgACABNgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhKgzEAQtBASEvQQAhMkEAIS5BASEqCyAAICo6ACsgAUEBaiEBAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgL0UNAwwCCyAuDQEMAgsgMkUNAQsgACgCBCEqIABBADYCBAJAIAAgKiABEK2AgIAAIioNACABIQEMYAsgAEHYADYCHCAAIAE2AhQgACAqNgIMQQAhKgzDAQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMsgELIABB2QA2AhwgACABNgIUIAAgBDYCDEEAISoMwgELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDLABCyAAQdoANgIcIAAgATYCFCAAIAQ2AgxBACEqDMEBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQyuAQsgAEHcADYCHCAAIAE2AhQgACAENgIMQQAhKgzAAQtBASEqCyAAICo6ACogAUEBaiEBDFwLIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKoBCyAAQd4ANgIcIAAgATYCFCAAIAQ2AgxBACEqDL0BCyAAQQA2AgAgMiAva0EEaiEBAkAgAC0AKUEjTw0AIAEhAQxcCyAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMQQAhKgy8AQsgAEEANgIAC0EAISogAEEANgIcIAAgATYCFCAAQZCzgIAANgIQIABBCDYCDAy6AQsgAEEANgIAIDIgL2tBA2ohAQJAIAAtAClBIUcNACABIQEMWQsgAEEANgIcIAAgATYCFCAAQZuKgIAANgIQIABBCDYCDEEAISoMuQELIABBADYCACAyIC9rQQRqIQECQCAALQApIipBXWpBC08NACABIQEMWAsCQCAqQQZLDQBBASAqdEHKAHFFDQAgASEBDFgLQQAhKiAAQQA2AhwgACABNgIUIABB94mAgAA2AhAgAEEINgIMDLgBCyAqQRVGDXUgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAISoMtwELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDFcLIABB5QA2AhwgACABNgIUIAAgKjYCDEEAISoMtgELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDE8LIABB0gA2AhwgACABNgIUIAAgKjYCDEEAISoMtQELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDE8LIABB0wA2AhwgACABNgIUIAAgKjYCDEEAISoMtAELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDFQLIABB5QA2AhwgACABNgIUIAAgKjYCDEEAISoMswELIABBADYCHCAAIAE2AhQgAEHGioCAADYCECAAQQc2AgxBACEqDLIBCyAAKAIEISogAEEANgIEAkAgACAqIAEQp4CAgAAiKg0AIAEhAQxLCyAAQdIANgIcIAAgATYCFCAAICo2AgxBACEqDLEBCyAAKAIEISogAEEANgIEAkAgACAqIAEQp4CAgAAiKg0AIAEhAQxLCyAAQdMANgIcIAAgATYCFCAAICo2AgxBACEqDLABCyAAKAIEISogAEEANgIEAkAgACAqIAEQp4CAgAAiKg0AIAEhAQxQCyAAQeUANgIcIAAgATYCFCAAICo2AgxBACEqDK8BCyAAQQA2AhwgACABNgIUIABB3IiAgAA2AhAgAEEHNgIMQQAhKgyuAQsgKkE/Rw0BIAFBAWohAQtBBSEqDJMBC0EAISogAEEANgIcIAAgATYCFCAAQf2SgIAANgIQIABBBzYCDAyrAQsgACgCBCEqIABBADYCBAJAIAAgKiABEKeAgIAAIioNACABIQEMRAsgAEHSADYCHCAAIAE2AhQgACAqNgIMQQAhKgyqAQsgACgCBCEqIABBADYCBAJAIAAgKiABEKeAgIAAIioNACABIQEMRAsgAEHTADYCHCAAIAE2AhQgACAqNgIMQQAhKgypAQsgACgCBCEqIABBADYCBAJAIAAgKiABEKeAgIAAIioNACABIQEMSQsgAEHlADYCHCAAIAE2AhQgACAqNgIMQQAhKgyoAQsgACgCBCEBIABBADYCBAJAIAAgASAuEKeAgIAAIgENACAuIQEMQQsgAEHSADYCHCAAIC42AhQgACABNgIMQQAhKgynAQsgACgCBCEBIABBADYCBAJAIAAgASAuEKeAgIAAIgENACAuIQEMQQsgAEHTADYCHCAAIC42AhQgACABNgIMQQAhKgymAQsgACgCBCEBIABBADYCBAJAIAAgASAuEKeAgIAAIgENACAuIQEMRgsgAEHlADYCHCAAIC42AhQgACABNgIMQQAhKgylAQsgAEEANgIcIAAgLjYCFCAAQcOPgIAANgIQIABBBzYCDEEAISoMpAELIABBADYCHCAAIAE2AhQgAEHDj4CAADYCECAAQQc2AgxBACEqDKMBC0EAISogAEEANgIcIAAgLjYCFCAAQYycgIAANgIQIABBBzYCDAyiAQsgAEEANgIcIAAgLjYCFCAAQYycgIAANgIQIABBBzYCDEEAISoMoQELIABBADYCHCAAIC42AhQgAEH+kYCAADYCECAAQQc2AgxBACEqDKABCyAAQQA2AhwgACABNgIUIABBjpuAgAA2AhAgAEEGNgIMQQAhKgyfAQsgKkEVRg1bIABBADYCHCAAIAE2AhQgAEHMjoCAADYCECAAQSA2AgxBACEqDJ4BCyAAQQA2AgAgKiAua0EGaiEBQSQhKgsgACAqOgApIAAoAgQhKiAAQQA2AgQgACAqIAEQq4CAgAAiKg1YIAEhAQxBCyAAQQA2AgALQQAhKiAAQQA2AhwgACAENgIUIABB8ZuAgAA2AhAgAEEGNgIMDJoBCyABQRVGDVQgAEEANgIcIAAgHTYCFCAAQfCMgIAANgIQIABBGzYCDEEAISoMmQELIAAoAgQhHSAAQQA2AgQgACAdICoQqYCAgAAiHQ0BICpBAWohHQtBrQEhKgx+CyAAQcEBNgIcIAAgHTYCDCAAICpBAWo2AhRBACEqDJYBCyAAKAIEIR4gAEEANgIEIAAgHiAqEKmAgIAAIh4NASAqQQFqIR4LQa4BISoMewsgAEHCATYCHCAAIB42AgwgACAqQQFqNgIUQQAhKgyTAQsgAEEANgIcIAAgHzYCFCAAQZeLgIAANgIQIABBDTYCDEEAISoMkgELIABBADYCHCAAICA2AhQgAEHjkICAADYCECAAQQk2AgxBACEqDJEBCyAAQQA2AhwgACAgNgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhKgyQAQtBASEvQQAhMkEAIS5BASEqCyAAICo6ACsgIUEBaiEgAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgL0UNAwwCCyAuDQEMAgsgMkUNAQsgACgCBCEqIABBADYCBCAAICogIBCtgICAACIqRQ1AIABByQE2AhwgACAgNgIUIAAgKjYCDEEAISoMjwELIAAoAgQhASAAQQA2AgQgACABICAQrYCAgAAiAUUNeSAAQcoBNgIcIAAgIDYCFCAAIAE2AgxBACEqDI4BCyAAKAIEIQEgAEEANgIEIAAgASAhEK2AgIAAIgFFDXcgAEHLATYCHCAAICE2AhQgACABNgIMQQAhKgyNAQsgACgCBCEBIABBADYCBCAAIAEgIhCtgICAACIBRQ11IABBzQE2AhwgACAiNgIUIAAgATYCDEEAISoMjAELQQEhKgsgACAqOgAqICNBAWohIgw9CyAAKAIEIQEgAEEANgIEIAAgASAjEK2AgIAAIgFFDXEgAEHPATYCHCAAICM2AhQgACABNgIMQQAhKgyJAQsgAEEANgIcIAAgIzYCFCAAQZCzgIAANgIQIABBCDYCDCAAQQA2AgBBACEqDIgBCyABQRVGDUEgAEEANgIcIAAgJDYCFCAAQcyOgIAANgIQIABBIDYCDEEAISoMhwELIABBADYCACAAQYEEOwEoIAAoAgQhKiAAQQA2AgQgACAqICUgJGtBAmoiJBCrgICAACIqRQ06IABB0wE2AhwgACAkNgIUIAAgKjYCDEEAISoMhgELIABBADYCAAtBACEqIABBADYCHCAAIAQ2AhQgAEHYm4CAADYCECAAQQg2AgwMhAELIABBADYCACAAKAIEISogAEEANgIEIAAgKiAmICNrQQNqIiMQq4CAgAAiKg0BQcYBISoMagsgAEECOgAoDFcLIABB1QE2AhwgACAjNgIUIAAgKjYCDEEAISoMgQELICpBFUYNOSAAQQA2AhwgACAENgIUIABBpIyAgAA2AhAgAEEQNgIMQQAhKgyAAQsgAC0ANEEBRw02IAAgBCACELyAgIAAIipFDTYgKkEVRw03IABB3AE2AhwgACAENgIUIABB1ZaAgAA2AhAgAEEVNgIMQQAhKgx/C0EAISogAEEANgIcIABBr4uAgAA2AhAgAEECNgIMIAAgLkEBajYCFAx+C0EAISoMZAtBAiEqDGMLQQ0hKgxiC0EPISoMYQtBJSEqDGALQRMhKgxfC0EVISoMXgtBFiEqDF0LQRchKgxcC0EYISoMWwtBGSEqDFoLQRohKgxZC0EbISoMWAtBHCEqDFcLQR0hKgxWC0EfISoMVQtBISEqDFQLQSMhKgxTC0HGACEqDFILQS4hKgxRC0EvISoMUAtBOyEqDE8LQT0hKgxOC0HIACEqDE0LQckAISoMTAtBywAhKgxLC0HMACEqDEoLQc4AISoMSQtBzwAhKgxIC0HRACEqDEcLQdUAISoMRgtB2AAhKgxFC0HZACEqDEQLQdsAISoMQwtB5AAhKgxCC0HlACEqDEELQfEAISoMQAtB9AAhKgw/C0GNASEqDD4LQZcBISoMPQtBqQEhKgw8C0GsASEqDDsLQcABISoMOgtBuQEhKgw5C0GvASEqDDgLQbEBISoMNwtBsgEhKgw2C0G0ASEqDDULQbUBISoMNAtBtgEhKgwzC0G6ASEqDDILQb0BISoMMQtBvwEhKgwwC0HBASEqDC8LIABBADYCHCAAIAQ2AhQgAEHpi4CAADYCECAAQR82AgxBACEqDEcLIABB2wE2AhwgACAENgIUIABB+paAgAA2AhAgAEEVNgIMQQAhKgxGCyAAQfgANgIcIAAgJDYCFCAAQcqYgIAANgIQIABBFTYCDEEAISoMRQsgAEHRADYCHCAAIB02AhQgAEGwl4CAADYCECAAQRU2AgxBACEqDEQLIABB+QA2AhwgACABNgIUIAAgKjYCDEEAISoMQwsgAEH4ADYCHCAAIAE2AhQgAEHKmICAADYCECAAQRU2AgxBACEqDEILIABB5AA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhKgxBCyAAQdcANgIcIAAgATYCFCAAQcmXgIAANgIQIABBFTYCDEEAISoMQAsgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAISoMPwsgAEHCADYCHCAAIAE2AhQgAEHjmICAADYCECAAQRU2AgxBACEqDD4LIABBADYCBCAAICkgKRCxgICAACIBRQ0BIABBOjYCHCAAIAE2AgwgACApQQFqNgIUQQAhKgw9CyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBEUNACAAQTs2AhwgACAENgIMIAAgAUEBajYCFEEAISoMPQsgAUEBaiEBDCwLIClBAWohAQwsCyAAQQA2AhwgACApNgIUIABB5JKAgAA2AhAgAEEENgIMQQAhKgw6CyAAQTY2AhwgACABNgIUIAAgBDYCDEEAISoMOQsgAEEuNgIcIAAgKDYCFCAAIAE2AgxBACEqDDgLIABB0AA2AhwgACABNgIUIABBkZiAgAA2AhAgAEEVNgIMQQAhKgw3CyAnQQFqIQEMKwsgAEEVNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAISoMNQsgAEEbNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAISoMNAsgAEEPNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAISoMMwsgAEELNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAISoMMgsgAEEaNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAISoMMQsgAEELNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAISoMMAsgAEEKNgIcIAAgATYCFCAAQeSWgIAANgIQIABBFTYCDEEAISoMLwsgAEEeNgIcIAAgATYCFCAAQfmXgIAANgIQIABBFTYCDEEAISoMLgsgAEEANgIcIAAgKjYCFCAAQdqNgIAANgIQIABBFDYCDEEAISoMLQsgAEEENgIcIAAgATYCFCAAQbCYgIAANgIQIABBFTYCDEEAISoMLAsgAEEANgIAIAQgLmtBBWohIwtBuAEhKgwRCyAAQQA2AgAgKiAua0ECaiEBQfUAISoMEAsgASEBAkAgAC0AKUEFRw0AQeMAISoMEAtB4gAhKgwPC0EAISogAEEANgIcIABB5JGAgAA2AhAgAEEHNgIMIAAgLkEBajYCFAwnCyAAQQA2AgAgMiAva0ECaiEBQcAAISoMDQsgASEBC0E4ISoMCwsCQCABIikgAkYNAANAAkAgKS0AAEGAvoCAAGotAAAiAUEBRg0AIAFBAkcNAyApQQFqIQEMBAsgKUEBaiIpIAJHDQALQT4hKgwkC0E+ISoMIwsgAEEAOgAsICkhAQwBC0ELISoMCAtBOiEqDAcLIAFBAWohAUEtISoMBgtBKCEqDAULIABBADYCACAvIDBrQQRqIQFBBiEqCyAAICo6ACwgASEBQQwhKgwDCyAAQQA2AgAgMiAva0EHaiEBQQohKgwCCyAAQQA2AgALIABBADoALCAnIQFBCSEqDAALC0EAISogAEEANgIcIAAgIzYCFCAAQc2QgIAANgIQIABBCTYCDAwXC0EAISogAEEANgIcIAAgIjYCFCAAQemKgIAANgIQIABBCTYCDAwWC0EAISogAEEANgIcIAAgITYCFCAAQbeQgIAANgIQIABBCTYCDAwVC0EAISogAEEANgIcIAAgIDYCFCAAQZyRgIAANgIQIABBCTYCDAwUC0EAISogAEEANgIcIAAgATYCFCAAQc2QgIAANgIQIABBCTYCDAwTC0EAISogAEEANgIcIAAgATYCFCAAQemKgIAANgIQIABBCTYCDAwSC0EAISogAEEANgIcIAAgATYCFCAAQbeQgIAANgIQIABBCTYCDAwRC0EAISogAEEANgIcIAAgATYCFCAAQZyRgIAANgIQIABBCTYCDAwQC0EAISogAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwPC0EAISogAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwOC0EAISogAEEANgIcIAAgATYCFCAAQcCSgIAANgIQIABBCzYCDAwNC0EAISogAEEANgIcIAAgATYCFCAAQZWJgIAANgIQIABBCzYCDAwMC0EAISogAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDAwLC0EAISogAEEANgIcIAAgATYCFCAAQfuPgIAANgIQIABBCjYCDAwKC0EAISogAEEANgIcIAAgATYCFCAAQfGZgIAANgIQIABBAjYCDAwJC0EAISogAEEANgIcIAAgATYCFCAAQcSUgIAANgIQIABBAjYCDAwIC0EAISogAEEANgIcIAAgATYCFCAAQfKVgIAANgIQIABBAjYCDAwHCyAAQQI2AhwgACABNgIUIABBnJqAgAA2AhAgAEEWNgIMQQAhKgwGC0EBISoMBQtB1AAhKiABIgEgAkYNBCADQQhqIAAgASACQdjCgIAAQQoQxYCAgAAgAygCDCEBIAMoAggOAwEEAgALEMuAgIAAAAsgAEEANgIcIABBtZqAgAA2AhAgAEEXNgIMIAAgAUEBajYCFEEAISoMAgsgAEEANgIcIAAgATYCFCAAQcqagIAANgIQIABBCTYCDEEAISoMAQsCQCABIgEgAkcNAEEiISoMAQsgAEGJgICAADYCCCAAIAE2AgRBISEqCyADQRBqJICAgIAAICoLrwEBAn8gASgCACEGAkACQCACIANGDQAgBCAGaiEEIAYgA2ogAmshByACIAZBf3MgBWoiBmohBQNAAkAgAi0AACAELQAARg0AQQIhBAwDCwJAIAYNAEEAIQQgBSECDAMLIAZBf2ohBiAEQQFqIQQgAkEBaiICIANHDQALIAchBiADIQILIABBATYCACABIAY2AgAgACACNgIEDwsgAUEANgIAIAAgBDYCACAAIAI2AgQLCgAgABDHgICAAAuVNwELfyOAgICAAEEQayIBJICAgIAAAkBBACgCoNCAgAANAEEAEMqAgIAAQYDUhIAAayICQdkASQ0AQQAhAwJAQQAoAuDTgIAAIgQNAEEAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEIakFwcUHYqtWqBXMiBDYC4NOAgABBAEEANgL004CAAEEAQQA2AsTTgIAAC0EAIAI2AszTgIAAQQBBgNSEgAA2AsjTgIAAQQBBgNSEgAA2ApjQgIAAQQAgBDYCrNCAgABBAEF/NgKo0ICAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALQYDUhIAAQXhBgNSEgABrQQ9xQQBBgNSEgABBCGpBD3EbIgNqIgRBBGogAiADa0FIaiIDQQFyNgIAQQBBACgC8NOAgAA2AqTQgIAAQQAgBDYCoNCAgABBACADNgKU0ICAACACQYDUhIAAakFMakE4NgIACwJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQewBSw0AAkBBACgCiNCAgAAiBkEQIABBE2pBcHEgAEELSRsiAkEDdiIEdiIDQQNxRQ0AIANBAXEgBHJBAXMiBUEDdCIAQbjQgIAAaigCACIEQQhqIQMCQAJAIAQoAggiAiAAQbDQgIAAaiIARw0AQQAgBkF+IAV3cTYCiNCAgAAMAQsgACACNgIIIAIgADYCDAsgBCAFQQN0IgVBA3I2AgQgBCAFakEEaiIEIAQoAgBBAXI2AgAMDAsgAkEAKAKQ0ICAACIHTQ0BAkAgA0UNAAJAAkAgAyAEdEECIAR0IgNBACADa3JxIgNBACADa3FBf2oiAyADQQx2QRBxIgN2IgRBBXZBCHEiBSADciAEIAV2IgNBAnZBBHEiBHIgAyAEdiIDQQF2QQJxIgRyIAMgBHYiA0EBdkEBcSIEciADIAR2aiIFQQN0IgBBuNCAgABqKAIAIgQoAggiAyAAQbDQgIAAaiIARw0AQQAgBkF+IAV3cSIGNgKI0ICAAAwBCyAAIAM2AgggAyAANgIMCyAEQQhqIQMgBCACQQNyNgIEIAQgBUEDdCIFaiAFIAJrIgU2AgAgBCACaiIAIAVBAXI2AgQCQCAHRQ0AIAdBA3YiCEEDdEGw0ICAAGohAkEAKAKc0ICAACEEAkACQCAGQQEgCHQiCHENAEEAIAYgCHI2AojQgIAAIAIhCAwBCyACKAIIIQgLIAggBDYCDCACIAQ2AgggBCACNgIMIAQgCDYCCAtBACAANgKc0ICAAEEAIAU2ApDQgIAADAwLQQAoAozQgIAAIglFDQEgCUEAIAlrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqQQJ0QbjSgIAAaigCACIAKAIEQXhxIAJrIQQgACEFAkADQAJAIAUoAhAiAw0AIAVBFGooAgAiA0UNAgsgAygCBEF4cSACayIFIAQgBSAESSIFGyEEIAMgACAFGyEAIAMhBQwACwsgACgCGCEKAkAgACgCDCIIIABGDQBBACgCmNCAgAAgACgCCCIDSxogCCADNgIIIAMgCDYCDAwLCwJAIABBFGoiBSgCACIDDQAgACgCECIDRQ0DIABBEGohBQsDQCAFIQsgAyIIQRRqIgUoAgAiAw0AIAhBEGohBSAIKAIQIgMNAAsgC0EANgIADAoLQX8hAiAAQb9/Sw0AIABBE2oiA0FwcSECQQAoAozQgIAAIgdFDQBBACELAkAgAkGAAkkNAEEfIQsgAkH///8HSw0AIANBCHYiAyADQYD+P2pBEHZBCHEiA3QiBCAEQYDgH2pBEHZBBHEiBHQiBSAFQYCAD2pBEHZBAnEiBXRBD3YgAyAEciAFcmsiA0EBdCACIANBFWp2QQFxckEcaiELC0EAIAJrIQQCQAJAAkACQCALQQJ0QbjSgIAAaigCACIFDQBBACEDQQAhCAwBC0EAIQMgAkEAQRkgC0EBdmsgC0EfRht0IQBBACEIA0ACQCAFKAIEQXhxIAJrIgYgBE8NACAGIQQgBSEIIAYNAEEAIQQgBSEIIAUhAwwDCyADIAVBFGooAgAiBiAGIAUgAEEddkEEcWpBEGooAgAiBUYbIAMgBhshAyAAQQF0IQAgBQ0ACwsCQCADIAhyDQBBACEIQQIgC3QiA0EAIANrciAHcSIDRQ0DIANBACADa3FBf2oiAyADQQx2QRBxIgN2IgVBBXZBCHEiACADciAFIAB2IgNBAnZBBHEiBXIgAyAFdiIDQQF2QQJxIgVyIAMgBXYiA0EBdkEBcSIFciADIAV2akECdEG40oCAAGooAgAhAwsgA0UNAQsDQCADKAIEQXhxIAJrIgYgBEkhAAJAIAMoAhAiBQ0AIANBFGooAgAhBQsgBiAEIAAbIQQgAyAIIAAbIQggBSEDIAUNAAsLIAhFDQAgBEEAKAKQ0ICAACACa08NACAIKAIYIQsCQCAIKAIMIgAgCEYNAEEAKAKY0ICAACAIKAIIIgNLGiAAIAM2AgggAyAANgIMDAkLAkAgCEEUaiIFKAIAIgMNACAIKAIQIgNFDQMgCEEQaiEFCwNAIAUhBiADIgBBFGoiBSgCACIDDQAgAEEQaiEFIAAoAhAiAw0ACyAGQQA2AgAMCAsCQEEAKAKQ0ICAACIDIAJJDQBBACgCnNCAgAAhBAJAAkAgAyACayIFQRBJDQAgBCACaiIAIAVBAXI2AgRBACAFNgKQ0ICAAEEAIAA2ApzQgIAAIAQgA2ogBTYCACAEIAJBA3I2AgQMAQsgBCADQQNyNgIEIAMgBGpBBGoiAyADKAIAQQFyNgIAQQBBADYCnNCAgABBAEEANgKQ0ICAAAsgBEEIaiEDDAoLAkBBACgClNCAgAAiACACTQ0AQQAoAqDQgIAAIgMgAmoiBCAAIAJrIgVBAXI2AgRBACAFNgKU0ICAAEEAIAQ2AqDQgIAAIAMgAkEDcjYCBCADQQhqIQMMCgsCQAJAQQAoAuDTgIAARQ0AQQAoAujTgIAAIQQMAQtBAEJ/NwLs04CAAEEAQoCAhICAgMAANwLk04CAAEEAIAFBDGpBcHFB2KrVqgVzNgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgABBgIAEIQQLQQAhAwJAIAQgAkHHAGoiB2oiBkEAIARrIgtxIgggAksNAEEAQTA2AvjTgIAADAoLAkBBACgCwNOAgAAiA0UNAAJAQQAoArjTgIAAIgQgCGoiBSAETQ0AIAUgA00NAQtBACEDQQBBMDYC+NOAgAAMCgtBAC0AxNOAgABBBHENBAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQAJAIAMoAgAiBSAESw0AIAUgAygCBGogBEsNAwsgAygCCCIDDQALC0EAEMqAgIAAIgBBf0YNBSAIIQYCQEEAKALk04CAACIDQX9qIgQgAHFFDQAgCCAAayAEIABqQQAgA2txaiEGCyAGIAJNDQUgBkH+////B0sNBQJAQQAoAsDTgIAAIgNFDQBBACgCuNOAgAAiBCAGaiIFIARNDQYgBSADSw0GCyAGEMqAgIAAIgMgAEcNAQwHCyAGIABrIAtxIgZB/v///wdLDQQgBhDKgICAACIAIAMoAgAgAygCBGpGDQMgACEDCwJAIANBf0YNACACQcgAaiAGTQ0AAkAgByAGa0EAKALo04CAACIEakEAIARrcSIEQf7///8HTQ0AIAMhAAwHCwJAIAQQyoCAgABBf0YNACAEIAZqIQYgAyEADAcLQQAgBmsQyoCAgAAaDAQLIAMhACADQX9HDQUMAwtBACEIDAcLQQAhAAwFCyAAQX9HDQILQQBBACgCxNOAgABBBHI2AsTTgIAACyAIQf7///8HSw0BIAgQyoCAgAAhAEEAEMqAgIAAIQMgAEF/Rg0BIANBf0YNASAAIANPDQEgAyAAayIGIAJBOGpNDQELQQBBACgCuNOAgAAgBmoiAzYCuNOAgAACQCADQQAoArzTgIAATQ0AQQAgAzYCvNOAgAALAkACQAJAAkBBACgCoNCAgAAiBEUNAEHI04CAACEDA0AgACADKAIAIgUgAygCBCIIakYNAiADKAIIIgMNAAwDCwsCQAJAQQAoApjQgIAAIgNFDQAgACADTw0BC0EAIAA2ApjQgIAAC0EAIQNBACAGNgLM04CAAEEAIAA2AsjTgIAAQQBBfzYCqNCAgABBAEEAKALg04CAADYCrNCAgABBAEEANgLU04CAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgQgBiADa0FIaiIDQQFyNgIEQQBBACgC8NOAgAA2AqTQgIAAQQAgBDYCoNCAgABBACADNgKU0ICAACAGIABqQUxqQTg2AgAMAgsgAy0ADEEIcQ0AIAUgBEsNACAAIARNDQAgBEF4IARrQQ9xQQAgBEEIakEPcRsiBWoiAEEAKAKU0ICAACAGaiILIAVrIgVBAXI2AgQgAyAIIAZqNgIEQQBBACgC8NOAgAA2AqTQgIAAQQAgBTYClNCAgABBACAANgKg0ICAACALIARqQQRqQTg2AgAMAQsCQCAAQQAoApjQgIAAIgtPDQBBACAANgKY0ICAACAAIQsLIAAgBmohCEHI04CAACEDAkACQAJAAkACQAJAAkADQCADKAIAIAhGDQEgAygCCCIDDQAMAgsLIAMtAAxBCHFFDQELQcjTgIAAIQMDQAJAIAMoAgAiBSAESw0AIAUgAygCBGoiBSAESw0DCyADKAIIIQMMAAsLIAMgADYCACADIAMoAgQgBmo2AgQgAEF4IABrQQ9xQQAgAEEIakEPcRtqIgYgAkEDcjYCBCAIQXggCGtBD3FBACAIQQhqQQ9xG2oiCCAGIAJqIgJrIQUCQCAEIAhHDQBBACACNgKg0ICAAEEAQQAoApTQgIAAIAVqIgM2ApTQgIAAIAIgA0EBcjYCBAwDCwJAQQAoApzQgIAAIAhHDQBBACACNgKc0ICAAEEAQQAoApDQgIAAIAVqIgM2ApDQgIAAIAIgA0EBcjYCBCACIANqIAM2AgAMAwsCQCAIKAIEIgNBA3FBAUcNACADQXhxIQcCQAJAIANB/wFLDQAgCCgCCCIEIANBA3YiC0EDdEGw0ICAAGoiAEYaAkAgCCgCDCIDIARHDQBBAEEAKAKI0ICAAEF+IAt3cTYCiNCAgAAMAgsgAyAARhogAyAENgIIIAQgAzYCDAwBCyAIKAIYIQkCQAJAIAgoAgwiACAIRg0AIAsgCCgCCCIDSxogACADNgIIIAMgADYCDAwBCwJAIAhBFGoiAygCACIEDQAgCEEQaiIDKAIAIgQNAEEAIQAMAQsDQCADIQsgBCIAQRRqIgMoAgAiBA0AIABBEGohAyAAKAIQIgQNAAsgC0EANgIACyAJRQ0AAkACQCAIKAIcIgRBAnRBuNKAgABqIgMoAgAgCEcNACADIAA2AgAgAA0BQQBBACgCjNCAgABBfiAEd3E2AozQgIAADAILIAlBEEEUIAkoAhAgCEYbaiAANgIAIABFDQELIAAgCTYCGAJAIAgoAhAiA0UNACAAIAM2AhAgAyAANgIYCyAIKAIUIgNFDQAgAEEUaiADNgIAIAMgADYCGAsgByAFaiEFIAggB2ohCAsgCCAIKAIEQX5xNgIEIAIgBWogBTYCACACIAVBAXI2AgQCQCAFQf8BSw0AIAVBA3YiBEEDdEGw0ICAAGohAwJAAkBBACgCiNCAgAAiBUEBIAR0IgRxDQBBACAFIARyNgKI0ICAACADIQQMAQsgAygCCCEECyAEIAI2AgwgAyACNgIIIAIgAzYCDCACIAQ2AggMAwtBHyEDAkAgBUH///8HSw0AIAVBCHYiAyADQYD+P2pBEHZBCHEiA3QiBCAEQYDgH2pBEHZBBHEiBHQiACAAQYCAD2pBEHZBAnEiAHRBD3YgAyAEciAAcmsiA0EBdCAFIANBFWp2QQFxckEcaiEDCyACIAM2AhwgAkIANwIQIANBAnRBuNKAgABqIQQCQEEAKAKM0ICAACIAQQEgA3QiCHENACAEIAI2AgBBACAAIAhyNgKM0ICAACACIAQ2AhggAiACNgIIIAIgAjYCDAwDCyAFQQBBGSADQQF2ayADQR9GG3QhAyAEKAIAIQADQCAAIgQoAgRBeHEgBUYNAiADQR12IQAgA0EBdCEDIAQgAEEEcWpBEGoiCCgCACIADQALIAggAjYCACACIAQ2AhggAiACNgIMIAIgAjYCCAwCCyAAQXggAGtBD3FBACAAQQhqQQ9xGyIDaiILIAYgA2tBSGoiA0EBcjYCBCAIQUxqQTg2AgAgBCAFQTcgBWtBD3FBACAFQUlqQQ9xG2pBQWoiCCAIIARBEGpJGyIIQSM2AgRBAEEAKALw04CAADYCpNCAgABBACALNgKg0ICAAEEAIAM2ApTQgIAAIAhBEGpBACkC0NOAgAA3AgAgCEEAKQLI04CAADcCCEEAIAhBCGo2AtDTgIAAQQAgBjYCzNOAgABBACAANgLI04CAAEEAQQA2AtTTgIAAIAhBJGohAwNAIANBBzYCACAFIANBBGoiA0sNAAsgCCAERg0DIAggCCgCBEF+cTYCBCAIIAggBGsiBjYCACAEIAZBAXI2AgQCQCAGQf8BSw0AIAZBA3YiBUEDdEGw0ICAAGohAwJAAkBBACgCiNCAgAAiAEEBIAV0IgVxDQBBACAAIAVyNgKI0ICAACADIQUMAQsgAygCCCEFCyAFIAQ2AgwgAyAENgIIIAQgAzYCDCAEIAU2AggMBAtBHyEDAkAgBkH///8HSw0AIAZBCHYiAyADQYD+P2pBEHZBCHEiA3QiBSAFQYDgH2pBEHZBBHEiBXQiACAAQYCAD2pBEHZBAnEiAHRBD3YgAyAFciAAcmsiA0EBdCAGIANBFWp2QQFxckEcaiEDCyAEQgA3AhAgBEEcaiADNgIAIANBAnRBuNKAgABqIQUCQEEAKAKM0ICAACIAQQEgA3QiCHENACAFIAQ2AgBBACAAIAhyNgKM0ICAACAEQRhqIAU2AgAgBCAENgIIIAQgBDYCDAwECyAGQQBBGSADQQF2ayADQR9GG3QhAyAFKAIAIQADQCAAIgUoAgRBeHEgBkYNAyADQR12IQAgA0EBdCEDIAUgAEEEcWpBEGoiCCgCACIADQALIAggBDYCACAEQRhqIAU2AgAgBCAENgIMIAQgBDYCCAwDCyAEKAIIIgMgAjYCDCAEIAI2AgggAkEANgIYIAIgBDYCDCACIAM2AggLIAZBCGohAwwFCyAFKAIIIgMgBDYCDCAFIAQ2AgggBEEYakEANgIAIAQgBTYCDCAEIAM2AggLQQAoApTQgIAAIgMgAk0NAEEAKAKg0ICAACIEIAJqIgUgAyACayIDQQFyNgIEQQAgAzYClNCAgABBACAFNgKg0ICAACAEIAJBA3I2AgQgBEEIaiEDDAMLQQAhA0EAQTA2AvjTgIAADAILAkAgC0UNAAJAAkAgCCAIKAIcIgVBAnRBuNKAgABqIgMoAgBHDQAgAyAANgIAIAANAUEAIAdBfiAFd3EiBzYCjNCAgAAMAgsgC0EQQRQgCygCECAIRhtqIAA2AgAgAEUNAQsgACALNgIYAkAgCCgCECIDRQ0AIAAgAzYCECADIAA2AhgLIAhBFGooAgAiA0UNACAAQRRqIAM2AgAgAyAANgIYCwJAAkAgBEEPSw0AIAggBCACaiIDQQNyNgIEIAMgCGpBBGoiAyADKAIAQQFyNgIADAELIAggAmoiACAEQQFyNgIEIAggAkEDcjYCBCAAIARqIAQ2AgACQCAEQf8BSw0AIARBA3YiBEEDdEGw0ICAAGohAwJAAkBBACgCiNCAgAAiBUEBIAR0IgRxDQBBACAFIARyNgKI0ICAACADIQQMAQsgAygCCCEECyAEIAA2AgwgAyAANgIIIAAgAzYCDCAAIAQ2AggMAQtBHyEDAkAgBEH///8HSw0AIARBCHYiAyADQYD+P2pBEHZBCHEiA3QiBSAFQYDgH2pBEHZBBHEiBXQiAiACQYCAD2pBEHZBAnEiAnRBD3YgAyAFciACcmsiA0EBdCAEIANBFWp2QQFxckEcaiEDCyAAIAM2AhwgAEIANwIQIANBAnRBuNKAgABqIQUCQCAHQQEgA3QiAnENACAFIAA2AgBBACAHIAJyNgKM0ICAACAAIAU2AhggACAANgIIIAAgADYCDAwBCyAEQQBBGSADQQF2ayADQR9GG3QhAyAFKAIAIQICQANAIAIiBSgCBEF4cSAERg0BIANBHXYhAiADQQF0IQMgBSACQQRxakEQaiIGKAIAIgINAAsgBiAANgIAIAAgBTYCGCAAIAA2AgwgACAANgIIDAELIAUoAggiAyAANgIMIAUgADYCCCAAQQA2AhggACAFNgIMIAAgAzYCCAsgCEEIaiEDDAELAkAgCkUNAAJAAkAgACAAKAIcIgVBAnRBuNKAgABqIgMoAgBHDQAgAyAINgIAIAgNAUEAIAlBfiAFd3E2AozQgIAADAILIApBEEEUIAooAhAgAEYbaiAINgIAIAhFDQELIAggCjYCGAJAIAAoAhAiA0UNACAIIAM2AhAgAyAINgIYCyAAQRRqKAIAIgNFDQAgCEEUaiADNgIAIAMgCDYCGAsCQAJAIARBD0sNACAAIAQgAmoiA0EDcjYCBCADIABqQQRqIgMgAygCAEEBcjYCAAwBCyAAIAJqIgUgBEEBcjYCBCAAIAJBA3I2AgQgBSAEaiAENgIAAkAgB0UNACAHQQN2IghBA3RBsNCAgABqIQJBACgCnNCAgAAhAwJAAkBBASAIdCIIIAZxDQBBACAIIAZyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAM2AgwgAiADNgIIIAMgAjYCDCADIAg2AggLQQAgBTYCnNCAgABBACAENgKQ0ICAAAsgAEEIaiEDCyABQRBqJICAgIAAIAMLCgAgABDJgICAAAvwDQEHfwJAIABFDQAgAEF4aiIBIABBfGooAgAiAkF4cSIAaiEDAkAgAkEBcQ0AIAJBA3FFDQEgASABKAIAIgJrIgFBACgCmNCAgAAiBEkNASACIABqIQACQEEAKAKc0ICAACABRg0AAkAgAkH/AUsNACABKAIIIgQgAkEDdiIFQQN0QbDQgIAAaiIGRhoCQCABKAIMIgIgBEcNAEEAQQAoAojQgIAAQX4gBXdxNgKI0ICAAAwDCyACIAZGGiACIAQ2AgggBCACNgIMDAILIAEoAhghBwJAAkAgASgCDCIGIAFGDQAgBCABKAIIIgJLGiAGIAI2AgggAiAGNgIMDAELAkAgAUEUaiICKAIAIgQNACABQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQECQAJAIAEoAhwiBEECdEG40oCAAGoiAigCACABRw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAwsgB0EQQRQgBygCECABRhtqIAY2AgAgBkUNAgsgBiAHNgIYAkAgASgCECICRQ0AIAYgAjYCECACIAY2AhgLIAEoAhQiAkUNASAGQRRqIAI2AgAgAiAGNgIYDAELIAMoAgQiAkEDcUEDRw0AIAMgAkF+cTYCBEEAIAA2ApDQgIAAIAEgAGogADYCACABIABBAXI2AgQPCyADIAFNDQAgAygCBCICQQFxRQ0AAkACQCACQQJxDQACQEEAKAKg0ICAACADRw0AQQAgATYCoNCAgABBAEEAKAKU0ICAACAAaiIANgKU0ICAACABIABBAXI2AgQgAUEAKAKc0ICAAEcNA0EAQQA2ApDQgIAAQQBBADYCnNCAgAAPCwJAQQAoApzQgIAAIANHDQBBACABNgKc0ICAAEEAQQAoApDQgIAAIABqIgA2ApDQgIAAIAEgAEEBcjYCBCABIABqIAA2AgAPCyACQXhxIABqIQACQAJAIAJB/wFLDQAgAygCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgAygCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAgsgAiAGRhogAiAENgIIIAQgAjYCDAwBCyADKAIYIQcCQAJAIAMoAgwiBiADRg0AQQAoApjQgIAAIAMoAggiAksaIAYgAjYCCCACIAY2AgwMAQsCQCADQRRqIgIoAgAiBA0AIANBEGoiAigCACIEDQBBACEGDAELA0AgAiEFIAQiBkEUaiICKAIAIgQNACAGQRBqIQIgBigCECIEDQALIAVBADYCAAsgB0UNAAJAAkAgAygCHCIEQQJ0QbjSgIAAaiICKAIAIANHDQAgAiAGNgIAIAYNAUEAQQAoAozQgIAAQX4gBHdxNgKM0ICAAAwCCyAHQRBBFCAHKAIQIANGG2ogBjYCACAGRQ0BCyAGIAc2AhgCQCADKAIQIgJFDQAgBiACNgIQIAIgBjYCGAsgAygCFCICRQ0AIAZBFGogAjYCACACIAY2AhgLIAEgAGogADYCACABIABBAXI2AgQgAUEAKAKc0ICAAEcNAUEAIAA2ApDQgIAADwsgAyACQX5xNgIEIAEgAGogADYCACABIABBAXI2AgQLAkAgAEH/AUsNACAAQQN2IgJBA3RBsNCAgABqIQACQAJAQQAoAojQgIAAIgRBASACdCICcQ0AQQAgBCACcjYCiNCAgAAgACECDAELIAAoAgghAgsgAiABNgIMIAAgATYCCCABIAA2AgwgASACNgIIDwtBHyECAkAgAEH///8HSw0AIABBCHYiAiACQYD+P2pBEHZBCHEiAnQiBCAEQYDgH2pBEHZBBHEiBHQiBiAGQYCAD2pBEHZBAnEiBnRBD3YgAiAEciAGcmsiAkEBdCAAIAJBFWp2QQFxckEcaiECCyABQgA3AhAgAUEcaiACNgIAIAJBAnRBuNKAgABqIQQCQAJAQQAoAozQgIAAIgZBASACdCIDcQ0AIAQgATYCAEEAIAYgA3I2AozQgIAAIAFBGGogBDYCACABIAE2AgggASABNgIMDAELIABBAEEZIAJBAXZrIAJBH0YbdCECIAQoAgAhBgJAA0AgBiIEKAIEQXhxIABGDQEgAkEddiEGIAJBAXQhAiAEIAZBBHFqQRBqIgMoAgAiBg0ACyADIAE2AgAgAUEYaiAENgIAIAEgATYCDCABIAE2AggMAQsgBCgCCCIAIAE2AgwgBCABNgIIIAFBGGpBADYCACABIAQ2AgwgASAANgIIC0EAQQAoAqjQgIAAQX9qIgFBfyABGzYCqNCAgAALC04AAkAgAA0APwBBEHQPCwJAIABB//8DcQ0AIABBf0wNAAJAIABBEHZAACIAQX9HDQBBAEEwNgL404CAAEF/DwsgAEEQdA8LEMuAgIAAAAsEAAAAC/sCAgN/AX4CQCACRQ0AIAAgAToAACACIABqIgNBf2ogAToAACACQQNJDQAgACABOgACIAAgAToAASADQX1qIAE6AAAgA0F+aiABOgAAIAJBB0kNACAAIAE6AAMgA0F8aiABOgAAIAJBCUkNACAAQQAgAGtBA3EiBGoiAyABQf8BcUGBgoQIbCIBNgIAIAMgAiAEa0F8cSIEaiICQXxqIAE2AgAgBEEJSQ0AIAMgATYCCCADIAE2AgQgAkF4aiABNgIAIAJBdGogATYCACAEQRlJDQAgAyABNgIYIAMgATYCFCADIAE2AhAgAyABNgIMIAJBcGogATYCACACQWxqIAE2AgAgAkFoaiABNgIAIAJBZGogATYCACAEIANBBHFBGHIiBWsiAkEgSQ0AIAGtQoGAgIAQfiEGIAMgBWohAQNAIAEgBjcDACABQRhqIAY3AwAgAUEQaiAGNwMAIAFBCGogBjcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACwuOSAEAQYAIC4ZIAQAAAAIAAAADAAAAAAAAAAAAAAAEAAAABQAAAAAAAAAAAAAABgAAAAcAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgACAgICAgAAAgIAAgIAAgICAgICAgICAgADAAQAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGxvc2VlZXAtYWxpdmUAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWNodW5rZWQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZWN0aW9uZW50LWxlbmd0aG9ucm94eS1jb25uZWN0aW9uAAAAAAAAAAAAAAAAAAAAcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAAAAAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAEAAAIAAAAAAAAAAAAAAAAAAAAAAAADBAAABAQEBAQEBAQEBAQFBAQEBAQEBAQEBAQEAAQABgcEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAACAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv";
  }
});

// node_modules/undici/lib/llhttp/llhttp_simd.wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp_simd.wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMBBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCsnkAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQy4CAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDLgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMuAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMuAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL8gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARBCHENAAJAIARBgARxRQ0AAkAgAC0AKEEBRw0AIAAtAC1BCnENAEEFDwtBBA8LAkAgBEEgcQ0AAkAgAC0AKEEBRg0AIAAvATIiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQYgEcUGABEYNAiAEQShxRQ0CC0EADwtBAEEDIAApAyBQGyEFCyAFC10BAn9BACEBAkAgAC0AKEEBRg0AIAAvATIiAkGcf2pB5ABJDQAgAkHMAUYNACACQbACRg0AIAAvATAiAEHAAHENAEEBIQEgAEGIBHFBgARGDQAgAEEocUUhAQsgAQuiAQEDfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEDIAAvATAiBEECcUUNAQwCC0EAIQMgAC8BMCIEQQFxRQ0BC0EBIQMgAC0AKEEBRg0AIAAvATIiBUGcf2pB5ABJDQAgBUHMAUYNACAFQbACRg0AIARBwABxDQBBACEDIARBiARxQYAERg0AIARBKHFBAEchAwsgAEEAOwEwIABBADoALyADC5QBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQEgAC8BMCICQQJxRQ0BDAILQQAhASAALwEwIgJBAXFFDQELQQEhASAALQAoQQFGDQAgAC8BMiIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC0kBAXsgAEEQav0MAAAAAAAAAAAAAAAAAAAAACIB/QsDACAAIAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC9z3AQMofwN+BX8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDyABIRAgASERIAEhEiABIRMgASEUIAEhFSABIRYgASEXIAEhGCABIRkgASEaIAEhGyABIRwgASEdIAEhHiABIR8gASEgIAEhISABISIgASEjIAEhJCABISUgASEmIAEhJyABISggASEpAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAhwiKkF/ag7dAdoBAdkBAgMEBQYHCAkKCwwNDtgBDxDXARES1gETFBUWFxgZGhvgAd8BHB0e1QEfICEiIyQl1AEmJygpKiss0wHSAS0u0QHQAS8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRtsBR0hJSs8BzgFLzQFMzAFNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBywHKAbgByQG5AcgBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgEA3AELQQAhKgzGAQtBDiEqDMUBC0ENISoMxAELQQ8hKgzDAQtBECEqDMIBC0ETISoMwQELQRQhKgzAAQtBFSEqDL8BC0EWISoMvgELQRchKgy9AQtBGCEqDLwBC0EZISoMuwELQRohKgy6AQtBGyEqDLkBC0EcISoMuAELQQghKgy3AQtBHSEqDLYBC0EgISoMtQELQR8hKgy0AQtBByEqDLMBC0EhISoMsgELQSIhKgyxAQtBHiEqDLABC0EjISoMrwELQRIhKgyuAQtBESEqDK0BC0EkISoMrAELQSUhKgyrAQtBJiEqDKoBC0EnISoMqQELQcMBISoMqAELQSkhKgynAQtBKyEqDKYBC0EsISoMpQELQS0hKgykAQtBLiEqDKMBC0EvISoMogELQcQBISoMoQELQTAhKgygAQtBNCEqDJ8BC0EMISoMngELQTEhKgydAQtBMiEqDJwBC0EzISoMmwELQTkhKgyaAQtBNSEqDJkBC0HFASEqDJgBC0ELISoMlwELQTohKgyWAQtBNiEqDJUBC0EKISoMlAELQTchKgyTAQtBOCEqDJIBC0E8ISoMkQELQTshKgyQAQtBPSEqDI8BC0EJISoMjgELQSghKgyNAQtBPiEqDIwBC0E/ISoMiwELQcAAISoMigELQcEAISoMiQELQcIAISoMiAELQcMAISoMhwELQcQAISoMhgELQcUAISoMhQELQcYAISoMhAELQSohKgyDAQtBxwAhKgyCAQtByAAhKgyBAQtByQAhKgyAAQtBygAhKgx/C0HLACEqDH4LQc0AISoMfQtBzAAhKgx8C0HOACEqDHsLQc8AISoMegtB0AAhKgx5C0HRACEqDHgLQdIAISoMdwtB0wAhKgx2C0HUACEqDHULQdYAISoMdAtB1QAhKgxzC0EGISoMcgtB1wAhKgxxC0EFISoMcAtB2AAhKgxvC0EEISoMbgtB2QAhKgxtC0HaACEqDGwLQdsAISoMawtB3AAhKgxqC0EDISoMaQtB3QAhKgxoC0HeACEqDGcLQd8AISoMZgtB4QAhKgxlC0HgACEqDGQLQeIAISoMYwtB4wAhKgxiC0ECISoMYQtB5AAhKgxgC0HlACEqDF8LQeYAISoMXgtB5wAhKgxdC0HoACEqDFwLQekAISoMWwtB6gAhKgxaC0HrACEqDFkLQewAISoMWAtB7QAhKgxXC0HuACEqDFYLQe8AISoMVQtB8AAhKgxUC0HxACEqDFMLQfIAISoMUgtB8wAhKgxRC0H0ACEqDFALQfUAISoMTwtB9gAhKgxOC0H3ACEqDE0LQfgAISoMTAtB+QAhKgxLC0H6ACEqDEoLQfsAISoMSQtB/AAhKgxIC0H9ACEqDEcLQf4AISoMRgtB/wAhKgxFC0GAASEqDEQLQYEBISoMQwtBggEhKgxCC0GDASEqDEELQYQBISoMQAtBhQEhKgw/C0GGASEqDD4LQYcBISoMPQtBiAEhKgw8C0GJASEqDDsLQYoBISoMOgtBiwEhKgw5C0GMASEqDDgLQY0BISoMNwtBjgEhKgw2C0GPASEqDDULQZABISoMNAtBkQEhKgwzC0GSASEqDDILQZMBISoMMQtBlAEhKgwwC0GVASEqDC8LQZYBISoMLgtBlwEhKgwtC0GYASEqDCwLQZkBISoMKwtBmgEhKgwqC0GbASEqDCkLQZwBISoMKAtBnQEhKgwnC0GeASEqDCYLQZ8BISoMJQtBoAEhKgwkC0GhASEqDCMLQaIBISoMIgtBowEhKgwhC0GkASEqDCALQaUBISoMHwtBpgEhKgweC0GnASEqDB0LQagBISoMHAtBqQEhKgwbC0GqASEqDBoLQasBISoMGQtBrAEhKgwYC0GtASEqDBcLQa4BISoMFgtBASEqDBULQa8BISoMFAtBsAEhKgwTC0GxASEqDBILQbMBISoMEQtBsgEhKgwQC0G0ASEqDA8LQbUBISoMDgtBtgEhKgwNC0G3ASEqDAwLQbgBISoMCwtBuQEhKgwKC0G6ASEqDAkLQbsBISoMCAtBxgEhKgwHC0G8ASEqDAYLQb0BISoMBQtBvgEhKgwEC0G/ASEqDAMLQcABISoMAgtBwgEhKgwBC0HBASEqCwNAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAqDscBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxweHyAhIyUoP0BBREVGR0hJSktMTU9QUVJT4wNXWVtcXWBiZWZnaGlqa2xtb3BxcnN0dXZ3eHl6e3x9foABggGFAYYBhwGJAYsBjAGNAY4BjwGQAZEBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAZkCpAKyAoQDhAMLIAEiBCACRw3zAUHdASEqDIYECyABIiogAkcN3QFBwwEhKgyFBAsgASIBIAJHDZABQfcAISoMhAQLIAEiASACRw2GAUHvACEqDIMECyABIgEgAkcNf0HqACEqDIIECyABIgEgAkcNe0HoACEqDIEECyABIgEgAkcNeEHmACEqDIAECyABIgEgAkcNGkEYISoM/wMLIAEiASACRw0UQRIhKgz+AwsgASIBIAJHDVlBxQAhKgz9AwsgASIBIAJHDUpBPyEqDPwDCyABIgEgAkcNSEE8ISoM+wMLIAEiASACRw1BQTEhKgz6AwsgAC0ALkEBRg3yAwyHAgsgACABIgEgAhDAgICAAEEBRw3mASAAQgA3AyAM5wELIAAgASIBIAIQtICAgAAiKg3nASABIQEM+wILAkAgASIBIAJHDQBBBiEqDPcDCyAAIAFBAWoiASACELuAgIAAIioN6AEgASEBDDELIABCADcDIEESISoM3AMLIAEiKiACRw0rQR0hKgz0AwsCQCABIgEgAkYNACABQQFqIQFBECEqDNsDC0EHISoM8wMLIABCACAAKQMgIisgAiABIiprrSIsfSItIC0gK1YbNwMgICsgLFYiLkUN5QFBCCEqDPIDCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEUISoM2QMLQQkhKgzxAwsgASEBIAApAyBQDeQBIAEhAQz4AgsCQCABIgEgAkcNAEELISoM8AMLIAAgAUEBaiIBIAIQtoCAgAAiKg3lASABIQEM+AILIAAgASIBIAIQuICAgAAiKg3lASABIQEM+AILIAAgASIBIAIQuICAgAAiKg3mASABIQEMDQsgACABIgEgAhC6gICAACIqDecBIAEhAQz2AgsCQCABIgEgAkcNAEEPISoM7AMLIAEtAAAiKkE7Rg0IICpBDUcN6AEgAUEBaiEBDPUCCyAAIAEiASACELqAgIAAIioN6AEgASEBDPgCCwNAAkAgAS0AAEHwtYCAAGotAAAiKkEBRg0AICpBAkcN6wEgACgCBCEqIABBADYCBCAAICogAUEBaiIBELmAgIAAIioN6gEgASEBDPoCCyABQQFqIgEgAkcNAAtBEiEqDOkDCyAAIAEiASACELqAgIAAIioN6QEgASEBDAoLIAEiASACRw0GQRshKgznAwsCQCABIgEgAkcNAEEWISoM5wMLIABBioCAgAA2AgggACABNgIEIAAgASACELiAgIAAIioN6gEgASEBQSAhKgzNAwsCQCABIgEgAkYNAANAAkAgAS0AAEHwt4CAAGotAAAiKkECRg0AAkAgKkF/ag4E5QHsAQDrAewBCyABQQFqIQFBCCEqDM8DCyABQQFqIgEgAkcNAAtBFSEqDOYDC0EVISoM5QMLA0ACQCABLQAAQfC5gIAAai0AACIqQQJGDQAgKkF/ag4E3gHsAeAB6wHsAQsgAUEBaiIBIAJHDQALQRghKgzkAwsCQCABIgEgAkYNACAAQYuAgIAANgIIIAAgATYCBCABIQFBByEqDMsDC0EZISoM4wMLIAFBAWohAQwCCwJAIAEiLiACRw0AQRohKgziAwsgLiEBAkAgLi0AAEFzag4U4wL0AvQC9AL0AvQC9AL0AvQC9AL0AvQC9AL0AvQC9AL0AvQC9AIA9AILQQAhKiAAQQA2AhwgAEGvi4CAADYCECAAQQI2AgwgACAuQQFqNgIUDOEDCwJAIAEtAAAiKkE7Rg0AICpBDUcN6AEgAUEBaiEBDOsCCyABQQFqIQELQSIhKgzGAwsCQCABIiogAkcNAEEcISoM3wMLQgAhKyAqIQEgKi0AAEFQag435wHmAQECAwQFBgcIAAAAAAAAAAkKCwwNDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADxAREhMUAAtBHiEqDMQDC0ICISsM5QELQgMhKwzkAQtCBCErDOMBC0IFISsM4gELQgYhKwzhAQtCByErDOABC0IIISsM3wELQgkhKwzeAQtCCiErDN0BC0ILISsM3AELQgwhKwzbAQtCDSErDNoBC0IOISsM2QELQg8hKwzYAQtCCiErDNcBC0ILISsM1gELQgwhKwzVAQtCDSErDNQBC0IOISsM0wELQg8hKwzSAQtCACErAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAqLQAAQVBqDjflAeQBAAECAwQFBgfmAeYB5gHmAeYB5gHmAQgJCgsMDeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gEODxAREhPmAQtCAiErDOQBC0IDISsM4wELQgQhKwziAQtCBSErDOEBC0IGISsM4AELQgchKwzfAQtCCCErDN4BC0IJISsM3QELQgohKwzcAQtCCyErDNsBC0IMISsM2gELQg0hKwzZAQtCDiErDNgBC0IPISsM1wELQgohKwzWAQtCCyErDNUBC0IMISsM1AELQg0hKwzTAQtCDiErDNIBC0IPISsM0QELIABCACAAKQMgIisgAiABIiprrSIsfSItIC0gK1YbNwMgICsgLFYiLkUN0gFBHyEqDMcDCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEkISoMrgMLQSAhKgzGAwsgACABIiogAhC+gICAAEF/ag4FtgEAywIB0QHSAQtBESEqDKsDCyAAQQE6AC8gKiEBDMIDCyABIgEgAkcN0gFBJCEqDMIDCyABIicgAkcNHkHGACEqDMEDCyAAIAEiASACELKAgIAAIioN1AEgASEBDLUBCyABIiogAkcNJkHQACEqDL8DCwJAIAEiASACRw0AQSghKgy/AwsgAEEANgIEIABBjICAgAA2AgggACABIAEQsYCAgAAiKg3TASABIQEM2AELAkAgASIqIAJHDQBBKSEqDL4DCyAqLQAAIgFBIEYNFCABQQlHDdMBICpBAWohAQwVCwJAIAEiASACRg0AIAFBAWohAQwXC0EqISoMvAMLAkAgASIqIAJHDQBBKyEqDLwDCwJAICotAAAiAUEJRg0AIAFBIEcN1QELIAAtACxBCEYN0wEgKiEBDJYDCwJAIAEiASACRw0AQSwhKgy7AwsgAS0AAEEKRw3VASABQQFqIQEMzwILIAEiKCACRw3VAUEvISoMuQMLA0ACQCABLQAAIipBIEYNAAJAICpBdmoOBADcAdwBANoBCyABIQEM4gELIAFBAWoiASACRw0AC0ExISoMuAMLQTIhKiABIi8gAkYNtwMgAiAvayAAKAIAIjBqITEgLyEyIDAhAQJAA0AgMi0AACIuQSByIC4gLkG/f2pB/wFxQRpJG0H/AXEgAUHwu4CAAGotAABHDQEgAUEDRg2bAyABQQFqIQEgMkEBaiIyIAJHDQALIAAgMTYCAAy4AwsgAEEANgIAIDIhAQzZAQtBMyEqIAEiLyACRg22AyACIC9rIAAoAgAiMGohMSAvITIgMCEBAkADQCAyLQAAIi5BIHIgLiAuQb9/akH/AXFBGkkbQf8BcSABQfS7gIAAai0AAEcNASABQQhGDdsBIAFBAWohASAyQQFqIjIgAkcNAAsgACAxNgIADLcDCyAAQQA2AgAgMiEBDNgBC0E0ISogASIvIAJGDbUDIAIgL2sgACgCACIwaiExIC8hMiAwIQECQANAIDItAAAiLkEgciAuIC5Bv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw0BIAFBBUYN2wEgAUEBaiEBIDJBAWoiMiACRw0ACyAAIDE2AgAMtgMLIABBADYCACAyIQEM1wELAkAgASIBIAJGDQADQAJAIAEtAABBgL6AgABqLQAAIipBAUYNACAqQQJGDQogASEBDN8BCyABQQFqIgEgAkcNAAtBMCEqDLUDC0EwISoMtAMLAkAgASIBIAJGDQADQAJAIAEtAAAiKkEgRg0AICpBdmoOBNsB3AHcAdsB3AELIAFBAWoiASACRw0AC0E4ISoMtAMLQTghKgyzAwsDQAJAIAEtAAAiKkEgRg0AICpBCUcNAwsgAUEBaiIBIAJHDQALQTwhKgyyAwsDQAJAIAEtAAAiKkEgRg0AAkACQCAqQXZqDgTcAQEB3AEACyAqQSxGDd0BCyABIQEMBAsgAUEBaiIBIAJHDQALQT8hKgyxAwsgASEBDN0BC0HAACEqIAEiMiACRg2vAyACIDJrIAAoAgAiL2ohMCAyIS4gLyEBAkADQCAuLQAAQSByIAFBgMCAgABqLQAARw0BIAFBBkYNlQMgAUEBaiEBIC5BAWoiLiACRw0ACyAAIDA2AgAMsAMLIABBADYCACAuIQELQTYhKgyVAwsCQCABIikgAkcNAEHBACEqDK4DCyAAQYyAgIAANgIIIAAgKTYCBCApIQEgAC0ALEF/ag4EzQHXAdkB2wGMAwsgAUEBaiEBDMwBCwJAIAEiASACRg0AA0ACQCABLQAAIipBIHIgKiAqQb9/akH/AXFBGkkbQf8BcSIqQQlGDQAgKkEgRg0AAkACQAJAAkAgKkGdf2oOEwADAwMDAwMDAQMDAwMDAwMDAwIDCyABQQFqIQFBMSEqDJgDCyABQQFqIQFBMiEqDJcDCyABQQFqIQFBMyEqDJYDCyABIQEM0AELIAFBAWoiASACRw0AC0E1ISoMrAMLQTUhKgyrAwsCQCABIgEgAkYNAANAAkAgAS0AAEGAvICAAGotAABBAUYNACABIQEM1QELIAFBAWoiASACRw0AC0E9ISoMqwMLQT0hKgyqAwsgACABIgEgAhCwgICAACIqDdgBIAEhAQwBCyAqQQFqIQELQTwhKgyOAwsCQCABIgEgAkcNAEHCACEqDKcDCwJAA0ACQCABLQAAQXdqDhgAAoMDgwOJA4MDgwODA4MDgwODA4MDgwODA4MDgwODA4MDgwODA4MDgwODAwCDAwsgAUEBaiIBIAJHDQALQcIAISoMpwMLIAFBAWohASAALQAtQQFxRQ29ASABIQELQSwhKgyMAwsgASIBIAJHDdUBQcQAISoMpAMLA0ACQCABLQAAQZDAgIAAai0AAEEBRg0AIAEhAQy9AgsgAUEBaiIBIAJHDQALQcUAISoMowMLICctAAAiKkEgRg2zASAqQTpHDYgDIAAoAgQhASAAQQA2AgQgACABICcQr4CAgAAiAQ3SASAnQQFqIQEMuQILQccAISogASIyIAJGDaEDIAIgMmsgACgCACIvaiEwIDIhJyAvIQECQANAICctAAAiLkEgciAuIC5Bv39qQf8BcUEaSRtB/wFxIAFBkMKAgABqLQAARw2IAyABQQVGDQEgAUEBaiEBICdBAWoiJyACRw0ACyAAIDA2AgAMogMLIABBADYCACAAQQE6ACwgMiAva0EGaiEBDIIDC0HIACEqIAEiMiACRg2gAyACIDJrIAAoAgAiL2ohMCAyIScgLyEBAkADQCAnLQAAIi5BIHIgLiAuQb9/akH/AXFBGkkbQf8BcSABQZbCgIAAai0AAEcNhwMgAUEJRg0BIAFBAWohASAnQQFqIicgAkcNAAsgACAwNgIADKEDCyAAQQA2AgAgAEECOgAsIDIgL2tBCmohAQyBAwsCQCABIicgAkcNAEHJACEqDKADCwJAAkAgJy0AACIBQSByIAEgAUG/f2pB/wFxQRpJG0H/AXFBkn9qDgcAhwOHA4cDhwOHAwGHAwsgJ0EBaiEBQT4hKgyHAwsgJ0EBaiEBQT8hKgyGAwtBygAhKiABIjIgAkYNngMgAiAyayAAKAIAIi9qITAgMiEnIC8hAQNAICctAAAiLkEgciAuIC5Bv39qQf8BcUEaSRtB/wFxIAFBoMKAgABqLQAARw2EAyABQQFGDfgCIAFBAWohASAnQQFqIicgAkcNAAsgACAwNgIADJ4DC0HLACEqIAEiMiACRg2dAyACIDJrIAAoAgAiL2ohMCAyIScgLyEBAkADQCAnLQAAIi5BIHIgLiAuQb9/akH/AXFBGkkbQf8BcSABQaLCgIAAai0AAEcNhAMgAUEORg0BIAFBAWohASAnQQFqIicgAkcNAAsgACAwNgIADJ4DCyAAQQA2AgAgAEEBOgAsIDIgL2tBD2ohAQz+AgtBzAAhKiABIjIgAkYNnAMgAiAyayAAKAIAIi9qITAgMiEnIC8hAQJAA0AgJy0AACIuQSByIC4gLkG/f2pB/wFxQRpJG0H/AXEgAUHAwoCAAGotAABHDYMDIAFBD0YNASABQQFqIQEgJ0EBaiInIAJHDQALIAAgMDYCAAydAwsgAEEANgIAIABBAzoALCAyIC9rQRBqIQEM/QILQc0AISogASIyIAJGDZsDIAIgMmsgACgCACIvaiEwIDIhJyAvIQECQANAICctAAAiLkEgciAuIC5Bv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw2CAyABQQVGDQEgAUEBaiEBICdBAWoiJyACRw0ACyAAIDA2AgAMnAMLIABBADYCACAAQQQ6ACwgMiAva0EGaiEBDPwCCwJAIAEiJyACRw0AQc4AISoMmwMLAkACQAJAAkAgJy0AACIBQSByIAEgAUG/f2pB/wFxQRpJG0H/AXFBnX9qDhMAhAOEA4QDhAOEA4QDhAOEA4QDhAOEA4QDAYQDhAOEAwIDhAMLICdBAWohAUHBACEqDIQDCyAnQQFqIQFBwgAhKgyDAwsgJ0EBaiEBQcMAISoMggMLICdBAWohAUHEACEqDIEDCwJAIAEiASACRg0AIABBjYCAgAA2AgggACABNgIEIAEhAUHFACEqDIEDC0HPACEqDJkDCyAqIQECQAJAICotAABBdmoOBAGuAq4CAK4CCyAqQQFqIQELQSchKgz/AgsCQCABIgEgAkcNAEHRACEqDJgDCwJAIAEtAABBIEYNACABIQEMjQELIAFBAWohASAALQAtQQFxRQ3JASABIQEMjAELIAEiASACRw3JAUHSACEqDJYDC0HTACEqIAEiMiACRg2VAyACIDJrIAAoAgAiL2ohMCAyIS4gLyEBAkADQCAuLQAAIAFB1sKAgABqLQAARw3PASABQQFGDQEgAUEBaiEBIC5BAWoiLiACRw0ACyAAIDA2AgAMlgMLIABBADYCACAyIC9rQQJqIQEMyQELAkAgASIBIAJHDQBB1QAhKgyVAwsgAS0AAEEKRw3OASABQQFqIQEMyQELAkAgASIBIAJHDQBB1gAhKgyUAwsCQAJAIAEtAABBdmoOBADPAc8BAc8BCyABQQFqIQEMyQELIAFBAWohAUHKACEqDPoCCyAAIAEiASACEK6AgIAAIioNzQEgASEBQc0AISoM+QILIAAtAClBIkYNjAMMrAILAkAgASIBIAJHDQBB2wAhKgyRAwtBACEuQQEhMkEBIS9BACEqAkACQAJAAkACQAJAAkACQAJAIAEtAABBUGoOCtYB1QEAAQIDBAUGCNcBC0ECISoMBgtBAyEqDAULQQQhKgwEC0EFISoMAwtBBiEqDAILQQchKgwBC0EIISoLQQAhMkEAIS9BACEuDM4BC0EJISpBASEuQQAhMkEAIS8MzQELAkAgASIBIAJHDQBB3QAhKgyQAwsgAS0AAEEuRw3OASABQQFqIQEMrAILAkAgASIBIAJHDQBB3wAhKgyPAwtBACEqAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgrXAdYBAAECAwQFBgfYAQtBAiEqDNYBC0EDISoM1QELQQQhKgzUAQtBBSEqDNMBC0EGISoM0gELQQchKgzRAQtBCCEqDNABC0EJISoMzwELAkAgASIBIAJGDQAgAEGOgICAADYCCCAAIAE2AgQgASEBQdAAISoM9QILQeAAISoMjQMLQeEAISogASIyIAJGDYwDIAIgMmsgACgCACIvaiEwIDIhASAvIS4DQCABLQAAIC5B4sKAgABqLQAARw3RASAuQQNGDdABIC5BAWohLiABQQFqIgEgAkcNAAsgACAwNgIADIwDC0HiACEqIAEiMiACRg2LAyACIDJrIAAoAgAiL2ohMCAyIQEgLyEuA0AgAS0AACAuQebCgIAAai0AAEcN0AEgLkECRg3SASAuQQFqIS4gAUEBaiIBIAJHDQALIAAgMDYCAAyLAwtB4wAhKiABIjIgAkYNigMgAiAyayAAKAIAIi9qITAgMiEBIC8hLgNAIAEtAAAgLkHpwoCAAGotAABHDc8BIC5BA0YN0gEgLkEBaiEuIAFBAWoiASACRw0ACyAAIDA2AgAMigMLAkAgASIBIAJHDQBB5QAhKgyKAwsgACABQQFqIgEgAhCogICAACIqDdEBIAEhAUHWACEqDPACCwJAIAEiASACRg0AA0ACQCABLQAAIipBIEYNAAJAAkACQCAqQbh/ag4LAAHTAdMB0wHTAdMB0wHTAdMBAtMBCyABQQFqIQFB0gAhKgz0AgsgAUEBaiEBQdMAISoM8wILIAFBAWohAUHUACEqDPICCyABQQFqIgEgAkcNAAtB5AAhKgyJAwtB5AAhKgyIAwsDQAJAIAEtAABB8MKAgABqLQAAIipBAUYNACAqQX5qDgPTAdQB1QHWAQsgAUEBaiIBIAJHDQALQeYAISoMhwMLAkAgASIBIAJGDQAgAUEBaiEBDAMLQecAISoMhgMLA0ACQCABLQAAQfDEgIAAai0AACIqQQFGDQACQCAqQX5qDgTWAdcB2AEA2QELIAEhAUHXACEqDO4CCyABQQFqIgEgAkcNAAtB6AAhKgyFAwsCQCABIgEgAkcNAEHpACEqDIUDCwJAIAEtAAAiKkF2ag4avAHZAdkBvgHZAdkB2QHZAdkB2QHZAdkB2QHZAdkB2QHZAdkB2QHZAdkB2QHOAdkB2QEA1wELIAFBAWohAQtBBiEqDOoCCwNAAkAgAS0AAEHwxoCAAGotAABBAUYNACABIQEMpQILIAFBAWoiASACRw0AC0HqACEqDIIDCwJAIAEiASACRg0AIAFBAWohAQwDC0HrACEqDIEDCwJAIAEiASACRw0AQewAISoMgQMLIAFBAWohAQwBCwJAIAEiASACRw0AQe0AISoMgAMLIAFBAWohAQtBBCEqDOUCCwJAIAEiLiACRw0AQe4AISoM/gILIC4hAQJAAkACQCAuLQAAQfDIgIAAai0AAEF/ag4H2AHZAdoBAKMCAQLbAQsgLkEBaiEBDAoLIC5BAWohAQzRAQtBACEqIABBADYCHCAAQZuSgIAANgIQIABBBzYCDCAAIC5BAWo2AhQM/QILAkADQAJAIAEtAABB8MiAgABqLQAAIipBBEYNAAJAAkAgKkF/ag4H1gHXAdgB3QEABAHdAQsgASEBQdoAISoM5wILIAFBAWohAUHcACEqDOYCCyABQQFqIgEgAkcNAAtB7wAhKgz9AgsgAUEBaiEBDM8BCwJAIAEiLiACRw0AQfAAISoM/AILIC4tAABBL0cN2AEgLkEBaiEBDAYLAkAgASIuIAJHDQBB8QAhKgz7AgsCQCAuLQAAIgFBL0cNACAuQQFqIQFB3QAhKgziAgsgAUF2aiIBQRZLDdcBQQEgAXRBiYCAAnFFDdcBDNICCwJAIAEiASACRg0AIAFBAWohAUHeACEqDOECC0HyACEqDPkCCwJAIAEiLiACRw0AQfQAISoM+QILIC4hAQJAIC4tAABB8MyAgABqLQAAQX9qDgPRApsCANgBC0HhACEqDN8CCwJAIAEiLiACRg0AA0ACQCAuLQAAQfDKgIAAai0AACIBQQNGDQACQCABQX9qDgLTAgDZAQsgLiEBQd8AISoM4QILIC5BAWoiLiACRw0AC0HzACEqDPgCC0HzACEqDPcCCwJAIAEiASACRg0AIABBj4CAgAA2AgggACABNgIEIAEhAUHgACEqDN4CC0H1ACEqDPYCCwJAIAEiASACRw0AQfYAISoM9gILIABBj4CAgAA2AgggACABNgIEIAEhAQtBAyEqDNsCCwNAIAEtAABBIEcNywIgAUEBaiIBIAJHDQALQfcAISoM8wILAkAgASIBIAJHDQBB+AAhKgzzAgsgAS0AAEEgRw3SASABQQFqIQEM9QELIAAgASIBIAIQrICAgAAiKg3SASABIQEMlQILAkAgASIEIAJHDQBB+gAhKgzxAgsgBC0AAEHMAEcN1QEgBEEBaiEBQRMhKgzTAQsCQCABIiogAkcNAEH7ACEqDPACCyACICprIAAoAgAiLmohMiAqIQQgLiEBA0AgBC0AACABQfDOgIAAai0AAEcN1AEgAUEFRg3SASABQQFqIQEgBEEBaiIEIAJHDQALIAAgMjYCAEH7ACEqDO8CCwJAIAEiBCACRw0AQfwAISoM7wILAkACQCAELQAAQb1/ag4MANUB1QHVAdUB1QHVAdUB1QHVAdUBAdUBCyAEQQFqIQFB5gAhKgzWAgsgBEEBaiEBQecAISoM1QILAkAgASIqIAJHDQBB/QAhKgzuAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQJAA0AgBC0AACABQe3PgIAAai0AAEcN0wEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAyNgIAQf0AISoM7gILIABBADYCACAqIC5rQQNqIQFBECEqDNABCwJAIAEiKiACRw0AQf4AISoM7QILIAIgKmsgACgCACIuaiEyICohBCAuIQECQANAIAQtAAAgAUH2zoCAAGotAABHDdIBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgMjYCAEH+ACEqDO0CCyAAQQA2AgAgKiAua0EGaiEBQRYhKgzPAQsCQCABIiogAkcNAEH/ACEqDOwCCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFB/M6AgABqLQAARw3RASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBB/wAhKgzsAgsgAEEANgIAICogLmtBBGohAUEFISoMzgELAkAgASIEIAJHDQBBgAEhKgzrAgsgBC0AAEHZAEcNzwEgBEEBaiEBQQghKgzNAQsCQCABIgQgAkcNAEGBASEqDOoCCwJAAkAgBC0AAEGyf2oOAwDQAQHQAQsgBEEBaiEBQesAISoM0QILIARBAWohAUHsACEqDNACCwJAIAEiBCACRw0AQYIBISoM6QILAkACQCAELQAAQbh/ag4IAM8BzwHPAc8BzwHPAQHPAQsgBEEBaiEBQeoAISoM0AILIARBAWohAUHtACEqDM8CCwJAIAEiLiACRw0AQYMBISoM6AILIAIgLmsgACgCACIyaiEqIC4hBCAyIQECQANAIAQtAAAgAUGAz4CAAGotAABHDc0BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgKjYCAEGDASEqDOgCC0EAISogAEEANgIAIC4gMmtBA2ohAQzKAQsCQCABIiogAkcNAEGEASEqDOcCCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFBg8+AgABqLQAARw3MASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBhAEhKgznAgsgAEEANgIAICogLmtBBWohAUEjISoMyQELAkAgASIEIAJHDQBBhQEhKgzmAgsCQAJAIAQtAABBtH9qDggAzAHMAcwBzAHMAcwBAcwBCyAEQQFqIQFB7wAhKgzNAgsgBEEBaiEBQfAAISoMzAILAkAgASIEIAJHDQBBhgEhKgzlAgsgBC0AAEHFAEcNyQEgBEEBaiEBDIoCCwJAIAEiKiACRw0AQYcBISoM5AILIAIgKmsgACgCACIuaiEyICohBCAuIQECQANAIAQtAAAgAUGIz4CAAGotAABHDckBIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgMjYCAEGHASEqDOQCCyAAQQA2AgAgKiAua0EEaiEBQS0hKgzGAQsCQCABIiogAkcNAEGIASEqDOMCCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFB0M+AgABqLQAARw3IASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBiAEhKgzjAgsgAEEANgIAICogLmtBCWohAUEpISoMxQELAkAgASIBIAJHDQBBiQEhKgziAgtBASEqIAEtAABB3wBHDcQBIAFBAWohAQyIAgsCQCABIiogAkcNAEGKASEqDOECCyACICprIAAoAgAiLmohMiAqIQQgLiEBA0AgBC0AACABQYzPgIAAai0AAEcNxQEgAUEBRg23AiABQQFqIQEgBEEBaiIEIAJHDQALIAAgMjYCAEGKASEqDOACCwJAIAEiKiACRw0AQYsBISoM4AILIAIgKmsgACgCACIuaiEyICohBCAuIQECQANAIAQtAAAgAUGOz4CAAGotAABHDcUBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgMjYCAEGLASEqDOACCyAAQQA2AgAgKiAua0EDaiEBQQIhKgzCAQsCQCABIiogAkcNAEGMASEqDN8CCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFB8M+AgABqLQAARw3EASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBjAEhKgzfAgsgAEEANgIAICogLmtBAmohAUEfISoMwQELAkAgASIqIAJHDQBBjQEhKgzeAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQJAA0AgBC0AACABQfLPgIAAai0AAEcNwwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAyNgIAQY0BISoM3gILIABBADYCACAqIC5rQQJqIQFBCSEqDMABCwJAIAEiBCACRw0AQY4BISoM3QILAkACQCAELQAAQbd/ag4HAMMBwwHDAcMBwwEBwwELIARBAWohAUH4ACEqDMQCCyAEQQFqIQFB+QAhKgzDAgsCQCABIiogAkcNAEGPASEqDNwCCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFBkc+AgABqLQAARw3BASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBjwEhKgzcAgsgAEEANgIAICogLmtBBmohAUEYISoMvgELAkAgASIqIAJHDQBBkAEhKgzbAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQJAA0AgBC0AACABQZfPgIAAai0AAEcNwAEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAyNgIAQZABISoM2wILIABBADYCACAqIC5rQQNqIQFBFyEqDL0BCwJAIAEiKiACRw0AQZEBISoM2gILIAIgKmsgACgCACIuaiEyICohBCAuIQECQANAIAQtAAAgAUGaz4CAAGotAABHDb8BIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgMjYCAEGRASEqDNoCCyAAQQA2AgAgKiAua0EHaiEBQRUhKgy8AQsCQCABIiogAkcNAEGSASEqDNkCCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFBoc+AgABqLQAARw2+ASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBkgEhKgzZAgsgAEEANgIAICogLmtBBmohAUEeISoMuwELAkAgASIEIAJHDQBBkwEhKgzYAgsgBC0AAEHMAEcNvAEgBEEBaiEBQQohKgy6AQsCQCAEIAJHDQBBlAEhKgzXAgsCQAJAIAQtAABBv39qDg8AvQG9Ab0BvQG9Ab0BvQG9Ab0BvQG9Ab0BvQEBvQELIARBAWohAUH+ACEqDL4CCyAEQQFqIQFB/wAhKgy9AgsCQCAEIAJHDQBBlQEhKgzWAgsCQAJAIAQtAABBv39qDgMAvAEBvAELIARBAWohAUH9ACEqDL0CCyAEQQFqIQRBgAEhKgy8AgsCQCAFIAJHDQBBlgEhKgzVAgsgAiAFayAAKAIAIipqIS4gBSEEICohAQJAA0AgBC0AACABQafPgIAAai0AAEcNugEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQZYBISoM1QILIABBADYCACAFICprQQJqIQFBCyEqDLcBCwJAIAQgAkcNAEGXASEqDNQCCwJAAkACQAJAIAQtAABBU2oOIwC8AbwBvAG8AbwBvAG8AbwBvAG8AbwBvAG8AbwBvAG8AbwBvAG8AbwBvAG8AbwBAbwBvAG8AbwBvAECvAG8AbwBA7wBCyAEQQFqIQFB+wAhKgy9AgsgBEEBaiEBQfwAISoMvAILIARBAWohBEGBASEqDLsCCyAEQQFqIQVBggEhKgy6AgsCQCAGIAJHDQBBmAEhKgzTAgsgAiAGayAAKAIAIipqIS4gBiEEICohAQJAA0AgBC0AACABQanPgIAAai0AAEcNuAEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQZgBISoM0wILIABBADYCACAGICprQQVqIQFBGSEqDLUBCwJAIAcgAkcNAEGZASEqDNICCyACIAdrIAAoAgAiLmohKiAHIQQgLiEBAkADQCAELQAAIAFBrs+AgABqLQAARw23ASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICo2AgBBmQEhKgzSAgsgAEEANgIAQQYhKiAHIC5rQQZqIQEMtAELAkAgCCACRw0AQZoBISoM0QILIAIgCGsgACgCACIqaiEuIAghBCAqIQECQANAIAQtAAAgAUG0z4CAAGotAABHDbYBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEGaASEqDNECCyAAQQA2AgAgCCAqa0ECaiEBQRwhKgyzAQsCQCAJIAJHDQBBmwEhKgzQAgsgAiAJayAAKAIAIipqIS4gCSEEICohAQJAA0AgBC0AACABQbbPgIAAai0AAEcNtQEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQZsBISoM0AILIABBADYCACAJICprQQJqIQFBJyEqDLIBCwJAIAQgAkcNAEGcASEqDM8CCwJAAkAgBC0AAEGsf2oOAgABtQELIARBAWohCEGGASEqDLYCCyAEQQFqIQlBhwEhKgy1AgsCQCAKIAJHDQBBnQEhKgzOAgsgAiAKayAAKAIAIipqIS4gCiEEICohAQJAA0AgBC0AACABQbjPgIAAai0AAEcNswEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQZ0BISoMzgILIABBADYCACAKICprQQJqIQFBJiEqDLABCwJAIAsgAkcNAEGeASEqDM0CCyACIAtrIAAoAgAiKmohLiALIQQgKiEBAkADQCAELQAAIAFBus+AgABqLQAARw2yASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBngEhKgzNAgsgAEEANgIAIAsgKmtBAmohAUEDISoMrwELAkAgDCACRw0AQZ8BISoMzAILIAIgDGsgACgCACIqaiEuIAwhBCAqIQECQANAIAQtAAAgAUHtz4CAAGotAABHDbEBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEGfASEqDMwCCyAAQQA2AgAgDCAqa0EDaiEBQQwhKgyuAQsCQCANIAJHDQBBoAEhKgzLAgsgAiANayAAKAIAIipqIS4gDSEEICohAQJAA0AgBC0AACABQbzPgIAAai0AAEcNsAEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQaABISoMywILIABBADYCACANICprQQRqIQFBDSEqDK0BCwJAIAQgAkcNAEGhASEqDMoCCwJAAkAgBC0AAEG6f2oOCwCwAbABsAGwAbABsAGwAbABsAEBsAELIARBAWohDEGLASEqDLECCyAEQQFqIQ1BjAEhKgywAgsCQCAEIAJHDQBBogEhKgzJAgsgBC0AAEHQAEcNrQEgBEEBaiEEDPABCwJAIAQgAkcNAEGjASEqDMgCCwJAAkAgBC0AAEG3f2oOBwGuAa4BrgGuAa4BAK4BCyAEQQFqIQRBjgEhKgyvAgsgBEEBaiEBQSIhKgyqAQsCQCAOIAJHDQBBpAEhKgzHAgsgAiAOayAAKAIAIipqIS4gDiEEICohAQJAA0AgBC0AACABQcDPgIAAai0AAEcNrAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQaQBISoMxwILIABBADYCACAOICprQQJqIQFBHSEqDKkBCwJAIAQgAkcNAEGlASEqDMYCCwJAAkAgBC0AAEGuf2oOAwCsAQGsAQsgBEEBaiEOQZABISoMrQILIARBAWohAUEEISoMqAELAkAgBCACRw0AQaYBISoMxQILAkACQAJAAkACQCAELQAAQb9/ag4VAK4BrgGuAa4BrgGuAa4BrgGuAa4BAa4BrgECrgGuAQOuAa4BBK4BCyAEQQFqIQRBiAEhKgyvAgsgBEEBaiEKQYkBISoMrgILIARBAWohC0GKASEqDK0CCyAEQQFqIQRBjwEhKgysAgsgBEEBaiEEQZEBISoMqwILAkAgDyACRw0AQacBISoMxAILIAIgD2sgACgCACIqaiEuIA8hBCAqIQECQANAIAQtAAAgAUHtz4CAAGotAABHDakBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEGnASEqDMQCCyAAQQA2AgAgDyAqa0EDaiEBQREhKgymAQsCQCAQIAJHDQBBqAEhKgzDAgsgAiAQayAAKAIAIipqIS4gECEEICohAQJAA0AgBC0AACABQcLPgIAAai0AAEcNqAEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQagBISoMwwILIABBADYCACAQICprQQNqIQFBLCEqDKUBCwJAIBEgAkcNAEGpASEqDMICCyACIBFrIAAoAgAiKmohLiARIQQgKiEBAkADQCAELQAAIAFBxc+AgABqLQAARw2nASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBqQEhKgzCAgsgAEEANgIAIBEgKmtBBWohAUErISoMpAELAkAgEiACRw0AQaoBISoMwQILIAIgEmsgACgCACIqaiEuIBIhBCAqIQECQANAIAQtAAAgAUHKz4CAAGotAABHDaYBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEGqASEqDMECCyAAQQA2AgAgEiAqa0EDaiEBQRQhKgyjAQsCQCAEIAJHDQBBqwEhKgzAAgsCQAJAAkACQCAELQAAQb5/ag4PAAECqAGoAagBqAGoAagBqAGoAagBqAGoAQOoAQsgBEEBaiEPQZMBISoMqQILIARBAWohEEGUASEqDKgCCyAEQQFqIRFBlQEhKgynAgsgBEEBaiESQZYBISoMpgILAkAgBCACRw0AQawBISoMvwILIAQtAABBxQBHDaMBIARBAWohBAznAQsCQCATIAJHDQBBrQEhKgy+AgsgAiATayAAKAIAIipqIS4gEyEEICohAQJAA0AgBC0AACABQc3PgIAAai0AAEcNowEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQa0BISoMvgILIABBADYCACATICprQQNqIQFBDiEqDKABCwJAIAQgAkcNAEGuASEqDL0CCyAELQAAQdAARw2hASAEQQFqIQFBJSEqDJ8BCwJAIBQgAkcNAEGvASEqDLwCCyACIBRrIAAoAgAiKmohLiAUIQQgKiEBAkADQCAELQAAIAFB0M+AgABqLQAARw2hASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBrwEhKgy8AgsgAEEANgIAIBQgKmtBCWohAUEqISoMngELAkAgBCACRw0AQbABISoMuwILAkACQCAELQAAQat/ag4LAKEBoQGhAaEBoQGhAaEBoQGhAQGhAQsgBEEBaiEEQZoBISoMogILIARBAWohFEGbASEqDKECCwJAIAQgAkcNAEGxASEqDLoCCwJAAkAgBC0AAEG/f2oOFACgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEBoAELIARBAWohE0GZASEqDKECCyAEQQFqIQRBnAEhKgygAgsCQCAVIAJHDQBBsgEhKgy5AgsgAiAVayAAKAIAIipqIS4gFSEEICohAQJAA0AgBC0AACABQdnPgIAAai0AAEcNngEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQbIBISoMuQILIABBADYCACAVICprQQRqIQFBISEqDJsBCwJAIBYgAkcNAEGzASEqDLgCCyACIBZrIAAoAgAiKmohLiAWIQQgKiEBAkADQCAELQAAIAFB3c+AgABqLQAARw2dASABQQZGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBswEhKgy4AgsgAEEANgIAIBYgKmtBB2ohAUEaISoMmgELAkAgBCACRw0AQbQBISoMtwILAkACQAJAIAQtAABBu39qDhEAngGeAZ4BngGeAZ4BngGeAZ4BAZ4BngGeAZ4BngECngELIARBAWohBEGdASEqDJ8CCyAEQQFqIRVBngEhKgyeAgsgBEEBaiEWQZ8BISoMnQILAkAgFyACRw0AQbUBISoMtgILIAIgF2sgACgCACIqaiEuIBchBCAqIQECQANAIAQtAAAgAUHkz4CAAGotAABHDZsBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEG1ASEqDLYCCyAAQQA2AgAgFyAqa0EGaiEBQSghKgyYAQsCQCAYIAJHDQBBtgEhKgy1AgsgAiAYayAAKAIAIipqIS4gGCEEICohAQJAA0AgBC0AACABQerPgIAAai0AAEcNmgEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQbYBISoMtQILIABBADYCACAYICprQQNqIQFBByEqDJcBCwJAIAQgAkcNAEG3ASEqDLQCCwJAAkAgBC0AAEG7f2oODgCaAZoBmgGaAZoBmgGaAZoBmgGaAZoBmgEBmgELIARBAWohF0GhASEqDJsCCyAEQQFqIRhBogEhKgyaAgsCQCAZIAJHDQBBuAEhKgyzAgsgAiAZayAAKAIAIipqIS4gGSEEICohAQJAA0AgBC0AACABQe3PgIAAai0AAEcNmAEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQbgBISoMswILIABBADYCACAZICprQQNqIQFBEiEqDJUBCwJAIBogAkcNAEG5ASEqDLICCyACIBprIAAoAgAiKmohLiAaIQQgKiEBAkADQCAELQAAIAFB8M+AgABqLQAARw2XASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBuQEhKgyyAgsgAEEANgIAIBogKmtBAmohAUEgISoMlAELAkAgGyACRw0AQboBISoMsQILIAIgG2sgACgCACIqaiEuIBshBCAqIQECQANAIAQtAAAgAUHyz4CAAGotAABHDZYBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEG6ASEqDLECCyAAQQA2AgAgGyAqa0ECaiEBQQ8hKgyTAQsCQCAEIAJHDQBBuwEhKgywAgsCQAJAIAQtAABBt39qDgcAlgGWAZYBlgGWAQGWAQsgBEEBaiEaQaUBISoMlwILIARBAWohG0GmASEqDJYCCwJAIBwgAkcNAEG8ASEqDK8CCyACIBxrIAAoAgAiKmohLiAcIQQgKiEBAkADQCAELQAAIAFB9M+AgABqLQAARw2UASABQQdGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBvAEhKgyvAgsgAEEANgIAIBwgKmtBCGohAUEbISoMkQELAkAgBCACRw0AQb0BISoMrgILAkACQAJAIAQtAABBvn9qDhIAlQGVAZUBlQGVAZUBlQGVAZUBAZUBlQGVAZUBlQGVAQKVAQsgBEEBaiEZQaQBISoMlgILIARBAWohBEGnASEqDJUCCyAEQQFqIRxBqAEhKgyUAgsCQCAEIAJHDQBBvgEhKgytAgsgBC0AAEHOAEcNkQEgBEEBaiEEDNYBCwJAIAQgAkcNAEG/ASEqDKwCCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAQtAABBv39qDhUAAQIDoAEEBQagAaABoAEHCAkKC6ABDA0OD6ABCyAEQQFqIQFB6AAhKgyhAgsgBEEBaiEBQekAISoMoAILIARBAWohAUHuACEqDJ8CCyAEQQFqIQFB8gAhKgyeAgsgBEEBaiEBQfMAISoMnQILIARBAWohAUH2ACEqDJwCCyAEQQFqIQFB9wAhKgybAgsgBEEBaiEBQfoAISoMmgILIARBAWohBEGDASEqDJkCCyAEQQFqIQZBhAEhKgyYAgsgBEEBaiEHQYUBISoMlwILIARBAWohBEGSASEqDJYCCyAEQQFqIQRBmAEhKgyVAgsgBEEBaiEEQaABISoMlAILIARBAWohBEGjASEqDJMCCyAEQQFqIQRBqgEhKgySAgsCQCAEIAJGDQAgAEGQgICAADYCCCAAIAQ2AgRBqwEhKgySAgtBwAEhKgyqAgsgACAdIAIQqoCAgAAiAQ2PASAdIQEMXgsCQCAeIAJGDQAgHkEBaiEdDJEBC0HCASEqDKgCCwNAAkAgKi0AAEF2ag4EkAEAAJMBAAsgKkEBaiIqIAJHDQALQcMBISoMpwILAkAgHyACRg0AIABBkYCAgAA2AgggACAfNgIEIB8hAUEBISoMjgILQcQBISoMpgILAkAgHyACRw0AQcUBISoMpgILAkACQCAfLQAAQXZqDgQB1QHVAQDVAQsgH0EBaiEeDJEBCyAfQQFqIR0MjQELAkAgHyACRw0AQcYBISoMpQILAkACQCAfLQAAQXZqDhcBkwGTAQGTAZMBkwGTAZMBkwGTAZMBkwGTAZMBkwGTAZMBkwGTAZMBkwEAkwELIB9BAWohHwtBsAEhKgyLAgsCQCAgIAJHDQBByAEhKgykAgsgIC0AAEEgRw2RASAAQQA7ATIgIEEBaiEBQbMBISoMigILIAEhMgJAA0AgMiIfIAJGDQEgHy0AAEFQakH/AXEiKkEKTw3TAQJAIAAvATIiLkGZM0sNACAAIC5BCmwiLjsBMiAqQf//A3MgLkH+/wNxSQ0AIB9BAWohMiAAIC4gKmoiKjsBMiAqQf//A3FB6AdJDQELC0EAISogAEEANgIcIABBwYmAgAA2AhAgAEENNgIMIAAgH0EBajYCFAyjAgtBxwEhKgyiAgsgACAgIAIQroCAgAAiKkUN0QEgKkEVRw2QASAAQcgBNgIcIAAgIDYCFCAAQcmXgIAANgIQIABBFTYCDEEAISoMoQILAkAgISACRw0AQcwBISoMoQILQQAhLkEBITJBASEvQQAhKgJAAkACQAJAAkACQAJAAkACQCAhLQAAQVBqDgqaAZkBAAECAwQFBgibAQtBAiEqDAYLQQMhKgwFC0EEISoMBAtBBSEqDAMLQQYhKgwCC0EHISoMAQtBCCEqC0EAITJBACEvQQAhLgySAQtBCSEqQQEhLkEAITJBACEvDJEBCwJAICIgAkcNAEHOASEqDKACCyAiLQAAQS5HDZIBICJBAWohIQzRAQsCQCAjIAJHDQBB0AEhKgyfAgtBACEqAkACQAJAAkACQAJAAkACQCAjLQAAQVBqDgqbAZoBAAECAwQFBgecAQtBAiEqDJoBC0EDISoMmQELQQQhKgyYAQtBBSEqDJcBC0EGISoMlgELQQchKgyVAQtBCCEqDJQBC0EJISoMkwELAkAgIyACRg0AIABBjoCAgAA2AgggACAjNgIEQbcBISoMhQILQdEBISoMnQILAkAgBCACRw0AQdIBISoMnQILIAIgBGsgACgCACIuaiEyIAQhIyAuISoDQCAjLQAAICpB/M+AgABqLQAARw2UASAqQQRGDfEBICpBAWohKiAjQQFqIiMgAkcNAAsgACAyNgIAQdIBISoMnAILIAAgJCACEKyAgIAAIgENkwEgJCEBDL8BCwJAICUgAkcNAEHUASEqDJsCCyACICVrIAAoAgAiJGohLiAlIQQgJCEqA0AgBC0AACAqQYHQgIAAai0AAEcNlQEgKkEBRg2UASAqQQFqISogBEEBaiIEIAJHDQALIAAgLjYCAEHUASEqDJoCCwJAICYgAkcNAEHWASEqDJoCCyACICZrIAAoAgAiI2ohLiAmIQQgIyEqA0AgBC0AACAqQYPQgIAAai0AAEcNlAEgKkECRg2WASAqQQFqISogBEEBaiIEIAJHDQALIAAgLjYCAEHWASEqDJkCCwJAIAQgAkcNAEHXASEqDJkCCwJAAkAgBC0AAEG7f2oOEACVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBAZUBCyAEQQFqISVBuwEhKgyAAgsgBEEBaiEmQbwBISoM/wELAkAgBCACRw0AQdgBISoMmAILIAQtAABByABHDZIBIARBAWohBAzMAQsCQCAEIAJGDQAgAEGQgICAADYCCCAAIAQ2AgRBvgEhKgz+AQtB2QEhKgyWAgsCQCAEIAJHDQBB2gEhKgyWAgsgBC0AAEHIAEYNywEgAEEBOgAoDMABCyAAQQI6AC8gACAEIAIQpoCAgAAiKg2TAUHCASEqDPsBCyAALQAoQX9qDgK+AcABvwELA0ACQCAELQAAQXZqDgQAlAGUAQCUAQsgBEEBaiIEIAJHDQALQd0BISoMkgILIABBADoALyAALQAtQQRxRQ2LAgsgAEEAOgAvIABBAToANCABIQEMkgELICpBFUYN4gEgAEEANgIcIAAgATYCFCAAQaeOgIAANgIQIABBEjYCDEEAISoMjwILAkAgACAqIAIQtICAgAAiAQ0AICohAQyIAgsCQCABQRVHDQAgAEEDNgIcIAAgKjYCFCAAQbCYgIAANgIQIABBFTYCDEEAISoMjwILIABBADYCHCAAICo2AhQgAEGnjoCAADYCECAAQRI2AgxBACEqDI4CCyAqQRVGDd4BIABBADYCHCAAIAE2AhQgAEHajYCAADYCECAAQRQ2AgxBACEqDI0CCyAAKAIEITIgAEEANgIEICogK6dqIi8hASAAIDIgKiAvIC4bIioQtYCAgAAiLkUNkwEgAEEHNgIcIAAgKjYCFCAAIC42AgxBACEqDIwCCyAAIAAvATBBgAFyOwEwIAEhAQtBKiEqDPEBCyAqQRVGDdkBIABBADYCHCAAIAE2AhQgAEGDjICAADYCECAAQRM2AgxBACEqDIkCCyAqQRVGDdcBIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEqDIgCCyAAKAIEISogAEEANgIEAkAgACAqIAEQt4CAgAAiKg0AIAFBAWohAQyTAQsgAEEMNgIcIAAgKjYCDCAAIAFBAWo2AhRBACEqDIcCCyAqQRVGDdQBIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEqDIYCCyAAKAIEISogAEEANgIEAkAgACAqIAEQt4CAgAAiKg0AIAFBAWohAQySAQsgAEENNgIcIAAgKjYCDCAAIAFBAWo2AhRBACEqDIUCCyAqQRVGDdEBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEqDIQCCyAAKAIEISogAEEANgIEAkAgACAqIAEQuYCAgAAiKg0AIAFBAWohAQyRAQsgAEEONgIcIAAgKjYCDCAAIAFBAWo2AhRBACEqDIMCCyAAQQA2AhwgACABNgIUIABBwJWAgAA2AhAgAEECNgIMQQAhKgyCAgsgKkEVRg3NASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhKgyBAgsgAEEQNgIcIAAgATYCFCAAICo2AgxBACEqDIACCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQz4AQsgAEERNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEqDP8BCyAqQRVGDckBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEqDP4BCyAAKAIEISogAEEANgIEAkAgACAqIAEQuYCAgAAiKg0AIAFBAWohAQyOAQsgAEETNgIcIAAgKjYCDCAAIAFBAWo2AhRBACEqDP0BCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQz0AQsgAEEUNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEqDPwBCyAqQRVGDcUBIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEqDPsBCyAAKAIEISogAEEANgIEAkAgACAqIAEQt4CAgAAiKg0AIAFBAWohAQyMAQsgAEEWNgIcIAAgKjYCDCAAIAFBAWo2AhRBACEqDPoBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQt4CAgAAiBA0AIAFBAWohAQzwAQsgAEEXNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEqDPkBCyAAQQA2AhwgACABNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhKgz4AQtCASErCyAqQQFqIQECQCAAKQMgIixC//////////8PVg0AIAAgLEIEhiArhDcDICABIQEMigELIABBADYCHCAAIAE2AhQgAEGtiYCAADYCECAAQQw2AgxBACEqDPYBCyAAQQA2AhwgACAqNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhKgz1AQsgACgCBCEyIABBADYCBCAqICunaiIvIQEgACAyICogLyAuGyIqELWAgIAAIi5FDXkgAEEFNgIcIAAgKjYCFCAAIC42AgxBACEqDPQBCyAAQQA2AhwgACAqNgIUIABBqpyAgAA2AhAgAEEPNgIMQQAhKgzzAQsgACAqIAIQtICAgAAiAQ0BICohAQtBDiEqDNgBCwJAIAFBFUcNACAAQQI2AhwgACAqNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhKgzxAQsgAEEANgIcIAAgKjYCFCAAQaeOgIAANgIQIABBEjYCDEEAISoM8AELIAFBAWohKgJAIAAvATAiAUGAAXFFDQACQCAAICogAhC7gICAACIBDQAgKiEBDHYLIAFBFUcNwgEgAEEFNgIcIAAgKjYCFCAAQfmXgIAANgIQIABBFTYCDEEAISoM8AELAkAgAUGgBHFBoARHDQAgAC0ALUECcQ0AIABBADYCHCAAICo2AhQgAEGWk4CAADYCECAAQQQ2AgxBACEqDPABCyAAICogAhC9gICAABogKiEBAkACQAJAAkACQCAAICogAhCzgICAAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIABBAToALgsgACAALwEwQcAAcjsBMCAqIQELQSYhKgzYAQsgAEEjNgIcIAAgKjYCFCAAQaWWgIAANgIQIABBFTYCDEEAISoM8AELIABBADYCHCAAICo2AhQgAEHVi4CAADYCECAAQRE2AgxBACEqDO8BCyAALQAtQQFxRQ0BQcMBISoM1QELAkAgJyACRg0AA0ACQCAnLQAAQSBGDQAgJyEBDNEBCyAnQQFqIicgAkcNAAtBJSEqDO4BC0ElISoM7QELIAAoAgQhASAAQQA2AgQgACABICcQr4CAgAAiAUUNtQEgAEEmNgIcIAAgATYCDCAAICdBAWo2AhRBACEqDOwBCyAqQRVGDbMBIABBADYCHCAAIAE2AhQgAEH9jYCAADYCECAAQR02AgxBACEqDOsBCyAAQSc2AhwgACABNgIUIAAgKjYCDEEAISoM6gELICohAUEBIS4CQAJAAkACQAJAAkACQCAALQAsQX5qDgcGBQUDAQIABQsgACAALwEwQQhyOwEwDAMLQQIhLgwBC0EEIS4LIABBAToALCAAIAAvATAgLnI7ATALICohAQtBKyEqDNEBCyAAQQA2AhwgACAqNgIUIABBq5KAgAA2AhAgAEELNgIMQQAhKgzpAQsgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDEEAISoM6AELIABBADoALCAqIQEMwgELICohAUEBIS4CQAJAAkACQAJAIAAtACxBe2oOBAMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEuDAELQQQhLgsgAEEBOgAsIAAgAC8BMCAucjsBMAsgKiEBC0EpISoMzAELIABBADYCHCAAIAE2AhQgAEHwlICAADYCECAAQQM2AgxBACEqDOQBCwJAICgtAABBDUcNACAAKAIEIQEgAEEANgIEAkAgACABICgQsYCAgAAiAQ0AIChBAWohAQx7CyAAQSw2AhwgACABNgIMIAAgKEEBajYCFEEAISoM5AELIAAtAC1BAXFFDQFBxAEhKgzKAQsCQCAoIAJHDQBBLSEqDOMBCwJAAkADQAJAICgtAABBdmoOBAIAAAMACyAoQQFqIiggAkcNAAtBLSEqDOQBCyAAKAIEIQEgAEEANgIEAkAgACABICgQsYCAgAAiAQ0AICghAQx6CyAAQSw2AhwgACAoNgIUIAAgATYCDEEAISoM4wELIAAoAgQhASAAQQA2AgQCQCAAIAEgKBCxgICAACIBDQAgKEEBaiEBDHkLIABBLDYCHCAAIAE2AgwgACAoQQFqNgIUQQAhKgziAQsgACgCBCEBIABBADYCBCAAIAEgKBCxgICAACIBDagBICghAQzVAQsgKkEsRw0BIAFBAWohKkEBIQECQAJAAkACQAJAIAAtACxBe2oOBAMBAgQACyAqIQEMBAtBAiEBDAELQQQhAQsgAEEBOgAsIAAgAC8BMCABcjsBMCAqIQEMAQsgACAALwEwQQhyOwEwICohAQtBOSEqDMYBCyAAQQA6ACwgASEBC0E0ISoMxAELIABBADYCACAvIDBrQQlqIQFBBSEqDL8BCyAAQQA2AgAgLyAwa0EGaiEBQQchKgy+AQsgACAALwEwQSByOwEwIAEhAQwCCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBA0AIAEhAQzMAQsgAEE3NgIcIAAgATYCFCAAIAQ2AgxBACEqDNkBCyAAQQg6ACwgASEBC0EwISoMvgELAkAgAC0AKEEBRg0AIAEhAQwECyAALQAtQQhxRQ2ZASABIQEMAwsgAC0AMEEgcQ2aAUHFASEqDLwBCwJAICkgAkYNAAJAA0ACQCApLQAAQVBqIgFB/wFxQQpJDQAgKSEBQTUhKgy/AQsgACkDICIrQpmz5syZs+bMGVYNASAAICtCCn4iKzcDICArIAGtIixCf4VCgH6EVg0BIAAgKyAsQv8Bg3w3AyAgKUEBaiIpIAJHDQALQTkhKgzWAQsgACgCBCEEIABBADYCBCAAIAQgKUEBaiIBELGAgIAAIgQNmwEgASEBDMgBC0E5ISoM1AELAkAgAC8BMCIBQQhxRQ0AIAAtAChBAUcNACAALQAtQQhxRQ2WAQsgACABQff7A3FBgARyOwEwICkhAQtBNyEqDLkBCyAAIAAvATBBEHI7ATAMrgELICpBFUYNkQEgAEEANgIcIAAgATYCFCAAQfCOgIAANgIQIABBHDYCDEEAISoM0AELIABBwwA2AhwgACABNgIMIAAgJ0EBajYCFEEAISoMzwELAkAgAS0AAEE6Rw0AIAAoAgQhKiAAQQA2AgQCQCAAICogARCvgICAACIqDQAgAUEBaiEBDGcLIABBwwA2AhwgACAqNgIMIAAgAUEBajYCFEEAISoMzwELIABBADYCHCAAIAE2AhQgAEGxkYCAADYCECAAQQo2AgxBACEqDM4BCyAAQQA2AhwgACABNgIUIABBoJmAgAA2AhAgAEEeNgIMQQAhKgzNAQsgAUEBaiEBCyAAQYASOwEqIAAgASACEKiAgIAAIioNASABIQELQccAISoMsQELICpBFUcNiQEgAEHRADYCHCAAIAE2AhQgAEHjl4CAADYCECAAQRU2AgxBACEqDMkBCyAAKAIEISogAEEANgIEAkAgACAqIAEQp4CAgAAiKg0AIAEhAQxiCyAAQdIANgIcIAAgATYCFCAAICo2AgxBACEqDMgBCyAAQQA2AhwgACAuNgIUIABBwaiAgAA2AhAgAEEHNgIMIABBADYCAEEAISoMxwELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDGELIABB0wA2AhwgACABNgIUIAAgKjYCDEEAISoMxgELQQAhKiAAQQA2AhwgACABNgIUIABBgJGAgAA2AhAgAEEJNgIMDMUBCyAqQRVGDYMBIABBADYCHCAAIAE2AhQgAEGUjYCAADYCECAAQSE2AgxBACEqDMQBC0EBIS9BACEyQQAhLkEBISoLIAAgKjoAKyABQQFqIQECQAJAIAAtAC1BEHENAAJAAkACQCAALQAqDgMBAAIECyAvRQ0DDAILIC4NAQwCCyAyRQ0BCyAAKAIEISogAEEANgIEAkAgACAqIAEQrYCAgAAiKg0AIAEhAQxgCyAAQdgANgIcIAAgATYCFCAAICo2AgxBACEqDMMBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQyyAQsgAEHZADYCHCAAIAE2AhQgACAENgIMQQAhKgzCAQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMsAELIABB2gA2AhwgACABNgIUIAAgBDYCDEEAISoMwQELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDK4BCyAAQdwANgIcIAAgATYCFCAAIAQ2AgxBACEqDMABC0EBISoLIAAgKjoAKiABQQFqIQEMXAsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMqgELIABB3gA2AhwgACABNgIUIAAgBDYCDEEAISoMvQELIABBADYCACAyIC9rQQRqIQECQCAALQApQSNPDQAgASEBDFwLIABBADYCHCAAIAE2AhQgAEHTiYCAADYCECAAQQg2AgxBACEqDLwBCyAAQQA2AgALQQAhKiAAQQA2AhwgACABNgIUIABBkLOAgAA2AhAgAEEINgIMDLoBCyAAQQA2AgAgMiAva0EDaiEBAkAgAC0AKUEhRw0AIAEhAQxZCyAAQQA2AhwgACABNgIUIABBm4qAgAA2AhAgAEEINgIMQQAhKgy5AQsgAEEANgIAIDIgL2tBBGohAQJAIAAtACkiKkFdakELTw0AIAEhAQxYCwJAICpBBksNAEEBICp0QcoAcUUNACABIQEMWAtBACEqIABBADYCHCAAIAE2AhQgAEH3iYCAADYCECAAQQg2AgwMuAELICpBFUYNdSAAQQA2AhwgACABNgIUIABBuY2AgAA2AhAgAEEaNgIMQQAhKgy3AQsgACgCBCEqIABBADYCBAJAIAAgKiABEKeAgIAAIioNACABIQEMVwsgAEHlADYCHCAAIAE2AhQgACAqNgIMQQAhKgy2AQsgACgCBCEqIABBADYCBAJAIAAgKiABEKeAgIAAIioNACABIQEMTwsgAEHSADYCHCAAIAE2AhQgACAqNgIMQQAhKgy1AQsgACgCBCEqIABBADYCBAJAIAAgKiABEKeAgIAAIioNACABIQEMTwsgAEHTADYCHCAAIAE2AhQgACAqNgIMQQAhKgy0AQsgACgCBCEqIABBADYCBAJAIAAgKiABEKeAgIAAIioNACABIQEMVAsgAEHlADYCHCAAIAE2AhQgACAqNgIMQQAhKgyzAQsgAEEANgIcIAAgATYCFCAAQcaKgIAANgIQIABBBzYCDEEAISoMsgELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDEsLIABB0gA2AhwgACABNgIUIAAgKjYCDEEAISoMsQELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDEsLIABB0wA2AhwgACABNgIUIAAgKjYCDEEAISoMsAELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDFALIABB5QA2AhwgACABNgIUIAAgKjYCDEEAISoMrwELIABBADYCHCAAIAE2AhQgAEHciICAADYCECAAQQc2AgxBACEqDK4BCyAqQT9HDQEgAUEBaiEBC0EFISoMkwELQQAhKiAAQQA2AhwgACABNgIUIABB/ZKAgAA2AhAgAEEHNgIMDKsBCyAAKAIEISogAEEANgIEAkAgACAqIAEQp4CAgAAiKg0AIAEhAQxECyAAQdIANgIcIAAgATYCFCAAICo2AgxBACEqDKoBCyAAKAIEISogAEEANgIEAkAgACAqIAEQp4CAgAAiKg0AIAEhAQxECyAAQdMANgIcIAAgATYCFCAAICo2AgxBACEqDKkBCyAAKAIEISogAEEANgIEAkAgACAqIAEQp4CAgAAiKg0AIAEhAQxJCyAAQeUANgIcIAAgATYCFCAAICo2AgxBACEqDKgBCyAAKAIEIQEgAEEANgIEAkAgACABIC4Qp4CAgAAiAQ0AIC4hAQxBCyAAQdIANgIcIAAgLjYCFCAAIAE2AgxBACEqDKcBCyAAKAIEIQEgAEEANgIEAkAgACABIC4Qp4CAgAAiAQ0AIC4hAQxBCyAAQdMANgIcIAAgLjYCFCAAIAE2AgxBACEqDKYBCyAAKAIEIQEgAEEANgIEAkAgACABIC4Qp4CAgAAiAQ0AIC4hAQxGCyAAQeUANgIcIAAgLjYCFCAAIAE2AgxBACEqDKUBCyAAQQA2AhwgACAuNgIUIABBw4+AgAA2AhAgAEEHNgIMQQAhKgykAQsgAEEANgIcIAAgATYCFCAAQcOPgIAANgIQIABBBzYCDEEAISoMowELQQAhKiAAQQA2AhwgACAuNgIUIABBjJyAgAA2AhAgAEEHNgIMDKIBCyAAQQA2AhwgACAuNgIUIABBjJyAgAA2AhAgAEEHNgIMQQAhKgyhAQsgAEEANgIcIAAgLjYCFCAAQf6RgIAANgIQIABBBzYCDEEAISoMoAELIABBADYCHCAAIAE2AhQgAEGOm4CAADYCECAAQQY2AgxBACEqDJ8BCyAqQRVGDVsgAEEANgIcIAAgATYCFCAAQcyOgIAANgIQIABBIDYCDEEAISoMngELIABBADYCACAqIC5rQQZqIQFBJCEqCyAAICo6ACkgACgCBCEqIABBADYCBCAAICogARCrgICAACIqDVggASEBDEELIABBADYCAAtBACEqIABBADYCHCAAIAQ2AhQgAEHxm4CAADYCECAAQQY2AgwMmgELIAFBFUYNVCAAQQA2AhwgACAdNgIUIABB8IyAgAA2AhAgAEEbNgIMQQAhKgyZAQsgACgCBCEdIABBADYCBCAAIB0gKhCpgICAACIdDQEgKkEBaiEdC0GtASEqDH4LIABBwQE2AhwgACAdNgIMIAAgKkEBajYCFEEAISoMlgELIAAoAgQhHiAAQQA2AgQgACAeICoQqYCAgAAiHg0BICpBAWohHgtBrgEhKgx7CyAAQcIBNgIcIAAgHjYCDCAAICpBAWo2AhRBACEqDJMBCyAAQQA2AhwgACAfNgIUIABBl4uAgAA2AhAgAEENNgIMQQAhKgySAQsgAEEANgIcIAAgIDYCFCAAQeOQgIAANgIQIABBCTYCDEEAISoMkQELIABBADYCHCAAICA2AhQgAEGUjYCAADYCECAAQSE2AgxBACEqDJABC0EBIS9BACEyQQAhLkEBISoLIAAgKjoAKyAhQQFqISACQAJAIAAtAC1BEHENAAJAAkACQCAALQAqDgMBAAIECyAvRQ0DDAILIC4NAQwCCyAyRQ0BCyAAKAIEISogAEEANgIEIAAgKiAgEK2AgIAAIipFDUAgAEHJATYCHCAAICA2AhQgACAqNgIMQQAhKgyPAQsgACgCBCEBIABBADYCBCAAIAEgIBCtgICAACIBRQ15IABBygE2AhwgACAgNgIUIAAgATYCDEEAISoMjgELIAAoAgQhASAAQQA2AgQgACABICEQrYCAgAAiAUUNdyAAQcsBNgIcIAAgITYCFCAAIAE2AgxBACEqDI0BCyAAKAIEIQEgAEEANgIEIAAgASAiEK2AgIAAIgFFDXUgAEHNATYCHCAAICI2AhQgACABNgIMQQAhKgyMAQtBASEqCyAAICo6ACogI0EBaiEiDD0LIAAoAgQhASAAQQA2AgQgACABICMQrYCAgAAiAUUNcSAAQc8BNgIcIAAgIzYCFCAAIAE2AgxBACEqDIkBCyAAQQA2AhwgACAjNgIUIABBkLOAgAA2AhAgAEEINgIMIABBADYCAEEAISoMiAELIAFBFUYNQSAAQQA2AhwgACAkNgIUIABBzI6AgAA2AhAgAEEgNgIMQQAhKgyHAQsgAEEANgIAIABBgQQ7ASggACgCBCEqIABBADYCBCAAICogJSAka0ECaiIkEKuAgIAAIipFDTogAEHTATYCHCAAICQ2AhQgACAqNgIMQQAhKgyGAQsgAEEANgIAC0EAISogAEEANgIcIAAgBDYCFCAAQdibgIAANgIQIABBCDYCDAyEAQsgAEEANgIAIAAoAgQhKiAAQQA2AgQgACAqICYgI2tBA2oiIxCrgICAACIqDQFBxgEhKgxqCyAAQQI6ACgMVwsgAEHVATYCHCAAICM2AhQgACAqNgIMQQAhKgyBAQsgKkEVRg05IABBADYCHCAAIAQ2AhQgAEGkjICAADYCECAAQRA2AgxBACEqDIABCyAALQA0QQFHDTYgACAEIAIQvICAgAAiKkUNNiAqQRVHDTcgAEHcATYCHCAAIAQ2AhQgAEHVloCAADYCECAAQRU2AgxBACEqDH8LQQAhKiAAQQA2AhwgAEGvi4CAADYCECAAQQI2AgwgACAuQQFqNgIUDH4LQQAhKgxkC0ECISoMYwtBDSEqDGILQQ8hKgxhC0ElISoMYAtBEyEqDF8LQRUhKgxeC0EWISoMXQtBFyEqDFwLQRghKgxbC0EZISoMWgtBGiEqDFkLQRshKgxYC0EcISoMVwtBHSEqDFYLQR8hKgxVC0EhISoMVAtBIyEqDFMLQcYAISoMUgtBLiEqDFELQS8hKgxQC0E7ISoMTwtBPSEqDE4LQcgAISoMTQtByQAhKgxMC0HLACEqDEsLQcwAISoMSgtBzgAhKgxJC0HPACEqDEgLQdEAISoMRwtB1QAhKgxGC0HYACEqDEULQdkAISoMRAtB2wAhKgxDC0HkACEqDEILQeUAISoMQQtB8QAhKgxAC0H0ACEqDD8LQY0BISoMPgtBlwEhKgw9C0GpASEqDDwLQawBISoMOwtBwAEhKgw6C0G5ASEqDDkLQa8BISoMOAtBsQEhKgw3C0GyASEqDDYLQbQBISoMNQtBtQEhKgw0C0G2ASEqDDMLQboBISoMMgtBvQEhKgwxC0G/ASEqDDALQcEBISoMLwsgAEEANgIcIAAgBDYCFCAAQemLgIAANgIQIABBHzYCDEEAISoMRwsgAEHbATYCHCAAIAQ2AhQgAEH6loCAADYCECAAQRU2AgxBACEqDEYLIABB+AA2AhwgACAkNgIUIABBypiAgAA2AhAgAEEVNgIMQQAhKgxFCyAAQdEANgIcIAAgHTYCFCAAQbCXgIAANgIQIABBFTYCDEEAISoMRAsgAEH5ADYCHCAAIAE2AhQgACAqNgIMQQAhKgxDCyAAQfgANgIcIAAgATYCFCAAQcqYgIAANgIQIABBFTYCDEEAISoMQgsgAEHkADYCHCAAIAE2AhQgAEHjl4CAADYCECAAQRU2AgxBACEqDEELIABB1wA2AhwgACABNgIUIABByZeAgAA2AhAgAEEVNgIMQQAhKgxACyAAQQA2AhwgACABNgIUIABBuY2AgAA2AhAgAEEaNgIMQQAhKgw/CyAAQcIANgIcIAAgATYCFCAAQeOYgIAANgIQIABBFTYCDEEAISoMPgsgAEEANgIEIAAgKSApELGAgIAAIgFFDQEgAEE6NgIcIAAgATYCDCAAIClBAWo2AhRBACEqDD0LIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCxgICAACIERQ0AIABBOzYCHCAAIAQ2AgwgACABQQFqNgIUQQAhKgw9CyABQQFqIQEMLAsgKUEBaiEBDCwLIABBADYCHCAAICk2AhQgAEHkkoCAADYCECAAQQQ2AgxBACEqDDoLIABBNjYCHCAAIAE2AhQgACAENgIMQQAhKgw5CyAAQS42AhwgACAoNgIUIAAgATYCDEEAISoMOAsgAEHQADYCHCAAIAE2AhQgAEGRmICAADYCECAAQRU2AgxBACEqDDcLICdBAWohAQwrCyAAQRU2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhKgw1CyAAQRs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhKgw0CyAAQQ82AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhKgwzCyAAQQs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhKgwyCyAAQRo2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhKgwxCyAAQQs2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhKgwwCyAAQQo2AhwgACABNgIUIABB5JaAgAA2AhAgAEEVNgIMQQAhKgwvCyAAQR42AhwgACABNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhKgwuCyAAQQA2AhwgACAqNgIUIABB2o2AgAA2AhAgAEEUNgIMQQAhKgwtCyAAQQQ2AhwgACABNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhKgwsCyAAQQA2AgAgBCAua0EFaiEjC0G4ASEqDBELIABBADYCACAqIC5rQQJqIQFB9QAhKgwQCyABIQECQCAALQApQQVHDQBB4wAhKgwQC0HiACEqDA8LQQAhKiAAQQA2AhwgAEHkkYCAADYCECAAQQc2AgwgACAuQQFqNgIUDCcLIABBADYCACAyIC9rQQJqIQFBwAAhKgwNCyABIQELQTghKgwLCwJAIAEiKSACRg0AA0ACQCApLQAAQYC+gIAAai0AACIBQQFGDQAgAUECRw0DIClBAWohAQwECyApQQFqIikgAkcNAAtBPiEqDCQLQT4hKgwjCyAAQQA6ACwgKSEBDAELQQshKgwIC0E6ISoMBwsgAUEBaiEBQS0hKgwGC0EoISoMBQsgAEEANgIAIC8gMGtBBGohAUEGISoLIAAgKjoALCABIQFBDCEqDAMLIABBADYCACAyIC9rQQdqIQFBCiEqDAILIABBADYCAAsgAEEAOgAsICchAUEJISoMAAsLQQAhKiAAQQA2AhwgACAjNgIUIABBzZCAgAA2AhAgAEEJNgIMDBcLQQAhKiAAQQA2AhwgACAiNgIUIABB6YqAgAA2AhAgAEEJNgIMDBYLQQAhKiAAQQA2AhwgACAhNgIUIABBt5CAgAA2AhAgAEEJNgIMDBULQQAhKiAAQQA2AhwgACAgNgIUIABBnJGAgAA2AhAgAEEJNgIMDBQLQQAhKiAAQQA2AhwgACABNgIUIABBzZCAgAA2AhAgAEEJNgIMDBMLQQAhKiAAQQA2AhwgACABNgIUIABB6YqAgAA2AhAgAEEJNgIMDBILQQAhKiAAQQA2AhwgACABNgIUIABBt5CAgAA2AhAgAEEJNgIMDBELQQAhKiAAQQA2AhwgACABNgIUIABBnJGAgAA2AhAgAEEJNgIMDBALQQAhKiAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA8LQQAhKiAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA4LQQAhKiAAQQA2AhwgACABNgIUIABBwJKAgAA2AhAgAEELNgIMDA0LQQAhKiAAQQA2AhwgACABNgIUIABBlYmAgAA2AhAgAEELNgIMDAwLQQAhKiAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMDAsLQQAhKiAAQQA2AhwgACABNgIUIABB+4+AgAA2AhAgAEEKNgIMDAoLQQAhKiAAQQA2AhwgACABNgIUIABB8ZmAgAA2AhAgAEECNgIMDAkLQQAhKiAAQQA2AhwgACABNgIUIABBxJSAgAA2AhAgAEECNgIMDAgLQQAhKiAAQQA2AhwgACABNgIUIABB8pWAgAA2AhAgAEECNgIMDAcLIABBAjYCHCAAIAE2AhQgAEGcmoCAADYCECAAQRY2AgxBACEqDAYLQQEhKgwFC0HUACEqIAEiASACRg0EIANBCGogACABIAJB2MKAgABBChDFgICAACADKAIMIQEgAygCCA4DAQQCAAsQy4CAgAAACyAAQQA2AhwgAEG1moCAADYCECAAQRc2AgwgACABQQFqNgIUQQAhKgwCCyAAQQA2AhwgACABNgIUIABBypqAgAA2AhAgAEEJNgIMQQAhKgwBCwJAIAEiASACRw0AQSIhKgwBCyAAQYmAgIAANgIIIAAgATYCBEEhISoLIANBEGokgICAgAAgKguvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAEMeAgIAAC5U3AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKg0ICAAA0AQQAQyoCAgABBgNSEgABrIgJB2QBJDQBBACEDAkBBACgC4NOAgAAiBA0AQQBCfzcC7NOAgABBAEKAgISAgIDAADcC5NOAgABBACABQQhqQXBxQdiq1aoFcyIENgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgAALQQAgAjYCzNOAgABBAEGA1ISAADYCyNOAgABBAEGA1ISAADYCmNCAgABBACAENgKs0ICAAEEAQX82AqjQgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgNSEgABBeEGA1ISAAGtBD3FBAEGA1ISAAEEIakEPcRsiA2oiBEEEaiACIANrQUhqIgNBAXI2AgBBAEEAKALw04CAADYCpNCAgABBACAENgKg0ICAAEEAIAM2ApTQgIAAIAJBgNSEgABqQUxqQTg2AgALAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKI0ICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQAgA0EBcSAEckEBcyIFQQN0IgBBuNCAgABqKAIAIgRBCGohAwJAAkAgBCgCCCICIABBsNCAgABqIgBHDQBBACAGQX4gBXdxNgKI0ICAAAwBCyAAIAI2AgggAiAANgIMCyAEIAVBA3QiBUEDcjYCBCAEIAVqQQRqIgQgBCgCAEEBcjYCAAwMCyACQQAoApDQgIAAIgdNDQECQCADRQ0AAkACQCADIAR0QQIgBHQiA0EAIANrcnEiA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqIgVBA3QiAEG40ICAAGooAgAiBCgCCCIDIABBsNCAgABqIgBHDQBBACAGQX4gBXdxIgY2AojQgIAADAELIAAgAzYCCCADIAA2AgwLIARBCGohAyAEIAJBA3I2AgQgBCAFQQN0IgVqIAUgAmsiBTYCACAEIAJqIgAgBUEBcjYCBAJAIAdFDQAgB0EDdiIIQQN0QbDQgIAAaiECQQAoApzQgIAAIQQCQAJAIAZBASAIdCIIcQ0AQQAgBiAIcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCAENgIMIAIgBDYCCCAEIAI2AgwgBCAINgIIC0EAIAA2ApzQgIAAQQAgBTYCkNCAgAAMDAtBACgCjNCAgAAiCUUNASAJQQAgCWtxQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmpBAnRBuNKAgABqKAIAIgAoAgRBeHEgAmshBCAAIQUCQANAAkAgBSgCECIDDQAgBUEUaigCACIDRQ0CCyADKAIEQXhxIAJrIgUgBCAFIARJIgUbIQQgAyAAIAUbIQAgAyEFDAALCyAAKAIYIQoCQCAAKAIMIgggAEYNAEEAKAKY0ICAACAAKAIIIgNLGiAIIAM2AgggAyAINgIMDAsLAkAgAEEUaiIFKAIAIgMNACAAKAIQIgNFDQMgAEEQaiEFCwNAIAUhCyADIghBFGoiBSgCACIDDQAgCEEQaiEFIAgoAhAiAw0ACyALQQA2AgAMCgtBfyECIABBv39LDQAgAEETaiIDQXBxIQJBACgCjNCAgAAiB0UNAEEAIQsCQCACQYACSQ0AQR8hCyACQf///wdLDQAgA0EIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIFIAVBgIAPakEQdkECcSIFdEEPdiADIARyIAVyayIDQQF0IAIgA0EVanZBAXFyQRxqIQsLQQAgAmshBAJAAkACQAJAIAtBAnRBuNKAgABqKAIAIgUNAEEAIQNBACEIDAELQQAhAyACQQBBGSALQQF2ayALQR9GG3QhAEEAIQgDQAJAIAUoAgRBeHEgAmsiBiAETw0AIAYhBCAFIQggBg0AQQAhBCAFIQggBSEDDAMLIAMgBUEUaigCACIGIAYgBSAAQR12QQRxakEQaigCACIFRhsgAyAGGyEDIABBAXQhACAFDQALCwJAIAMgCHINAEEAIQhBAiALdCIDQQAgA2tyIAdxIgNFDQMgA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBUEFdkEIcSIAIANyIAUgAHYiA0ECdkEEcSIFciADIAV2IgNBAXZBAnEiBXIgAyAFdiIDQQF2QQFxIgVyIAMgBXZqQQJ0QbjSgIAAaigCACEDCyADRQ0BCwNAIAMoAgRBeHEgAmsiBiAESSEAAkAgAygCECIFDQAgA0EUaigCACEFCyAGIAQgABshBCADIAggABshCCAFIQMgBQ0ACwsgCEUNACAEQQAoApDQgIAAIAJrTw0AIAgoAhghCwJAIAgoAgwiACAIRg0AQQAoApjQgIAAIAgoAggiA0saIAAgAzYCCCADIAA2AgwMCQsCQCAIQRRqIgUoAgAiAw0AIAgoAhAiA0UNAyAIQRBqIQULA0AgBSEGIAMiAEEUaiIFKAIAIgMNACAAQRBqIQUgACgCECIDDQALIAZBADYCAAwICwJAQQAoApDQgIAAIgMgAkkNAEEAKAKc0ICAACEEAkACQCADIAJrIgVBEEkNACAEIAJqIgAgBUEBcjYCBEEAIAU2ApDQgIAAQQAgADYCnNCAgAAgBCADaiAFNgIAIAQgAkEDcjYCBAwBCyAEIANBA3I2AgQgAyAEakEEaiIDIAMoAgBBAXI2AgBBAEEANgKc0ICAAEEAQQA2ApDQgIAACyAEQQhqIQMMCgsCQEEAKAKU0ICAACIAIAJNDQBBACgCoNCAgAAiAyACaiIEIAAgAmsiBUEBcjYCBEEAIAU2ApTQgIAAQQAgBDYCoNCAgAAgAyACQQNyNgIEIANBCGohAwwKCwJAAkBBACgC4NOAgABFDQBBACgC6NOAgAAhBAwBC0EAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEMakFwcUHYqtWqBXM2AuDTgIAAQQBBADYC9NOAgABBAEEANgLE04CAAEGAgAQhBAtBACEDAkAgBCACQccAaiIHaiIGQQAgBGsiC3EiCCACSw0AQQBBMDYC+NOAgAAMCgsCQEEAKALA04CAACIDRQ0AAkBBACgCuNOAgAAiBCAIaiIFIARNDQAgBSADTQ0BC0EAIQNBAEEwNgL404CAAAwKC0EALQDE04CAAEEEcQ0EAkACQAJAQQAoAqDQgIAAIgRFDQBByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiAESw0DCyADKAIIIgMNAAsLQQAQyoCAgAAiAEF/Rg0FIAghBgJAQQAoAuTTgIAAIgNBf2oiBCAAcUUNACAIIABrIAQgAGpBACADa3FqIQYLIAYgAk0NBSAGQf7///8HSw0FAkBBACgCwNOAgAAiA0UNAEEAKAK404CAACIEIAZqIgUgBE0NBiAFIANLDQYLIAYQyoCAgAAiAyAARw0BDAcLIAYgAGsgC3EiBkH+////B0sNBCAGEMqAgIAAIgAgAygCACADKAIEakYNAyAAIQMLAkAgA0F/Rg0AIAJByABqIAZNDQACQCAHIAZrQQAoAujTgIAAIgRqQQAgBGtxIgRB/v///wdNDQAgAyEADAcLAkAgBBDKgICAAEF/Rg0AIAQgBmohBiADIQAMBwtBACAGaxDKgICAABoMBAsgAyEAIANBf0cNBQwDC0EAIQgMBwtBACEADAULIABBf0cNAgtBAEEAKALE04CAAEEEcjYCxNOAgAALIAhB/v///wdLDQEgCBDKgICAACEAQQAQyoCAgAAhAyAAQX9GDQEgA0F/Rg0BIAAgA08NASADIABrIgYgAkE4ak0NAQtBAEEAKAK404CAACAGaiIDNgK404CAAAJAIANBACgCvNOAgABNDQBBACADNgK804CAAAsCQAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQCAAIAMoAgAiBSADKAIEIghqRg0CIAMoAggiAw0ADAMLCwJAAkBBACgCmNCAgAAiA0UNACAAIANPDQELQQAgADYCmNCAgAALQQAhA0EAIAY2AszTgIAAQQAgADYCyNOAgABBAEF/NgKo0ICAAEEAQQAoAuDTgIAANgKs0ICAAEEAQQA2AtTTgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiBCAGIANrQUhqIgNBAXI2AgRBAEEAKALw04CAADYCpNCAgABBACAENgKg0ICAAEEAIAM2ApTQgIAAIAYgAGpBTGpBODYCAAwCCyADLQAMQQhxDQAgBSAESw0AIAAgBE0NACAEQXggBGtBD3FBACAEQQhqQQ9xGyIFaiIAQQAoApTQgIAAIAZqIgsgBWsiBUEBcjYCBCADIAggBmo2AgRBAEEAKALw04CAADYCpNCAgABBACAFNgKU0ICAAEEAIAA2AqDQgIAAIAsgBGpBBGpBODYCAAwBCwJAIABBACgCmNCAgAAiC08NAEEAIAA2ApjQgIAAIAAhCwsgACAGaiEIQcjTgIAAIQMCQAJAAkACQAJAAkACQANAIAMoAgAgCEYNASADKAIIIgMNAAwCCwsgAy0ADEEIcUUNAQtByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiIFIARLDQMLIAMoAgghAwwACwsgAyAANgIAIAMgAygCBCAGajYCBCAAQXggAGtBD3FBACAAQQhqQQ9xG2oiBiACQQNyNgIEIAhBeCAIa0EPcUEAIAhBCGpBD3EbaiIIIAYgAmoiAmshBQJAIAQgCEcNAEEAIAI2AqDQgIAAQQBBACgClNCAgAAgBWoiAzYClNCAgAAgAiADQQFyNgIEDAMLAkBBACgCnNCAgAAgCEcNAEEAIAI2ApzQgIAAQQBBACgCkNCAgAAgBWoiAzYCkNCAgAAgAiADQQFyNgIEIAIgA2ogAzYCAAwDCwJAIAgoAgQiA0EDcUEBRw0AIANBeHEhBwJAAkAgA0H/AUsNACAIKAIIIgQgA0EDdiILQQN0QbDQgIAAaiIARhoCQCAIKAIMIgMgBEcNAEEAQQAoAojQgIAAQX4gC3dxNgKI0ICAAAwCCyADIABGGiADIAQ2AgggBCADNgIMDAELIAgoAhghCQJAAkAgCCgCDCIAIAhGDQAgCyAIKAIIIgNLGiAAIAM2AgggAyAANgIMDAELAkAgCEEUaiIDKAIAIgQNACAIQRBqIgMoAgAiBA0AQQAhAAwBCwNAIAMhCyAEIgBBFGoiAygCACIEDQAgAEEQaiEDIAAoAhAiBA0ACyALQQA2AgALIAlFDQACQAJAIAgoAhwiBEECdEG40oCAAGoiAygCACAIRw0AIAMgADYCACAADQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAgsgCUEQQRQgCSgCECAIRhtqIAA2AgAgAEUNAQsgACAJNgIYAkAgCCgCECIDRQ0AIAAgAzYCECADIAA2AhgLIAgoAhQiA0UNACAAQRRqIAM2AgAgAyAANgIYCyAHIAVqIQUgCCAHaiEICyAIIAgoAgRBfnE2AgQgAiAFaiAFNgIAIAIgBUEBcjYCBAJAIAVB/wFLDQAgBUEDdiIEQQN0QbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgBHQiBHENAEEAIAUgBHI2AojQgIAAIAMhBAwBCyADKAIIIQQLIAQgAjYCDCADIAI2AgggAiADNgIMIAIgBDYCCAwDC0EfIQMCQCAFQf///wdLDQAgBUEIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIAIABBgIAPakEQdkECcSIAdEEPdiADIARyIAByayIDQQF0IAUgA0EVanZBAXFyQRxqIQMLIAIgAzYCHCACQgA3AhAgA0ECdEG40oCAAGohBAJAQQAoAozQgIAAIgBBASADdCIIcQ0AIAQgAjYCAEEAIAAgCHI2AozQgIAAIAIgBDYCGCACIAI2AgggAiACNgIMDAMLIAVBAEEZIANBAXZrIANBH0YbdCEDIAQoAgAhAANAIAAiBCgCBEF4cSAFRg0CIANBHXYhACADQQF0IQMgBCAAQQRxakEQaiIIKAIAIgANAAsgCCACNgIAIAIgBDYCGCACIAI2AgwgAiACNgIIDAILIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgsgBiADa0FIaiIDQQFyNgIEIAhBTGpBODYCACAEIAVBNyAFa0EPcUEAIAVBSWpBD3EbakFBaiIIIAggBEEQakkbIghBIzYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAs2AqDQgIAAQQAgAzYClNCAgAAgCEEQakEAKQLQ04CAADcCACAIQQApAsjTgIAANwIIQQAgCEEIajYC0NOAgABBACAGNgLM04CAAEEAIAA2AsjTgIAAQQBBADYC1NOAgAAgCEEkaiEDA0AgA0EHNgIAIAUgA0EEaiIDSw0ACyAIIARGDQMgCCAIKAIEQX5xNgIEIAggCCAEayIGNgIAIAQgBkEBcjYCBAJAIAZB/wFLDQAgBkEDdiIFQQN0QbDQgIAAaiEDAkACQEEAKAKI0ICAACIAQQEgBXQiBXENAEEAIAAgBXI2AojQgIAAIAMhBQwBCyADKAIIIQULIAUgBDYCDCADIAQ2AgggBCADNgIMIAQgBTYCCAwEC0EfIQMCQCAGQf///wdLDQAgBkEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCIAIABBgIAPakEQdkECcSIAdEEPdiADIAVyIAByayIDQQF0IAYgA0EVanZBAXFyQRxqIQMLIARCADcCECAEQRxqIAM2AgAgA0ECdEG40oCAAGohBQJAQQAoAozQgIAAIgBBASADdCIIcQ0AIAUgBDYCAEEAIAAgCHI2AozQgIAAIARBGGogBTYCACAEIAQ2AgggBCAENgIMDAQLIAZBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAANAIAAiBSgCBEF4cSAGRg0DIANBHXYhACADQQF0IQMgBSAAQQRxakEQaiIIKAIAIgANAAsgCCAENgIAIARBGGogBTYCACAEIAQ2AgwgBCAENgIIDAMLIAQoAggiAyACNgIMIAQgAjYCCCACQQA2AhggAiAENgIMIAIgAzYCCAsgBkEIaiEDDAULIAUoAggiAyAENgIMIAUgBDYCCCAEQRhqQQA2AgAgBCAFNgIMIAQgAzYCCAtBACgClNCAgAAiAyACTQ0AQQAoAqDQgIAAIgQgAmoiBSADIAJrIgNBAXI2AgRBACADNgKU0ICAAEEAIAU2AqDQgIAAIAQgAkEDcjYCBCAEQQhqIQMMAwtBACEDQQBBMDYC+NOAgAAMAgsCQCALRQ0AAkACQCAIIAgoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAA2AgAgAA0BQQAgB0F+IAV3cSIHNgKM0ICAAAwCCyALQRBBFCALKAIQIAhGG2ogADYCACAARQ0BCyAAIAs2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCEEUaigCACIDRQ0AIABBFGogAzYCACADIAA2AhgLAkACQCAEQQ9LDQAgCCAEIAJqIgNBA3I2AgQgAyAIakEEaiIDIAMoAgBBAXI2AgAMAQsgCCACaiIAIARBAXI2AgQgCCACQQNyNgIEIAAgBGogBDYCAAJAIARB/wFLDQAgBEEDdiIEQQN0QbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgBHQiBHENAEEAIAUgBHI2AojQgIAAIAMhBAwBCyADKAIIIQQLIAQgADYCDCADIAA2AgggACADNgIMIAAgBDYCCAwBC0EfIQMCQCAEQf///wdLDQAgBEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCICIAJBgIAPakEQdkECcSICdEEPdiADIAVyIAJyayIDQQF0IAQgA0EVanZBAXFyQRxqIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEG40oCAAGohBQJAIAdBASADdCICcQ0AIAUgADYCAEEAIAcgAnI2AozQgIAAIAAgBTYCGCAAIAA2AgggACAANgIMDAELIARBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAgJAA0AgAiIFKAIEQXhxIARGDQEgA0EddiECIANBAXQhAyAFIAJBBHFqQRBqIgYoAgAiAg0ACyAGIAA2AgAgACAFNgIYIAAgADYCDCAAIAA2AggMAQsgBSgCCCIDIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACADNgIICyAIQQhqIQMMAQsCQCAKRQ0AAkACQCAAIAAoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAg2AgAgCA0BQQAgCUF+IAV3cTYCjNCAgAAMAgsgCkEQQRQgCigCECAARhtqIAg2AgAgCEUNAQsgCCAKNgIYAkAgACgCECIDRQ0AIAggAzYCECADIAg2AhgLIABBFGooAgAiA0UNACAIQRRqIAM2AgAgAyAINgIYCwJAAkAgBEEPSw0AIAAgBCACaiIDQQNyNgIEIAMgAGpBBGoiAyADKAIAQQFyNgIADAELIAAgAmoiBSAEQQFyNgIEIAAgAkEDcjYCBCAFIARqIAQ2AgACQCAHRQ0AIAdBA3YiCEEDdEGw0ICAAGohAkEAKAKc0ICAACEDAkACQEEBIAh0IgggBnENAEEAIAggBnI2AojQgIAAIAIhCAwBCyACKAIIIQgLIAggAzYCDCACIAM2AgggAyACNgIMIAMgCDYCCAtBACAFNgKc0ICAAEEAIAQ2ApDQgIAACyAAQQhqIQMLIAFBEGokgICAgAAgAwsKACAAEMmAgIAAC/ANAQd/AkAgAEUNACAAQXhqIgEgAEF8aigCACICQXhxIgBqIQMCQCACQQFxDQAgAkEDcUUNASABIAEoAgAiAmsiAUEAKAKY0ICAACIESQ0BIAIgAGohAAJAQQAoApzQgIAAIAFGDQACQCACQf8BSw0AIAEoAggiBCACQQN2IgVBA3RBsNCAgABqIgZGGgJAIAEoAgwiAiAERw0AQQBBACgCiNCAgABBfiAFd3E2AojQgIAADAMLIAIgBkYaIAIgBDYCCCAEIAI2AgwMAgsgASgCGCEHAkACQCABKAIMIgYgAUYNACAEIAEoAggiAksaIAYgAjYCCCACIAY2AgwMAQsCQCABQRRqIgIoAgAiBA0AIAFBEGoiAigCACIEDQBBACEGDAELA0AgAiEFIAQiBkEUaiICKAIAIgQNACAGQRBqIQIgBigCECIEDQALIAVBADYCAAsgB0UNAQJAAkAgASgCHCIEQQJ0QbjSgIAAaiICKAIAIAFHDQAgAiAGNgIAIAYNAUEAQQAoAozQgIAAQX4gBHdxNgKM0ICAAAwDCyAHQRBBFCAHKAIQIAFGG2ogBjYCACAGRQ0CCyAGIAc2AhgCQCABKAIQIgJFDQAgBiACNgIQIAIgBjYCGAsgASgCFCICRQ0BIAZBFGogAjYCACACIAY2AhgMAQsgAygCBCICQQNxQQNHDQAgAyACQX5xNgIEQQAgADYCkNCAgAAgASAAaiAANgIAIAEgAEEBcjYCBA8LIAMgAU0NACADKAIEIgJBAXFFDQACQAJAIAJBAnENAAJAQQAoAqDQgIAAIANHDQBBACABNgKg0ICAAEEAQQAoApTQgIAAIABqIgA2ApTQgIAAIAEgAEEBcjYCBCABQQAoApzQgIAARw0DQQBBADYCkNCAgABBAEEANgKc0ICAAA8LAkBBACgCnNCAgAAgA0cNAEEAIAE2ApzQgIAAQQBBACgCkNCAgAAgAGoiADYCkNCAgAAgASAAQQFyNgIEIAEgAGogADYCAA8LIAJBeHEgAGohAAJAAkAgAkH/AUsNACADKAIIIgQgAkEDdiIFQQN0QbDQgIAAaiIGRhoCQCADKAIMIgIgBEcNAEEAQQAoAojQgIAAQX4gBXdxNgKI0ICAAAwCCyACIAZGGiACIAQ2AgggBCACNgIMDAELIAMoAhghBwJAAkAgAygCDCIGIANGDQBBACgCmNCAgAAgAygCCCICSxogBiACNgIIIAIgBjYCDAwBCwJAIANBFGoiAigCACIEDQAgA0EQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0AAkACQCADKAIcIgRBAnRBuNKAgABqIgIoAgAgA0cNACACIAY2AgAgBg0BQQBBACgCjNCAgABBfiAEd3E2AozQgIAADAILIAdBEEEUIAcoAhAgA0YbaiAGNgIAIAZFDQELIAYgBzYCGAJAIAMoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyADKAIUIgJFDQAgBkEUaiACNgIAIAIgBjYCGAsgASAAaiAANgIAIAEgAEEBcjYCBCABQQAoApzQgIAARw0BQQAgADYCkNCAgAAPCyADIAJBfnE2AgQgASAAaiAANgIAIAEgAEEBcjYCBAsCQCAAQf8BSw0AIABBA3YiAkEDdEGw0ICAAGohAAJAAkBBACgCiNCAgAAiBEEBIAJ0IgJxDQBBACAEIAJyNgKI0ICAACAAIQIMAQsgACgCCCECCyACIAE2AgwgACABNgIIIAEgADYCDCABIAI2AggPC0EfIQICQCAAQf///wdLDQAgAEEIdiICIAJBgP4/akEQdkEIcSICdCIEIARBgOAfakEQdkEEcSIEdCIGIAZBgIAPakEQdkECcSIGdEEPdiACIARyIAZyayICQQF0IAAgAkEVanZBAXFyQRxqIQILIAFCADcCECABQRxqIAI2AgAgAkECdEG40oCAAGohBAJAAkBBACgCjNCAgAAiBkEBIAJ0IgNxDQAgBCABNgIAQQAgBiADcjYCjNCAgAAgAUEYaiAENgIAIAEgATYCCCABIAE2AgwMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgBCgCACEGAkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABQRhqIAQ2AgAgASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEYakEANgIAIAEgBDYCDCABIAA2AggLQQBBACgCqNCAgABBf2oiAUF/IAEbNgKo0ICAAAsLTgACQCAADQA/AEEQdA8LAkAgAEH//wNxDQAgAEF/TA0AAkAgAEEQdkAAIgBBf0cNAEEAQTA2AvjTgIAAQX8PCyAAQRB0DwsQy4CAgAAACwQAAAAL+wICA38BfgJAIAJFDQAgACABOgAAIAIgAGoiA0F/aiABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBfWogAToAACADQX5qIAE6AAAgAkEHSQ0AIAAgAToAAyADQXxqIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIFayICQSBJDQAgAa1CgYCAgBB+IQYgAyAFaiEBA0AgASAGNwMAIAFBGGogBjcDACABQRBqIAY3AwAgAUEIaiAGNwMAIAFBIGohASACQWBqIgJBH0sNAAsLIAALC45IAQBBgAgLhkgBAAAAAgAAAAMAAAAAAAAAAAAAAAQAAAAFAAAAAAAAAAAAAAAGAAAABwAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
  }
});

// node_modules/undici/lib/client.js
var require_client = __commonJS({
  "node_modules/undici/lib/client.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var net = require("net");
    var util2 = require_util();
    var timers = require_timers();
    var Request = require_request();
    var DispatcherBase = require_dispatcher_base();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError
    } = require_errors();
    var buildConnector = require_connect();
    var {
      kUrl,
      kReset,
      kServerName,
      kClient,
      kBusy,
      kParser,
      kConnect,
      kBlocking,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kInterceptors,
      kLocalAddress,
      kMaxResponseSize
    } = require_symbols();
    var FastBuffer = Buffer[Symbol.species];
    var kClosedResolve = Symbol("kClosedResolve");
    var channels = {};
    try {
      const diagnosticsChannel = require("diagnostics_channel");
      channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
      channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
      channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
      channels.connected = diagnosticsChannel.channel("undici:client:connected");
    } catch {
      channels.sendHeaders = { hasSubscribers: false };
      channels.beforeConnect = { hasSubscribers: false };
      channels.connectError = { hasSubscribers: false };
      channels.connected = { hasSubscribers: false };
    }
    var Client3 = class extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../types/client').Client.Options} options
       */
      constructor(url2, {
        interceptors,
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        maxRedirections,
        connect: connect2,
        maxRequestsPerClient,
        localAddress,
        maxResponseSize,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout
      } = {}) {
        super();
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
          throw new InvalidArgumentError("localAddress must be valid string IP address");
        }
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
          throw new InvalidArgumentError("maxResponseSize must be a positive number");
        }
        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
          throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
        }
        if (typeof connect2 !== "function") {
          connect2 = buildConnector({
            ...tls,
            maxCachedSessions,
            socketPath,
            timeout: connectTimeout,
            ...util2.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect2
          });
        }
        this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
        this[kUrl] = util2.parseOrigin(url2);
        this[kConnector] = connect2;
        this[kSocket] = null;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || 16384;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRedirections] = maxRedirections;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        resume(this, true);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
      }
      get [kBusy]() {
        const socket = this[kSocket];
        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
      }
      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request = new Request(origin, opts, handler);
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util2.bodyLength(request.body) == null && util2.isIterable(request.body)) {
          this[kResuming] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve) => {
          if (!this[kSize]) {
            this.destroy(resolve);
          } else {
            this[kClosedResolve] = resolve;
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            errorRequest(this, request, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve();
          };
          if (!this[kSocket]) {
            queueMicrotask(callback);
          } else {
            util2.destroy(this[kSocket].on("close", callback), err);
          }
          resume(this);
        });
      }
    };
    var constants = require_constants2();
    var createRedirectInterceptor = require_redirectInterceptor();
    var EMPTY_BUF = Buffer.alloc(0);
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
      } catch (e) {
        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          /* eslint-disable camelcase */
          wasm_on_url: (p, at, len) => {
            return 0;
          },
          wasm_on_status: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_begin: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageBegin() || 0;
          },
          wasm_on_header_field: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_header_value: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
          },
          wasm_on_body: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_complete: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageComplete() || 0;
          }
          /* eslint-enable camelcase */
        }
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp();
    llhttpPromise.catch();
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var TIMEOUT_HEADERS = 1;
    var TIMEOUT_BODY = 2;
    var TIMEOUT_IDLE = 3;
    var Parser = class {
      constructor(client, socket, { exports: exports3 }) {
        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
        this.llhttp = exports3;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(value, type) {
        this.timeoutType = type;
        if (value !== this.timeoutValue) {
          timers.clearTimeout(this.timeout);
          if (value) {
            this.timeout = timers.setTimeout(onParserTimeout, value, this);
            if (this.timeout.unref) {
              this.timeout.unref();
            }
          } else {
            this.timeout = null;
          }
          this.timeoutValue = value;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_resume(this.ptr);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }
      execute(data) {
        assert(this.ptr != null);
        assert(currentParser == null);
        assert(!this.paused);
        const { socket, llhttp } = this;
        if (data.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(data.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data.slice(offset));
          } else if (ret === constants.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data.slice(offset));
          } else if (ret !== constants.ERROR.OK) {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = Buffer.from(llhttp.memory.buffer, ptr, len).toString();
            }
            throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
          }
        } catch (err) {
          util2.destroy(socket, err);
        }
      }
      destroy() {
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        timers.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
      }
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
          this.connection += buf.toString();
        } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util2.destroy(this.socket, new HeadersOverflowError());
        }
      }
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert(upgrade);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(!socket.destroyed);
        assert(socket === client[kSocket]);
        assert(!this.paused);
        assert(request.upgrade || request.method === "CONNECT");
        this.statusCode = null;
        this.statusText = "";
        this.shouldKeepAlive = null;
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
        client[kSocket] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util2.destroy(socket, err);
        }
        resume(client);
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        assert(!this.upgrade);
        assert(this.statusCode < 200);
        if (statusCode === 100) {
          util2.destroy(socket, new SocketError("bad response", util2.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request.upgrade) {
          util2.destroy(socket, new SocketError("bad upgrade", util2.getSocketInfo(socket)));
          return -1;
        }
        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
        request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
        if (this.statusCode >= 200) {
          const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request.method === "CONNECT") {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util2.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        let pause;
        try {
          pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
        } catch (err) {
          util2.destroy(socket, err);
          return -1;
        }
        if (request.method === "HEAD") {
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          resume(client);
        }
        return pause ? constants.ERROR.PAUSED : 0;
      }
      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert(statusCode >= 200);
        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
          util2.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }
        this.bytesRead += buf.length;
        try {
          if (request.onData(buf) === false) {
            return constants.ERROR.PAUSED;
          }
        } catch (err) {
          util2.destroy(socket, err);
          return -1;
        }
      }
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(statusCode >= 100);
        this.statusCode = null;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return;
        }
        if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util2.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        try {
          request.onComplete(headers);
        } catch (err) {
          errorRequest(client, request, err);
        }
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert.strictEqual(client[kRunning], 0);
          util2.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util2.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util2.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (client[kPipelining] === 1) {
          setImmediate(resume, client);
        } else {
          resume(client);
        }
      }
    };
    function onParserTimeout(parser) {
      const { socket, timeoutType, client } = parser;
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert(!parser.paused, "cannot be paused while waiting for headers");
          util2.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!parser.paused) {
          util2.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_IDLE) {
        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util2.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    function onSocketReadable() {
      const { [kParser]: parser } = this;
      parser.readMore();
    }
    function onSocketError(err) {
      const { [kParser]: parser } = this;
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      this[kError] = err;
      onError(this[kClient], err);
    }
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
        assert(client[kSize] === 0);
      }
    }
    function onSocketEnd() {
      const { [kParser]: parser } = this;
      if (parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      util2.destroy(this, new SocketError("other side closed", util2.getSocketInfo(this)));
    }
    function onSocketClose() {
      const { [kClient]: client } = this;
      if (!this[kError] && this[kParser].statusCode && !this[kParser].shouldKeepAlive) {
        this[kParser].onMessageComplete();
      }
      this[kParser].destroy();
      this[kParser] = null;
      const err = this[kError] || new SocketError("closed", util2.getSocketInfo(this));
      client[kSocket] = null;
      if (client.destroyed) {
        assert(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      resume(client);
    }
    async function connect(client) {
      assert(!client[kConnecting]);
      assert(!client[kSocket]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === "[") {
        const idx = hostname.indexOf("]");
        assert(idx !== -1);
        const ip = hostname.substr(1, idx - 1);
        assert(net.isIP(ip));
        hostname = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve, reject) => {
          client[kConnector]({
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          }, (err, socket2) => {
            if (err) {
              reject(err);
            } else {
              resolve(socket2);
            }
          });
        });
        if (!llhttpInstance) {
          llhttpInstance = await llhttpPromise;
          llhttpPromise = null;
        }
        client[kConnecting] = false;
        assert(socket);
        socket[kNoRef] = false;
        socket[kWriting] = false;
        socket[kReset] = false;
        socket[kBlocking] = false;
        socket[kError] = null;
        socket[kParser] = new Parser(client, socket, llhttpInstance);
        socket[kClient] = client;
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
        client[kSocket] = socket;
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            error: err
          });
        }
        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request = client[kQueue][client[kPendingIdx]++];
            errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }
        client.emit("connectionError", client[kUrl], [client], err);
      }
      resume(client);
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert(client[kPending] === 0);
          return;
        }
        if (client.closed && !client[kSize]) {
          client.destroy();
          return;
        }
        const socket = client[kSocket];
        if (socket && !socket.destroyed) {
          if (client[kSize] === 0) {
            if (!socket[kNoRef] && socket.unref) {
              socket.unref();
              socket[kNoRef] = true;
            }
          } else if (socket[kNoRef] && socket.ref) {
            socket.ref();
            socket[kNoRef] = false;
          }
          if (client[kSize] === 0) {
            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
              socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
            }
          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
              const request2 = client[kQueue][client[kRunningIdx]];
              const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
            }
          }
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            process.nextTick(emitDrain, client);
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (client[kPipelining] || 1)) {
          return;
        }
        const request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request.servername;
          if (socket && socket.servername !== request.servername) {
            util2.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
        if (client[kConnecting]) {
          return;
        }
        if (!socket) {
          connect(client);
          return;
        }
        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return;
        }
        if (client[kRunning] > 0 && !request.idempotent) {
          return;
        }
        if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
          return;
        }
        if (util2.isStream(request.body) && util2.bodyLength(request.body) === 0) {
          request.body.on(
            "data",
            /* istanbul ignore next */
            function() {
              assert(false);
            }
          ).on("error", function(err) {
            errorRequest(client, request, err);
          }).on("end", function() {
            util2.destroy(this);
          });
          request.body = null;
        }
        if (client[kRunning] > 0 && (util2.isStream(request.body) || util2.isAsyncIterable(request.body))) {
          return;
        }
        if (!request.aborted && write2(client, request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    function write2(client, request) {
      const { body, method, path, host, upgrade, headers, blocking, reset } = request;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util2.bodyLength(body);
      if (contentLength === null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
          util2.destroy(socket, new InformationalError("aborted"));
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (reset != null) {
        socket[kReset] = reset;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (headers) {
        header += headers;
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request, headers: header, socket });
      }
      if (!body) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "ascii");
        } else {
          assert(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "ascii");
        }
        request.onRequestSent();
      } else if (util2.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      } else if (util2.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
        } else {
          writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
        }
      } else if (util2.isStream(body)) {
        writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
      } else if (util2.isIterable(body)) {
        writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
      } else {
        assert(false);
      }
      return true;
    }
    function writeStream({ body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      let finished = false;
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      const onData = function(chunk) {
        try {
          assert(!finished);
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util2.destroy(this, err);
        }
      };
      const onDrain = function() {
        assert(!finished);
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function() {
        onFinished(new RequestAbortedError());
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util2.destroy(body, err);
        } else {
          util2.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
    }
    async function writeBlob({ body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength === body.size, "blob body must have content length");
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
        socket.write(buffer);
        socket.uncork();
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        resume(client);
      } catch (err) {
        util2.destroy(socket, err);
      }
    }
    async function writeIterable({ body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve, reject) => {
        assert(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve;
        }
      });
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      constructor({ socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        socket[kWriting] = true;
      }
      write(chunk) {
        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork();
        if (bytesWritten === 0) {
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "ascii");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "ascii");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk);
        socket.uncork();
        request.onBodySent(chunk);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        request.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "ascii");
          } else {
            socket.write(`${header}\r
`, "ascii");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "ascii");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        resume(client);
      }
      destroy(err) {
        const { socket, client } = this;
        socket[kWriting] = false;
        if (err) {
          assert(client[kRunning] <= 1, "pipeline should only contain this request");
          util2.destroy(socket, err);
        }
      }
    };
    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert(request.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    module2.exports = Client3;
  }
});

// node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({
  "node_modules/undici/lib/node/fixed-queue.js"(exports2, module2) {
    "use strict";
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module2.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    };
  }
});

// node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({
  "node_modules/undici/lib/pool-stats.js"(exports2, module2) {
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
    var kPool = Symbol("pool");
    var PoolStats = class {
      constructor(pool) {
        this[kPool] = pool;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module2.exports = PoolStats;
  }
});

// node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({
  "node_modules/undici/lib/pool-base.js"(exports2, module2) {
    "use strict";
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
    var PoolStats = require_pool_stats();
    var kClients = Symbol("clients");
    var kNeedDrain = Symbol("needDrain");
    var kQueue = Symbol("queue");
    var kClosedResolve = Symbol("closed resolve");
    var kOnDrain = Symbol("onDrain");
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kGetDispatcher = Symbol("get dispatcher");
    var kAddClient = Symbol("add client");
    var kRemoveClient = Symbol("remove client");
    var kStats = Symbol("stats");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        };
        this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          return Promise.all(this[kClients].map((c) => c.close()));
        } else {
          return new Promise((resolve) => {
            this[kClosedResolve] = resolve;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        return Promise.all(this[kClients].map((c) => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          process.nextTick(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module2.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// node_modules/undici/lib/pool.js
var require_pool = __commonJS({
  "node_modules/undici/lib/pool.js"(exports2, module2) {
    "use strict";
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher
    } = require_pool_base();
    var Client3 = require_client();
    var {
      InvalidArgumentError
    } = require_errors();
    var util2 = require_util();
    var { kUrl, kInterceptors } = require_symbols();
    var buildConnector = require_connect();
    var kOptions = Symbol("options");
    var kConnections = Symbol("connections");
    var kFactory = Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client3(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        ...options
      } = {}) {
        super();
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            socketPath,
            timeout: connectTimeout == null ? 1e4 : connectTimeout,
            ...util2.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect
          });
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
        this[kConnections] = connections || null;
        this[kUrl] = util2.parseOrigin(origin);
        this[kOptions] = { ...util2.deepClone(options), connect };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kFactory] = factory;
      }
      [kGetDispatcher]() {
        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
        if (dispatcher) {
          return dispatcher;
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
        }
        return dispatcher;
      }
    };
    module2.exports = Pool;
  }
});

// node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({
  "node_modules/undici/lib/balanced-pool.js"(exports2, module2) {
    "use strict";
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl, kInterceptors } = require_symbols();
    var { parseOrigin } = require_util();
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
    var kCurrentWeight = Symbol("kCurrentWeight");
    var kIndex = Symbol("kIndex");
    var kWeight = Symbol("kWeight");
    var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
    var kErrorPenalty = Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a, b) {
      if (b === 0)
        return a;
      return getGreatestCommonDivisor(b, a % b);
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
          return this;
        }
        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool);
        pool.on("connect", () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        });
        pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool.on("disconnect", (...args) => {
          const err = args[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
        if (allClientsBusy) {
          return;
        }
        let counter = 0;
        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module2.exports = BalancedPool;
  }
});

// node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "node_modules/undici/lib/compat/dispatcher-weakref.js"(exports2, module2) {
    "use strict";
    var { kConnected, kSize } = require_symbols();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        dispatcher.on("disconnect", () => {
          if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
            this.finalizer(key);
          }
        });
      }
    };
    module2.exports = function() {
      return {
        WeakRef: global.WeakRef || CompatWeakRef,
        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
      };
    };
  }
});

// node_modules/undici/lib/agent.js
var require_agent = __commonJS({
  "node_modules/undici/lib/agent.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError } = require_errors();
    var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client3 = require_client();
    var util2 = require_util();
    var createRedirectInterceptor = require_redirectInterceptor();
    var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kMaxRedirections = Symbol("maxRedirections");
    var kOnDrain = Symbol("onDrain");
    var kFactory = Symbol("factory");
    var kFinalizer = Symbol("finalizer");
    var kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client3(origin, opts) : new Pool(origin, opts);
    }
    var Agent = class extends DispatcherBase {
      constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
        super();
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
        this[kOptions] = { ...util2.deepClone(options), connect };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kMaxRedirections] = maxRedirections;
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kFinalizer] = new FinalizationRegistry(
          /* istanbul ignore next: gc is undeterministic */
          (key) => {
            const ref = this[kClients].get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this[kClients].delete(key);
            }
          }
        );
        const agent = this;
        this[kOnDrain] = (origin, targets) => {
          agent.emit("drain", origin, [agent, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          agent.emit("connect", origin, [agent, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          agent.emit("disconnect", origin, [agent, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          agent.emit("connectionError", origin, [agent, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            ret += client[kRunning];
          }
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        const ref = this[kClients].get(key);
        let dispatcher = ref ? ref.deref() : null;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, new WeakRef2(dispatcher));
          this[kFinalizer].register(dispatcher, key);
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            closePromises.push(client.close());
          }
        }
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            destroyPromises.push(client.destroy(err));
          }
        }
        await Promise.all(destroyPromises);
      }
    };
    module2.exports = Agent;
  }
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "node_modules/undici/lib/api/readable.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { Readable: Readable2 } = require("stream");
    var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
    var util2 = require_util();
    var { ReadableStreamFrom, toUSVString } = require_util();
    var Blob2;
    var kConsume = Symbol("kConsume");
    var kReading = Symbol("kReading");
    var kBody = Symbol("kBody");
    var kAbort = Symbol("abort");
    var kContentType = Symbol("kContentType");
    module2.exports = class BodyReadable extends Readable2 {
      constructor(resume, abort, contentType = "") {
        super({
          autoDestroy: true,
          read: resume,
          highWaterMark: 64 * 1024
          // Same as nodejs fs streams.
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBody] = null;
        this[kContentType] = contentType;
        this[kReading] = false;
      }
      destroy(err) {
        if (this.destroyed) {
          return this;
        }
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        return super.destroy(err);
      }
      emit(ev, ...args) {
        if (ev === "data") {
          this._readableState.dataEmitted = true;
        } else if (ev === "error") {
          this._readableState.errorEmitted = true;
        }
        return super.emit(ev, ...args);
      }
      on(ev, ...args) {
        if (ev === "data" || ev === "readable") {
          this[kReading] = true;
        }
        return super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        const ret = super.off(ev, ...args);
        if (ev === "data" || ev === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk) {
        if (this[kConsume] && chunk !== null && this.readableLength === 0) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
        return super.push(chunk);
      }
      // https://fetch.spec.whatwg.org/#dom-body-text
      async text() {
        return consume(this, "text");
      }
      // https://fetch.spec.whatwg.org/#dom-body-json
      async json() {
        return consume(this, "json");
      }
      // https://fetch.spec.whatwg.org/#dom-body-blob
      async blob() {
        return consume(this, "blob");
      }
      // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      // https://fetch.spec.whatwg.org/#dom-body-formdata
      async formData() {
        throw new NotSupportedError();
      }
      // https://fetch.spec.whatwg.org/#dom-body-bodyused
      get bodyUsed() {
        return util2.isDisturbed(this);
      }
      // https://fetch.spec.whatwg.org/#dom-body-body
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      async dump(opts) {
        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
        const signal = opts && opts.signal;
        const abortFn = () => {
          this.destroy();
        };
        if (signal) {
          if (typeof signal !== "object" || !("aborted" in signal)) {
            throw new InvalidArgumentError("signal must be an AbortSignal");
          }
          util2.throwIfAborted(signal);
          signal.addEventListener("abort", abortFn, { once: true });
        }
        try {
          for await (const chunk of this) {
            util2.throwIfAborted(signal);
            limit -= Buffer.byteLength(chunk);
            if (limit < 0) {
              return;
            }
          }
        } catch {
          util2.throwIfAborted(signal);
        } finally {
          if (signal) {
            signal.removeEventListener("abort", abortFn);
          }
        }
      }
    };
    function isLocked(self2) {
      return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
    }
    function isUnusable(self2) {
      return util2.isDisturbed(self2) || isLocked(self2);
    }
    async function consume(stream4, type) {
      if (isUnusable(stream4)) {
        throw new TypeError("unusable");
      }
      assert(!stream4[kConsume]);
      return new Promise((resolve, reject) => {
        stream4[kConsume] = {
          type,
          stream: stream4,
          resolve,
          reject,
          length: 0,
          body: []
        };
        stream4.on("error", function(err) {
          consumeFinish(this[kConsume], err);
        }).on("close", function() {
          if (this[kConsume].body !== null) {
            consumeFinish(this[kConsume], new RequestAbortedError());
          }
        });
        process.nextTick(consumeStart, stream4[kConsume]);
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume]);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume]);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function consumeEnd(consume2) {
      const { type, body, resolve, stream: stream4, length } = consume2;
      try {
        if (type === "text") {
          resolve(toUSVString(Buffer.concat(body)));
        } else if (type === "json") {
          resolve(JSON.parse(Buffer.concat(body)));
        } else if (type === "arrayBuffer") {
          const dst = new Uint8Array(length);
          let pos = 0;
          for (const buf of body) {
            dst.set(buf, pos);
            pos += buf.byteLength;
          }
          resolve(dst);
        } else if (type === "blob") {
          if (!Blob2) {
            Blob2 = require("buffer").Blob;
          }
          resolve(new Blob2(body, { type: stream4[kContentType] }));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream4.destroy(err);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length;
      consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
  }
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "node_modules/undici/lib/api/abort-signal.js"(exports2, module2) {
    var { RequestAbortedError } = require_errors();
    var kListener = Symbol("kListener");
    var kSignal = Symbol("kSignal");
    function abort(self2) {
      if (self2.abort) {
        self2.abort();
      } else {
        self2.onError(new RequestAbortedError());
      }
    }
    function addSignal(self2, signal) {
      self2[kSignal] = null;
      self2[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self2);
        return;
      }
      self2[kSignal] = signal;
      self2[kListener] = () => {
        abort(self2);
      };
      if ("addEventListener" in self2[kSignal]) {
        self2[kSignal].addEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].addListener("abort", self2[kListener]);
      }
    }
    function removeSignal(self2) {
      if (!self2[kSignal]) {
        return;
      }
      if ("removeEventListener" in self2[kSignal]) {
        self2[kSignal].removeEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].removeListener("abort", self2[kListener]);
      }
      self2[kSignal] = null;
      self2[kListener] = null;
    }
    module2.exports = {
      addSignal,
      removeSignal
    };
  }
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "node_modules/undici/lib/api/api-request.js"(exports2, module2) {
    "use strict";
    var Readable2 = require_readable();
    var {
      InvalidArgumentError,
      RequestAbortedError,
      ResponseStatusCodeError
    } = require_errors();
    var util2 = require_util();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util2.isStream(body)) {
            util2.destroy(body.on("error", util2.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError;
        if (util2.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { callback, opaque, abort, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers: headers2 });
          }
          return;
        }
        const parsedHeaders = util2.parseHeaders(rawHeaders);
        const contentType = parsedHeaders["content-type"];
        const body = new Readable2(resume, abort, contentType);
        this.callback = null;
        this.res = body;
        const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
        if (callback !== null) {
          if (this.throwOnError && statusCode >= 400) {
            this.runInAsyncScope(
              getResolveErrorBodyCallback,
              null,
              { callback, body, contentType, statusCode, statusMessage, headers }
            );
            return;
          }
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers,
            trailers: this.trailers,
            opaque,
            body,
            context
          });
        }
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        util2.parseHeaders(trailers, this.trailers);
        res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util2.destroy(res, err);
          });
        }
        if (body) {
          this.body = null;
          util2.destroy(body, err);
        }
      }
    };
    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
      if (statusCode === 204 || !contentType) {
        body.dump();
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
        return;
      }
      try {
        if (contentType.startsWith("application/json")) {
          const payload = await body.json();
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
        if (contentType.startsWith("text/")) {
          const payload = await body.text();
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
      } catch (err) {
      }
      body.dump();
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
    }
    function request(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = request;
  }
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "node_modules/undici/lib/api/api-stream.js"(exports2, module2) {
    "use strict";
    var { finished, PassThrough } = require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ResponseStatusCodeError
    } = require_errors();
    var util2 = require_util();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util2.isStream(body)) {
            util2.destroy(body.on("error", util2.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError || false;
        if (util2.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { factory, opaque, context, callback } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers: headers2 });
          }
          return;
        }
        this.factory = null;
        const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
        const res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers,
          opaque,
          context
        });
        if (this.throwOnError && statusCode >= 400) {
          const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
          const chunks = [];
          const pt = new PassThrough();
          pt.on("data", (chunk) => chunks.push(chunk)).on("end", () => {
            const payload = Buffer.concat(chunks).toString("utf8");
            this.runInAsyncScope(
              callback,
              null,
              new ResponseStatusCodeError(
                `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`,
                statusCode,
                headers2,
                payload
              )
            );
          }).on("error", (err) => {
            this.onError(err);
          });
          this.res = pt;
          return;
        }
        if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
          throw new InvalidReturnValueError("expected Writable");
        }
        res.on("drain", resume);
        finished(res, { readable: false }, (err) => {
          const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
          this.res = null;
          if (err || !res2.readable) {
            util2.destroy(res2, err);
          }
          this.callback = null;
          this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
          if (err) {
            abort();
          }
        });
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res.write(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        this.trailers = util2.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util2.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util2.destroy(body, err);
        }
      }
    };
    function stream4(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          stream4.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = stream4;
  }
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "node_modules/undici/lib/api/api-pipeline.js"(exports2, module2) {
    "use strict";
    var {
      Readable: Readable2,
      Duplex,
      PassThrough
    } = require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util2 = require_util();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require("assert");
    var kResume = Symbol("resume");
    var PipelineRequest = class extends Readable2 {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume } = this;
        if (resume) {
          this[kResume] = null;
          resume();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable2 {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", util2.nop);
        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body && body.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util2.destroy(body, err);
            util2.destroy(req, err);
            util2.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        const { ret, res } = this;
        assert(!res, "pipeline cannot be retried");
        if (ret.destroyed) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        const { opaque, handler, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context
          });
        } catch (err) {
          this.res.on("error", util2.nop);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util2.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util2.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util2.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module2.exports = pipeline;
  }
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "node_modules/undici/lib/api/api-upgrade.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var { AsyncResource } = require("async_hooks");
    var util2 = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require("assert");
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        assert.strictEqual(statusCode, 101);
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch({
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        }, upgradeHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = upgrade;
  }
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "node_modules/undici/lib/api/api-connect.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var { AsyncResource } = require("async_hooks");
    var util2 = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = connect;
  }
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "node_modules/undici/lib/api/index.js"(exports2, module2) {
    "use strict";
    module2.exports.request = require_api_request();
    module2.exports.stream = require_api_stream();
    module2.exports.pipeline = require_api_pipeline();
    module2.exports.upgrade = require_api_upgrade();
    module2.exports.connect = require_api_connect();
  }
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "node_modules/undici/lib/mock/mock-errors.js"(exports2, module2) {
    "use strict";
    var { UndiciError } = require_errors();
    var MockNotMatchedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, MockNotMatchedError);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module2.exports = {
      MockNotMatchedError
    };
  }
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "node_modules/undici/lib/mock/mock-symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected")
    };
  }
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "node_modules/undici/lib/mock/mock-utils.js"(exports2, module2) {
    "use strict";
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols();
    var { buildURL: buildURL2, nop } = require_util();
    var { STATUS_CODES } = require("http");
    var {
      types: {
        isPromise
      }
    } = require("util");
    function matchValue(match, value) {
      if (typeof match === "string") {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === "function") {
        return match(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone = headers.slice();
      const entries = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue2] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue2, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function safeUrl(path) {
      if (typeof path !== "string") {
        return path;
      }
      const pathSegments = path.split("?");
      if (pathSegments.length !== 2) {
        return path;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else {
        return data.toString();
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? buildURL2(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function buildKey(opts) {
      const { path, method, body, headers, query } = opts;
      return {
        path,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
        ...keyValuePairs,
        Buffer.from(`${key}`),
        Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
      ], []);
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
      const { timesInvoked, times } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times;
      mockDispatch2.pending = timesInvoked < times;
      if (error !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error);
        return true;
      }
      if (typeof delay === "number" && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches, _data = data) {
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
        if (isPromise(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.abort = nop;
        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
        handler.onData(Buffer.from(responseData));
        handler.onComplete(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error) {
            if (error instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url2 = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url2.host))) {
        return true;
      }
      return false;
    }
    function buildMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        return mockOptions;
      }
    }
    module2.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions,
      getHeaderByName
    };
  }
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "node_modules/undici/lib/mock/mock-interceptor.js"(exports2, module2) {
    "use strict";
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors();
    var { buildURL: buildURL2 } = require_util();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = buildURL2(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(statusCode, data, responseOptions) {
        if (typeof statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof data === "undefined") {
          throw new InvalidArgumentError("data must be defined");
        }
        if (typeof responseOptions !== "object") {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyData) {
        if (typeof replyData === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyData(opts);
            if (typeof resolvedData !== "object") {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
            this.validateReplyParameters(statusCode2, data2, responseOptions2);
            return {
              ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch2);
        }
        const [statusCode, data = "", responseOptions = {}] = [...arguments];
        this.validateReplyParameters(statusCode, data, responseOptions);
        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error) {
        if (typeof error === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
        return new MockScope(newMockDispatch);
      }
      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module2.exports.MockInterceptor = MockInterceptor;
    module2.exports.MockScope = MockScope;
  }
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "node_modules/undici/lib/mock/mock-client.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util");
    var Client3 = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockClient = class extends Client3 {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockClient;
  }
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "node_modules/undici/lib/mock/mock-pool.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util");
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockPool;
  }
});

// node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({
  "node_modules/undici/lib/mock/pluralizer.js"(exports2, module2) {
    "use strict";
    var singulars = {
      pronoun: "it",
      is: "is",
      was: "was",
      this: "this"
    };
    var plurals = {
      pronoun: "they",
      is: "are",
      was: "were",
      this: "these"
    };
    module2.exports = class Pluralizer {
      constructor(singular, plural) {
        this.singular = singular;
        this.plural = plural;
      }
      pluralize(count) {
        const one = count === 1;
        const keys = one ? singulars : plurals;
        const noun = one ? this.singular : this.plural;
        return { ...keys, count, noun };
      }
    };
  }
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("stream");
    var { Console } = require("console");
    module2.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          }
        });
        this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path,
            "Status code": statusCode,
            Persistent: persist ? "\u2705" : "\u274C",
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  }
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "node_modules/undici/lib/mock/mock-agent.js"(exports2, module2) {
    "use strict";
    var { kClients } = require_symbols();
    var Agent = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, buildMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors();
    var Dispatcher = require_dispatcher();
    var Pluralizer = require_pluralizer();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var FakeWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = opts && opts.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        return this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, new FakeWeakRef(dispatcher));
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const ref = this[kClients].get(origin);
        if (ref) {
          return ref.deref();
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
          const nonExplicitDispatcher = nonExplicitRef.deref();
          if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending = this.pendingInterceptors();
        if (pending.length === 0) {
          return;
        }
        const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
        throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
      }
    };
    module2.exports = MockAgent;
  }
});

// node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({
  "node_modules/undici/lib/proxy-agent.js"(exports2, module2) {
    "use strict";
    var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
    var { URL: URL2 } = require("url");
    var Agent = require_agent();
    var Pool = require_pool();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var buildConnector = require_connect();
    var kAgent = Symbol("proxy agent");
    var kClient = Symbol("proxy client");
    var kProxyHeaders = Symbol("proxy headers");
    var kRequestTls = Symbol("request tls settings");
    var kProxyTls = Symbol("proxy tls settings");
    var kConnectEndpoint = Symbol("connect endpoint function");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function buildProxyOptions(opts) {
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      return {
        uri: opts.uri,
        protocol: opts.protocol || "https"
      };
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        super(opts);
        this[kProxy] = buildProxyOptions(opts);
        this[kAgent] = new Agent(opts);
        this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
        if (typeof opts === "string") {
          opts = { uri: opts };
        }
        if (!opts || !opts.uri) {
          throw new InvalidArgumentError("Proxy opts.uri is mandatory");
        }
        const { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory !== "function") {
          throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        }
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};
        if (opts.auth && opts.token) {
          throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        } else if (opts.auth) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]["proxy-authorization"] = opts.token;
        }
        const resolvedUrl = new URL2(opts.uri);
        const { origin, port, host } = resolvedUrl;
        const connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        this[kClient] = clientFactory(resolvedUrl, { connect });
        this[kAgent] = new Agent({
          ...opts,
          connect: async (opts2, callback) => {
            let requestedHost = opts2.host;
            if (!opts2.port) {
              requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedHost,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host
                }
              });
              if (statusCode !== 200) {
                socket.on("error", () => {
                }).destroy();
                callback(new RequestAbortedError("Proxy response !== 200 when HTTP Tunneling"));
              }
              if (opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts2.servername;
              }
              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              callback(err);
            }
          }
        });
      }
      dispatch(opts, handler) {
        const { host } = new URL2(opts.origin);
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        return this[kAgent].dispatch(
          {
            ...opts,
            headers: {
              ...headers,
              host
            }
          },
          handler
        );
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i = 0; i < headers.length; i += 2) {
          headersPair[headers[i]] = headers[i + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
      if (existProxyAuth) {
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    module2.exports = ProxyAgent;
  }
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS({
  "node_modules/undici/lib/global.js"(exports2, module2) {
    "use strict";
    var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
    var { InvalidArgumentError } = require_errors();
    var Agent = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module2.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({
  "node_modules/undici/lib/handler/DecoratorHandler.js"(exports2, module2) {
    "use strict";
    module2.exports = class DecoratorHandler {
      constructor(handler) {
        this.handler = handler;
      }
      onConnect(...args) {
        return this.handler.onConnect(...args);
      }
      onError(...args) {
        return this.handler.onError(...args);
      }
      onUpgrade(...args) {
        return this.handler.onUpgrade(...args);
      }
      onHeaders(...args) {
        return this.handler.onHeaders(...args);
      }
      onData(...args) {
        return this.handler.onData(...args);
      }
      onComplete(...args) {
        return this.handler.onComplete(...args);
      }
      onBodySent(...args) {
        return this.handler.onBodySent(...args);
      }
    };
  }
});

// node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({
  "node_modules/undici/lib/fetch/headers.js"(exports2, module2) {
    "use strict";
    var { kHeadersList } = require_symbols();
    var { kGuard, kHeadersCaseInsensitive } = require_symbols2();
    var { kEnumerableProperty } = require_util();
    var {
      makeIterator,
      isValidHeaderName: isValidHeaderName2,
      isValidHeaderValue
    } = require_util2();
    var { webidl } = require_webidl();
    var assert = require("assert");
    var kHeadersMap = Symbol("headers map");
    var kHeadersSortedMap = Symbol("headers map sorted");
    function headerValueNormalize(potentialValue) {
      let i = potentialValue.length;
      while (/[\r\n\t ]/.test(potentialValue.charAt(--i)))
        ;
      return potentialValue.slice(0, i + 1).replace(/^[\r\n\t ]+/, "");
    }
    function fill(headers, object) {
      if (Array.isArray(object)) {
        for (const header of object) {
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          }
          headers.append(header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        for (const [key, value] of Object.entries(object)) {
          headers.append(key, value);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      }
    }
    var HeadersList = class {
      /** @type {[string, string][]|null} */
      cookies = null;
      constructor(init) {
        if (init instanceof HeadersList) {
          this[kHeadersMap] = new Map(init[kHeadersMap]);
          this[kHeadersSortedMap] = init[kHeadersSortedMap];
          this.cookies = init.cookies;
        } else {
          this[kHeadersMap] = new Map(init);
          this[kHeadersSortedMap] = null;
        }
      }
      // https://fetch.spec.whatwg.org/#header-list-contains
      contains(name) {
        name = name.toLowerCase();
        return this[kHeadersMap].has(name);
      }
      clear() {
        this[kHeadersMap].clear();
        this[kHeadersSortedMap] = null;
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-append
      append(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        const exists = this[kHeadersMap].get(lowercaseName);
        if (exists) {
          const delimiter = lowercaseName === "cookie" ? "; " : ", ";
          this[kHeadersMap].set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter}${value}`
          });
        } else {
          this[kHeadersMap].set(lowercaseName, { name, value });
        }
        if (lowercaseName === "set-cookie") {
          this.cookies ??= [];
          this.cookies.push(value);
        }
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-set
      set(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        if (lowercaseName === "set-cookie") {
          this.cookies = [value];
        }
        return this[kHeadersMap].set(lowercaseName, { name, value });
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-delete
      delete(name) {
        this[kHeadersSortedMap] = null;
        name = name.toLowerCase();
        if (name === "set-cookie") {
          this.cookies = null;
        }
        return this[kHeadersMap].delete(name);
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-get
      get(name) {
        if (!this.contains(name)) {
          return null;
        }
        return this[kHeadersMap].get(name.toLowerCase())?.value ?? null;
      }
      *[Symbol.iterator]() {
        for (const [name, { value }] of this[kHeadersMap]) {
          yield [name, value];
        }
      }
      get [kHeadersCaseInsensitive]() {
        const flatList = [];
        for (const { name, value } of this[kHeadersMap].values()) {
          flatList.push(name, value);
        }
        return flatList;
      }
    };
    var Headers = class {
      constructor(init = void 0) {
        this[kHeadersList] = new HeadersList();
        this[kGuard] = "none";
        if (init !== void 0) {
          init = webidl.converters.HeadersInit(init);
          fill(this, init);
        }
      }
      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name, value) {
        webidl.brandCheck(this, Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName2(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.append",
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.append",
            value,
            type: "header value"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        return this[kHeadersList].append(name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name) {
        webidl.brandCheck(this, Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName2(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name,
            type: "header name"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        if (!this[kHeadersList].contains(name)) {
          return;
        }
        return this[kHeadersList].delete(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name) {
        webidl.brandCheck(this, Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName2(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.get",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].get(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name) {
        webidl.brandCheck(this, Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName2(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.has",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].contains(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name, value) {
        webidl.brandCheck(this, Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName2(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value,
            type: "header value"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        return this[kHeadersList].set(name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, Headers);
        const list = this[kHeadersList].cookies;
        if (list) {
          return [...list];
        }
        return [];
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
      get [kHeadersSortedMap]() {
        if (this[kHeadersList][kHeadersSortedMap]) {
          return this[kHeadersList][kHeadersSortedMap];
        }
        const headers = [];
        const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
        const cookies = this[kHeadersList].cookies;
        for (const [name, value] of names) {
          if (name === "set-cookie") {
            for (const value2 of cookies) {
              headers.push([name, value2]);
            }
          } else {
            assert(value !== null);
            headers.push([name, value]);
          }
        }
        this[kHeadersList][kHeadersSortedMap] = headers;
        return headers;
      }
      keys() {
        webidl.brandCheck(this, Headers);
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, Headers);
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "value"
        );
      }
      entries() {
        webidl.brandCheck(this, Headers);
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key+value"
        );
      }
      /**
       * @param {(value: string, key: string, self: Headers) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        webidl.brandCheck(this, Headers);
        return this[kHeadersList];
      }
    };
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      keys: kEnumerableProperty,
      values: kEnumerableProperty,
      entries: kEnumerableProperty,
      forEach: kEnumerableProperty,
      [Symbol.iterator]: { enumerable: false },
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: true
      }
    });
    webidl.converters.HeadersInit = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (V[Symbol.iterator]) {
          return webidl.converters["sequence<sequence<ByteString>>"](V);
        }
        return webidl.converters["record<ByteString, ByteString>"](V);
      }
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module2.exports = {
      fill,
      Headers,
      HeadersList
    };
  }
});

// node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({
  "node_modules/undici/lib/fetch/response.js"(exports2, module2) {
    "use strict";
    var { Headers, HeadersList, fill } = require_headers();
    var { extractBody, cloneBody, mixinBody } = require_body();
    var util2 = require_util();
    var { kEnumerableProperty } = util2;
    var {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      isBlobLike,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode
    } = require_util2();
    var {
      redirectStatus,
      nullBodyStatus,
      DOMException
    } = require_constants();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { FormData: FormData3 } = require_formdata();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList } = require_symbols();
    var assert = require("assert");
    var { types } = require("util");
    var ReadableStream = globalThis.ReadableStream || require("stream/web").ReadableStream;
    var Response = class {
      // Creates network error Response.
      static error() {
        const relevantRealm = { settingsObject: {} };
        const responseObject = new Response();
        responseObject[kState] = makeNetworkError();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data = void 0, init = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
        if (init !== null) {
          init = webidl.converters.ResponseInit(init);
        }
        const bytes = new TextEncoder("utf-8").encode(
          serializeJavascriptValueToJSONString(data)
        );
        const body = extractBody(bytes);
        const relevantRealm = { settingsObject: {} };
        const responseObject = new Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "response";
        responseObject[kHeaders][kRealm] = relevantRealm;
        initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
        return responseObject;
      }
      // Creates a redirect Response that redirects to url with status status.
      static redirect(url2, status = 302) {
        const relevantRealm = { settingsObject: {} };
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
        url2 = webidl.converters.USVString(url2);
        status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url2, getGlobalOrigin());
        } catch (err) {
          throw Object.assign(new TypeError("Failed to parse URL from " + url2), {
            cause: err
          });
        }
        if (!redirectStatus.includes(status)) {
          throw new RangeError("Invalid status code " + status);
        }
        const responseObject = new Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        responseObject[kState].status = status;
        const value = isomorphicEncode(URLSerializer(parsedURL));
        responseObject[kState].headersList.append("location", value);
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init = {}) {
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init = webidl.converters.ResponseInit(init);
        this[kRealm] = { settingsObject: {} };
        this[kState] = makeResponse({});
        this[kHeaders] = new Headers();
        this[kHeaders][kGuard] = "response";
        this[kHeaders][kHeadersList] = this[kState].headersList;
        this[kHeaders][kRealm] = this[kRealm];
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init, bodyWithType);
      }
      // Returns response’s type, e.g., "cors".
      get type() {
        webidl.brandCheck(this, Response);
        return this[kState].type;
      }
      // Returns response’s URL, if it has one; otherwise the empty string.
      get url() {
        webidl.brandCheck(this, Response);
        const urlList = this[kState].urlList;
        const url2 = urlList[urlList.length - 1] ?? null;
        if (url2 === null) {
          return "";
        }
        return URLSerializer(url2, true);
      }
      // Returns whether response was obtained through a redirect.
      get redirected() {
        webidl.brandCheck(this, Response);
        return this[kState].urlList.length > 1;
      }
      // Returns response’s status.
      get status() {
        webidl.brandCheck(this, Response);
        return this[kState].status;
      }
      // Returns whether response’s status is an ok status.
      get ok() {
        webidl.brandCheck(this, Response);
        return this[kState].status >= 200 && this[kState].status <= 299;
      }
      // Returns response’s status message.
      get statusText() {
        webidl.brandCheck(this, Response);
        return this[kState].statusText;
      }
      // Returns response’s headers as Headers.
      get headers() {
        webidl.brandCheck(this, Response);
        return this[kHeaders];
      }
      get body() {
        webidl.brandCheck(this, Response);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, Response);
        return !!this[kState].body && util2.isDisturbed(this[kState].body.stream);
      }
      // Returns a clone of response.
      clone() {
        webidl.brandCheck(this, Response);
        if (this.bodyUsed || this.body && this.body.locked) {
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        }
        const clonedResponse = cloneResponse(this[kState]);
        const clonedResponseObject = new Response();
        clonedResponseObject[kState] = clonedResponse;
        clonedResponseObject[kRealm] = this[kRealm];
        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        return clonedResponseObject;
      }
    };
    mixinBody(Response);
    Object.defineProperties(Response.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: true
      }
    });
    Object.defineProperties(Response, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(response.body);
      }
      return newResponse;
    }
    function makeResponse(init) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
        urlList: init.urlList ? [...init.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      const isError = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError ? reason : new Error(reason ? String(reason) : reason, {
          cause: isError ? reason : void 0
        }),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert(!(p in state));
          target[p] = value;
          return true;
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      } else if (type === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      } else if (type === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      } else {
        assert(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams) {
      assert(isCancelled(fetchParams));
      return isAborted(fetchParams) ? makeNetworkError(new DOMException("The operation was aborted.", "AbortError")) : makeNetworkError("Request was cancelled.");
    }
    function initializeResponse(response, init, body) {
      if (init.status !== null && (init.status < 200 || init.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in init && init.statusText != null) {
        if (!isValidReasonPhrase(String(init.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in init && init.status != null) {
        response[kState].status = init.status;
      }
      if ("statusText" in init && init.statusText != null) {
        response[kState].statusText = init.statusText;
      }
      if ("headers" in init && init.headers != null) {
        fill(response[kState].headersList, init.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: "Response constructor",
            message: "Invalid response status code " + response.status
          });
        }
        response[kState].body = body.body;
        if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
          response[kState].headersList.append("content-type", body.type);
        }
      }
    }
    webidl.converters.ReadableStream = webidl.interfaceConverter(
      ReadableStream
    );
    webidl.converters.FormData = webidl.interfaceConverter(
      FormData3
    );
    webidl.converters.URLSearchParams = webidl.interfaceConverter(
      URLSearchParams
    );
    webidl.converters.XMLHttpRequestBodyInit = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (types.isAnyArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
        return webidl.converters.BufferSource(V);
      }
      if (util2.isFormDataLike(V)) {
        return webidl.converters.FormData(V, { strict: false });
      }
      if (V instanceof URLSearchParams) {
        return webidl.converters.URLSearchParams(V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.BodyInit = function(V) {
      if (V instanceof ReadableStream) {
        return webidl.converters.ReadableStream(V);
      }
      if (V?.[Symbol.asyncIterator]) {
        return V;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    module2.exports = {
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response
    };
  }
});

// node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS({
  "node_modules/undici/lib/fetch/request.js"(exports2, module2) {
    "use strict";
    var { extractBody, mixinBody, cloneBody } = require_body();
    var { Headers, fill: fillHeaders, HeadersList } = require_headers();
    var { FinalizationRegistry } = require_dispatcher_weakref()();
    var util2 = require_util();
    var {
      isValidHTTPToken,
      sameOrigin,
      normalizeMethod,
      makePolicyContainer
    } = require_util2();
    var {
      forbiddenMethods,
      corsSafeListedMethods,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex
    } = require_constants();
    var { kEnumerableProperty } = util2;
    var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList } = require_symbols();
    var assert = require("assert");
    var { setMaxListeners, getEventListeners, defaultMaxListeners } = require("events");
    var TransformStream = globalThis.TransformStream;
    var kInit = Symbol("init");
    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var Request = class {
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input, init = {}) {
        if (input === kInit) {
          return;
        }
        webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
        input = webidl.converters.RequestInfo(input);
        init = webidl.converters.RequestInit(init);
        this[kRealm] = {
          settingsObject: {
            baseUrl: getGlobalOrigin(),
            get origin() {
              return this.baseUrl?.origin;
            },
            policyContainer: makePolicyContainer()
          }
        };
        let request = null;
        let fallbackMode = null;
        const baseUrl = this[kRealm].settingsObject.baseUrl;
        let signal = null;
        if (typeof input === "string") {
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input
            );
          }
          request = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          assert(input instanceof Request);
          request = input[kState];
          signal = input[kSignal];
        }
        const origin = this[kRealm].settingsObject.origin;
        let window2 = "client";
        if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
          window2 = request.window;
        }
        if (init.window !== void 0 && init.window != null) {
          throw new TypeError(`'window' option '${window2}' must be null`);
        }
        if (init.window !== void 0) {
          window2 = "no-window";
        }
        request = makeRequest({
          // URL request’s URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method request’s method.
          method: request.method,
          // header list A copy of request’s header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request.unsafeRequest,
          // client This’s relevant settings object.
          client: this[kRealm].settingsObject,
          // window window.
          window: window2,
          // priority request’s priority.
          priority: request.priority,
          // origin request’s origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request.origin,
          // referrer request’s referrer.
          referrer: request.referrer,
          // referrer policy request’s referrer policy.
          referrerPolicy: request.referrerPolicy,
          // mode request’s mode.
          mode: request.mode,
          // credentials mode request’s credentials mode.
          credentials: request.credentials,
          // cache mode request’s cache mode.
          cache: request.cache,
          // redirect mode request’s redirect mode.
          redirect: request.redirect,
          // integrity metadata request’s integrity metadata.
          integrity: request.integrity,
          // keepalive request’s keepalive.
          keepalive: request.keepalive,
          // reload-navigation flag request’s reload-navigation flag.
          reloadNavigation: request.reloadNavigation,
          // history-navigation flag request’s history-navigation flag.
          historyNavigation: request.historyNavigation,
          // URL list A clone of request’s URL list.
          urlList: [...request.urlList]
        });
        if (Object.keys(init).length > 0) {
          if (request.mode === "navigate") {
            request.mode = "same-origin";
          }
          request.reloadNavigation = false;
          request.historyNavigation = false;
          request.origin = "client";
          request.referrer = "client";
          request.referrerPolicy = "";
          request.url = request.urlList[request.urlList.length - 1];
          request.urlList = [request.url];
        }
        if (init.referrer !== void 0) {
          const referrer = init.referrer;
          if (referrer === "") {
            request.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            request.referrer = parsedReferrer;
          }
        }
        if (init.referrerPolicy !== void 0) {
          request.referrerPolicy = init.referrerPolicy;
        }
        let mode;
        if (init.mode !== void 0) {
          mode = init.mode;
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        }
        if (mode != null) {
          request.mode = mode;
        }
        if (init.credentials !== void 0) {
          request.credentials = init.credentials;
        }
        if (init.cache !== void 0) {
          request.cache = init.cache;
        }
        if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }
        if (init.redirect !== void 0) {
          request.redirect = init.redirect;
        }
        if (init.integrity !== void 0 && init.integrity != null) {
          request.integrity = String(init.integrity);
        }
        if (init.keepalive !== void 0) {
          request.keepalive = Boolean(init.keepalive);
        }
        if (init.method !== void 0) {
          let method = init.method;
          if (!isValidHTTPToken(init.method)) {
            throw TypeError(`'${init.method}' is not a valid HTTP method.`);
          }
          if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {
            throw TypeError(`'${init.method}' HTTP method is unsupported.`);
          }
          method = normalizeMethod(init.method);
          request.method = method;
        }
        if (init.signal !== void 0) {
          signal = init.signal;
        }
        this[kState] = request;
        const ac = new AbortController();
        this[kSignal] = ac.signal;
        this[kSignal][kRealm] = this[kRealm];
        if (signal != null) {
          if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
            throw new TypeError(
              "Failed to construct 'Request': member signal is not of type AbortSignal."
            );
          }
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            const abort = function() {
              ac.abort(this.reason);
            };
            try {
              if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
                setMaxListeners(100, signal);
              }
            } catch {
            }
            signal.addEventListener("abort", abort, { once: true });
            requestFinalizer.register(this, { signal, abort });
          }
        }
        this[kHeaders] = new Headers();
        this[kHeaders][kHeadersList] = request.headersList;
        this[kHeaders][kGuard] = "request";
        this[kHeaders][kRealm] = this[kRealm];
        if (mode === "no-cors") {
          if (!corsSafeListedMethods.includes(request.method)) {
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          }
          this[kHeaders][kGuard] = "request-no-cors";
        }
        if (Object.keys(init).length !== 0) {
          let headers = new Headers(this[kHeaders]);
          if (init.headers !== void 0) {
            headers = init.headers;
          }
          this[kHeaders][kHeadersList].clear();
          if (headers.constructor.name === "Headers") {
            for (const [key, val] of headers) {
              this[kHeaders].append(key, val);
            }
          } else {
            fillHeaders(this[kHeaders], headers);
          }
        }
        const inputBody = input instanceof Request ? input[kState].body : null;
        if ((init.body !== void 0 && init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init.body !== void 0 && init.body != null) {
          const [extractedBody, contentType] = extractBody(
            init.body,
            request.keepalive
          );
          initBody = extractedBody;
          if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
            this[kHeaders].append("content-type", contentType);
          }
        }
        const inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init.duplex == null) {
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          }
          if (request.mode !== "same-origin" && request.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }
          request.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (util2.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }
          if (!TransformStream) {
            TransformStream = require("stream/web").TransformStream;
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this[kState].body = finalBody;
      }
      // Returns request’s HTTP method, which is "GET" by default.
      get method() {
        webidl.brandCheck(this, Request);
        return this[kState].method;
      }
      // Returns the URL of request as a string.
      get url() {
        webidl.brandCheck(this, Request);
        return URLSerializer(this[kState].url);
      }
      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        webidl.brandCheck(this, Request);
        return this[kHeaders];
      }
      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        webidl.brandCheck(this, Request);
        return this[kState].destination;
      }
      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the global’s default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        webidl.brandCheck(this, Request);
        if (this[kState].referrer === "no-referrer") {
          return "";
        }
        if (this[kState].referrer === "client") {
          return "about:client";
        }
        return this[kState].referrer.toString();
      }
      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the request’s
      // referrer.
      get referrerPolicy() {
        webidl.brandCheck(this, Request);
        return this[kState].referrerPolicy;
      }
      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        webidl.brandCheck(this, Request);
        return this[kState].mode;
      }
      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        return this[kState].credentials;
      }
      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browser’s cache when fetching.
      get cache() {
        webidl.brandCheck(this, Request);
        return this[kState].cache;
      }
      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        webidl.brandCheck(this, Request);
        return this[kState].redirect;
      }
      // Returns request’s subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        webidl.brandCheck(this, Request);
        return this[kState].integrity;
      }
      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        webidl.brandCheck(this, Request);
        return this[kState].keepalive;
      }
      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        webidl.brandCheck(this, Request);
        return this[kState].reloadNavigation;
      }
      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-foward navigation).
      get isHistoryNavigation() {
        webidl.brandCheck(this, Request);
        return this[kState].historyNavigation;
      }
      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        webidl.brandCheck(this, Request);
        return this[kSignal];
      }
      get body() {
        webidl.brandCheck(this, Request);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, Request);
        return !!this[kState].body && util2.isDisturbed(this[kState].body.stream);
      }
      get duplex() {
        webidl.brandCheck(this, Request);
        return "half";
      }
      // Returns a clone of request.
      clone() {
        webidl.brandCheck(this, Request);
        if (this.bodyUsed || this.body?.locked) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this[kState]);
        const clonedRequestObject = new Request(kInit);
        clonedRequestObject[kState] = clonedRequest;
        clonedRequestObject[kRealm] = this[kRealm];
        clonedRequestObject[kHeaders] = new Headers();
        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          this.signal.addEventListener(
            "abort",
            () => {
              ac.abort(this.signal.reason);
            },
            { once: true }
          );
        }
        clonedRequestObject[kSignal] = ac.signal;
        return clonedRequestObject;
      }
    };
    mixinBody(Request);
    function makeRequest(init) {
      const request = {
        method: "GET",
        localURLsOnly: false,
        unsafeRequest: false,
        body: null,
        client: null,
        reservedClient: null,
        replacesClientId: "",
        window: "client",
        keepalive: false,
        serviceWorkers: "all",
        initiator: "",
        destination: "",
        priority: null,
        origin: "client",
        policyContainer: "client",
        referrer: "client",
        referrerPolicy: "",
        mode: "no-cors",
        useCORSPreflightFlag: false,
        credentials: "same-origin",
        useCredentials: false,
        cache: "default",
        redirect: "follow",
        integrity: "",
        cryptoGraphicsNonceMetadata: "",
        parserMetadata: "",
        reloadNavigation: false,
        historyNavigation: false,
        userActivation: false,
        taintedOrigin: false,
        redirectCount: 0,
        responseTainting: "basic",
        preventNoCacheCacheControlHeaderModification: false,
        done: false,
        timingAllowFailed: false,
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
      };
      request.url = request.urlList[0];
      return request;
    }
    function cloneRequest(request) {
      const newRequest = makeRequest({ ...request, body: null });
      if (request.body != null) {
        newRequest.body = cloneBody(request.body);
      }
      return newRequest;
    }
    Object.defineProperties(Request.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: true
      }
    });
    webidl.converters.Request = webidl.interfaceConverter(
      Request
    );
    webidl.converters.RequestInfo = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (V instanceof Request) {
        return webidl.converters.Request(V);
      }
      return webidl.converters.USVString(V);
    };
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      AbortSignal
    );
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            { strict: false }
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex
      }
    ]);
    module2.exports = { Request, makeRequest };
  }
});

// node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/undici/lib/fetch/index.js"(exports2, module2) {
    "use strict";
    var {
      Response,
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse
    } = require_response();
    var { Headers } = require_headers();
    var { Request, makeRequest } = require_request2();
    var zlib2 = require("zlib");
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode
    } = require_util2();
    var { kState, kHeaders, kGuard, kRealm, kHeadersCaseInsensitive } = require_symbols2();
    var assert = require("assert");
    var { safelyExtractBody } = require_body();
    var {
      redirectStatus,
      nullBodyStatus,
      safeMethods,
      requestBodyHeader,
      subresource,
      DOMException
    } = require_constants();
    var { kHeadersList } = require_symbols();
    var EE = require("events");
    var { Readable: Readable2, pipeline } = require("stream");
    var { isErrored, isReadable, nodeMajor, nodeMinor } = require_util();
    var { dataURLProcessor, serializeAMimeType } = require_dataURL();
    var { TransformStream } = require("stream/web");
    var { getGlobalDispatcher } = require_global2();
    var { webidl } = require_webidl();
    var { STATUS_CODES } = require("http");
    var resolveObjectURL;
    var ReadableStream = globalThis.ReadableStream;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
        this.setMaxListeners(21);
      }
      terminate(reason) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        this.connection?.destroy(reason);
        this.emit("terminated", reason);
      }
      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "aborted";
        if (!error) {
          error = new DOMException("The operation was aborted.", "AbortError");
        }
        this.serializedAbortReason = error;
        this.connection?.destroy(error);
        this.emit("terminated", error);
      }
    };
    async function fetch(input, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
      const p = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request(input, init);
      } catch (e) {
        p.reject(e);
        return p.promise;
      }
      const request = requestObject[kState];
      if (requestObject.signal.aborted) {
        abortFetch(p, request, null, requestObject.signal.reason);
        return p.promise;
      }
      const globalObject = request.client.globalObject;
      if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
        request.serviceWorkers = "none";
      }
      let responseObject = null;
      const relevantRealm = null;
      let locallyAborted = false;
      let controller = null;
      requestObject.signal.addEventListener(
        "abort",
        () => {
          locallyAborted = true;
          abortFetch(p, request, responseObject, requestObject.signal.reason);
          if (controller != null) {
            controller.abort();
          }
        },
        { once: true }
      );
      const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
      const processResponse = (response) => {
        if (locallyAborted) {
          return;
        }
        if (response.aborted) {
          abortFetch(p, request, responseObject, controller.serializedAbortReason);
          return;
        }
        if (response.type === "error") {
          p.reject(
            Object.assign(new TypeError("fetch failed"), { cause: response.error })
          );
          return;
        }
        responseObject = new Response();
        responseObject[kState] = response;
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        p.resolve(responseObject);
      };
      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: init.dispatcher ?? getGlobalDispatcher()
        // undici
      });
      return p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!response.urlList?.length) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!/^https?:/.test(originalURL.protocol)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!timingInfo.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(
        timingInfo,
        originalURL,
        initiatorType,
        globalThis,
        cacheState
      );
    }
    function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
      if (nodeMajor >= 18 && nodeMinor >= 2) {
        performance.markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState);
      }
    }
    function abortFetch(p, request, responseObject, error) {
      if (!error) {
        error = new DOMException("The operation was aborted.", "AbortError");
      }
      p.reject(error);
      if (request.body != null && isReadable(request.body?.stream)) {
        request.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = responseObject[kState];
      if (response.body != null && isReadable(response.body?.stream)) {
        response.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher
      // undici
    }) {
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request.client != null) {
        taskDestination = request.client.globalObject;
        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
      }
      const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currenTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert(!request.body || request.body.stream);
      if (request.window === "client") {
        request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
      }
      if (request.origin === "client") {
        request.origin = request.client?.origin;
      }
      if (request.policyContainer === "client") {
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(
            request.client.policyContainer
          );
        } else {
          request.policyContainer = makePolicyContainer();
        }
      }
      if (!request.headersList.contains("accept")) {
        const value = "*/*";
        request.headersList.append("accept", value);
      }
      if (!request.headersList.contains("accept-language")) {
        request.headersList.append("accept-language", "*");
      }
      if (request.priority === null) {
      }
      if (subresource.includes(request.destination)) {
      }
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request = fetchParams.request;
      let response = null;
      if (request.localURLsOnly && !/^(about|blob|data):/.test(requestCurrentURL(request).protocol)) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
      if (requestBadPort(request) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }
      if (request.referrer !== "no-referrer") {
        request.referrer = determineRequestsReferrer(request);
      }
      if (response === null) {
        response = await (async () => {
          const currentURL = requestCurrentURL(request);
          if (
            // - request’s current URL’s origin is same origin with request’s origin,
            //   and request’s response tainting is "basic"
            sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || // request’s current URL’s scheme is "data"
            currentURL.protocol === "data:" || // - request’s mode is "navigate" or "websocket"
            (request.mode === "navigate" || request.mode === "websocket")
          ) {
            request.responseTainting = "basic";
            return await schemeFetch(fetchParams);
          }
          if (request.mode === "same-origin") {
            return makeNetworkError('request mode cannot be "same-origin"');
          }
          if (request.mode === "no-cors") {
            if (request.redirect !== "follow") {
              return makeNetworkError(
                'redirect mode cannot be "follow" for "no-cors" request'
              );
            }
            request.responseTainting = "opaque";
            return await schemeFetch(fetchParams);
          }
          if (!/^https?:/.test(requestCurrentURL(request).protocol)) {
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }
          request.responseTainting = "cors";
          return await httpFetch(fetchParams);
        })();
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request.responseTainting === "cors") {
        }
        if (request.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range")) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    async function schemeFetch(fetchParams) {
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return makeAppropriateNetworkError(fetchParams);
      }
      const { request } = fetchParams;
      const { protocol: scheme } = requestCurrentURL(request);
      switch (scheme) {
        case "about:": {
          return makeNetworkError("about scheme is not supported");
        }
        case "blob:": {
          if (!resolveObjectURL) {
            resolveObjectURL = require("buffer").resolveObjectURL;
          }
          const blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0) {
            return makeNetworkError("NetworkError when attempting to fetch resource.");
          }
          const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
            return makeNetworkError("invalid method");
          }
          const bodyWithType = safelyExtractBody(blobURLEntryObject);
          const body = bodyWithType[0];
          const length = isomorphicEncode(`${body.length}`);
          const type = bodyWithType[1] ?? "";
          const response = makeResponse({
            statusText: "OK",
            headersList: [
              ["content-length", { name: "Content-Length", value: length }],
              ["content-type", { name: "Content-Type", value: type }]
            ]
          });
          response.body = body;
          return response;
        }
        case "data:": {
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return makeNetworkError("failed to fetch the data URL");
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", { name: "Content-Type", value: mimeType }]
            ],
            body: safelyExtractBody(dataURLStruct.body)[0]
          });
        }
        case "file:": {
          return makeNetworkError("not implemented... yet...");
        }
        case "http:":
        case "https:": {
          return await httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return makeNetworkError("unknown scheme");
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    async function fetchFinale(fetchParams, response) {
      if (response.type === "error") {
        response.urlList = [fetchParams.request.urlList[0]];
        response.timingInfo = createOpaqueTimingInfo({
          startTime: fetchParams.timingInfo.startTime
        });
      }
      const processResponseEndOfBody = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => fetchParams.processResponse(response));
      }
      if (response.body == null) {
        processResponseEndOfBody();
      } else {
        const identityTransformAlgorithm = (chunk, controller) => {
          controller.enqueue(chunk);
        };
        const transformStream = new TransformStream({
          start() {
          },
          transform: identityTransformAlgorithm,
          flush: processResponseEndOfBody
        }, {
          size() {
            return 1;
          }
        }, {
          size() {
            return 1;
          }
        });
        response.body = { stream: response.body.stream.pipeThrough(transformStream) };
      }
      if (fetchParams.processResponseConsumeBody != null) {
        const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
        const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
        if (response.body == null) {
          queueMicrotask(() => processBody(null));
        } else {
          await fullyReadBody(response.body, processBody, processBodyError);
        }
      }
    }
    async function httpFetch(fetchParams) {
      const request = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers === "all") {
      }
      if (response === null) {
        if (request.redirect === "follow") {
          request.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request, response) === "failure") {
          request.timingAllowFailed = true;
        }
      }
      if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request.origin,
        request.client,
        request.destination,
        actualResponse
      ) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatus.includes(actualResponse.status)) {
        if (request.redirect !== "manual") {
          fetchParams.controller.connection.destroy();
        }
        if (request.redirect === "error") {
          response = makeNetworkError("unexpected redirect");
        } else if (request.redirect === "manual") {
          response = actualResponse;
        } else if (request.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    async function httpRedirectFetch(fetchParams, response) {
      const request = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        );
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return makeNetworkError(err);
      }
      if (!/^https?:/.test(locationURL.protocol)) {
        return makeNetworkError("URL scheme must be a HTTP(S) scheme");
      }
      if (request.redirectCount === 20) {
        return makeNetworkError("redirect count exceeded");
      }
      request.redirectCount += 1;
      if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
        return makeNetworkError('cross origin not allowed for request mode "cors"');
      }
      if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        );
      }
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
        return makeNetworkError();
      }
      if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !["GET", "HEAD"].includes(request.method)) {
        request.method = "GET";
        request.body = null;
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }
      if (!sameOrigin(requestCurrentURL(request), locationURL)) {
        request.headersList.delete("authorization");
      }
      if (request.body != null) {
        assert(request.body.source);
        request.body = safelyExtractBody(request.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      const httpCache = null;
      const revalidatingFlag = false;
      if (request.window === "no-window" && request.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        httpRequest = makeRequest(request);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue);
      }
      if (contentLength != null && httpRequest.keepalive) {
      }
      if (httpRequest.referrer instanceof URL) {
        httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.contains("user-agent")) {
        httpRequest.headersList.append("user-agent", "undici");
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
        httpRequest.headersList.append("cache-control", "max-age=0");
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.contains("pragma")) {
          httpRequest.headersList.append("pragma", "no-cache");
        }
        if (!httpRequest.headersList.contains("cache-control")) {
          httpRequest.headersList.append("cache-control", "no-cache");
        }
      }
      if (httpRequest.headersList.contains("range")) {
        httpRequest.headersList.append("accept-encoding", "identity");
      }
      if (!httpRequest.headersList.contains("accept-encoding")) {
        if (/^https:/.test(requestCurrentURL(httpRequest).protocol)) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate");
        }
      }
      if (includeCredentials) {
      }
      if (httpCache == null) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
      }
      if (response == null) {
        if (httpRequest.mode === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        if (!safeMethods.includes(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
        }
        if (revalidatingFlag && forwardResponse.status === 304) {
        }
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.contains("range")) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (
        // response’s status is 421
        response.status === 421 && // isNewConnectionFetch is false
        !isNewConnectionFetch && // request’s body is null, or request’s body is non-null and request’s body’s source is non-null
        (request.body == null || request.body.source != null)
      ) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }
      if (isAuthenticationFetch) {
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err) {
          if (!this.destroyed) {
            this.destroyed = true;
            this.abort?.(err ?? new DOMException("The operation was aborted.", "AbortError"));
          }
        }
      };
      const request = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      const httpCache = null;
      if (httpCache == null) {
        request.cache = "no-store";
      }
      const newConnection = forceNewConnection ? "yes" : "no";
      if (request.mode === "websocket") {
      } else {
      }
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        const processBodyChunk = async function* (bytes) {
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };
        requestBody = async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        }();
      }
      try {
        const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket) {
          response = makeResponse({ status, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();
          response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        if (err.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = () => {
        fetchParams.controller.resume();
      };
      const cancelAlgorithm = (reason) => {
        fetchParams.controller.abort(reason);
      };
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      const stream4 = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm(controller);
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          }
        },
        {
          highWaterMark: 0,
          size() {
            return 1;
          }
        }
      );
      response.body = { stream: stream4 };
      fetchParams.controller.on("terminated", onAborted);
      fetchParams.controller.resume = async () => {
        while (true) {
          let bytes;
          try {
            const { done, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams)) {
              break;
            }
            bytes = done ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
            }
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller);
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
          if (isErrorLike(bytes)) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
          if (isErrored(stream4)) {
            fetchParams.controller.terminate();
            return;
          }
          if (!fetchParams.controller.controller.desiredSize) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream4)) {
            fetchParams.controller.controller.error(
              fetchParams.controller.serializedAbortReason
            );
          }
        } else {
          if (isReadable(stream4)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: isErrorLike(reason) ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      async function dispatch({ body }) {
        const url2 = requestCurrentURL(request);
        const agent = fetchParams.controller.dispatcher;
        return new Promise((resolve, reject) => agent.dispatch(
          {
            path: url2.pathname + url2.search,
            origin: url2.origin,
            method: request.method,
            body: fetchParams.controller.dispatcher.isMockActive ? request.body && request.body.source : body,
            headers: request.headersList[kHeadersCaseInsensitive],
            maxRedirections: 0,
            upgrade: request.mode === "websocket" ? "websocket" : void 0
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              const { connection } = fetchParams.controller;
              if (connection.destroyed) {
                abort(new DOMException("The operation was aborted.", "AbortError"));
              } else {
                fetchParams.controller.on("terminated", abort);
                this.abort = connection.abort = abort;
              }
            },
            onHeaders(status, headersList, resume, statusText) {
              if (status < 200) {
                return;
              }
              let codings = [];
              let location = "";
              const headers = new Headers();
              for (let n = 0; n < headersList.length; n += 2) {
                const key = headersList[n + 0].toString("latin1");
                const val = headersList[n + 1].toString("latin1");
                if (key.toLowerCase() === "content-encoding") {
                  codings = val.split(",").map((x) => x.trim());
                } else if (key.toLowerCase() === "location") {
                  location = val;
                }
                headers.append(key, val);
              }
              this.body = new Readable2({ read: resume });
              const decoders = [];
              const willFollow = request.redirect === "follow" && location && redirectStatus.includes(status);
              if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                for (const coding of codings) {
                  if (/(x-)?gzip/.test(coding)) {
                    decoders.push(zlib2.createGunzip());
                  } else if (/(x-)?deflate/.test(coding)) {
                    decoders.push(zlib2.createInflate());
                  } else if (coding === "br") {
                    decoders.push(zlib2.createBrotliDecompress());
                  } else {
                    decoders.length = 0;
                    break;
                  }
                }
              }
              resolve({
                status,
                statusText,
                headersList: headers[kHeadersList],
                body: decoders.length ? pipeline(this.body, ...decoders, () => {
                }) : this.body.on("error", () => {
                })
              });
              return true;
            },
            onData(chunk) {
              if (fetchParams.controller.dump) {
                return;
              }
              const bytes = chunk;
              timingInfo.encodedBodySize += bytes.byteLength;
              return this.body.push(bytes);
            },
            onComplete() {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              fetchParams.controller.ended = true;
              this.body.push(null);
            },
            onError(error) {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              this.body?.destroy(error);
              fetchParams.controller.terminate(error);
              reject(error);
            },
            onUpgrade(status, headersList, socket) {
              if (status !== 101) {
                return;
              }
              const headers = new Headers();
              for (let n = 0; n < headersList.length; n += 2) {
                const key = headersList[n + 0].toString("latin1");
                const val = headersList[n + 1].toString("latin1");
                headers.append(key, val);
              }
              resolve({
                status,
                statusText: STATUS_CODES[status],
                headersList: headers[kHeadersList],
                socket
              });
              return true;
            }
          }
        ));
      }
    }
    module2.exports = {
      fetch,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS({
  "node_modules/undici/lib/fileapi/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kState: Symbol("FileReader state"),
      kResult: Symbol("FileReader result"),
      kError: Symbol("FileReader error"),
      kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
      kEvents: Symbol("FileReader events"),
      kAborted: Symbol("FileReader aborted")
    };
  }
});

// node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS({
  "node_modules/undici/lib/fileapi/progressevent.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var kState = Symbol("ProgressEvent state");
    var ProgressEvent = class extends Event {
      constructor(type, eventInitDict = {}) {
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
        super(type, eventInitDict);
        this[kState] = {
          lengthComputable: eventInitDict.lengthComputable,
          loaded: eventInitDict.loaded,
          total: eventInitDict.total
        };
      }
      get lengthComputable() {
        webidl.brandCheck(this, ProgressEvent);
        return this[kState].lengthComputable;
      }
      get loaded() {
        webidl.brandCheck(this, ProgressEvent);
        return this[kState].loaded;
      }
      get total() {
        webidl.brandCheck(this, ProgressEvent);
        return this[kState].total;
      }
    };
    webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
      {
        key: "lengthComputable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "loaded",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "total",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ]);
    module2.exports = {
      ProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS({
  "node_modules/undici/lib/fileapi/encoding.js"(exports2, module2) {
    "use strict";
    function getEncoding(label) {
      if (!label) {
        return "failure";
      }
      switch (label.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }
    module2.exports = {
      getEncoding
    };
  }
});

// node_modules/undici/lib/fileapi/util.js
var require_util3 = __commonJS({
  "node_modules/undici/lib/fileapi/util.js"(exports2, module2) {
    "use strict";
    var {
      kState,
      kError,
      kResult,
      kAborted,
      kLastProgressEventFired
    } = require_symbols3();
    var { ProgressEvent } = require_progressevent();
    var { getEncoding } = require_encoding();
    var { DOMException } = require_constants();
    var { serializeAMimeType, parseMIMEType } = require_dataURL();
    var { types } = require("util");
    var { StringDecoder } = require("string_decoder");
    var { btoa: btoa2 } = require("buffer");
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    function readOperation(fr, blob, type, encodingName) {
      if (fr[kState] === "loading") {
        throw new DOMException("Invalid state", "InvalidStateError");
      }
      fr[kState] = "loading";
      fr[kResult] = null;
      fr[kError] = null;
      const stream4 = blob.stream();
      const reader = stream4.getReader();
      const bytes = [];
      let chunkPromise = reader.read();
      let isFirstChunk = true;
      (async () => {
        while (!fr[kAborted]) {
          try {
            const { done, value } = await chunkPromise;
            if (isFirstChunk && !fr[kAborted]) {
              queueMicrotask(() => {
                fireAProgressEvent("loadstart", fr);
              });
            }
            isFirstChunk = false;
            if (!done && types.isUint8Array(value)) {
              bytes.push(value);
              if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
                fr[kLastProgressEventFired] = Date.now();
                queueMicrotask(() => {
                  fireAProgressEvent("progress", fr);
                });
              }
              chunkPromise = reader.read();
            } else if (done) {
              queueMicrotask(() => {
                fr[kState] = "done";
                try {
                  const result = packageData(bytes, type, blob.type, encodingName);
                  if (fr[kAborted]) {
                    return;
                  }
                  fr[kResult] = result;
                  fireAProgressEvent("load", fr);
                } catch (error) {
                  fr[kError] = error;
                  fireAProgressEvent("error", fr);
                }
                if (fr[kState] !== "loading") {
                  fireAProgressEvent("loadend", fr);
                }
              });
              break;
            }
          } catch (error) {
            if (fr[kAborted]) {
              return;
            }
            queueMicrotask(() => {
              fr[kState] = "done";
              fr[kError] = error;
              fireAProgressEvent("error", fr);
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        }
      })();
    }
    function fireAProgressEvent(e, reader) {
      const event = new ProgressEvent(e, {
        bubbles: false,
        cancelable: false
      });
      reader.dispatchEvent(event);
    }
    function packageData(bytes, type, mimeType, encodingName) {
      switch (type) {
        case "DataURL": {
          let dataURL = "data:";
          const parsed = parseMIMEType(mimeType || "application/octet-stream");
          if (parsed !== "failure") {
            dataURL += serializeAMimeType(parsed);
          }
          dataURL += ";base64,";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            dataURL += btoa2(decoder.write(chunk));
          }
          dataURL += btoa2(decoder.end());
          return dataURL;
        }
        case "Text": {
          let encoding = "failure";
          if (encodingName) {
            encoding = getEncoding(encodingName);
          }
          if (encoding === "failure" && mimeType) {
            const type2 = parseMIMEType(mimeType);
            if (type2 !== "failure") {
              encoding = getEncoding(type2.parameters.get("charset"));
            }
          }
          if (encoding === "failure") {
            encoding = "UTF-8";
          }
          return decode(bytes, encoding);
        }
        case "ArrayBuffer": {
          const sequence = combineByteSequences(bytes);
          return sequence.buffer;
        }
        case "BinaryString": {
          let binaryString = "";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            binaryString += decoder.write(chunk);
          }
          binaryString += decoder.end();
          return binaryString;
        }
      }
    }
    function decode(ioQueue, encoding) {
      const bytes = combineByteSequences(ioQueue);
      const BOMEncoding = BOMSniffing(bytes);
      let slice = 0;
      if (BOMEncoding !== null) {
        encoding = BOMEncoding;
        slice = BOMEncoding === "UTF-8" ? 3 : 2;
      }
      const sliced = bytes.slice(slice);
      return new TextDecoder(encoding).decode(sliced);
    }
    function BOMSniffing(ioQueue) {
      const [a, b, c] = ioQueue;
      if (a === 239 && b === 187 && c === 191) {
        return "UTF-8";
      } else if (a === 254 && b === 255) {
        return "UTF-16BE";
      } else if (a === 255 && b === 254) {
        return "UTF-16LE";
      }
      return null;
    }
    function combineByteSequences(sequences) {
      const size = sequences.reduce((a, b) => {
        return a + b.byteLength;
      }, 0);
      let offset = 0;
      return sequences.reduce((a, b) => {
        a.set(b, offset);
        offset += b.byteLength;
        return a;
      }, new Uint8Array(size));
    }
    module2.exports = {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS({
  "node_modules/undici/lib/fileapi/filereader.js"(exports2, module2) {
    "use strict";
    var {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    } = require_util3();
    var {
      kState,
      kError,
      kResult,
      kEvents,
      kAborted
    } = require_symbols3();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var FileReader = class extends EventTarget {
      constructor() {
        super();
        this[kState] = "empty";
        this[kResult] = null;
        this[kError] = null;
        this[kEvents] = {
          loadend: null,
          error: null,
          abort: null,
          load: null,
          progress: null,
          loadstart: null
        };
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
       * @param {import('buffer').Blob} blob
       */
      readAsArrayBuffer(blob) {
        webidl.brandCheck(this, FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "ArrayBuffer");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsBinaryString
       * @param {import('buffer').Blob} blob
       */
      readAsBinaryString(blob) {
        webidl.brandCheck(this, FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "BinaryString");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsDataText
       * @param {import('buffer').Blob} blob
       * @param {string?} encoding
       */
      readAsText(blob, encoding = void 0) {
        webidl.brandCheck(this, FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
        blob = webidl.converters.Blob(blob, { strict: false });
        if (encoding !== void 0) {
          encoding = webidl.converters.DOMString(encoding);
        }
        readOperation(this, blob, "Text", encoding);
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
       * @param {import('buffer').Blob} blob
       */
      readAsDataURL(blob) {
        webidl.brandCheck(this, FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "DataURL");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-abort
       */
      abort() {
        if (this[kState] === "empty" || this[kState] === "done") {
          this[kResult] = null;
          return;
        }
        if (this[kState] === "loading") {
          this[kState] = "done";
          this[kResult] = null;
        }
        this[kAborted] = true;
        fireAProgressEvent("abort", this);
        if (this[kState] !== "loading") {
          fireAProgressEvent("loadend", this);
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
       */
      get readyState() {
        webidl.brandCheck(this, FileReader);
        switch (this[kState]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-result
       */
      get result() {
        webidl.brandCheck(this, FileReader);
        return this[kResult];
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-error
       */
      get error() {
        webidl.brandCheck(this, FileReader);
        return this[kError];
      }
      get onloadend() {
        webidl.brandCheck(this, FileReader);
        return this[kEvents].loadend;
      }
      set onloadend(fn) {
        webidl.brandCheck(this, FileReader);
        if (this[kEvents].loadend) {
          this.removeEventListener("loadend", this[kEvents].loadend);
        }
        if (typeof fn === "function") {
          this[kEvents].loadend = fn;
          this.addEventListener("loadend", fn);
        } else {
          this[kEvents].loadend = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, FileReader);
        return this[kEvents].error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, FileReader);
        if (this[kEvents].error) {
          this.removeEventListener("error", this[kEvents].error);
        }
        if (typeof fn === "function") {
          this[kEvents].error = fn;
          this.addEventListener("error", fn);
        } else {
          this[kEvents].error = null;
        }
      }
      get onloadstart() {
        webidl.brandCheck(this, FileReader);
        return this[kEvents].loadstart;
      }
      set onloadstart(fn) {
        webidl.brandCheck(this, FileReader);
        if (this[kEvents].loadstart) {
          this.removeEventListener("loadstart", this[kEvents].loadstart);
        }
        if (typeof fn === "function") {
          this[kEvents].loadstart = fn;
          this.addEventListener("loadstart", fn);
        } else {
          this[kEvents].loadstart = null;
        }
      }
      get onprogress() {
        webidl.brandCheck(this, FileReader);
        return this[kEvents].progress;
      }
      set onprogress(fn) {
        webidl.brandCheck(this, FileReader);
        if (this[kEvents].progress) {
          this.removeEventListener("progress", this[kEvents].progress);
        }
        if (typeof fn === "function") {
          this[kEvents].progress = fn;
          this.addEventListener("progress", fn);
        } else {
          this[kEvents].progress = null;
        }
      }
      get onload() {
        webidl.brandCheck(this, FileReader);
        return this[kEvents].load;
      }
      set onload(fn) {
        webidl.brandCheck(this, FileReader);
        if (this[kEvents].load) {
          this.removeEventListener("load", this[kEvents].load);
        }
        if (typeof fn === "function") {
          this[kEvents].load = fn;
          this.addEventListener("load", fn);
        } else {
          this[kEvents].load = null;
        }
      }
      get onabort() {
        webidl.brandCheck(this, FileReader);
        return this[kEvents].abort;
      }
      set onabort(fn) {
        webidl.brandCheck(this, FileReader);
        if (this[kEvents].abort) {
          this.removeEventListener("abort", this[kEvents].abort);
        }
        if (typeof fn === "function") {
          this[kEvents].abort = fn;
          this.addEventListener("abort", fn);
        } else {
          this[kEvents].abort = null;
        }
      }
    };
    FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
    FileReader.LOADING = FileReader.prototype.LOADING = 1;
    FileReader.DONE = FileReader.prototype.DONE = 2;
    Object.defineProperties(FileReader.prototype, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
      readAsArrayBuffer: kEnumerableProperty,
      readAsBinaryString: kEnumerableProperty,
      readAsText: kEnumerableProperty,
      readAsDataURL: kEnumerableProperty,
      abort: kEnumerableProperty,
      readyState: kEnumerableProperty,
      result: kEnumerableProperty,
      error: kEnumerableProperty,
      onloadstart: kEnumerableProperty,
      onprogress: kEnumerableProperty,
      onload: kEnumerableProperty,
      onabort: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onloadend: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FileReader",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(FileReader, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors
    });
    module2.exports = {
      FileReader
    };
  }
});

// node_modules/undici/lib/cookies/constants.js
var require_constants3 = __commonJS({
  "node_modules/undici/lib/cookies/constants.js"(exports2, module2) {
    "use strict";
    var maxAttributeValueSize = 1024;
    var maxNameValuePairSize = 4096;
    module2.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize
    };
  }
});

// node_modules/undici/lib/cookies/util.js
var require_util4 = __commonJS({
  "node_modules/undici/lib/cookies/util.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { kHeadersList } = require_symbols();
    function isCTLExcludingHtab(value) {
      if (value.length === 0) {
        return false;
      }
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
          return false;
        }
      }
    }
    function validateCookieName(name) {
      for (const char of name) {
        const code = char.charCodeAt(0);
        if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
          throw new Error("Invalid cookie name");
        }
      }
    }
    function validateCookieValue(value) {
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code < 33 || // exclude CTLs (0-31)
        code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
          throw new Error("Invalid header value");
        }
      }
    }
    function validateCookiePath(path) {
      for (const char of path) {
        const code = char.charCodeAt(0);
        if (code < 33 || char === ";") {
          throw new Error("Invalid cookie path");
        }
      }
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
        throw new Error("Invalid cookie domain");
      }
    }
    function toIMFDate(date) {
      if (typeof date === "number") {
        date = new Date(date);
      }
      const days = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ];
      const months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      const dayName = days[date.getUTCDay()];
      const day = date.getUTCDate().toString().padStart(2, "0");
      const month = months[date.getUTCMonth()];
      const year = date.getUTCFullYear();
      const hour = date.getUTCHours().toString().padStart(2, "0");
      const minute = date.getUTCMinutes().toString().padStart(2, "0");
      const second = date.getUTCSeconds().toString().padStart(2, "0");
      return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }
    function stringify(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }
      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);
      const out = [`${cookie.name}=${cookie.value}`];
      if (cookie.name.startsWith("__Secure-")) {
        cookie.secure = true;
      }
      if (cookie.name.startsWith("__Host-")) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = "/";
      }
      if (cookie.secure) {
        out.push("Secure");
      }
      if (cookie.httpOnly) {
        out.push("HttpOnly");
      }
      if (typeof cookie.maxAge === "number") {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }
      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }
      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }
      if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }
      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }
      for (const part of cookie.unparsed) {
        if (!part.includes("=")) {
          throw new Error("Invalid unparsed");
        }
        const [key, ...value] = part.split("=");
        out.push(`${key.trim()}=${value.join("=")}`);
      }
      return out.join("; ");
    }
    var kHeadersListNode;
    function getHeadersList(headers) {
      if (headers[kHeadersList]) {
        return headers[kHeadersList];
      }
      if (!kHeadersListNode) {
        kHeadersListNode = Object.getOwnPropertySymbols(headers).find(
          (symbol) => symbol.description === "headers list"
        );
        assert(kHeadersListNode, "Headers cannot be parsed");
      }
      const headersList = headers[kHeadersListNode];
      assert(headersList);
      return headersList;
    }
    module2.exports = {
      isCTLExcludingHtab,
      stringify,
      getHeadersList
    };
  }
});

// node_modules/undici/lib/cookies/parse.js
var require_parse = __commonJS({
  "node_modules/undici/lib/cookies/parse.js"(exports2, module2) {
    "use strict";
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants3();
    var { isCTLExcludingHtab } = require_util4();
    var { collectASequenceOfCodePointsFast } = require_dataURL();
    var assert = require("assert");
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header)) {
        return null;
      }
      let nameValuePair = "";
      let unparsedAttributes = "";
      let name = "";
      let value = "";
      if (header.includes(";")) {
        const position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        nameValuePair = header;
      }
      if (!nameValuePair.includes("=")) {
        value = nameValuePair;
      } else {
        const position = { position: 0 };
        name = collectASequenceOfCodePointsFast(
          "=",
          nameValuePair,
          position
        );
        value = nameValuePair.slice(position.position + 1);
      }
      name = name.trim();
      value = value.trim();
      if (name.length + value.length > maxNameValuePairSize) {
        return null;
      }
      return {
        name,
        value,
        ...parseUnparsedAttributes(unparsedAttributes)
      };
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }
      assert(unparsedAttributes[0] === ";");
      unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = "";
      if (unparsedAttributes.includes(";")) {
        cookieAv = collectASequenceOfCodePointsFast(
          ";",
          unparsedAttributes,
          { position: 0 }
        );
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        cookieAv = unparsedAttributes;
        unparsedAttributes = "";
      }
      let attributeName = "";
      let attributeValue = "";
      if (cookieAv.includes("=")) {
        const position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        );
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        attributeName = cookieAv;
      }
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === "expires") {
        const expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        const charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        let cookieDomain = attributeValue;
        if (cookieDomain[0] === ".") {
          cookieDomain = cookieDomain.slice(1);
        }
        cookieDomain = cookieDomain.toLowerCase();
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        let cookiePath = "";
        if (attributeValue.length === 0 || attributeValue[0] !== "/") {
          cookiePath = "/";
        } else {
          cookiePath = attributeValue;
        }
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure") {
        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === "httponly") {
        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === "samesite") {
        let enforcement = "Default";
        const attributeValueLowercase = attributeValue.toLowerCase();
        if (attributeValueLowercase.includes("none")) {
          enforcement = "None";
        }
        if (attributeValueLowercase.includes("strict")) {
          enforcement = "Strict";
        }
        if (attributeValueLowercase.includes("lax")) {
          enforcement = "Lax";
        }
        cookieAttributeList.sameSite = enforcement;
      } else {
        cookieAttributeList.unparsed ??= [];
        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module2.exports = {
      parseSetCookie,
      parseUnparsedAttributes
    };
  }
});

// node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS({
  "node_modules/undici/lib/cookies/index.js"(exports2, module2) {
    "use strict";
    var { parseSetCookie } = require_parse();
    var { stringify, getHeadersList } = require_util4();
    var { webidl } = require_webidl();
    var { Headers } = require_headers();
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookie = headers.get("cookie");
      const out = {};
      if (!cookie) {
        return out;
      }
      for (const piece of cookie.split(";")) {
        const [name, ...value] = piece.split("=");
        out[name.trim()] = value.join("=");
      }
      return out;
    }
    function deleteCookie(headers, name, attributes) {
      webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      name = webidl.converters.DOMString(name);
      attributes = webidl.converters.DeleteCookieAttributes(attributes);
      setCookie(headers, {
        name,
        value: "",
        expires: /* @__PURE__ */ new Date(0),
        ...attributes
      });
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookies = getHeadersList(headers).cookies;
      if (!cookies) {
        return [];
      }
      return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair));
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      cookie = webidl.converters.Cookie(cookie);
      const str = stringify(cookie);
      if (str) {
        headers.append("Set-Cookie", stringify(cookie));
      }
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      }
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name"
      },
      {
        converter: webidl.converters.DOMString,
        key: "value"
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === "number") {
            return webidl.converters["unsigned long long"](value);
          }
          return new Date(value);
        }),
        key: "expires",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: null
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"]
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: []
      }
    ]);
    module2.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie
    };
  }
});

// node_modules/undici/lib/websocket/constants.js
var require_constants4 = __commonJS({
  "node_modules/undici/lib/websocket/constants.js"(exports2, module2) {
    "use strict";
    var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    var states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };
    var opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10
    };
    var maxUnsigned16Bit = 2 ** 16 - 1;
    var parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4
    };
    var emptyBuffer = Buffer.allocUnsafe(0);
    module2.exports = {
      uid,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer
    };
  }
});

// node_modules/undici/lib/websocket/symbols.js
var require_symbols4 = __commonJS({
  "node_modules/undici/lib/websocket/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kWebSocketURL: Symbol("url"),
      kReadyState: Symbol("ready state"),
      kController: Symbol("controller"),
      kResponse: Symbol("response"),
      kBinaryType: Symbol("binary type"),
      kSentClose: Symbol("sent close"),
      kReceivedClose: Symbol("received close"),
      kByteParser: Symbol("byte parser")
    };
  }
});

// node_modules/undici/lib/websocket/events.js
var require_events = __commonJS({
  "node_modules/undici/lib/websocket/events.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var { MessagePort } = require("worker_threads");
    var MessageEvent = class extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
      }
      get data() {
        webidl.brandCheck(this, MessageEvent);
        return this.#eventInit.data;
      }
      get origin() {
        webidl.brandCheck(this, MessageEvent);
        return this.#eventInit.origin;
      }
      get lastEventId() {
        webidl.brandCheck(this, MessageEvent);
        return this.#eventInit.lastEventId;
      }
      get source() {
        webidl.brandCheck(this, MessageEvent);
        return this.#eventInit.source;
      }
      get ports() {
        webidl.brandCheck(this, MessageEvent);
        if (!Object.isFrozen(this.#eventInit.ports)) {
          Object.freeze(this.#eventInit.ports);
        }
        return this.#eventInit.ports;
      }
      initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
        webidl.brandCheck(this, MessageEvent);
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
        return new MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports
        });
      }
    };
    var CloseEvent = class extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
      }
      get wasClean() {
        webidl.brandCheck(this, CloseEvent);
        return this.#eventInit.wasClean;
      }
      get code() {
        webidl.brandCheck(this, CloseEvent);
        return this.#eventInit.code;
      }
      get reason() {
        webidl.brandCheck(this, CloseEvent);
        return this.#eventInit.reason;
      }
    };
    var ErrorEvent = class extends Event {
      #eventInit;
      constructor(type, eventInitDict) {
        webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
        super(type, eventInitDict);
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
        this.#eventInit = eventInitDict;
      }
      get message() {
        webidl.brandCheck(this, ErrorEvent);
        return this.#eventInit.message;
      }
      get filename() {
        webidl.brandCheck(this, ErrorEvent);
        return this.#eventInit.filename;
      }
      get lineno() {
        webidl.brandCheck(this, ErrorEvent);
        return this.#eventInit.lineno;
      }
      get colno() {
        webidl.brandCheck(this, ErrorEvent);
        return this.#eventInit.colno;
      }
      get error() {
        webidl.brandCheck(this, ErrorEvent);
        return this.#eventInit.error;
      }
    };
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: true
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: true
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: true
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );
    var eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: null
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: null
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        get defaultValue() {
          return [];
        }
      }
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: 0
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: ""
      }
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "error",
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent
    };
  }
});

// node_modules/undici/lib/websocket/util.js
var require_util5 = __commonJS({
  "node_modules/undici/lib/websocket/util.js"(exports2, module2) {
    "use strict";
    var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols4();
    var { states, opcodes } = require_constants4();
    var { MessageEvent, ErrorEvent } = require_events();
    function isEstablished(ws) {
      return ws[kReadyState] === states.OPEN;
    }
    function isClosing(ws) {
      return ws[kReadyState] === states.CLOSING;
    }
    function isClosed(ws) {
      return ws[kReadyState] === states.CLOSED;
    }
    function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
      const event = new eventConstructor(e, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(ws, type, data) {
      if (ws[kReadyState] !== states.OPEN) {
        return;
      }
      let dataForEvent;
      if (type === opcodes.TEXT) {
        try {
          dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
        } catch {
          failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type === opcodes.BINARY) {
        if (ws[kBinaryType] === "blob") {
          dataForEvent = new Blob([data]);
        } else {
          dataForEvent = new Uint8Array(data).buffer;
        }
      }
      fireEvent("message", ws, MessageEvent, {
        origin: ws[kWebSocketURL].origin,
        data: dataForEvent
      });
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0) {
        return false;
      }
      for (const char of protocol) {
        const code = char.charCodeAt(0);
        if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || // SP
        code === 9) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(code) {
      if (code >= 1e3 && code < 1015) {
        return code !== 1004 && // reserved
        code !== 1005 && // "MUST NOT be set as a status code"
        code !== 1006;
      }
      return code >= 3e3 && code <= 4999;
    }
    function failWebsocketConnection(ws, reason) {
      const { [kController]: controller, [kResponse]: response } = ws;
      controller.abort();
      if (response?.socket && !response.socket.destroyed) {
        response.socket.destroy();
      }
      if (reason) {
        fireEvent("error", ws, ErrorEvent, {
          error: new Error(reason)
        });
      }
    }
    module2.exports = {
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      failWebsocketConnection,
      websocketMessageReceived
    };
  }
});

// node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS({
  "node_modules/undici/lib/websocket/connection.js"(exports2, module2) {
    "use strict";
    var { randomBytes, createHash } = require("crypto");
    var diagnosticsChannel = require("diagnostics_channel");
    var { uid, states } = require_constants4();
    var {
      kReadyState,
      kSentClose,
      kByteParser,
      kReceivedClose
    } = require_symbols4();
    var { fireEvent, failWebsocketConnection } = require_util5();
    var { CloseEvent } = require_events();
    var { makeRequest } = require_request2();
    var { fetching } = require_fetch();
    var { getGlobalDispatcher } = require_global2();
    var channels = {};
    channels.open = diagnosticsChannel.channel("undici:websocket:open");
    channels.close = diagnosticsChannel.channel("undici:websocket:close");
    channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
    function establishWebSocketConnection(url2, protocols, ws, onEstablish) {
      const requestURL = url2;
      requestURL.protocol = url2.protocol === "ws:" ? "http:" : "https:";
      const request = makeRequest({
        urlList: [requestURL],
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error"
      });
      const keyValue = randomBytes(16).toString("base64");
      request.headersList.append("sec-websocket-key", keyValue);
      request.headersList.append("sec-websocket-version", "13");
      for (const protocol of protocols) {
        request.headersList.append("sec-websocket-protocol", protocol);
      }
      const permessageDeflate = "";
      const controller = fetching({
        request,
        useParallelQueue: true,
        dispatcher: getGlobalDispatcher(),
        processResponse(response) {
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(ws, "Received network error or non-101 status code.");
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Server did not respond with sent protocols.");
            return;
          }
          if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
          const digest = createHash("sha1").update(keyValue + uid).digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
          if (secExtension !== null && secExtension !== permessageDeflate) {
            failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
            return;
          }
          const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
          if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
            return;
          }
          response.socket.on("data", onSocketData);
          response.socket.on("close", onSocketClose);
          response.socket.on("error", onSocketError);
          if (channels.open.hasSubscribers) {
            channels.open.publish({
              address: response.socket.address(),
              protocol: secProtocol,
              extensions: secExtension
            });
          }
          onEstablish(response);
        }
      });
      return controller;
    }
    function onSocketData(chunk) {
      if (!this.ws[kByteParser].write(chunk)) {
        this.pause();
      }
    }
    function onSocketClose() {
      const { ws } = this;
      const wasClean = ws[kSentClose] && ws[kReceivedClose];
      let code = 1005;
      let reason = "";
      const result = ws[kByteParser].closingInfo;
      if (result) {
        code = result.code ?? 1005;
        reason = result.reason;
      } else if (!ws[kSentClose]) {
        code = 1006;
      }
      ws[kReadyState] = states.CLOSED;
      fireEvent("close", ws, CloseEvent, {
        wasClean,
        code,
        reason
      });
      if (channels.close.hasSubscribers) {
        channels.close.publish({
          websocket: ws,
          code,
          reason
        });
      }
    }
    function onSocketError(error) {
      const { ws } = this;
      ws[kReadyState] = states.CLOSING;
      if (channels.socketError.hasSubscribers) {
        channels.socketError.publish(error);
      }
      this.destroy();
    }
    module2.exports = {
      establishWebSocketConnection
    };
  }
});

// node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS({
  "node_modules/undici/lib/websocket/frame.js"(exports2, module2) {
    "use strict";
    var { randomBytes } = require("crypto");
    var { maxUnsigned16Bit } = require_constants4();
    var WebsocketFrameSend = class {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data;
        this.maskKey = randomBytes(4);
      }
      createFrame(opcode) {
        const bodyLength = this.frameData?.byteLength ?? 0;
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const buffer = Buffer.allocUnsafe(bodyLength + offset);
        buffer[0] = buffer[1] = 0;
        buffer[0] |= 128;
        buffer[0] = (buffer[0] & 240) + opcode;
        buffer[offset - 4] = this.maskKey[0];
        buffer[offset - 3] = this.maskKey[1];
        buffer[offset - 2] = this.maskKey[2];
        buffer[offset - 1] = this.maskKey[3];
        buffer[1] = payloadLength;
        if (payloadLength === 126) {
          new DataView(buffer.buffer).setUint16(2, bodyLength);
        } else if (payloadLength === 127) {
          buffer[2] = buffer[3] = 0;
          buffer.writeUIntBE(bodyLength, 4, 6);
        }
        buffer[1] |= 128;
        for (let i = 0; i < bodyLength; i++) {
          buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
        }
        return buffer;
      }
    };
    module2.exports = {
      WebsocketFrameSend
    };
  }
});

// node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS({
  "node_modules/undici/lib/websocket/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var diagnosticsChannel = require("diagnostics_channel");
    var { parserStates, opcodes, states, emptyBuffer } = require_constants4();
    var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols4();
    var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util5();
    var { WebsocketFrameSend } = require_frame();
    var channels = {};
    channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
    channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
    var ByteParser = class extends Writable {
      #buffers = [];
      #byteOffset = 0;
      #state = parserStates.INFO;
      #info = {};
      #fragments = [];
      constructor(ws) {
        super();
        this.ws = ws;
      }
      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk, _, callback) {
        this.#buffers.push(chunk);
        this.#byteOffset += chunk.length;
        this.run(callback);
      }
      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        while (true) {
          if (this.#state === parserStates.INFO) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            this.#info.fin = (buffer[0] & 128) !== 0;
            this.#info.opcode = buffer[0] & 15;
            this.#info.originalOpcode ??= this.#info.opcode;
            this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;
            if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
              failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            const payloadLength = buffer[1] & 127;
            if (payloadLength <= 125) {
              this.#info.payloadLength = payloadLength;
              this.#state = parserStates.READ_DATA;
            } else if (payloadLength === 126) {
              this.#state = parserStates.PAYLOADLENGTH_16;
            } else if (payloadLength === 127) {
              this.#state = parserStates.PAYLOADLENGTH_64;
            }
            if (this.#info.fragmented && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
              return;
            } else if (this.#info.opcode === opcodes.CLOSE) {
              if (payloadLength === 1) {
                failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
                return;
              }
              const body = this.consume(payloadLength);
              this.#info.closeInfo = this.parseCloseBody(false, body);
              if (!this.ws[kSentClose]) {
                const body2 = Buffer.allocUnsafe(2);
                body2.writeUInt16BE(this.#info.closeInfo.code, 0);
                const closeFrame = new WebsocketFrameSend(body2);
                this.ws[kResponse].socket.write(
                  closeFrame.createFrame(opcodes.CLOSE),
                  (err) => {
                    if (!err) {
                      this.ws[kSentClose] = true;
                    }
                  }
                );
              }
              this.ws[kReadyState] = states.CLOSING;
              this.ws[kReceivedClose] = true;
              this.end();
              return;
            } else if (this.#info.opcode === opcodes.PING) {
              const body = this.consume(payloadLength);
              if (!this.ws[kReceivedClose]) {
                const frame = new WebsocketFrameSend(body);
                this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
                if (channels.ping.hasSubscribers) {
                  channels.ping.publish({
                    payload: body
                  });
                }
              }
              this.#state = parserStates.INFO;
              if (this.#byteOffset > 0) {
                continue;
              } else {
                callback();
                return;
              }
            } else if (this.#info.opcode === opcodes.PONG) {
              const body = this.consume(payloadLength);
              if (channels.pong.hasSubscribers) {
                channels.pong.publish({
                  payload: body
                });
              }
              if (this.#byteOffset > 0) {
                continue;
              } else {
                callback();
                return;
              }
            }
          } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            this.#info.payloadLength = buffer.readUInt16BE(0);
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
            if (this.#byteOffset < 8) {
              return callback();
            }
            const buffer = this.consume(8);
            const upper = buffer.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            const lower = buffer.readUInt32BE(4);
            this.#info.payloadLength = (upper << 8) + lower;
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.READ_DATA) {
            if (this.#byteOffset < this.#info.payloadLength) {
              return callback();
            } else if (this.#byteOffset >= this.#info.payloadLength) {
              const body = this.consume(this.#info.payloadLength);
              this.#fragments.push(body);
              if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
                const fullMessage = Buffer.concat(this.#fragments);
                websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
                this.#info = {};
                this.#fragments.length = 0;
              }
              this.#state = parserStates.INFO;
            }
          }
          if (this.#byteOffset > 0) {
            continue;
          } else {
            callback();
            break;
          }
        }
      }
      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer|null}
       */
      consume(n) {
        if (n > this.#byteOffset) {
          return null;
        } else if (n === 0) {
          return emptyBuffer;
        }
        if (this.#buffers[0].length === n) {
          this.#byteOffset -= this.#buffers[0].length;
          return this.#buffers.shift();
        }
        const buffer = Buffer.allocUnsafe(n);
        let offset = 0;
        while (offset !== n) {
          const next = this.#buffers[0];
          const { length } = next;
          if (length + offset === n) {
            buffer.set(this.#buffers.shift(), offset);
            break;
          } else if (length + offset > n) {
            buffer.set(next.subarray(0, n - offset), offset);
            this.#buffers[0] = next.subarray(n - offset);
            break;
          } else {
            buffer.set(this.#buffers.shift(), offset);
            offset += next.length;
          }
        }
        this.#byteOffset -= n;
        return buffer;
      }
      parseCloseBody(onlyCode, data) {
        let code;
        if (data.length >= 2) {
          code = data.readUInt16BE(0);
        }
        if (onlyCode) {
          if (!isValidStatusCode(code)) {
            return null;
          }
          return { code };
        }
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
          reason = reason.subarray(3);
        }
        if (code !== void 0 && !isValidStatusCode(code)) {
          return null;
        }
        try {
          reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
        } catch {
          return null;
        }
        return { code, reason };
      }
      get closingInfo() {
        return this.#info.closeInfo;
      }
    };
    module2.exports = {
      ByteParser
    };
  }
});

// node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS({
  "node_modules/undici/lib/websocket/websocket.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { DOMException } = require_constants();
    var { URLSerializer } = require_dataURL();
    var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants4();
    var {
      kWebSocketURL,
      kReadyState,
      kController,
      kBinaryType,
      kResponse,
      kSentClose,
      kByteParser
    } = require_symbols4();
    var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util5();
    var { establishWebSocketConnection } = require_connection();
    var { WebsocketFrameSend } = require_frame();
    var { ByteParser } = require_receiver();
    var { kEnumerableProperty, isBlobLike } = require_util();
    var { types } = require("util");
    var experimentalWarned = false;
    var WebSocket2 = class extends EventTarget {
      #events = {
        open: null,
        error: null,
        close: null,
        message: null
      };
      #bufferedAmount = 0;
      #protocol = "";
      #extensions = "";
      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url2, protocols = []) {
        super();
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
            code: "UNDICI-WS"
          });
        }
        url2 = webidl.converters.USVString(url2);
        protocols = webidl.converters["DOMString or sequence<DOMString>"](protocols);
        let urlRecord;
        try {
          urlRecord = new URL(url2);
        } catch (e) {
          throw new DOMException(e, "SyntaxError");
        }
        if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
          throw new DOMException(
            `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
            "SyntaxError"
          );
        }
        if (urlRecord.hash) {
          throw new DOMException("Got fragment", "SyntaxError");
        }
        if (typeof protocols === "string") {
          protocols = [protocols];
        }
        if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this[kWebSocketURL] = urlRecord;
        this[kController] = establishWebSocketConnection(
          urlRecord,
          protocols,
          this,
          (response) => this.#onConnectionEstablished(response)
        );
        this[kReadyState] = WebSocket2.CONNECTING;
        this[kBinaryType] = "blob";
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, WebSocket2);
        if (code !== void 0) {
          code = webidl.converters["unsigned short"](code, { clamp: true });
        }
        if (reason !== void 0) {
          reason = webidl.converters.USVString(reason);
        }
        if (code !== void 0) {
          if (code !== 1e3 && (code < 3e3 || code > 4999)) {
            throw new DOMException("invalid code", "InvalidAccessError");
          }
        }
        let reasonByteLength = 0;
        if (reason !== void 0) {
          reasonByteLength = Buffer.byteLength(reason);
          if (reasonByteLength > 123) {
            throw new DOMException(
              `Reason must be less than 123 bytes; received ${reasonByteLength}`,
              "SyntaxError"
            );
          }
        }
        if (this[kReadyState] === WebSocket2.CLOSING || this[kReadyState] === WebSocket2.CLOSED) {
        } else if (!isEstablished(this)) {
          failWebsocketConnection(this, "Connection was closed before it was established.");
          this[kReadyState] = WebSocket2.CLOSING;
        } else if (!isClosing(this)) {
          const frame = new WebsocketFrameSend();
          if (code !== void 0 && reason === void 0) {
            frame.frameData = Buffer.allocUnsafe(2);
            frame.frameData.writeUInt16BE(code, 0);
          } else if (code !== void 0 && reason !== void 0) {
            frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
            frame.frameData.writeUInt16BE(code, 0);
            frame.frameData.write(reason, 2, "utf-8");
          } else {
            frame.frameData = emptyBuffer;
          }
          const socket = this[kResponse].socket;
          socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
            if (!err) {
              this[kSentClose] = true;
            }
          });
          this[kReadyState] = states.CLOSING;
        } else {
          this[kReadyState] = WebSocket2.CLOSING;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        webidl.brandCheck(this, WebSocket2);
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
        data = webidl.converters.WebSocketSendData(data);
        if (this[kReadyState] === WebSocket2.CONNECTING) {
          throw new DOMException("Sent before connected.", "InvalidStateError");
        }
        if (!isEstablished(this) || isClosing(this)) {
          return;
        }
        const socket = this[kResponse].socket;
        if (typeof data === "string") {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.TEXT);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (types.isArrayBuffer(data)) {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (ArrayBuffer.isView(data)) {
          const ab = Buffer.from(data, data.byteOffset, data.byteLength);
          const frame = new WebsocketFrameSend(ab);
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += ab.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= ab.byteLength;
          });
        } else if (isBlobLike(data)) {
          const frame = new WebsocketFrameSend();
          data.arrayBuffer().then((ab) => {
            const value = Buffer.from(ab);
            frame.frameData = value;
            const buffer = frame.createFrame(opcodes.BINARY);
            this.#bufferedAmount += value.byteLength;
            socket.write(buffer, () => {
              this.#bufferedAmount -= value.byteLength;
            });
          });
        }
      }
      get readyState() {
        webidl.brandCheck(this, WebSocket2);
        return this[kReadyState];
      }
      get bufferedAmount() {
        webidl.brandCheck(this, WebSocket2);
        return this.#bufferedAmount;
      }
      get url() {
        webidl.brandCheck(this, WebSocket2);
        return URLSerializer(this[kWebSocketURL]);
      }
      get extensions() {
        webidl.brandCheck(this, WebSocket2);
        return this.#extensions;
      }
      get protocol() {
        webidl.brandCheck(this, WebSocket2);
        return this.#protocol;
      }
      get onopen() {
        webidl.brandCheck(this, WebSocket2);
        return this.#events.open;
      }
      set onopen(fn) {
        webidl.brandCheck(this, WebSocket2);
        if (this.#events.open) {
          this.removeEventListener("open", this.#events.open);
        }
        if (typeof fn === "function") {
          this.#events.open = fn;
          this.addEventListener("open", fn);
        } else {
          this.#events.open = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, WebSocket2);
        return this.#events.error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, WebSocket2);
        if (this.#events.error) {
          this.removeEventListener("error", this.#events.error);
        }
        if (typeof fn === "function") {
          this.#events.error = fn;
          this.addEventListener("error", fn);
        } else {
          this.#events.error = null;
        }
      }
      get onclose() {
        webidl.brandCheck(this, WebSocket2);
        return this.#events.close;
      }
      set onclose(fn) {
        webidl.brandCheck(this, WebSocket2);
        if (this.#events.close) {
          this.removeEventListener("close", this.#events.close);
        }
        if (typeof fn === "function") {
          this.#events.close = fn;
          this.addEventListener("close", fn);
        } else {
          this.#events.close = null;
        }
      }
      get onmessage() {
        webidl.brandCheck(this, WebSocket2);
        return this.#events.message;
      }
      set onmessage(fn) {
        webidl.brandCheck(this, WebSocket2);
        if (this.#events.message) {
          this.removeEventListener("message", this.#events.message);
        }
        if (typeof fn === "function") {
          this.#events.message = fn;
          this.addEventListener("message", fn);
        } else {
          this.#events.message = null;
        }
      }
      get binaryType() {
        webidl.brandCheck(this, WebSocket2);
        return this[kBinaryType];
      }
      set binaryType(type) {
        webidl.brandCheck(this, WebSocket2);
        if (type !== "blob" && type !== "arraybuffer") {
          this[kBinaryType] = "blob";
        } else {
          this[kBinaryType] = type;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
       */
      #onConnectionEstablished(response) {
        this[kResponse] = response;
        const parser = new ByteParser(this);
        parser.on("drain", function onParserDrain() {
          this.ws[kResponse].socket.resume();
        });
        response.socket.ws = this;
        this[kByteParser] = parser;
        this[kReadyState] = states.OPEN;
        const extensions2 = response.headersList.get("sec-websocket-extensions");
        if (extensions2 !== null) {
          this.#extensions = extensions2;
        }
        const protocol = response.headersList.get("sec-websocket-protocol");
        if (protocol !== null) {
          this.#protocol = protocol;
        }
        fireEvent("open", this);
      }
    };
    WebSocket2.CONNECTING = WebSocket2.prototype.CONNECTING = states.CONNECTING;
    WebSocket2.OPEN = WebSocket2.prototype.OPEN = states.OPEN;
    WebSocket2.CLOSING = WebSocket2.prototype.CLOSING = states.CLOSING;
    WebSocket2.CLOSED = WebSocket2.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket2.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(WebSocket2, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors
    });
    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );
    webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
      if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
        return webidl.converters["sequence<DOMString>"](V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.WebSocketSendData = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V);
        }
      }
      return webidl.converters.USVString(V);
    };
    module2.exports = {
      WebSocket: WebSocket2
    };
  }
});

// node_modules/undici/index.js
var require_undici = __commonJS({
  "node_modules/undici/index.js"(exports2, module2) {
    "use strict";
    var Client3 = require_client();
    var Dispatcher = require_dispatcher();
    var errors = require_errors();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent = require_agent();
    var util2 = require_util();
    var { InvalidArgumentError } = errors;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var ProxyAgent = require_proxy_agent();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
    var DecoratorHandler = require_DecoratorHandler();
    var RedirectHandler = require_RedirectHandler();
    var createRedirectInterceptor = require_redirectInterceptor();
    var hasCrypto;
    try {
      require("crypto");
      hasCrypto = true;
    } catch {
      hasCrypto = false;
    }
    Object.assign(Dispatcher.prototype, api);
    module2.exports.Dispatcher = Dispatcher;
    module2.exports.Client = Client3;
    module2.exports.Pool = Pool;
    module2.exports.BalancedPool = BalancedPool;
    module2.exports.Agent = Agent;
    module2.exports.ProxyAgent = ProxyAgent;
    module2.exports.DecoratorHandler = DecoratorHandler;
    module2.exports.RedirectHandler = RedirectHandler;
    module2.exports.createRedirectInterceptor = createRedirectInterceptor;
    module2.exports.buildConnector = buildConnector;
    module2.exports.errors = errors;
    function makeDispatcher(fn) {
      return (url2, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url2 || typeof url2 !== "string" && typeof url2 !== "object" && !(url2 instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path = opts.path;
          if (!opts.path.startsWith("/")) {
            path = `/${path}`;
          }
          url2 = new URL(util2.parseOrigin(url2).origin + path);
        } else {
          if (!opts) {
            opts = typeof url2 === "object" ? url2 : {};
          }
          url2 = util2.parseURL(url2);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn.call(dispatcher, {
          ...opts,
          origin: url2.origin,
          path: url2.search ? `${url2.pathname}${url2.search}` : url2.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module2.exports.setGlobalDispatcher = setGlobalDispatcher;
    module2.exports.getGlobalDispatcher = getGlobalDispatcher;
    if (util2.nodeMajor > 16 || util2.nodeMajor === 16 && util2.nodeMinor >= 8) {
      let fetchImpl = null;
      module2.exports.fetch = async function fetch(resource) {
        if (!fetchImpl) {
          fetchImpl = require_fetch().fetch;
        }
        try {
          return await fetchImpl(...arguments);
        } catch (err) {
          Error.captureStackTrace(err, this);
          throw err;
        }
      };
      module2.exports.Headers = require_headers().Headers;
      module2.exports.Response = require_response().Response;
      module2.exports.Request = require_request2().Request;
      module2.exports.FormData = require_formdata().FormData;
      module2.exports.File = require_file().File;
      module2.exports.FileReader = require_filereader().FileReader;
      const { setGlobalOrigin, getGlobalOrigin } = require_global();
      module2.exports.setGlobalOrigin = setGlobalOrigin;
      module2.exports.getGlobalOrigin = getGlobalOrigin;
    }
    if (util2.nodeMajor >= 16) {
      const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
      module2.exports.deleteCookie = deleteCookie;
      module2.exports.getCookies = getCookies;
      module2.exports.getSetCookies = getSetCookies;
      module2.exports.setCookie = setCookie;
      const { parseMIMEType, serializeAMimeType } = require_dataURL();
      module2.exports.parseMIMEType = parseMIMEType;
      module2.exports.serializeAMimeType = serializeAMimeType;
    }
    if (util2.nodeMajor >= 18 && hasCrypto) {
      const { WebSocket: WebSocket2 } = require_websocket();
      module2.exports.WebSocket = WebSocket2;
    }
    module2.exports.request = makeDispatcher(api.request);
    module2.exports.stream = makeDispatcher(api.stream);
    module2.exports.pipeline = makeDispatcher(api.pipeline);
    module2.exports.connect = makeDispatcher(api.connect);
    module2.exports.upgrade = makeDispatcher(api.upgrade);
    module2.exports.MockClient = MockClient;
    module2.exports.MockPool = MockPool;
    module2.exports.MockAgent = MockAgent;
    module2.exports.mockErrors = mockErrors;
  }
});

// node_modules/@discordjs/collection/dist/index.js
var require_dist = __commonJS({
  "node_modules/@discordjs/collection/dist/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp2(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Collection: () => Collection2,
      version: () => version
    });
    module2.exports = __toCommonJS2(src_exports);
    var Collection2 = class extends Map {
      /**
       * Obtains the value of the given key if it exists, otherwise sets and returns the value provided by the default value generator.
       *
       * @param key - The key to get if it exists, or set otherwise
       * @param defaultValueGenerator - A function that generates the default value
       * @example
       * ```ts
       * collection.ensure(guildId, () => defaultGuildConfig);
       * ```
       */
      ensure(key, defaultValueGenerator) {
        if (this.has(key))
          return this.get(key);
        if (typeof defaultValueGenerator !== "function")
          throw new TypeError(`${defaultValueGenerator} is not a function`);
        const defaultValue = defaultValueGenerator(key, this);
        this.set(key, defaultValue);
        return defaultValue;
      }
      /**
       * Checks if all of the elements exist in the collection.
       *
       * @param keys - The keys of the elements to check for
       * @returns `true` if all of the elements exist, `false` if at least one does not exist.
       */
      hasAll(...keys) {
        return keys.every((key) => super.has(key));
      }
      /**
       * Checks if any of the elements exist in the collection.
       *
       * @param keys - The keys of the elements to check for
       * @returns `true` if any of the elements exist, `false` if none exist.
       */
      hasAny(...keys) {
        return keys.some((key) => super.has(key));
      }
      first(amount) {
        if (amount === void 0)
          return this.values().next().value;
        if (amount < 0)
          return this.last(amount * -1);
        amount = Math.min(this.size, amount);
        const iter = this.values();
        return Array.from({ length: amount }, () => iter.next().value);
      }
      firstKey(amount) {
        if (amount === void 0)
          return this.keys().next().value;
        if (amount < 0)
          return this.lastKey(amount * -1);
        amount = Math.min(this.size, amount);
        const iter = this.keys();
        return Array.from({ length: amount }, () => iter.next().value);
      }
      last(amount) {
        const arr = [...this.values()];
        if (amount === void 0)
          return arr[arr.length - 1];
        if (amount < 0)
          return this.first(amount * -1);
        if (!amount)
          return [];
        return arr.slice(-amount);
      }
      lastKey(amount) {
        const arr = [...this.keys()];
        if (amount === void 0)
          return arr[arr.length - 1];
        if (amount < 0)
          return this.firstKey(amount * -1);
        if (!amount)
          return [];
        return arr.slice(-amount);
      }
      /**
       * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at | Array.at()}.
       * Returns the item at a given index, allowing for positive and negative integers.
       * Negative integers count back from the last item in the collection.
       *
       * @param index - The index of the element to obtain
       */
      at(index) {
        index = Math.floor(index);
        const arr = [...this.values()];
        return arr.at(index);
      }
      /**
       * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at | Array.at()}.
       * Returns the key at a given index, allowing for positive and negative integers.
       * Negative integers count back from the last item in the collection.
       *
       * @param index - The index of the key to obtain
       */
      keyAt(index) {
        index = Math.floor(index);
        const arr = [...this.keys()];
        return arr.at(index);
      }
      random(amount) {
        const arr = [...this.values()];
        if (amount === void 0)
          return arr[Math.floor(Math.random() * arr.length)];
        if (!arr.length || !amount)
          return [];
        return Array.from(
          { length: Math.min(amount, arr.length) },
          () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]
        );
      }
      randomKey(amount) {
        const arr = [...this.keys()];
        if (amount === void 0)
          return arr[Math.floor(Math.random() * arr.length)];
        if (!arr.length || !amount)
          return [];
        return Array.from(
          { length: Math.min(amount, arr.length) },
          () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]
        );
      }
      /**
       * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse | Array.reverse()}
       * but returns a Collection instead of an Array.
       */
      reverse() {
        const entries = [...this.entries()].reverse();
        this.clear();
        for (const [key, value] of entries)
          this.set(key, value);
        return this;
      }
      find(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (fn(val, key, this))
            return val;
        }
        return void 0;
      }
      findKey(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (fn(val, key, this))
            return key;
        }
        return void 0;
      }
      sweep(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const previousSize = this.size;
        for (const [key, val] of this) {
          if (fn(val, key, this))
            this.delete(key);
        }
        return previousSize - this.size;
      }
      filter(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const results = new this.constructor[Symbol.species]();
        for (const [key, val] of this) {
          if (fn(val, key, this))
            results.set(key, val);
        }
        return results;
      }
      partition(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const results = [
          new this.constructor[Symbol.species](),
          new this.constructor[Symbol.species]()
        ];
        for (const [key, val] of this) {
          if (fn(val, key, this)) {
            results[0].set(key, val);
          } else {
            results[1].set(key, val);
          }
        }
        return results;
      }
      flatMap(fn, thisArg) {
        const collections = this.map(fn, thisArg);
        return new this.constructor[Symbol.species]().concat(...collections);
      }
      map(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const iter = this.entries();
        return Array.from({ length: this.size }, () => {
          const [key, value] = iter.next().value;
          return fn(value, key, this);
        });
      }
      mapValues(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const coll = new this.constructor[Symbol.species]();
        for (const [key, val] of this)
          coll.set(key, fn(val, key, this));
        return coll;
      }
      some(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (fn(val, key, this))
            return true;
        }
        return false;
      }
      every(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (!fn(val, key, this))
            return false;
        }
        return true;
      }
      /**
       * Applies a function to produce a single value. Identical in behavior to
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce | Array.reduce()}.
       *
       * @param fn - Function used to reduce, taking four arguments; `accumulator`, `currentValue`, `currentKey`,
       * and `collection`
       * @param initialValue - Starting value for the accumulator
       * @example
       * ```ts
       * collection.reduce((acc, guild) => acc + guild.memberCount, 0);
       * ```
       */
      reduce(fn, initialValue) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        let accumulator;
        if (initialValue !== void 0) {
          accumulator = initialValue;
          for (const [key, val] of this)
            accumulator = fn(accumulator, val, key, this);
          return accumulator;
        }
        let first = true;
        for (const [key, val] of this) {
          if (first) {
            accumulator = val;
            first = false;
            continue;
          }
          accumulator = fn(accumulator, val, key, this);
        }
        if (first) {
          throw new TypeError("Reduce of empty collection with no initial value");
        }
        return accumulator;
      }
      each(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, value] of this) {
          fn(value, key, this);
        }
        return this;
      }
      tap(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        fn(this);
        return this;
      }
      /**
       * Creates an identical shallow copy of this collection.
       *
       * @example
       * ```ts
       * const newColl = someColl.clone();
       * ```
       */
      clone() {
        return new this.constructor[Symbol.species](this);
      }
      /**
       * Combines this collection with others into a new collection. None of the source collections are modified.
       *
       * @param collections - Collections to merge
       * @example
       * ```ts
       * const newColl = someColl.concat(someOtherColl, anotherColl, ohBoyAColl);
       * ```
       */
      concat(...collections) {
        const newColl = this.clone();
        for (const coll of collections) {
          for (const [key, val] of coll)
            newColl.set(key, val);
        }
        return newColl;
      }
      /**
       * Checks if this collection shares identical items with another.
       * This is different to checking for equality using equal-signs, because
       * the collections may be different objects, but contain the same data.
       *
       * @param collection - Collection to compare with
       * @returns Whether the collections have identical contents
       */
      equals(collection) {
        if (!collection)
          return false;
        if (this === collection)
          return true;
        if (this.size !== collection.size)
          return false;
        for (const [key, value] of this) {
          if (!collection.has(key) || value !== collection.get(key)) {
            return false;
          }
        }
        return true;
      }
      /**
       * The sort method sorts the items of a collection in place and returns it.
       * The sort is not necessarily stable in Node 10 or older.
       * The default sort order is according to string Unicode code points.
       *
       * @param compareFunction - Specifies a function that defines the sort order.
       * If omitted, the collection is sorted according to each character's Unicode code point value, according to the string conversion of each element.
       * @example
       * ```ts
       * collection.sort((userA, userB) => userA.createdTimestamp - userB.createdTimestamp);
       * ```
       */
      sort(compareFunction = Collection2.defaultSort) {
        const entries = [...this.entries()];
        entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
        super.clear();
        for (const [key, value] of entries) {
          super.set(key, value);
        }
        return this;
      }
      /**
       * The intersect method returns a new structure containing items where the keys and values are present in both original structures.
       *
       * @param other - The other Collection to filter against
       */
      intersect(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [key, value] of other) {
          if (this.has(key) && Object.is(value, this.get(key))) {
            coll.set(key, value);
          }
        }
        return coll;
      }
      /**
       * The subtract method returns a new structure containing items where the keys and values of the original structure are not present in the other.
       *
       * @param other - The other Collection to filter against
       */
      subtract(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [key, value] of this) {
          if (!other.has(key) || !Object.is(value, other.get(key))) {
            coll.set(key, value);
          }
        }
        return coll;
      }
      /**
       * The difference method returns a new structure containing items where the key is present in one of the original structures but not the other.
       *
       * @param other - The other Collection to filter against
       */
      difference(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [key, value] of other) {
          if (!this.has(key))
            coll.set(key, value);
        }
        for (const [key, value] of this) {
          if (!other.has(key))
            coll.set(key, value);
        }
        return coll;
      }
      /**
       * Merges two Collections together into a new Collection.
       *
       * @param other - The other Collection to merge with
       * @param whenInSelf - Function getting the result if the entry only exists in this Collection
       * @param whenInOther - Function getting the result if the entry only exists in the other Collection
       * @param whenInBoth - Function getting the result if the entry exists in both Collections
       * @example
       * ```ts
       * // Sums up the entries in two collections.
       * coll.merge(
       *  other,
       *  x => ({ keep: true, value: x }),
       *  y => ({ keep: true, value: y }),
       *  (x, y) => ({ keep: true, value: x + y }),
       * );
       * ```
       * @example
       * ```ts
       * // Intersects two collections in a left-biased manner.
       * coll.merge(
       *  other,
       *  x => ({ keep: false }),
       *  y => ({ keep: false }),
       *  (x, _) => ({ keep: true, value: x }),
       * );
       * ```
       */
      merge(other, whenInSelf, whenInOther, whenInBoth) {
        const coll = new this.constructor[Symbol.species]();
        const keys = /* @__PURE__ */ new Set([...this.keys(), ...other.keys()]);
        for (const key of keys) {
          const hasInSelf = this.has(key);
          const hasInOther = other.has(key);
          if (hasInSelf && hasInOther) {
            const result = whenInBoth(this.get(key), other.get(key), key);
            if (result.keep)
              coll.set(key, result.value);
          } else if (hasInSelf) {
            const result = whenInSelf(this.get(key), key);
            if (result.keep)
              coll.set(key, result.value);
          } else if (hasInOther) {
            const result = whenInOther(other.get(key), key);
            if (result.keep)
              coll.set(key, result.value);
          }
        }
        return coll;
      }
      /**
       * The sorted method sorts the items of a collection and returns it.
       * The sort is not necessarily stable in Node 10 or older.
       * The default sort order is according to string Unicode code points.
       *
       * @param compareFunction - Specifies a function that defines the sort order.
       * If omitted, the collection is sorted according to each character's Unicode code point value,
       * according to the string conversion of each element.
       * @example
       * ```ts
       * collection.sorted((userA, userB) => userA.createdTimestamp - userB.createdTimestamp);
       * ```
       */
      sorted(compareFunction = Collection2.defaultSort) {
        return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
      }
      toJSON() {
        return [...this.values()];
      }
      static defaultSort(firstValue, secondValue) {
        return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
      }
      /**
       * Creates a Collection from a list of entries.
       *
       * @param entries - The list of entries
       * @param combine - Function to combine an existing entry with a new one
       * @example
       * ```ts
       * Collection.combineEntries([["a", 1], ["b", 2], ["a", 2]], (x, y) => x + y);
       * // returns Collection { "a" => 3, "b" => 2 }
       * ```
       */
      static combineEntries(entries, combine2) {
        const coll = new Collection2();
        for (const [key, value] of entries) {
          if (coll.has(key)) {
            coll.set(key, combine2(coll.get(key), value, key));
          } else {
            coll.set(key, value);
          }
        }
        return coll;
      }
    };
    __name(Collection2, "Collection");
    var version = "1.5.0";
  }
});

// node_modules/@discordjs/util/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@discordjs/util/dist/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp2(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      calculateShardId: () => calculateShardId,
      isEquatable: () => isEquatable,
      isJSONEncodable: () => isJSONEncodable,
      lazy: () => lazy,
      range: () => range
    });
    module2.exports = __toCommonJS2(src_exports);
    function lazy(cb) {
      let defaultValue;
      return () => defaultValue ??= cb();
    }
    __name(lazy, "lazy");
    function* range(range2) {
      let rangeEnd;
      let start = 0;
      let step = 1;
      if (typeof range2 === "number") {
        rangeEnd = range2;
      } else {
        start = range2.start;
        rangeEnd = range2.end;
        step = range2.step ?? 1;
      }
      for (let index = start; index < rangeEnd; index += step) {
        yield index;
      }
    }
    __name(range, "range");
    function calculateShardId(guildId, shardCount) {
      return Number((BigInt(guildId) >> 22n) % BigInt(shardCount));
    }
    __name(calculateShardId, "calculateShardId");
    function isJSONEncodable(maybeEncodable) {
      return maybeEncodable !== null && typeof maybeEncodable === "object" && "toJSON" in maybeEncodable;
    }
    __name(isJSONEncodable, "isJSONEncodable");
    function isEquatable(maybeEquatable) {
      return maybeEquatable !== null && typeof maybeEquatable === "object" && "equals" in maybeEquatable;
    }
    __name(isEquatable, "isEquatable");
  }
});

// node_modules/@sapphire/snowflake/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@sapphire/snowflake/dist/index.js"(exports2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __publicField2 = (obj, key, value) => {
      __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    var __accessCheck = (obj, member, msg) => {
      if (!member.has(obj))
        throw TypeError("Cannot " + msg);
    };
    var __privateGet = (obj, member, getter) => {
      __accessCheck(obj, member, "read from private field");
      return getter ? getter.call(obj) : member.get(obj);
    };
    var __privateAdd = (obj, member, value) => {
      if (member.has(obj))
        throw TypeError("Cannot add the same private member more than once");
      member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    };
    var __privateSet = (obj, member, value, setter) => {
      __accessCheck(obj, member, "write to private field");
      setter ? setter.call(obj, value) : member.set(obj, value);
      return value;
    };
    var __privateWrapper = (obj, member, setter, getter) => ({
      set _(value) {
        __privateSet(obj, member, value, setter);
      },
      get _() {
        return __privateGet(obj, member, getter);
      }
    });
    var ProcessId = 1n;
    var WorkerId = 0n;
    var _increment;
    var _epoch;
    var Snowflake = class {
      /**
       * @param epoch the epoch to use
       */
      constructor(epoch) {
        __publicField2(this, "decode", this.deconstruct);
        __privateAdd(this, _increment, 0n);
        __privateAdd(this, _epoch, void 0);
        __privateSet(this, _epoch, BigInt(epoch instanceof Date ? epoch.getTime() : epoch));
      }
      /**
       * The epoch for this snowflake.
       */
      get epoch() {
        return __privateGet(this, _epoch);
      }
      /**
       * Generates a snowflake given an epoch and optionally a timestamp
       * @param options options to pass into the generator, see {@link SnowflakeGenerateOptions}
       *
       * **note** when `increment` is not provided it defaults to the private `increment` of the instance
       * @example
       * ```typescript
       * const epoch = new Date('2000-01-01T00:00:00.000Z');
       * const snowflake = new Snowflake(epoch).generate();
       * ```
       * @returns A unique snowflake
       */
      generate({ increment, timestamp: timestamp2 = Date.now(), workerId = WorkerId, processId = ProcessId } = {}) {
        if (timestamp2 instanceof Date)
          timestamp2 = BigInt(timestamp2.getTime());
        else if (typeof timestamp2 === "number")
          timestamp2 = BigInt(timestamp2);
        else if (typeof timestamp2 !== "bigint") {
          throw new TypeError(`"timestamp" argument must be a number, bigint, or Date (received ${typeof timestamp2})`);
        }
        if (typeof increment === "bigint" && increment >= 4095n)
          increment = 0n;
        else {
          increment = __privateWrapper(this, _increment)._++;
          if (__privateGet(this, _increment) >= 4095n)
            __privateSet(this, _increment, 0n);
        }
        return timestamp2 - __privateGet(this, _epoch) << 22n | (workerId & 0b11111n) << 17n | (processId & 0b11111n) << 12n | increment;
      }
      /**
       * Deconstructs a snowflake given a snowflake ID
       * @param id the snowflake to deconstruct
       * @returns a deconstructed snowflake
       * @example
       * ```typescript
       * const epoch = new Date('2000-01-01T00:00:00.000Z');
       * const snowflake = new Snowflake(epoch).deconstruct('3971046231244935168');
       * ```
       */
      deconstruct(id) {
        const bigIntId = BigInt(id);
        return {
          id: bigIntId,
          timestamp: (bigIntId >> 22n) + __privateGet(this, _epoch),
          workerId: bigIntId >> 17n & 0b11111n,
          processId: bigIntId >> 12n & 0b11111n,
          increment: bigIntId & 0b111111111111n,
          epoch: __privateGet(this, _epoch)
        };
      }
      /**
       * Retrieves the timestamp field's value from a snowflake.
       * @param id The snowflake to get the timestamp value from.
       * @returns The UNIX timestamp that is stored in `id`.
       */
      timestampFrom(id) {
        return Number((BigInt(id) >> 22n) + __privateGet(this, _epoch));
      }
      /**
       * Returns a number indicating whether a reference snowflake comes before, or after, or is same as the given
       * snowflake in sort order.
       * @param a The first snowflake to compare.
       * @param b The second snowflake to compare.
       * @returns `-1` if `a` is older than `b`, `0` if `a` and `b` are equals, `1` if `a` is newer than `b`.
       * @example Sort snowflakes in ascending order
       * ```typescript
       * const ids = ['737141877803057244', '1056191128120082432', '254360814063058944'];
       * console.log(ids.sort((a, b) => Snowflake.compare(a, b)));
       * // → ['254360814063058944', '737141877803057244', '1056191128120082432'];
       * ```
       * @example Sort snowflakes in descending order
       * ```typescript
       * const ids = ['737141877803057244', '1056191128120082432', '254360814063058944'];
       * console.log(ids.sort((a, b) => -Snowflake.compare(a, b)));
       * // → ['1056191128120082432', '737141877803057244', '254360814063058944'];
       * ```
       */
      static compare(a, b) {
        if (typeof a === "bigint" || typeof b === "bigint") {
          if (typeof a === "string")
            a = BigInt(a);
          if (typeof b === "string")
            b = BigInt(b);
          return a === b ? 0 : a < b ? -1 : 1;
        }
        return a === b ? 0 : a.length < b.length ? -1 : a.length > b.length ? 1 : a < b ? -1 : 1;
      }
    };
    __name(Snowflake, "Snowflake");
    _increment = /* @__PURE__ */ new WeakMap();
    _epoch = /* @__PURE__ */ new WeakMap();
    var DiscordSnowflake = new Snowflake(1420070400000n);
    var TwitterSnowflake = new Snowflake(1288834974657n);
    exports2.DiscordSnowflake = DiscordSnowflake;
    exports2.Snowflake = Snowflake;
    exports2.TwitterSnowflake = TwitterSnowflake;
  }
});

// node_modules/@sapphire/async-queue/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@sapphire/async-queue/dist/index.js"(exports2, module2) {
    "use strict";
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp2(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var __publicField2 = (obj, key, value) => {
      __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    var src_exports = {};
    __export2(src_exports, {
      AsyncQueue: () => AsyncQueue
    });
    module2.exports = __toCommonJS2(src_exports);
    var AsyncQueueEntry = class {
      constructor(queue) {
        __publicField2(this, "promise");
        __publicField2(this, "resolve");
        __publicField2(this, "reject");
        __publicField2(this, "queue");
        __publicField2(this, "signal", null);
        __publicField2(this, "signalListener", null);
        this.queue = queue;
        this.promise = new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
      }
      setSignal(signal) {
        if (signal.aborted)
          return this;
        this.signal = signal;
        this.signalListener = () => {
          const index = this.queue["promises"].indexOf(this);
          if (index !== -1)
            this.queue["promises"].splice(index, 1);
          this.reject(new Error("Request aborted manually"));
        };
        this.signal.addEventListener("abort", this.signalListener);
        return this;
      }
      use() {
        this.dispose();
        this.resolve();
        return this;
      }
      abort() {
        this.dispose();
        this.reject(new Error("Request aborted manually"));
        return this;
      }
      dispose() {
        if (this.signal) {
          this.signal.removeEventListener("abort", this.signalListener);
          this.signal = null;
          this.signalListener = null;
        }
      }
    };
    __name(AsyncQueueEntry, "AsyncQueueEntry");
    var AsyncQueue = class {
      constructor() {
        __publicField2(this, "promises", []);
      }
      get remaining() {
        return this.promises.length;
      }
      get queued() {
        return this.remaining === 0 ? 0 : this.remaining - 1;
      }
      wait(options) {
        const entry = new AsyncQueueEntry(this);
        if (this.promises.length === 0) {
          this.promises.push(entry);
          return Promise.resolve();
        }
        this.promises.push(entry);
        if (options?.signal)
          entry.setSignal(options.signal);
        return entry.promise;
      }
      shift() {
        if (this.promises.length === 0)
          return;
        if (this.promises.length === 1) {
          this.promises.shift();
          return;
        }
        this.promises.shift();
        this.promises[0].use();
      }
      abortAll() {
        if (this.queued === 0)
          return;
        for (let i = 1; i < this.promises.length; ++i) {
          this.promises[i].abort();
        }
        this.promises.length = 1;
      }
    };
    __name(AsyncQueue, "AsyncQueue");
  }
});

// node_modules/strtok3/lib/FsPromise.js
async function stat(path) {
  return new Promise((resolve, reject) => {
    import_node_fs.default.stat(path, (err, stats) => {
      if (err)
        reject(err);
      else
        resolve(stats);
    });
  });
}
async function close(fd) {
  return new Promise((resolve, reject) => {
    import_node_fs.default.close(fd, (err) => {
      if (err)
        reject(err);
      else
        resolve();
    });
  });
}
async function open(path, mode) {
  return new Promise((resolve, reject) => {
    import_node_fs.default.open(path, mode, (err, fd) => {
      if (err)
        reject(err);
      else
        resolve(fd);
    });
  });
}
async function read(fd, buffer, offset, length, position) {
  return new Promise((resolve, reject) => {
    import_node_fs.default.read(fd, buffer, offset, length, position, (err, bytesRead, _buffer) => {
      if (err)
        reject(err);
      else
        resolve({ bytesRead, buffer: _buffer });
    });
  });
}
var import_node_fs, pathExists, createReadStream;
var init_FsPromise = __esm({
  "node_modules/strtok3/lib/FsPromise.js"() {
    import_node_fs = __toESM(require("node:fs"), 1);
    pathExists = import_node_fs.default.existsSync;
    createReadStream = import_node_fs.default.createReadStream;
  }
});

// node_modules/peek-readable/lib/EndOfFileStream.js
var defaultMessages, EndOfStreamError;
var init_EndOfFileStream = __esm({
  "node_modules/peek-readable/lib/EndOfFileStream.js"() {
    defaultMessages = "End-Of-Stream";
    EndOfStreamError = class extends Error {
      constructor() {
        super(defaultMessages);
      }
    };
  }
});

// node_modules/peek-readable/lib/Deferred.js
var Deferred;
var init_Deferred = __esm({
  "node_modules/peek-readable/lib/Deferred.js"() {
    Deferred = class {
      constructor() {
        this.resolve = () => null;
        this.reject = () => null;
        this.promise = new Promise((resolve, reject) => {
          this.reject = reject;
          this.resolve = resolve;
        });
      }
    };
  }
});

// node_modules/peek-readable/lib/StreamReader.js
var maxStreamReadSize, StreamReader;
var init_StreamReader = __esm({
  "node_modules/peek-readable/lib/StreamReader.js"() {
    init_EndOfFileStream();
    init_Deferred();
    init_EndOfFileStream();
    maxStreamReadSize = 1 * 1024 * 1024;
    StreamReader = class {
      constructor(s) {
        this.s = s;
        this.deferred = null;
        this.endOfStream = false;
        this.peekQueue = [];
        if (!s.read || !s.once) {
          throw new Error("Expected an instance of stream.Readable");
        }
        this.s.once("end", () => this.reject(new EndOfStreamError()));
        this.s.once("error", (err) => this.reject(err));
        this.s.once("close", () => this.reject(new Error("Stream closed")));
      }
      /**
       * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
       * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in
       * @param offset - Offset target
       * @param length - Number of bytes to read
       * @returns Number of bytes peeked
       */
      async peek(uint8Array, offset, length) {
        const bytesRead = await this.read(uint8Array, offset, length);
        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead));
        return bytesRead;
      }
      /**
       * Read chunk from stream
       * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
       * @param offset - Offset target
       * @param length - Number of bytes to read
       * @returns Number of bytes read
       */
      async read(buffer, offset, length) {
        if (length === 0) {
          return 0;
        }
        if (this.peekQueue.length === 0 && this.endOfStream) {
          throw new EndOfStreamError();
        }
        let remaining = length;
        let bytesRead = 0;
        while (this.peekQueue.length > 0 && remaining > 0) {
          const peekData = this.peekQueue.pop();
          if (!peekData)
            throw new Error("peekData should be defined");
          const lenCopy = Math.min(peekData.length, remaining);
          buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
          bytesRead += lenCopy;
          remaining -= lenCopy;
          if (lenCopy < peekData.length) {
            this.peekQueue.push(peekData.subarray(lenCopy));
          }
        }
        while (remaining > 0 && !this.endOfStream) {
          const reqLen = Math.min(remaining, maxStreamReadSize);
          const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
          bytesRead += chunkLen;
          if (chunkLen < reqLen)
            break;
          remaining -= chunkLen;
        }
        return bytesRead;
      }
      /**
       * Read chunk from stream
       * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
       * @param offset Offset target
       * @param length Number of bytes to read
       * @returns Number of bytes read
       */
      async readFromStream(buffer, offset, length) {
        const readBuffer = this.s.read(length);
        if (readBuffer) {
          buffer.set(readBuffer, offset);
          return readBuffer.length;
        } else {
          const request = {
            buffer,
            offset,
            length,
            deferred: new Deferred()
          };
          this.deferred = request.deferred;
          this.s.once("readable", () => {
            this.readDeferred(request);
          });
          return request.deferred.promise;
        }
      }
      /**
       * Process deferred read request
       * @param request Deferred read request
       */
      readDeferred(request) {
        const readBuffer = this.s.read(request.length);
        if (readBuffer) {
          request.buffer.set(readBuffer, request.offset);
          request.deferred.resolve(readBuffer.length);
          this.deferred = null;
        } else {
          this.s.once("readable", () => {
            this.readDeferred(request);
          });
        }
      }
      reject(err) {
        this.endOfStream = true;
        if (this.deferred) {
          this.deferred.reject(err);
          this.deferred = null;
        }
      }
    };
  }
});

// node_modules/peek-readable/lib/index.js
var init_lib = __esm({
  "node_modules/peek-readable/lib/index.js"() {
    init_EndOfFileStream();
    init_StreamReader();
  }
});

// node_modules/strtok3/lib/AbstractTokenizer.js
var import_node_buffer, AbstractTokenizer;
var init_AbstractTokenizer = __esm({
  "node_modules/strtok3/lib/AbstractTokenizer.js"() {
    init_lib();
    import_node_buffer = require("node:buffer");
    AbstractTokenizer = class {
      constructor(fileInfo) {
        this.position = 0;
        this.numBuffer = new Uint8Array(8);
        this.fileInfo = fileInfo ? fileInfo : {};
      }
      /**
       * Read a token from the tokenizer-stream
       * @param token - The token to read
       * @param position - If provided, the desired position in the tokenizer-stream
       * @returns Promise with token data
       */
      async readToken(token, position = this.position) {
        const uint8Array = import_node_buffer.Buffer.alloc(token.len);
        const len = await this.readBuffer(uint8Array, { position });
        if (len < token.len)
          throw new EndOfStreamError();
        return token.get(uint8Array, 0);
      }
      /**
       * Peek a token from the tokenizer-stream.
       * @param token - Token to peek from the tokenizer-stream.
       * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
       * @returns Promise with token data
       */
      async peekToken(token, position = this.position) {
        const uint8Array = import_node_buffer.Buffer.alloc(token.len);
        const len = await this.peekBuffer(uint8Array, { position });
        if (len < token.len)
          throw new EndOfStreamError();
        return token.get(uint8Array, 0);
      }
      /**
       * Read a numeric token from the stream
       * @param token - Numeric token
       * @returns Promise with number
       */
      async readNumber(token) {
        const len = await this.readBuffer(this.numBuffer, { length: token.len });
        if (len < token.len)
          throw new EndOfStreamError();
        return token.get(this.numBuffer, 0);
      }
      /**
       * Read a numeric token from the stream
       * @param token - Numeric token
       * @returns Promise with number
       */
      async peekNumber(token) {
        const len = await this.peekBuffer(this.numBuffer, { length: token.len });
        if (len < token.len)
          throw new EndOfStreamError();
        return token.get(this.numBuffer, 0);
      }
      /**
       * Ignore number of bytes, advances the pointer in under tokenizer-stream.
       * @param length - Number of bytes to ignore
       * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
       */
      async ignore(length) {
        if (this.fileInfo.size !== void 0) {
          const bytesLeft = this.fileInfo.size - this.position;
          if (length > bytesLeft) {
            this.position += bytesLeft;
            return bytesLeft;
          }
        }
        this.position += length;
        return length;
      }
      async close() {
      }
      normalizeOptions(uint8Array, options) {
        if (options && options.position !== void 0 && options.position < this.position) {
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        }
        if (options) {
          return {
            mayBeLess: options.mayBeLess === true,
            offset: options.offset ? options.offset : 0,
            length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
            position: options.position ? options.position : this.position
          };
        }
        return {
          mayBeLess: false,
          offset: 0,
          length: uint8Array.length,
          position: this.position
        };
      }
    };
  }
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var maxBufferSize, ReadStreamTokenizer;
var init_ReadStreamTokenizer = __esm({
  "node_modules/strtok3/lib/ReadStreamTokenizer.js"() {
    init_AbstractTokenizer();
    init_lib();
    maxBufferSize = 256e3;
    ReadStreamTokenizer = class extends AbstractTokenizer {
      constructor(stream4, fileInfo) {
        super(fileInfo);
        this.streamReader = new StreamReader(stream4);
      }
      /**
       * Get file information, an HTTP-client may implement this doing a HEAD request
       * @return Promise with file information
       */
      async getFileInfo() {
        return this.fileInfo;
      }
      /**
       * Read buffer from tokenizer
       * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
       * @param options - Read behaviour options
       * @returns Promise with number of bytes read
       */
      async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          await this.ignore(skipBytes);
          return this.readBuffer(uint8Array, options);
        } else if (skipBytes < 0) {
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        }
        if (normOptions.length === 0) {
          return 0;
        }
        const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
        this.position += bytesRead;
        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
          throw new EndOfStreamError();
        }
        return bytesRead;
      }
      /**
       * Peek (read ahead) buffer from tokenizer
       * @param uint8Array - Uint8Array (or Buffer) to write data to
       * @param options - Read behaviour options
       * @returns Promise with number of bytes peeked
       */
      async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        let bytesRead = 0;
        if (normOptions.position) {
          const skipBytes = normOptions.position - this.position;
          if (skipBytes > 0) {
            const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
            bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
            uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
            return bytesRead - skipBytes;
          } else if (skipBytes < 0) {
            throw new Error("Cannot peek from a negative offset in a stream");
          }
        }
        if (normOptions.length > 0) {
          try {
            bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
          } catch (err) {
            if (options && options.mayBeLess && err instanceof EndOfStreamError) {
              return 0;
            }
            throw err;
          }
          if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
            throw new EndOfStreamError();
          }
        }
        return bytesRead;
      }
      async ignore(length) {
        const bufSize = Math.min(maxBufferSize, length);
        const buf = new Uint8Array(bufSize);
        let totBytesRead = 0;
        while (totBytesRead < length) {
          const remaining = length - totBytesRead;
          const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
          if (bytesRead < 0) {
            return bytesRead;
          }
          totBytesRead += bytesRead;
        }
        return totBytesRead;
      }
    };
  }
});

// node_modules/strtok3/lib/BufferTokenizer.js
var BufferTokenizer;
var init_BufferTokenizer = __esm({
  "node_modules/strtok3/lib/BufferTokenizer.js"() {
    init_lib();
    init_AbstractTokenizer();
    BufferTokenizer = class extends AbstractTokenizer {
      /**
       * Construct BufferTokenizer
       * @param uint8Array - Uint8Array to tokenize
       * @param fileInfo - Pass additional file information to the tokenizer
       */
      constructor(uint8Array, fileInfo) {
        super(fileInfo);
        this.uint8Array = uint8Array;
        this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
      }
      /**
       * Read buffer from tokenizer
       * @param uint8Array - Uint8Array to tokenize
       * @param options - Read behaviour options
       * @returns {Promise<number>}
       */
      async readBuffer(uint8Array, options) {
        if (options && options.position) {
          if (options.position < this.position) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          this.position = options.position;
        }
        const bytesRead = await this.peekBuffer(uint8Array, options);
        this.position += bytesRead;
        return bytesRead;
      }
      /**
       * Peek (read ahead) buffer from tokenizer
       * @param uint8Array
       * @param options - Read behaviour options
       * @returns {Promise<number>}
       */
      async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
        if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
          throw new EndOfStreamError();
        } else {
          uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
          return bytes2read;
        }
      }
      async close() {
      }
    };
  }
});

// node_modules/strtok3/lib/core.js
function fromStream(stream4, fileInfo) {
  fileInfo = fileInfo ? fileInfo : {};
  return new ReadStreamTokenizer(stream4, fileInfo);
}
function fromBuffer(uint8Array, fileInfo) {
  return new BufferTokenizer(uint8Array, fileInfo);
}
var init_core = __esm({
  "node_modules/strtok3/lib/core.js"() {
    init_ReadStreamTokenizer();
    init_BufferTokenizer();
    init_lib();
  }
});

// node_modules/strtok3/lib/FileTokenizer.js
async function fromFile(sourceFilePath) {
  const stat2 = await stat(sourceFilePath);
  if (!stat2.isFile) {
    throw new Error(`File not a file: ${sourceFilePath}`);
  }
  const fd = await open(sourceFilePath, "r");
  return new FileTokenizer(fd, { path: sourceFilePath, size: stat2.size });
}
var FileTokenizer;
var init_FileTokenizer = __esm({
  "node_modules/strtok3/lib/FileTokenizer.js"() {
    init_AbstractTokenizer();
    init_lib();
    init_FsPromise();
    FileTokenizer = class extends AbstractTokenizer {
      constructor(fd, fileInfo) {
        super(fileInfo);
        this.fd = fd;
      }
      /**
       * Read buffer from file
       * @param uint8Array - Uint8Array to write result to
       * @param options - Read behaviour options
       * @returns Promise number of bytes read
       */
      async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        this.position = normOptions.position;
        const res = await read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        this.position += res.bytesRead;
        if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
          throw new EndOfStreamError();
        }
        return res.bytesRead;
      }
      /**
       * Peek buffer from file
       * @param uint8Array - Uint8Array (or Buffer) to write data to
       * @param options - Read behaviour options
       * @returns Promise number of bytes read
       */
      async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const res = await read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
          throw new EndOfStreamError();
        }
        return res.bytesRead;
      }
      async close() {
        return close(this.fd);
      }
    };
  }
});

// node_modules/strtok3/lib/index.js
var init_lib2 = __esm({
  "node_modules/strtok3/lib/index.js"() {
    init_FsPromise();
    init_core();
    init_FileTokenizer();
    init_core();
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/token-types/lib/index.js
function dv(array) {
  return new DataView(array.buffer, array.byteOffset);
}
var ieee754, import_node_buffer2, UINT8, UINT16_LE, UINT16_BE, UINT32_LE, UINT32_BE, INT32_BE, UINT64_LE, StringType, AnsiStringType;
var init_lib3 = __esm({
  "node_modules/token-types/lib/index.js"() {
    ieee754 = __toESM(require_ieee754(), 1);
    import_node_buffer2 = require("node:buffer");
    UINT8 = {
      len: 1,
      get(array, offset) {
        return dv(array).getUint8(offset);
      },
      put(array, offset, value) {
        dv(array).setUint8(offset, value);
        return offset + 1;
      }
    };
    UINT16_LE = {
      len: 2,
      get(array, offset) {
        return dv(array).getUint16(offset, true);
      },
      put(array, offset, value) {
        dv(array).setUint16(offset, value, true);
        return offset + 2;
      }
    };
    UINT16_BE = {
      len: 2,
      get(array, offset) {
        return dv(array).getUint16(offset);
      },
      put(array, offset, value) {
        dv(array).setUint16(offset, value);
        return offset + 2;
      }
    };
    UINT32_LE = {
      len: 4,
      get(array, offset) {
        return dv(array).getUint32(offset, true);
      },
      put(array, offset, value) {
        dv(array).setUint32(offset, value, true);
        return offset + 4;
      }
    };
    UINT32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getUint32(offset);
      },
      put(array, offset, value) {
        dv(array).setUint32(offset, value);
        return offset + 4;
      }
    };
    INT32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getInt32(offset);
      },
      put(array, offset, value) {
        dv(array).setInt32(offset, value);
        return offset + 4;
      }
    };
    UINT64_LE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigUint64(offset, true);
      },
      put(array, offset, value) {
        dv(array).setBigUint64(offset, value, true);
        return offset + 8;
      }
    };
    StringType = class {
      constructor(len, encoding) {
        this.len = len;
        this.encoding = encoding;
      }
      get(uint8Array, offset) {
        return import_node_buffer2.Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);
      }
    };
    AnsiStringType = class {
      constructor(len) {
        this.len = len;
      }
      static decode(buffer, offset, until) {
        let str = "";
        for (let i = offset; i < until; ++i) {
          str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i]));
        }
        return str;
      }
      static inRange(a, min, max) {
        return min <= a && a <= max;
      }
      static codePointToString(cp) {
        if (cp <= 65535) {
          return String.fromCharCode(cp);
        } else {
          cp -= 65536;
          return String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
        }
      }
      static singleByteDecoder(bite) {
        if (AnsiStringType.inRange(bite, 0, 127)) {
          return bite;
        }
        const codePoint = AnsiStringType.windows1252[bite - 128];
        if (codePoint === null) {
          throw Error("invaliding encoding");
        }
        return codePoint;
      }
      get(buffer, offset = 0) {
        return AnsiStringType.decode(buffer, offset, offset + this.len);
      }
    };
    AnsiStringType.windows1252 = [
      8364,
      129,
      8218,
      402,
      8222,
      8230,
      8224,
      8225,
      710,
      8240,
      352,
      8249,
      338,
      141,
      381,
      143,
      144,
      8216,
      8217,
      8220,
      8221,
      8226,
      8211,
      8212,
      732,
      8482,
      353,
      8250,
      339,
      157,
      382,
      376,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      235,
      236,
      237,
      238,
      239,
      240,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250,
      251,
      252,
      253,
      254,
      255
    ];
  }
});

// node_modules/file-type/util.js
function stringToBytes(string) {
  return [...string].map((character) => character.charCodeAt(0));
}
function tarHeaderChecksumMatches(buffer, offset = 0) {
  const readSum = Number.parseInt(buffer.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(readSum)) {
    return false;
  }
  let sum = 8 * 32;
  for (let index = offset; index < offset + 148; index++) {
    sum += buffer[index];
  }
  for (let index = offset + 156; index < offset + 512; index++) {
    sum += buffer[index];
  }
  return readSum === sum;
}
var uint32SyncSafeToken;
var init_util = __esm({
  "node_modules/file-type/util.js"() {
    uint32SyncSafeToken = {
      get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
      len: 4
    };
  }
});

// node_modules/file-type/supported.js
var extensions, mimeTypes;
var init_supported = __esm({
  "node_modules/file-type/supported.js"() {
    extensions = [
      "jpg",
      "png",
      "apng",
      "gif",
      "webp",
      "flif",
      "xcf",
      "cr2",
      "cr3",
      "orf",
      "arw",
      "dng",
      "nef",
      "rw2",
      "raf",
      "tif",
      "bmp",
      "icns",
      "jxr",
      "psd",
      "indd",
      "zip",
      "tar",
      "rar",
      "gz",
      "bz2",
      "7z",
      "dmg",
      "mp4",
      "mid",
      "mkv",
      "webm",
      "mov",
      "avi",
      "mpg",
      "mp2",
      "mp3",
      "m4a",
      "oga",
      "ogg",
      "ogv",
      "opus",
      "flac",
      "wav",
      "spx",
      "amr",
      "pdf",
      "epub",
      "elf",
      "exe",
      "swf",
      "rtf",
      "wasm",
      "woff",
      "woff2",
      "eot",
      "ttf",
      "otf",
      "ico",
      "flv",
      "ps",
      "xz",
      "sqlite",
      "nes",
      "crx",
      "xpi",
      "cab",
      "deb",
      "ar",
      "rpm",
      "Z",
      "lz",
      "cfb",
      "mxf",
      "mts",
      "blend",
      "bpg",
      "docx",
      "pptx",
      "xlsx",
      "3gp",
      "3g2",
      "jp2",
      "jpm",
      "jpx",
      "mj2",
      "aif",
      "qcp",
      "odt",
      "ods",
      "odp",
      "xml",
      "mobi",
      "heic",
      "cur",
      "ktx",
      "ape",
      "wv",
      "dcm",
      "ics",
      "glb",
      "pcap",
      "dsf",
      "lnk",
      "alias",
      "voc",
      "ac3",
      "m4v",
      "m4p",
      "m4b",
      "f4v",
      "f4p",
      "f4b",
      "f4a",
      "mie",
      "asf",
      "ogm",
      "ogx",
      "mpc",
      "arrow",
      "shp",
      "aac",
      "mp1",
      "it",
      "s3m",
      "xm",
      "ai",
      "skp",
      "avif",
      "eps",
      "lzh",
      "pgp",
      "asar",
      "stl",
      "chm",
      "3mf",
      "zst",
      "jxl",
      "vcf",
      "jls",
      "pst",
      "dwg",
      "parquet"
    ];
    mimeTypes = [
      "image/jpeg",
      "image/png",
      "image/gif",
      "image/webp",
      "image/flif",
      "image/x-xcf",
      "image/x-canon-cr2",
      "image/x-canon-cr3",
      "image/tiff",
      "image/bmp",
      "image/vnd.ms-photo",
      "image/vnd.adobe.photoshop",
      "application/x-indesign",
      "application/epub+zip",
      "application/x-xpinstall",
      "application/vnd.oasis.opendocument.text",
      "application/vnd.oasis.opendocument.spreadsheet",
      "application/vnd.oasis.opendocument.presentation",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "application/vnd.openxmlformats-officedocument.presentationml.presentation",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      "application/zip",
      "application/x-tar",
      "application/x-rar-compressed",
      "application/gzip",
      "application/x-bzip2",
      "application/x-7z-compressed",
      "application/x-apple-diskimage",
      "application/x-apache-arrow",
      "video/mp4",
      "audio/midi",
      "video/x-matroska",
      "video/webm",
      "video/quicktime",
      "video/vnd.avi",
      "audio/vnd.wave",
      "audio/qcelp",
      "audio/x-ms-asf",
      "video/x-ms-asf",
      "application/vnd.ms-asf",
      "video/mpeg",
      "video/3gpp",
      "audio/mpeg",
      "audio/mp4",
      // RFC 4337
      "audio/opus",
      "video/ogg",
      "audio/ogg",
      "application/ogg",
      "audio/x-flac",
      "audio/ape",
      "audio/wavpack",
      "audio/amr",
      "application/pdf",
      "application/x-elf",
      "application/x-msdownload",
      "application/x-shockwave-flash",
      "application/rtf",
      "application/wasm",
      "font/woff",
      "font/woff2",
      "application/vnd.ms-fontobject",
      "font/ttf",
      "font/otf",
      "image/x-icon",
      "video/x-flv",
      "application/postscript",
      "application/eps",
      "application/x-xz",
      "application/x-sqlite3",
      "application/x-nintendo-nes-rom",
      "application/x-google-chrome-extension",
      "application/vnd.ms-cab-compressed",
      "application/x-deb",
      "application/x-unix-archive",
      "application/x-rpm",
      "application/x-compress",
      "application/x-lzip",
      "application/x-cfb",
      "application/x-mie",
      "application/mxf",
      "video/mp2t",
      "application/x-blender",
      "image/bpg",
      "image/jp2",
      "image/jpx",
      "image/jpm",
      "image/mj2",
      "audio/aiff",
      "application/xml",
      "application/x-mobipocket-ebook",
      "image/heif",
      "image/heif-sequence",
      "image/heic",
      "image/heic-sequence",
      "image/icns",
      "image/ktx",
      "application/dicom",
      "audio/x-musepack",
      "text/calendar",
      "text/vcard",
      "model/gltf-binary",
      "application/vnd.tcpdump.pcap",
      "audio/x-dsf",
      // Non-standard
      "application/x.ms.shortcut",
      // Invented by us
      "application/x.apple.alias",
      // Invented by us
      "audio/x-voc",
      "audio/vnd.dolby.dd-raw",
      "audio/x-m4a",
      "image/apng",
      "image/x-olympus-orf",
      "image/x-sony-arw",
      "image/x-adobe-dng",
      "image/x-nikon-nef",
      "image/x-panasonic-rw2",
      "image/x-fujifilm-raf",
      "video/x-m4v",
      "video/3gpp2",
      "application/x-esri-shape",
      "audio/aac",
      "audio/x-it",
      "audio/x-s3m",
      "audio/x-xm",
      "video/MP1S",
      "video/MP2P",
      "application/vnd.sketchup.skp",
      "image/avif",
      "application/x-lzh-compressed",
      "application/pgp-encrypted",
      "application/x-asar",
      "model/stl",
      "application/vnd.ms-htmlhelp",
      "model/3mf",
      "image/jxl",
      "application/zstd",
      "image/jls",
      "application/vnd.ms-outlook",
      "image/vnd.dwg",
      "application/x-parquet"
    ];
  }
});

// node_modules/file-type/core.js
async function fileTypeFromStream(stream4) {
  const tokenizer = await fromStream(stream4);
  try {
    return await fileTypeFromTokenizer(tokenizer);
  } finally {
    await tokenizer.close();
  }
}
async function fileTypeFromBuffer(input) {
  if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
    throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
  }
  const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
  if (!(buffer?.length > 1)) {
    return;
  }
  return fileTypeFromTokenizer(fromBuffer(buffer));
}
function _check(buffer, headers, options) {
  options = {
    offset: 0,
    ...options
  };
  for (const [index, header] of headers.entries()) {
    if (options.mask) {
      if (header !== (options.mask[index] & buffer[index + options.offset])) {
        return false;
      }
    } else if (header !== buffer[index + options.offset]) {
      return false;
    }
  }
  return true;
}
async function fileTypeFromTokenizer(tokenizer) {
  try {
    return new FileTypeParser().parse(tokenizer);
  } catch (error) {
    if (!(error instanceof EndOfStreamError)) {
      throw error;
    }
  }
}
async function fileTypeStream(readableStream, { sampleSize = minimumBytes } = {}) {
  const { default: stream4 } = await import("node:stream");
  return new Promise((resolve, reject) => {
    readableStream.on("error", reject);
    readableStream.once("readable", () => {
      (async () => {
        try {
          const pass = new stream4.PassThrough();
          const outputStream = stream4.pipeline ? stream4.pipeline(readableStream, pass, () => {
          }) : readableStream.pipe(pass);
          const chunk = readableStream.read(sampleSize) ?? readableStream.read() ?? import_node_buffer3.Buffer.alloc(0);
          try {
            const fileType = await fileTypeFromBuffer(chunk);
            pass.fileType = fileType;
          } catch (error) {
            if (error instanceof EndOfStreamError) {
              pass.fileType = void 0;
            } else {
              reject(error);
            }
          }
          resolve(outputStream);
        } catch (error) {
          reject(error);
        }
      })();
    });
  });
}
var import_node_buffer3, minimumBytes, FileTypeParser, supportedExtensions, supportedMimeTypes;
var init_core2 = __esm({
  "node_modules/file-type/core.js"() {
    import_node_buffer3 = require("node:buffer");
    init_lib3();
    init_core();
    init_util();
    init_supported();
    minimumBytes = 4100;
    FileTypeParser = class {
      check(header, options) {
        return _check(this.buffer, header, options);
      }
      checkString(header, options) {
        return this.check(stringToBytes(header), options);
      }
      async parse(tokenizer) {
        this.buffer = import_node_buffer3.Buffer.alloc(minimumBytes);
        if (tokenizer.fileInfo.size === void 0) {
          tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
        }
        this.tokenizer = tokenizer;
        await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
        if (this.check([66, 77])) {
          return {
            ext: "bmp",
            mime: "image/bmp"
          };
        }
        if (this.check([11, 119])) {
          return {
            ext: "ac3",
            mime: "audio/vnd.dolby.dd-raw"
          };
        }
        if (this.check([120, 1])) {
          return {
            ext: "dmg",
            mime: "application/x-apple-diskimage"
          };
        }
        if (this.check([77, 90])) {
          return {
            ext: "exe",
            mime: "application/x-msdownload"
          };
        }
        if (this.check([37, 33])) {
          await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
          if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
            return {
              ext: "eps",
              mime: "application/eps"
            };
          }
          return {
            ext: "ps",
            mime: "application/postscript"
          };
        }
        if (this.check([31, 160]) || this.check([31, 157])) {
          return {
            ext: "Z",
            mime: "application/x-compress"
          };
        }
        if (this.check([239, 187, 191])) {
          this.tokenizer.ignore(3);
          return this.parse(tokenizer);
        }
        if (this.check([71, 73, 70])) {
          return {
            ext: "gif",
            mime: "image/gif"
          };
        }
        if (this.check([73, 73, 188])) {
          return {
            ext: "jxr",
            mime: "image/vnd.ms-photo"
          };
        }
        if (this.check([31, 139, 8])) {
          return {
            ext: "gz",
            mime: "application/gzip"
          };
        }
        if (this.check([66, 90, 104])) {
          return {
            ext: "bz2",
            mime: "application/x-bzip2"
          };
        }
        if (this.checkString("ID3")) {
          await tokenizer.ignore(6);
          const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
          if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
            return {
              ext: "mp3",
              mime: "audio/mpeg"
            };
          }
          await tokenizer.ignore(id3HeaderLength);
          return fileTypeFromTokenizer(tokenizer);
        }
        if (this.checkString("MP+")) {
          return {
            ext: "mpc",
            mime: "audio/x-musepack"
          };
        }
        if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
          return {
            ext: "swf",
            mime: "application/x-shockwave-flash"
          };
        }
        if (this.check([255, 216, 255])) {
          if (this.check([247], { offset: 3 })) {
            return {
              ext: "jls",
              mime: "image/jls"
            };
          }
          return {
            ext: "jpg",
            mime: "image/jpeg"
          };
        }
        if (this.checkString("FLIF")) {
          return {
            ext: "flif",
            mime: "image/flif"
          };
        }
        if (this.checkString("8BPS")) {
          return {
            ext: "psd",
            mime: "image/vnd.adobe.photoshop"
          };
        }
        if (this.checkString("WEBP", { offset: 8 })) {
          return {
            ext: "webp",
            mime: "image/webp"
          };
        }
        if (this.checkString("MPCK")) {
          return {
            ext: "mpc",
            mime: "audio/x-musepack"
          };
        }
        if (this.checkString("FORM")) {
          return {
            ext: "aif",
            mime: "audio/aiff"
          };
        }
        if (this.checkString("icns", { offset: 0 })) {
          return {
            ext: "icns",
            mime: "image/icns"
          };
        }
        if (this.check([80, 75, 3, 4])) {
          try {
            while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
              await tokenizer.readBuffer(this.buffer, { length: 30 });
              const zipHeader = {
                compressedSize: this.buffer.readUInt32LE(18),
                uncompressedSize: this.buffer.readUInt32LE(22),
                filenameLength: this.buffer.readUInt16LE(26),
                extraFieldLength: this.buffer.readUInt16LE(28)
              };
              zipHeader.filename = await tokenizer.readToken(new StringType(zipHeader.filenameLength, "utf-8"));
              await tokenizer.ignore(zipHeader.extraFieldLength);
              if (zipHeader.filename === "META-INF/mozilla.rsa") {
                return {
                  ext: "xpi",
                  mime: "application/x-xpinstall"
                };
              }
              if (zipHeader.filename.endsWith(".rels") || zipHeader.filename.endsWith(".xml")) {
                const type = zipHeader.filename.split("/")[0];
                switch (type) {
                  case "_rels":
                    break;
                  case "word":
                    return {
                      ext: "docx",
                      mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                    };
                  case "ppt":
                    return {
                      ext: "pptx",
                      mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                    };
                  case "xl":
                    return {
                      ext: "xlsx",
                      mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                    };
                  default:
                    break;
                }
              }
              if (zipHeader.filename.startsWith("xl/")) {
                return {
                  ext: "xlsx",
                  mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                };
              }
              if (zipHeader.filename.startsWith("3D/") && zipHeader.filename.endsWith(".model")) {
                return {
                  ext: "3mf",
                  mime: "model/3mf"
                };
              }
              if (zipHeader.filename === "mimetype" && zipHeader.compressedSize === zipHeader.uncompressedSize) {
                let mimeType = await tokenizer.readToken(new StringType(zipHeader.compressedSize, "utf-8"));
                mimeType = mimeType.trim();
                switch (mimeType) {
                  case "application/epub+zip":
                    return {
                      ext: "epub",
                      mime: "application/epub+zip"
                    };
                  case "application/vnd.oasis.opendocument.text":
                    return {
                      ext: "odt",
                      mime: "application/vnd.oasis.opendocument.text"
                    };
                  case "application/vnd.oasis.opendocument.spreadsheet":
                    return {
                      ext: "ods",
                      mime: "application/vnd.oasis.opendocument.spreadsheet"
                    };
                  case "application/vnd.oasis.opendocument.presentation":
                    return {
                      ext: "odp",
                      mime: "application/vnd.oasis.opendocument.presentation"
                    };
                  default:
                }
              }
              if (zipHeader.compressedSize === 0) {
                let nextHeaderIndex = -1;
                while (nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size) {
                  await tokenizer.peekBuffer(this.buffer, { mayBeLess: true });
                  nextHeaderIndex = this.buffer.indexOf("504B0304", 0, "hex");
                  await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : this.buffer.length);
                }
              } else {
                await tokenizer.ignore(zipHeader.compressedSize);
              }
            }
          } catch (error) {
            if (!(error instanceof EndOfStreamError)) {
              throw error;
            }
          }
          return {
            ext: "zip",
            mime: "application/zip"
          };
        }
        if (this.checkString("OggS")) {
          await tokenizer.ignore(28);
          const type = import_node_buffer3.Buffer.alloc(8);
          await tokenizer.readBuffer(type);
          if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
            return {
              ext: "opus",
              mime: "audio/opus"
            };
          }
          if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
            return {
              ext: "ogv",
              mime: "video/ogg"
            };
          }
          if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
            return {
              ext: "ogm",
              mime: "video/ogg"
            };
          }
          if (_check(type, [127, 70, 76, 65, 67])) {
            return {
              ext: "oga",
              mime: "audio/ogg"
            };
          }
          if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
            return {
              ext: "spx",
              mime: "audio/ogg"
            };
          }
          if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
            return {
              ext: "ogg",
              mime: "audio/ogg"
            };
          }
          return {
            ext: "ogx",
            mime: "application/ogg"
          };
        }
        if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
          return {
            ext: "zip",
            mime: "application/zip"
          };
        }
        if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
          const brandMajor = this.buffer.toString("binary", 8, 12).replace("\0", " ").trim();
          switch (brandMajor) {
            case "avif":
            case "avis":
              return { ext: "avif", mime: "image/avif" };
            case "mif1":
              return { ext: "heic", mime: "image/heif" };
            case "msf1":
              return { ext: "heic", mime: "image/heif-sequence" };
            case "heic":
            case "heix":
              return { ext: "heic", mime: "image/heic" };
            case "hevc":
            case "hevx":
              return { ext: "heic", mime: "image/heic-sequence" };
            case "qt":
              return { ext: "mov", mime: "video/quicktime" };
            case "M4V":
            case "M4VH":
            case "M4VP":
              return { ext: "m4v", mime: "video/x-m4v" };
            case "M4P":
              return { ext: "m4p", mime: "video/mp4" };
            case "M4B":
              return { ext: "m4b", mime: "audio/mp4" };
            case "M4A":
              return { ext: "m4a", mime: "audio/x-m4a" };
            case "F4V":
              return { ext: "f4v", mime: "video/mp4" };
            case "F4P":
              return { ext: "f4p", mime: "video/mp4" };
            case "F4A":
              return { ext: "f4a", mime: "audio/mp4" };
            case "F4B":
              return { ext: "f4b", mime: "audio/mp4" };
            case "crx":
              return { ext: "cr3", mime: "image/x-canon-cr3" };
            default:
              if (brandMajor.startsWith("3g")) {
                if (brandMajor.startsWith("3g2")) {
                  return { ext: "3g2", mime: "video/3gpp2" };
                }
                return { ext: "3gp", mime: "video/3gpp" };
              }
              return { ext: "mp4", mime: "video/mp4" };
          }
        }
        if (this.checkString("MThd")) {
          return {
            ext: "mid",
            mime: "audio/midi"
          };
        }
        if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
          return {
            ext: "woff",
            mime: "font/woff"
          };
        }
        if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
          return {
            ext: "woff2",
            mime: "font/woff2"
          };
        }
        if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
          return {
            ext: "pcap",
            mime: "application/vnd.tcpdump.pcap"
          };
        }
        if (this.checkString("DSD ")) {
          return {
            ext: "dsf",
            mime: "audio/x-dsf"
            // Non-standard
          };
        }
        if (this.checkString("LZIP")) {
          return {
            ext: "lz",
            mime: "application/x-lzip"
          };
        }
        if (this.checkString("fLaC")) {
          return {
            ext: "flac",
            mime: "audio/x-flac"
          };
        }
        if (this.check([66, 80, 71, 251])) {
          return {
            ext: "bpg",
            mime: "image/bpg"
          };
        }
        if (this.checkString("wvpk")) {
          return {
            ext: "wv",
            mime: "audio/wavpack"
          };
        }
        if (this.checkString("%PDF")) {
          try {
            await tokenizer.ignore(1350);
            const maxBufferSize2 = 10 * 1024 * 1024;
            const buffer = import_node_buffer3.Buffer.alloc(Math.min(maxBufferSize2, tokenizer.fileInfo.size));
            await tokenizer.readBuffer(buffer, { mayBeLess: true });
            if (buffer.includes(import_node_buffer3.Buffer.from("AIPrivateData"))) {
              return {
                ext: "ai",
                mime: "application/postscript"
              };
            }
          } catch (error) {
            if (!(error instanceof EndOfStreamError)) {
              throw error;
            }
          }
          return {
            ext: "pdf",
            mime: "application/pdf"
          };
        }
        if (this.check([0, 97, 115, 109])) {
          return {
            ext: "wasm",
            mime: "application/wasm"
          };
        }
        if (this.check([73, 73])) {
          const fileType = await this.readTiffHeader(false);
          if (fileType) {
            return fileType;
          }
        }
        if (this.check([77, 77])) {
          const fileType = await this.readTiffHeader(true);
          if (fileType) {
            return fileType;
          }
        }
        if (this.checkString("MAC ")) {
          return {
            ext: "ape",
            mime: "audio/ape"
          };
        }
        if (this.check([26, 69, 223, 163])) {
          async function readField() {
            const msb = await tokenizer.peekNumber(UINT8);
            let mask = 128;
            let ic = 0;
            while ((msb & mask) === 0 && mask !== 0) {
              ++ic;
              mask >>= 1;
            }
            const id = import_node_buffer3.Buffer.alloc(ic + 1);
            await tokenizer.readBuffer(id);
            return id;
          }
          async function readElement() {
            const id = await readField();
            const lengthField = await readField();
            lengthField[0] ^= 128 >> lengthField.length - 1;
            const nrLength = Math.min(6, lengthField.length);
            return {
              id: id.readUIntBE(0, id.length),
              len: lengthField.readUIntBE(lengthField.length - nrLength, nrLength)
            };
          }
          async function readChildren(children) {
            while (children > 0) {
              const element = await readElement();
              if (element.id === 17026) {
                const rawValue = await tokenizer.readToken(new StringType(element.len, "utf-8"));
                return rawValue.replace(/\00.*$/g, "");
              }
              await tokenizer.ignore(element.len);
              --children;
            }
          }
          const re = await readElement();
          const docType = await readChildren(re.len);
          switch (docType) {
            case "webm":
              return {
                ext: "webm",
                mime: "video/webm"
              };
            case "matroska":
              return {
                ext: "mkv",
                mime: "video/x-matroska"
              };
            default:
              return;
          }
        }
        if (this.check([82, 73, 70, 70])) {
          if (this.check([65, 86, 73], { offset: 8 })) {
            return {
              ext: "avi",
              mime: "video/vnd.avi"
            };
          }
          if (this.check([87, 65, 86, 69], { offset: 8 })) {
            return {
              ext: "wav",
              mime: "audio/vnd.wave"
            };
          }
          if (this.check([81, 76, 67, 77], { offset: 8 })) {
            return {
              ext: "qcp",
              mime: "audio/qcelp"
            };
          }
        }
        if (this.checkString("SQLi")) {
          return {
            ext: "sqlite",
            mime: "application/x-sqlite3"
          };
        }
        if (this.check([78, 69, 83, 26])) {
          return {
            ext: "nes",
            mime: "application/x-nintendo-nes-rom"
          };
        }
        if (this.checkString("Cr24")) {
          return {
            ext: "crx",
            mime: "application/x-google-chrome-extension"
          };
        }
        if (this.checkString("MSCF") || this.checkString("ISc(")) {
          return {
            ext: "cab",
            mime: "application/vnd.ms-cab-compressed"
          };
        }
        if (this.check([237, 171, 238, 219])) {
          return {
            ext: "rpm",
            mime: "application/x-rpm"
          };
        }
        if (this.check([197, 208, 211, 198])) {
          return {
            ext: "eps",
            mime: "application/eps"
          };
        }
        if (this.check([40, 181, 47, 253])) {
          return {
            ext: "zst",
            mime: "application/zstd"
          };
        }
        if (this.check([127, 69, 76, 70])) {
          return {
            ext: "elf",
            mime: "application/x-elf"
          };
        }
        if (this.check([33, 66, 68, 78])) {
          return {
            ext: "pst",
            mime: "application/vnd.ms-outlook"
          };
        }
        if (this.checkString("PAR1")) {
          return {
            ext: "parquet",
            mime: "application/x-parquet"
          };
        }
        if (this.check([79, 84, 84, 79, 0])) {
          return {
            ext: "otf",
            mime: "font/otf"
          };
        }
        if (this.checkString("#!AMR")) {
          return {
            ext: "amr",
            mime: "audio/amr"
          };
        }
        if (this.checkString("{\\rtf")) {
          return {
            ext: "rtf",
            mime: "application/rtf"
          };
        }
        if (this.check([70, 76, 86, 1])) {
          return {
            ext: "flv",
            mime: "video/x-flv"
          };
        }
        if (this.checkString("IMPM")) {
          return {
            ext: "it",
            mime: "audio/x-it"
          };
        }
        if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
          return {
            ext: "lzh",
            mime: "application/x-lzh-compressed"
          };
        }
        if (this.check([0, 0, 1, 186])) {
          if (this.check([33], { offset: 4, mask: [241] })) {
            return {
              ext: "mpg",
              // May also be .ps, .mpeg
              mime: "video/MP1S"
            };
          }
          if (this.check([68], { offset: 4, mask: [196] })) {
            return {
              ext: "mpg",
              // May also be .mpg, .m2p, .vob or .sub
              mime: "video/MP2P"
            };
          }
        }
        if (this.checkString("ITSF")) {
          return {
            ext: "chm",
            mime: "application/vnd.ms-htmlhelp"
          };
        }
        if (this.check([253, 55, 122, 88, 90, 0])) {
          return {
            ext: "xz",
            mime: "application/x-xz"
          };
        }
        if (this.checkString("<?xml ")) {
          return {
            ext: "xml",
            mime: "application/xml"
          };
        }
        if (this.check([55, 122, 188, 175, 39, 28])) {
          return {
            ext: "7z",
            mime: "application/x-7z-compressed"
          };
        }
        if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
          return {
            ext: "rar",
            mime: "application/x-rar-compressed"
          };
        }
        if (this.checkString("solid ")) {
          return {
            ext: "stl",
            mime: "model/stl"
          };
        }
        if (this.checkString("AC")) {
          const version = this.buffer.toString("binary", 2, 6);
          if (version.match("^d*") && version >= 1e3 && version <= 1050) {
            return {
              ext: "dwg",
              mime: "image/vnd.dwg"
            };
          }
        }
        if (this.checkString("BLENDER")) {
          return {
            ext: "blend",
            mime: "application/x-blender"
          };
        }
        if (this.checkString("!<arch>")) {
          await tokenizer.ignore(8);
          const string = await tokenizer.readToken(new StringType(13, "ascii"));
          if (string === "debian-binary") {
            return {
              ext: "deb",
              mime: "application/x-deb"
            };
          }
          return {
            ext: "ar",
            mime: "application/x-unix-archive"
          };
        }
        if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
          await tokenizer.ignore(8);
          async function readChunkHeader() {
            return {
              length: await tokenizer.readToken(INT32_BE),
              type: await tokenizer.readToken(new StringType(4, "binary"))
            };
          }
          do {
            const chunk = await readChunkHeader();
            if (chunk.length < 0) {
              return;
            }
            switch (chunk.type) {
              case "IDAT":
                return {
                  ext: "png",
                  mime: "image/png"
                };
              case "acTL":
                return {
                  ext: "apng",
                  mime: "image/apng"
                };
              default:
                await tokenizer.ignore(chunk.length + 4);
            }
          } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
          return {
            ext: "png",
            mime: "image/png"
          };
        }
        if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
          return {
            ext: "arrow",
            mime: "application/x-apache-arrow"
          };
        }
        if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
          return {
            ext: "glb",
            mime: "model/gltf-binary"
          };
        }
        if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
          return {
            ext: "mov",
            mime: "video/quicktime"
          };
        }
        if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
          return {
            ext: "orf",
            mime: "image/x-olympus-orf"
          };
        }
        if (this.checkString("gimp xcf ")) {
          return {
            ext: "xcf",
            mime: "image/x-xcf"
          };
        }
        if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
          return {
            ext: "rw2",
            mime: "image/x-panasonic-rw2"
          };
        }
        if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
          async function readHeader() {
            const guid = import_node_buffer3.Buffer.alloc(16);
            await tokenizer.readBuffer(guid);
            return {
              id: guid,
              size: Number(await tokenizer.readToken(UINT64_LE))
            };
          }
          await tokenizer.ignore(30);
          while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
            const header = await readHeader();
            let payload = header.size - 24;
            if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
              const typeId = import_node_buffer3.Buffer.alloc(16);
              payload -= await tokenizer.readBuffer(typeId);
              if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
                return {
                  ext: "asf",
                  mime: "audio/x-ms-asf"
                };
              }
              if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
                return {
                  ext: "asf",
                  mime: "video/x-ms-asf"
                };
              }
              break;
            }
            await tokenizer.ignore(payload);
          }
          return {
            ext: "asf",
            mime: "application/vnd.ms-asf"
          };
        }
        if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
          return {
            ext: "ktx",
            mime: "image/ktx"
          };
        }
        if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
          return {
            ext: "mie",
            mime: "application/x-mie"
          };
        }
        if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
          return {
            ext: "shp",
            mime: "application/x-esri-shape"
          };
        }
        if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
          await tokenizer.ignore(20);
          const type = await tokenizer.readToken(new StringType(4, "ascii"));
          switch (type) {
            case "jp2 ":
              return {
                ext: "jp2",
                mime: "image/jp2"
              };
            case "jpx ":
              return {
                ext: "jpx",
                mime: "image/jpx"
              };
            case "jpm ":
              return {
                ext: "jpm",
                mime: "image/jpm"
              };
            case "mjp2":
              return {
                ext: "mj2",
                mime: "image/mj2"
              };
            default:
              return;
          }
        }
        if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
          return {
            ext: "jxl",
            mime: "image/jxl"
          };
        }
        if (this.check([254, 255])) {
          if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
            return {
              ext: "xml",
              mime: "application/xml"
            };
          }
          return void 0;
        }
        if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
          return {
            ext: "mpg",
            mime: "video/mpeg"
          };
        }
        if (this.check([0, 1, 0, 0, 0])) {
          return {
            ext: "ttf",
            mime: "font/ttf"
          };
        }
        if (this.check([0, 0, 1, 0])) {
          return {
            ext: "ico",
            mime: "image/x-icon"
          };
        }
        if (this.check([0, 0, 2, 0])) {
          return {
            ext: "cur",
            mime: "image/x-icon"
          };
        }
        if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
          return {
            ext: "cfb",
            mime: "application/x-cfb"
          };
        }
        await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
        if (this.checkString("BEGIN:")) {
          if (this.checkString("VCARD", { offset: 6 })) {
            return {
              ext: "vcf",
              mime: "text/vcard"
            };
          }
          if (this.checkString("VCALENDAR", { offset: 6 })) {
            return {
              ext: "ics",
              mime: "text/calendar"
            };
          }
        }
        if (this.checkString("FUJIFILMCCD-RAW")) {
          return {
            ext: "raf",
            mime: "image/x-fujifilm-raf"
          };
        }
        if (this.checkString("Extended Module:")) {
          return {
            ext: "xm",
            mime: "audio/x-xm"
          };
        }
        if (this.checkString("Creative Voice File")) {
          return {
            ext: "voc",
            mime: "audio/x-voc"
          };
        }
        if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
          const jsonSize = this.buffer.readUInt32LE(12);
          if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
            try {
              const header = this.buffer.slice(16, jsonSize + 16).toString();
              const json2 = JSON.parse(header);
              if (json2.files) {
                return {
                  ext: "asar",
                  mime: "application/x-asar"
                };
              }
            } catch {
            }
          }
        }
        if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
          return {
            ext: "mxf",
            mime: "application/mxf"
          };
        }
        if (this.checkString("SCRM", { offset: 44 })) {
          return {
            ext: "s3m",
            mime: "audio/x-s3m"
          };
        }
        if (this.check([71]) && this.check([71], { offset: 188 })) {
          return {
            ext: "mts",
            mime: "video/mp2t"
          };
        }
        if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
          return {
            ext: "mts",
            mime: "video/mp2t"
          };
        }
        if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
          return {
            ext: "mobi",
            mime: "application/x-mobipocket-ebook"
          };
        }
        if (this.check([68, 73, 67, 77], { offset: 128 })) {
          return {
            ext: "dcm",
            mime: "application/dicom"
          };
        }
        if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
          return {
            ext: "lnk",
            mime: "application/x.ms.shortcut"
            // Invented by us
          };
        }
        if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
          return {
            ext: "alias",
            mime: "application/x.apple.alias"
            // Invented by us
          };
        }
        if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
          return {
            ext: "eot",
            mime: "application/vnd.ms-fontobject"
          };
        }
        if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
          return {
            ext: "indd",
            mime: "application/x-indesign"
          };
        }
        await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
        if (tarHeaderChecksumMatches(this.buffer)) {
          return {
            ext: "tar",
            mime: "application/x-tar"
          };
        }
        if (this.check([255, 254])) {
          if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
            return {
              ext: "xml",
              mime: "application/xml"
            };
          }
          if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
            return {
              ext: "skp",
              mime: "application/vnd.sketchup.skp"
            };
          }
          return void 0;
        }
        if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
          return {
            ext: "pgp",
            mime: "application/pgp-encrypted"
          };
        }
        if (this.buffer.length >= 2 && this.check([255, 224], { offset: 0, mask: [255, 224] })) {
          if (this.check([16], { offset: 1, mask: [22] })) {
            if (this.check([8], { offset: 1, mask: [8] })) {
              return {
                ext: "aac",
                mime: "audio/aac"
              };
            }
            return {
              ext: "aac",
              mime: "audio/aac"
            };
          }
          if (this.check([2], { offset: 1, mask: [6] })) {
            return {
              ext: "mp3",
              mime: "audio/mpeg"
            };
          }
          if (this.check([4], { offset: 1, mask: [6] })) {
            return {
              ext: "mp2",
              mime: "audio/mpeg"
            };
          }
          if (this.check([6], { offset: 1, mask: [6] })) {
            return {
              ext: "mp1",
              mime: "audio/mpeg"
            };
          }
        }
      }
      async readTiffTag(bigEndian) {
        const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
        this.tokenizer.ignore(10);
        switch (tagId) {
          case 50341:
            return {
              ext: "arw",
              mime: "image/x-sony-arw"
            };
          case 50706:
            return {
              ext: "dng",
              mime: "image/x-adobe-dng"
            };
          default:
        }
      }
      async readTiffIFD(bigEndian) {
        const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
        for (let n = 0; n < numberOfTags; ++n) {
          const fileType = await this.readTiffTag(bigEndian);
          if (fileType) {
            return fileType;
          }
        }
      }
      async readTiffHeader(bigEndian) {
        const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
        const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
        if (version === 42) {
          if (ifdOffset >= 6) {
            if (this.checkString("CR", { offset: 8 })) {
              return {
                ext: "cr2",
                mime: "image/x-canon-cr2"
              };
            }
            if (ifdOffset >= 8 && (this.check([28, 0, 254, 0], { offset: 8 }) || this.check([31, 0, 11, 0], { offset: 8 }))) {
              return {
                ext: "nef",
                mime: "image/x-nikon-nef"
              };
            }
          }
          await this.tokenizer.ignore(ifdOffset);
          const fileType = await this.readTiffIFD(bigEndian);
          return fileType ?? {
            ext: "tif",
            mime: "image/tiff"
          };
        }
        if (version === 43) {
          return {
            ext: "tif",
            mime: "image/tiff"
          };
        }
      }
    };
    supportedExtensions = new Set(extensions);
    supportedMimeTypes = new Set(mimeTypes);
  }
});

// node_modules/file-type/index.js
var file_type_exports = {};
__export(file_type_exports, {
  fileTypeFromBuffer: () => fileTypeFromBuffer,
  fileTypeFromFile: () => fileTypeFromFile,
  fileTypeFromStream: () => fileTypeFromStream,
  fileTypeFromTokenizer: () => fileTypeFromTokenizer,
  fileTypeStream: () => fileTypeStream,
  supportedExtensions: () => supportedExtensions,
  supportedMimeTypes: () => supportedMimeTypes
});
async function fileTypeFromFile(path) {
  const tokenizer = await fromFile(path);
  try {
    return await fileTypeFromTokenizer(tokenizer);
  } finally {
    await tokenizer.close();
  }
}
var init_file_type = __esm({
  "node_modules/file-type/index.js"() {
    init_lib2();
    init_core2();
    init_core2();
  }
});

// node_modules/@discordjs/rest/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@discordjs/rest/dist/index.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp2(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,
      ALLOWED_SIZES: () => ALLOWED_SIZES,
      ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,
      BurstHandlerMajorIdKey: () => BurstHandlerMajorIdKey,
      CDN: () => CDN,
      DefaultRestOptions: () => DefaultRestOptions,
      DefaultUserAgent: () => DefaultUserAgent,
      DefaultUserAgentAppendix: () => DefaultUserAgentAppendix,
      DiscordAPIError: () => DiscordAPIError,
      HTTPError: () => HTTPError,
      OverwrittenMimeTypes: () => OverwrittenMimeTypes,
      REST: () => REST,
      RESTEvents: () => RESTEvents,
      RateLimitError: () => RateLimitError,
      RequestManager: () => RequestManager,
      RequestMethod: () => RequestMethod,
      makeURLSearchParams: () => makeURLSearchParams2,
      parseResponse: () => parseResponse,
      version: () => version
    });
    module2.exports = __toCommonJS2(src_exports);
    var import_node_url = require("url");
    var import_node_process = __toESM2(require("process"));
    var import_v10 = require_v106();
    var import_undici = require_undici();
    var DefaultUserAgent = `DiscordBot (https://discord.js.org, 1.7.0)`;
    var DefaultUserAgentAppendix = import_node_process.default.release?.name === "node" ? `Node.js/${import_node_process.default.version}` : "";
    var DefaultRestOptions = {
      get agent() {
        return new import_undici.Agent({
          connect: {
            timeout: 3e4
          }
        });
      },
      api: "https://discord.com/api",
      authPrefix: "Bot",
      cdn: "https://cdn.discordapp.com",
      headers: {},
      invalidRequestWarningInterval: 0,
      globalRequestsPerSecond: 50,
      offset: 50,
      rejectOnRateLimit: null,
      retries: 3,
      timeout: 15e3,
      userAgentAppendix: DefaultUserAgentAppendix,
      version: import_v10.APIVersion,
      hashSweepInterval: 144e5,
      // 4 Hours
      hashLifetime: 864e5,
      // 24 Hours
      handlerSweepInterval: 36e5
      // 1 Hour
    };
    var RESTEvents = /* @__PURE__ */ ((RESTEvents2) => {
      RESTEvents2["Debug"] = "restDebug";
      RESTEvents2["HandlerSweep"] = "handlerSweep";
      RESTEvents2["HashSweep"] = "hashSweep";
      RESTEvents2["InvalidRequestWarning"] = "invalidRequestWarning";
      RESTEvents2["RateLimited"] = "rateLimited";
      RESTEvents2["Response"] = "response";
      return RESTEvents2;
    })(RESTEvents || {});
    var ALLOWED_EXTENSIONS = ["webp", "png", "jpg", "jpeg", "gif"];
    var ALLOWED_STICKER_EXTENSIONS = ["png", "json", "gif"];
    var ALLOWED_SIZES = [16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
    var OverwrittenMimeTypes = {
      // https://github.com/discordjs/discord.js/issues/8557
      "image/apng": "image/png"
    };
    var BurstHandlerMajorIdKey = "burst";
    var CDN = class {
      constructor(base = DefaultRestOptions.cdn) {
        this.base = base;
      }
      /**
       * Generates an app asset URL for a client's asset.
       *
       * @param clientId - The client id that has the asset
       * @param assetHash - The hash provided by Discord for this asset
       * @param options - Optional options for the asset
       */
      appAsset(clientId, assetHash, options) {
        return this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);
      }
      /**
       * Generates an app icon URL for a client's icon.
       *
       * @param clientId - The client id that has the icon
       * @param iconHash - The hash provided by Discord for this icon
       * @param options - Optional options for the icon
       */
      appIcon(clientId, iconHash, options) {
        return this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);
      }
      /**
       * Generates an avatar URL, e.g. for a user or a webhook.
       *
       * @param id - The id that has the icon
       * @param avatarHash - The hash provided by Discord for this avatar
       * @param options - Optional options for the avatar
       */
      avatar(id, avatarHash, options) {
        return this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);
      }
      /**
       * Generates a banner URL, e.g. for a user or a guild.
       *
       * @param id - The id that has the banner splash
       * @param bannerHash - The hash provided by Discord for this banner
       * @param options - Optional options for the banner
       */
      banner(id, bannerHash, options) {
        return this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);
      }
      /**
       * Generates an icon URL for a channel, e.g. a group DM.
       *
       * @param channelId - The channel id that has the icon
       * @param iconHash - The hash provided by Discord for this channel
       * @param options - Optional options for the icon
       */
      channelIcon(channelId, iconHash, options) {
        return this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);
      }
      /**
       * Generates the default avatar URL for a discriminator.
       *
       * @param discriminator - The discriminator modulo 5
       */
      defaultAvatar(discriminator) {
        return this.makeURL(`/embed/avatars/${discriminator}`, { extension: "png" });
      }
      /**
       * Generates a discovery splash URL for a guild's discovery splash.
       *
       * @param guildId - The guild id that has the discovery splash
       * @param splashHash - The hash provided by Discord for this splash
       * @param options - Optional options for the splash
       */
      discoverySplash(guildId, splashHash, options) {
        return this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);
      }
      /**
       * Generates an emoji's URL for an emoji.
       *
       * @param emojiId - The emoji id
       * @param extension - The extension of the emoji
       */
      emoji(emojiId, extension) {
        return this.makeURL(`/emojis/${emojiId}`, { extension });
      }
      /**
       * Generates a guild member avatar URL.
       *
       * @param guildId - The id of the guild
       * @param userId - The id of the user
       * @param avatarHash - The hash provided by Discord for this avatar
       * @param options - Optional options for the avatar
       */
      guildMemberAvatar(guildId, userId, avatarHash, options) {
        return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);
      }
      /**
       * Generates a guild member banner URL.
       *
       * @param guildId - The id of the guild
       * @param userId - The id of the user
       * @param bannerHash - The hash provided by Discord for this banner
       * @param options - Optional options for the banner
       */
      guildMemberBanner(guildId, userId, bannerHash, options) {
        return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banner`, bannerHash, options);
      }
      /**
       * Generates an icon URL, e.g. for a guild.
       *
       * @param id - The id that has the icon splash
       * @param iconHash - The hash provided by Discord for this icon
       * @param options - Optional options for the icon
       */
      icon(id, iconHash, options) {
        return this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);
      }
      /**
       * Generates a URL for the icon of a role
       *
       * @param roleId - The id of the role that has the icon
       * @param roleIconHash - The hash provided by Discord for this role icon
       * @param options - Optional options for the role icon
       */
      roleIcon(roleId, roleIconHash, options) {
        return this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);
      }
      /**
       * Generates a guild invite splash URL for a guild's invite splash.
       *
       * @param guildId - The guild id that has the invite splash
       * @param splashHash - The hash provided by Discord for this splash
       * @param options - Optional options for the splash
       */
      splash(guildId, splashHash, options) {
        return this.makeURL(`/splashes/${guildId}/${splashHash}`, options);
      }
      /**
       * Generates a sticker URL.
       *
       * @param stickerId - The sticker id
       * @param extension - The extension of the sticker
       * @privateRemarks
       * Stickers cannot have a `.webp` extension, so we default to a `.png`
       */
      sticker(stickerId, extension = "png") {
        return this.makeURL(`/stickers/${stickerId}`, { allowedExtensions: ALLOWED_STICKER_EXTENSIONS, extension });
      }
      /**
       * Generates a sticker pack banner URL.
       *
       * @param bannerId - The banner id
       * @param options - Optional options for the banner
       */
      stickerPackBanner(bannerId, options) {
        return this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);
      }
      /**
       * Generates a team icon URL for a team's icon.
       *
       * @param teamId - The team id that has the icon
       * @param iconHash - The hash provided by Discord for this icon
       * @param options - Optional options for the icon
       */
      teamIcon(teamId, iconHash, options) {
        return this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);
      }
      /**
       * Generates a cover image for a guild scheduled event.
       *
       * @param scheduledEventId - The scheduled event id
       * @param coverHash - The hash provided by discord for this cover image
       * @param options - Optional options for the cover image
       */
      guildScheduledEventCover(scheduledEventId, coverHash, options) {
        return this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);
      }
      /**
       * Constructs the URL for the resource, checking whether or not `hash` starts with `a_` if `dynamic` is set to `true`.
       *
       * @param route - The base cdn route
       * @param hash - The hash provided by Discord for this icon
       * @param options - Optional options for the link
       */
      dynamicMakeURL(route, hash, { forceStatic = false, ...options } = {}) {
        return this.makeURL(route, !forceStatic && hash.startsWith("a_") ? { ...options, extension: "gif" } : options);
      }
      /**
       * Constructs the URL for the resource
       *
       * @param route - The base cdn route
       * @param options - The extension/size options for the link
       */
      makeURL(route, { allowedExtensions = ALLOWED_EXTENSIONS, extension = "webp", size } = {}) {
        extension = String(extension).toLowerCase();
        if (!allowedExtensions.includes(extension)) {
          throw new RangeError(`Invalid extension provided: ${extension}
Must be one of: ${allowedExtensions.join(", ")}`);
        }
        if (size && !ALLOWED_SIZES.includes(size)) {
          throw new RangeError(`Invalid size provided: ${size}
Must be one of: ${ALLOWED_SIZES.join(", ")}`);
        }
        const url2 = new import_node_url.URL(`${this.base}${route}.${extension}`);
        if (size) {
          url2.searchParams.set("size", String(size));
        }
        return url2.toString();
      }
    };
    __name(CDN, "CDN");
    function isErrorGroupWrapper(error) {
      return Reflect.has(error, "_errors");
    }
    __name(isErrorGroupWrapper, "isErrorGroupWrapper");
    function isErrorResponse(error) {
      return typeof Reflect.get(error, "message") === "string";
    }
    __name(isErrorResponse, "isErrorResponse");
    var DiscordAPIError = class extends Error {
      /**
       * @param rawError - The error reported by Discord
       * @param code - The error code reported by Discord
       * @param status - The status code of the response
       * @param method - The method of the request that erred
       * @param url - The url of the request that erred
       * @param bodyData - The unparsed data for the request that errored
       */
      constructor(rawError, code, status, method, url2, bodyData) {
        super(DiscordAPIError.getMessage(rawError));
        this.rawError = rawError;
        this.code = code;
        this.status = status;
        this.method = method;
        this.url = url2;
        this.requestBody = { files: bodyData.files, json: bodyData.body };
      }
      requestBody;
      /**
       * The name of the error
       */
      get name() {
        return `${DiscordAPIError.name}[${this.code}]`;
      }
      static getMessage(error) {
        let flattened = "";
        if ("code" in error) {
          if (error.errors) {
            flattened = [...this.flattenDiscordError(error.errors)].join("\n");
          }
          return error.message && flattened ? `${error.message}
${flattened}` : error.message || flattened || "Unknown Error";
        }
        return error.error_description ?? "No Description";
      }
      static *flattenDiscordError(obj, key = "") {
        if (isErrorResponse(obj)) {
          return yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();
        }
        for (const [otherKey, val] of Object.entries(obj)) {
          const nextKey = otherKey.startsWith("_") ? key : key ? Number.isNaN(Number(otherKey)) ? `${key}.${otherKey}` : `${key}[${otherKey}]` : otherKey;
          if (typeof val === "string") {
            yield val;
          } else if (isErrorGroupWrapper(val)) {
            for (const error of val._errors) {
              yield* this.flattenDiscordError(error, nextKey);
            }
          } else {
            yield* this.flattenDiscordError(val, nextKey);
          }
        }
      }
    };
    __name(DiscordAPIError, "DiscordAPIError");
    var import_node_http = require("http");
    var HTTPError = class extends Error {
      /**
       * @param status - The status code of the response
       * @param method - The method of the request that erred
       * @param url - The url of the request that erred
       * @param bodyData - The unparsed data for the request that errored
       */
      constructor(status, method, url2, bodyData) {
        super(import_node_http.STATUS_CODES[status]);
        this.status = status;
        this.method = method;
        this.url = url2;
        this.requestBody = { files: bodyData.files, json: bodyData.body };
      }
      requestBody;
      name = HTTPError.name;
    };
    __name(HTTPError, "HTTPError");
    var RateLimitError = class extends Error {
      timeToReset;
      limit;
      method;
      hash;
      url;
      route;
      majorParameter;
      global;
      constructor({ timeToReset, limit, method, hash, url: url2, route, majorParameter, global: global2 }) {
        super();
        this.timeToReset = timeToReset;
        this.limit = limit;
        this.method = method;
        this.hash = hash;
        this.url = url2;
        this.route = route;
        this.majorParameter = majorParameter;
        this.global = global2;
      }
      /**
       * The name of the error
       */
      get name() {
        return `${RateLimitError.name}[${this.route}]`;
      }
    };
    __name(RateLimitError, "RateLimitError");
    var import_node_buffer22 = require("buffer");
    var import_node_events = require("events");
    var import_node_timers2 = require("timers");
    var import_collection = require_dist();
    var import_util4 = require_dist2();
    var import_snowflake = require_dist3();
    var import_undici4 = require_undici();
    var import_promises = require("timers/promises");
    var import_node_buffer4 = require("buffer");
    var import_node_url2 = require("url");
    var import_node_util = require("util");
    var import_undici2 = require_undici();
    function parseHeader(header) {
      if (header === void 0 || typeof header === "string") {
        return header;
      }
      return header.join(";");
    }
    __name(parseHeader, "parseHeader");
    function serializeSearchParam(value) {
      switch (typeof value) {
        case "string":
          return value;
        case "number":
        case "bigint":
        case "boolean":
          return value.toString();
        case "object":
          if (value === null)
            return null;
          if (value instanceof Date) {
            return Number.isNaN(value.getTime()) ? null : value.toISOString();
          }
          if (typeof value.toString === "function" && value.toString !== Object.prototype.toString)
            return value.toString();
          return null;
        default:
          return null;
      }
    }
    __name(serializeSearchParam, "serializeSearchParam");
    function makeURLSearchParams2(options) {
      const params = new import_node_url2.URLSearchParams();
      if (!options)
        return params;
      for (const [key, value] of Object.entries(options)) {
        const serialized = serializeSearchParam(value);
        if (serialized !== null)
          params.append(key, serialized);
      }
      return params;
    }
    __name(makeURLSearchParams2, "makeURLSearchParams");
    async function parseResponse(res) {
      const header = parseHeader(res.headers["content-type"]);
      if (header?.startsWith("application/json")) {
        return res.body.json();
      }
      return res.body.arrayBuffer();
    }
    __name(parseResponse, "parseResponse");
    function hasSublimit(bucketRoute, body, method) {
      if (bucketRoute === "/channels/:id") {
        if (typeof body !== "object" || body === null)
          return false;
        if (method !== "PATCH")
          return false;
        const castedBody = body;
        return ["name", "topic"].some((key) => Reflect.has(castedBody, key));
      }
      return true;
    }
    __name(hasSublimit, "hasSublimit");
    async function resolveBody(body) {
      if (body == null) {
        return null;
      } else if (typeof body === "string") {
        return body;
      } else if (import_node_util.types.isUint8Array(body)) {
        return body;
      } else if (import_node_util.types.isArrayBuffer(body)) {
        return new Uint8Array(body);
      } else if (body instanceof import_node_url2.URLSearchParams) {
        return body.toString();
      } else if (body instanceof DataView) {
        return new Uint8Array(body.buffer);
      } else if (body instanceof import_node_buffer4.Blob) {
        return new Uint8Array(await body.arrayBuffer());
      } else if (body instanceof import_undici2.FormData) {
        return body;
      } else if (body[Symbol.iterator]) {
        const chunks = [...body];
        const length = chunks.reduce((a, b) => a + b.length, 0);
        const uint8 = new Uint8Array(length);
        let lengthUsed = 0;
        return chunks.reduce((a, b) => {
          a.set(b, lengthUsed);
          lengthUsed += b.length;
          return a;
        }, uint8);
      } else if (body[Symbol.asyncIterator]) {
        const chunks = [];
        for await (const chunk of body) {
          chunks.push(chunk);
        }
        return import_node_buffer4.Buffer.concat(chunks);
      }
      throw new TypeError(`Unable to resolve body.`);
    }
    __name(resolveBody, "resolveBody");
    function shouldRetry(error) {
      if (error.name === "AbortError")
        return true;
      return "code" in error && error.code === "ECONNRESET" || error.message.includes("ECONNRESET");
    }
    __name(shouldRetry, "shouldRetry");
    async function onRateLimit(manager, rateLimitData) {
      const { options } = manager;
      if (!options.rejectOnRateLimit)
        return;
      const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
      if (shouldThrow) {
        throw new RateLimitError(rateLimitData);
      }
    }
    __name(onRateLimit, "onRateLimit");
    var import_node_timers = require("timers");
    var import_undici3 = require_undici();
    var invalidCount = 0;
    var invalidCountResetTime = null;
    function incrementInvalidCount(manager) {
      if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
        invalidCountResetTime = Date.now() + 1e3 * 60 * 10;
        invalidCount = 0;
      }
      invalidCount++;
      const emitInvalid = manager.options.invalidRequestWarningInterval > 0 && invalidCount % manager.options.invalidRequestWarningInterval === 0;
      if (emitInvalid) {
        manager.emit("invalidRequestWarning", {
          count: invalidCount,
          remainingTime: invalidCountResetTime - Date.now()
        });
      }
    }
    __name(incrementInvalidCount, "incrementInvalidCount");
    async function makeNetworkRequest(manager, routeId, url2, options, requestData, retries) {
      const controller = new AbortController();
      const timeout = (0, import_node_timers.setTimeout)(() => controller.abort(), manager.options.timeout).unref();
      if (requestData.signal) {
        const signal = requestData.signal;
        if (signal.aborted)
          controller.abort();
        else
          signal.addEventListener("abort", () => controller.abort());
      }
      let res;
      try {
        res = await (0, import_undici3.request)(url2, { ...options, signal: controller.signal });
      } catch (error) {
        if (!(error instanceof Error))
          throw error;
        if (shouldRetry(error) && retries !== manager.options.retries) {
          return null;
        }
        throw error;
      } finally {
        (0, import_node_timers.clearTimeout)(timeout);
      }
      if (manager.listenerCount(
        "response"
        /* Response */
      )) {
        manager.emit(
          "response",
          {
            method: options.method ?? "get",
            path: routeId.original,
            route: routeId.bucketRoute,
            options,
            data: requestData,
            retries
          },
          { ...res }
        );
      }
      return res;
    }
    __name(makeNetworkRequest, "makeNetworkRequest");
    async function handleErrors(manager, res, method, url2, requestData, retries) {
      const status = res.statusCode;
      if (status >= 500 && status < 600) {
        if (retries !== manager.options.retries) {
          return null;
        }
        throw new HTTPError(status, method, url2, requestData);
      } else {
        if (status >= 400 && status < 500) {
          if (status === 401 && requestData.auth) {
            manager.setToken(null);
          }
          const data = await parseResponse(res);
          throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url2, requestData);
        }
        return res;
      }
    }
    __name(handleErrors, "handleErrors");
    var BurstHandler = class {
      /**
       * @param manager - The request manager
       * @param hash - The hash that this RequestHandler handles
       * @param majorParameter - The major parameter for this handler
       */
      constructor(manager, hash, majorParameter) {
        this.manager = manager;
        this.hash = hash;
        this.majorParameter = majorParameter;
        this.id = `${hash}:${majorParameter}`;
      }
      /**
       * {@inheritdoc IHandler.id}
       */
      id;
      /**
       * {@inheritDoc IHandler.inactive}
       */
      inactive = false;
      /**
       * Emits a debug message
       *
       * @param message - The message to debug
       */
      debug(message) {
        this.manager.emit("restDebug", `[REST ${this.id}] ${message}`);
      }
      /**
       * {@inheritDoc IHandler.queueRequest}
       */
      async queueRequest(routeId, url2, options, requestData) {
        return this.runRequest(routeId, url2, options, requestData);
      }
      /**
       * The method that actually makes the request to the API, and updates info about the bucket accordingly
       *
       * @param routeId - The generalized API route with literal ids for major parameters
       * @param url - The fully resolved URL to make the request to
       * @param options - The fetch options needed to make the request
       * @param requestData - Extra data from the user's request needed for errors and additional processing
       * @param retries - The number of retries this request has already attempted (recursion)
       */
      async runRequest(routeId, url2, options, requestData, retries = 0) {
        const method = options.method ?? "get";
        const res = await makeNetworkRequest(this.manager, routeId, url2, options, requestData, retries);
        if (res === null) {
          return this.runRequest(routeId, url2, options, requestData, ++retries);
        }
        const status = res.statusCode;
        let retryAfter = 0;
        const retry = parseHeader(res.headers["retry-after"]);
        if (retry)
          retryAfter = Number(retry) * 1e3 + this.manager.options.offset;
        if (status === 401 || status === 403 || status === 429) {
          incrementInvalidCount(this.manager);
        }
        if (status >= 200 && status < 300) {
          return res;
        } else if (status === 429) {
          const isGlobal = res.headers["x-ratelimit-global"] !== void 0;
          await onRateLimit(this.manager, {
            timeToReset: retryAfter,
            limit: Number.POSITIVE_INFINITY,
            method,
            hash: this.hash,
            url: url2,
            route: routeId.bucketRoute,
            majorParameter: this.majorParameter,
            global: isGlobal
          });
          this.debug(
            [
              "Encountered unexpected 429 rate limit",
              `  Global         : ${isGlobal}`,
              `  Method         : ${method}`,
              `  URL            : ${url2}`,
              `  Bucket         : ${routeId.bucketRoute}`,
              `  Major parameter: ${routeId.majorParameter}`,
              `  Hash           : ${this.hash}`,
              `  Limit          : ${Number.POSITIVE_INFINITY}`,
              `  Retry After    : ${retryAfter}ms`,
              `  Sublimit       : None`
            ].join("\n")
          );
          await (0, import_promises.setTimeout)(retryAfter);
          return this.runRequest(routeId, url2, options, requestData, retries);
        } else {
          const handled = await handleErrors(this.manager, res, method, url2, requestData, retries);
          if (handled === null) {
            return this.runRequest(routeId, url2, options, requestData, ++retries);
          }
          return handled;
        }
      }
    };
    __name(BurstHandler, "BurstHandler");
    var import_promises2 = require("timers/promises");
    var import_async_queue = require_dist4();
    var SequentialHandler = class {
      /**
       * @param manager - The request manager
       * @param hash - The hash that this RequestHandler handles
       * @param majorParameter - The major parameter for this handler
       */
      constructor(manager, hash, majorParameter) {
        this.manager = manager;
        this.hash = hash;
        this.majorParameter = majorParameter;
        this.id = `${hash}:${majorParameter}`;
      }
      /**
       * {@inheritDoc IHandler.id}
       */
      id;
      /**
       * The time this rate limit bucket will reset
       */
      reset = -1;
      /**
       * The remaining requests that can be made before we are rate limited
       */
      remaining = 1;
      /**
       * The total number of requests that can be made before we are rate limited
       */
      limit = Number.POSITIVE_INFINITY;
      /**
       * The interface used to sequence async requests sequentially
       */
      #asyncQueue = new import_async_queue.AsyncQueue();
      /**
       * The interface used to sequence sublimited async requests sequentially
       */
      #sublimitedQueue = null;
      /**
       * A promise wrapper for when the sublimited queue is finished being processed or null when not being processed
       */
      #sublimitPromise = null;
      /**
       * Whether the sublimit queue needs to be shifted in the finally block
       */
      #shiftSublimit = false;
      /**
       * {@inheritDoc IHandler.inactive}
       */
      get inactive() {
        return this.#asyncQueue.remaining === 0 && (this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) && !this.limited;
      }
      /**
       * If the rate limit bucket is currently limited by the global limit
       */
      get globalLimited() {
        return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;
      }
      /**
       * If the rate limit bucket is currently limited by its limit
       */
      get localLimited() {
        return this.remaining <= 0 && Date.now() < this.reset;
      }
      /**
       * If the rate limit bucket is currently limited
       */
      get limited() {
        return this.globalLimited || this.localLimited;
      }
      /**
       * The time until queued requests can continue
       */
      get timeToReset() {
        return this.reset + this.manager.options.offset - Date.now();
      }
      /**
       * Emits a debug message
       *
       * @param message - The message to debug
       */
      debug(message) {
        this.manager.emit("restDebug", `[REST ${this.id}] ${message}`);
      }
      /**
       * Delay all requests for the specified amount of time, handling global rate limits
       *
       * @param time - The amount of time to delay all requests for
       */
      async globalDelayFor(time) {
        await (0, import_promises2.setTimeout)(time);
        this.manager.globalDelay = null;
      }
      /**
       * {@inheritDoc IHandler.queueRequest}
       */
      async queueRequest(routeId, url2, options, requestData) {
        let queue = this.#asyncQueue;
        let queueType = 0;
        if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
          queue = this.#sublimitedQueue;
          queueType = 1;
        }
        await queue.wait({ signal: requestData.signal });
        if (queueType === 0) {
          if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
            queue = this.#sublimitedQueue;
            const wait = queue.wait();
            this.#asyncQueue.shift();
            await wait;
          } else if (this.#sublimitPromise) {
            await this.#sublimitPromise.promise;
          }
        }
        try {
          return await this.runRequest(routeId, url2, options, requestData);
        } finally {
          queue.shift();
          if (this.#shiftSublimit) {
            this.#shiftSublimit = false;
            this.#sublimitedQueue?.shift();
          }
          if (this.#sublimitedQueue?.remaining === 0) {
            this.#sublimitPromise?.resolve();
            this.#sublimitedQueue = null;
          }
        }
      }
      /**
       * The method that actually makes the request to the api, and updates info about the bucket accordingly
       *
       * @param routeId - The generalized api route with literal ids for major parameters
       * @param url - The fully resolved url to make the request to
       * @param options - The fetch options needed to make the request
       * @param requestData - Extra data from the user's request needed for errors and additional processing
       * @param retries - The number of retries this request has already attempted (recursion)
       */
      async runRequest(routeId, url2, options, requestData, retries = 0) {
        while (this.limited) {
          const isGlobal = this.globalLimited;
          let limit2;
          let timeout;
          let delay;
          if (isGlobal) {
            limit2 = this.manager.options.globalRequestsPerSecond;
            timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
            if (!this.manager.globalDelay) {
              this.manager.globalDelay = this.globalDelayFor(timeout);
            }
            delay = this.manager.globalDelay;
          } else {
            limit2 = this.limit;
            timeout = this.timeToReset;
            delay = (0, import_promises2.setTimeout)(timeout);
          }
          const rateLimitData = {
            timeToReset: timeout,
            limit: limit2,
            method: options.method ?? "get",
            hash: this.hash,
            url: url2,
            route: routeId.bucketRoute,
            majorParameter: this.majorParameter,
            global: isGlobal
          };
          this.manager.emit("rateLimited", rateLimitData);
          await onRateLimit(this.manager, rateLimitData);
          if (isGlobal) {
            this.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);
          } else {
            this.debug(`Waiting ${timeout}ms for rate limit to pass`);
          }
          await delay;
        }
        if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {
          this.manager.globalReset = Date.now() + 1e3;
          this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
        }
        this.manager.globalRemaining--;
        const method = options.method ?? "get";
        const res = await makeNetworkRequest(this.manager, routeId, url2, options, requestData, retries);
        if (res === null) {
          return this.runRequest(routeId, url2, options, requestData, ++retries);
        }
        const status = res.statusCode;
        let retryAfter = 0;
        const limit = parseHeader(res.headers["x-ratelimit-limit"]);
        const remaining = parseHeader(res.headers["x-ratelimit-remaining"]);
        const reset = parseHeader(res.headers["x-ratelimit-reset-after"]);
        const hash = parseHeader(res.headers["x-ratelimit-bucket"]);
        const retry = parseHeader(res.headers["retry-after"]);
        this.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;
        this.remaining = remaining ? Number(remaining) : 1;
        this.reset = reset ? Number(reset) * 1e3 + Date.now() + this.manager.options.offset : Date.now();
        if (retry)
          retryAfter = Number(retry) * 1e3 + this.manager.options.offset;
        if (hash && hash !== this.hash) {
          this.debug(["Received bucket hash update", `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join("\n"));
          this.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });
        } else if (hash) {
          const hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);
          if (hashData) {
            hashData.lastAccess = Date.now();
          }
        }
        let sublimitTimeout = null;
        if (retryAfter > 0) {
          if (res.headers["x-ratelimit-global"] !== void 0) {
            this.manager.globalRemaining = 0;
            this.manager.globalReset = Date.now() + retryAfter;
          } else if (!this.localLimited) {
            sublimitTimeout = retryAfter;
          }
        }
        if (status === 401 || status === 403 || status === 429) {
          incrementInvalidCount(this.manager);
        }
        if (status >= 200 && status < 300) {
          return res;
        } else if (status === 429) {
          const isGlobal = this.globalLimited;
          let limit2;
          let timeout;
          if (isGlobal) {
            limit2 = this.manager.options.globalRequestsPerSecond;
            timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
          } else {
            limit2 = this.limit;
            timeout = this.timeToReset;
          }
          await onRateLimit(this.manager, {
            timeToReset: timeout,
            limit: limit2,
            method,
            hash: this.hash,
            url: url2,
            route: routeId.bucketRoute,
            majorParameter: this.majorParameter,
            global: isGlobal
          });
          this.debug(
            [
              "Encountered unexpected 429 rate limit",
              `  Global         : ${isGlobal.toString()}`,
              `  Method         : ${method}`,
              `  URL            : ${url2}`,
              `  Bucket         : ${routeId.bucketRoute}`,
              `  Major parameter: ${routeId.majorParameter}`,
              `  Hash           : ${this.hash}`,
              `  Limit          : ${limit2}`,
              `  Retry After    : ${retryAfter}ms`,
              `  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : "None"}`
            ].join("\n")
          );
          if (sublimitTimeout) {
            const firstSublimit = !this.#sublimitedQueue;
            if (firstSublimit) {
              this.#sublimitedQueue = new import_async_queue.AsyncQueue();
              void this.#sublimitedQueue.wait();
              this.#asyncQueue.shift();
            }
            this.#sublimitPromise?.resolve();
            this.#sublimitPromise = null;
            await (0, import_promises2.setTimeout)(sublimitTimeout);
            let resolve;
            const promise = new Promise((res2) => resolve = res2);
            this.#sublimitPromise = { promise, resolve };
            if (firstSublimit) {
              await this.#asyncQueue.wait();
              this.#shiftSublimit = true;
            }
          }
          return this.runRequest(routeId, url2, options, requestData, retries);
        } else {
          const handled = await handleErrors(this.manager, res, method, url2, requestData, retries);
          if (handled === null) {
            return this.runRequest(routeId, url2, options, requestData, ++retries);
          }
          return handled;
        }
      }
    };
    __name(SequentialHandler, "SequentialHandler");
    var getFileType = (0, import_util4.lazy)(async () => Promise.resolve().then(() => (init_file_type(), file_type_exports)));
    var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
      RequestMethod2["Delete"] = "DELETE";
      RequestMethod2["Get"] = "GET";
      RequestMethod2["Patch"] = "PATCH";
      RequestMethod2["Post"] = "POST";
      RequestMethod2["Put"] = "PUT";
      return RequestMethod2;
    })(RequestMethod || {});
    var RequestManager = class extends import_node_events.EventEmitter {
      /**
       * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
       * performed by this manager.
       */
      agent = null;
      /**
       * The number of requests remaining in the global bucket
       */
      globalRemaining;
      /**
       * The promise used to wait out the global rate limit
       */
      globalDelay = null;
      /**
       * The timestamp at which the global bucket resets
       */
      globalReset = -1;
      /**
       * API bucket hashes that are cached from provided routes
       */
      hashes = new import_collection.Collection();
      /**
       * Request handlers created from the bucket hash and the major parameters
       */
      handlers = new import_collection.Collection();
      #token = null;
      hashTimer;
      handlerTimer;
      options;
      constructor(options) {
        super();
        this.options = { ...DefaultRestOptions, ...options };
        this.options.offset = Math.max(0, this.options.offset);
        this.globalRemaining = this.options.globalRequestsPerSecond;
        this.agent = options.agent ?? null;
        this.setupSweepers();
      }
      setupSweepers() {
        const validateMaxInterval = /* @__PURE__ */ __name((interval) => {
          if (interval > 144e5) {
            throw new Error("Cannot set an interval greater than 4 hours");
          }
        }, "validateMaxInterval");
        if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {
          validateMaxInterval(this.options.hashSweepInterval);
          this.hashTimer = (0, import_node_timers2.setInterval)(() => {
            const sweptHashes = new import_collection.Collection();
            const currentDate = Date.now();
            this.hashes.sweep((val, key) => {
              if (val.lastAccess === -1)
                return false;
              const shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;
              if (shouldSweep) {
                sweptHashes.set(key, val);
              }
              this.emit("restDebug", `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);
              return shouldSweep;
            });
            this.emit("hashSweep", sweptHashes);
          }, this.options.hashSweepInterval).unref();
        }
        if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
          validateMaxInterval(this.options.handlerSweepInterval);
          this.handlerTimer = (0, import_node_timers2.setInterval)(() => {
            const sweptHandlers = new import_collection.Collection();
            this.handlers.sweep((val, key) => {
              const { inactive } = val;
              if (inactive) {
                sweptHandlers.set(key, val);
              }
              this.emit("restDebug", `Handler ${val.id} for ${key} swept due to being inactive`);
              return inactive;
            });
            this.emit("handlerSweep", sweptHandlers);
          }, this.options.handlerSweepInterval).unref();
        }
      }
      /**
       * Sets the default agent to use for requests performed by this manager
       *
       * @param agent - The agent to use
       */
      setAgent(agent) {
        this.agent = agent;
        return this;
      }
      /**
       * Sets the authorization token that should be used for requests
       *
       * @param token - The authorization token to use
       */
      setToken(token) {
        this.#token = token;
        return this;
      }
      /**
       * Queues a request to be sent
       *
       * @param request - All the information needed to make a request
       * @returns The response from the api request
       */
      async queueRequest(request2) {
        const routeId = RequestManager.generateRouteData(request2.fullRoute, request2.method);
        const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
          value: `Global(${request2.method}:${routeId.bucketRoute})`,
          lastAccess: -1
        };
        const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
        const { url: url2, fetchOptions } = await this.resolveRequest(request2);
        return handler.queueRequest(routeId, url2, fetchOptions, {
          body: request2.body,
          files: request2.files,
          auth: request2.auth !== false,
          signal: request2.signal
        });
      }
      /**
       * Creates a new rate limit handler from a hash, based on the hash and the major parameter
       *
       * @param hash - The hash for the route
       * @param majorParameter - The major parameter for this handler
       * @internal
       */
      createHandler(hash, majorParameter) {
        const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);
        this.handlers.set(queue.id, queue);
        return queue;
      }
      /**
       * Formats the request data to a usable format for fetch
       *
       * @param request - The request data
       */
      async resolveRequest(request2) {
        const { options } = this;
        let query = "";
        if (request2.query) {
          const resolvedQuery = request2.query.toString();
          if (resolvedQuery !== "") {
            query = `?${resolvedQuery}`;
          }
        }
        const headers = {
          ...this.options.headers,
          "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
        };
        if (request2.auth !== false) {
          if (!this.#token) {
            throw new Error("Expected token to be set for this request, but none was present");
          }
          headers.Authorization = `${request2.authPrefix ?? this.options.authPrefix} ${this.#token}`;
        }
        if (request2.reason?.length) {
          headers["X-Audit-Log-Reason"] = encodeURIComponent(request2.reason);
        }
        const url2 = `${options.api}${request2.versioned === false ? "" : `/v${options.version}`}${request2.fullRoute}${query}`;
        let finalBody;
        let additionalHeaders = {};
        if (request2.files?.length) {
          const formData = new import_undici4.FormData();
          for (const [index, file] of request2.files.entries()) {
            const fileKey = file.key ?? `files[${index}]`;
            if (import_node_buffer22.Buffer.isBuffer(file.data)) {
              const { fileTypeFromBuffer: fileTypeFromBuffer2 } = await getFileType();
              let contentType = file.contentType;
              if (!contentType) {
                const parsedType = (await fileTypeFromBuffer2(file.data))?.mime;
                if (parsedType) {
                  contentType = OverwrittenMimeTypes[parsedType] ?? parsedType;
                }
              }
              formData.append(fileKey, new import_node_buffer22.Blob([file.data], { type: contentType }), file.name);
            } else {
              formData.append(fileKey, new import_node_buffer22.Blob([`${file.data}`], { type: file.contentType }), file.name);
            }
          }
          if (request2.body != null) {
            if (request2.appendToFormData) {
              for (const [key, value] of Object.entries(request2.body)) {
                formData.append(key, value);
              }
            } else {
              formData.append("payload_json", JSON.stringify(request2.body));
            }
          }
          finalBody = formData;
        } else if (request2.body != null) {
          if (request2.passThroughBody) {
            finalBody = request2.body;
          } else {
            finalBody = JSON.stringify(request2.body);
            additionalHeaders = { "Content-Type": "application/json" };
          }
        }
        finalBody = await resolveBody(finalBody);
        const fetchOptions = {
          headers: { ...request2.headers, ...additionalHeaders, ...headers },
          method: request2.method.toUpperCase()
        };
        if (finalBody !== void 0) {
          fetchOptions.body = finalBody;
        }
        fetchOptions.dispatcher = request2.dispatcher ?? this.agent ?? void 0;
        return { url: url2, fetchOptions };
      }
      /**
       * Stops the hash sweeping interval
       */
      clearHashSweeper() {
        (0, import_node_timers2.clearInterval)(this.hashTimer);
      }
      /**
       * Stops the request handler sweeping interval
       */
      clearHandlerSweeper() {
        (0, import_node_timers2.clearInterval)(this.handlerTimer);
      }
      /**
       * Generates route data for an endpoint:method
       *
       * @param endpoint - The raw endpoint to generalize
       * @param method - The HTTP method this endpoint is called without
       * @internal
       */
      static generateRouteData(endpoint, method) {
        if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
          return {
            majorParameter: BurstHandlerMajorIdKey,
            bucketRoute: "/interactions/:id/:token/callback",
            original: endpoint
          };
        }
        const majorIdMatch = /^\/(?:channels|guilds|webhooks)\/(\d{17,19})/.exec(endpoint);
        const majorId = majorIdMatch?.[1] ?? "global";
        const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction");
        let exceptions = "";
        if (method === "DELETE" && baseRoute === "/channels/:id/messages/:id") {
          const id = /\d{17,19}$/.exec(endpoint)[0];
          const timestamp2 = import_snowflake.DiscordSnowflake.timestampFrom(id);
          if (Date.now() - timestamp2 > 1e3 * 60 * 60 * 24 * 14) {
            exceptions += "/Delete Old Message";
          }
        }
        return {
          majorParameter: majorId,
          bucketRoute: baseRoute + exceptions,
          original: endpoint
        };
      }
    };
    __name(RequestManager, "RequestManager");
    var import_node_events2 = require("events");
    var REST = class extends import_node_events2.EventEmitter {
      cdn;
      requestManager;
      constructor(options = {}) {
        super();
        this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);
        this.requestManager = new RequestManager(options).on("restDebug", this.emit.bind(
          this,
          "restDebug"
          /* Debug */
        )).on("rateLimited", this.emit.bind(
          this,
          "rateLimited"
          /* RateLimited */
        )).on("invalidRequestWarning", this.emit.bind(
          this,
          "invalidRequestWarning"
          /* InvalidRequestWarning */
        )).on("hashSweep", this.emit.bind(
          this,
          "hashSweep"
          /* HashSweep */
        ));
        this.on("newListener", (name, listener) => {
          if (name === "response")
            this.requestManager.on(name, listener);
        });
        this.on("removeListener", (name, listener) => {
          if (name === "response")
            this.requestManager.off(name, listener);
        });
      }
      /**
       * Gets the agent set for this instance
       */
      getAgent() {
        return this.requestManager.agent;
      }
      /**
       * Sets the default agent to use for requests performed by this instance
       *
       * @param agent - Sets the agent to use
       */
      setAgent(agent) {
        this.requestManager.setAgent(agent);
        return this;
      }
      /**
       * Sets the authorization token that should be used for requests
       *
       * @param token - The authorization token to use
       */
      setToken(token) {
        this.requestManager.setToken(token);
        return this;
      }
      /**
       * Runs a get request from the api
       *
       * @param fullRoute - The full route to query
       * @param options - Optional request options
       */
      async get(fullRoute, options = {}) {
        return this.request({
          ...options,
          fullRoute,
          method: "GET"
          /* Get */
        });
      }
      /**
       * Runs a delete request from the api
       *
       * @param fullRoute - The full route to query
       * @param options - Optional request options
       */
      async delete(fullRoute, options = {}) {
        return this.request({
          ...options,
          fullRoute,
          method: "DELETE"
          /* Delete */
        });
      }
      /**
       * Runs a post request from the api
       *
       * @param fullRoute - The full route to query
       * @param options - Optional request options
       */
      async post(fullRoute, options = {}) {
        return this.request({
          ...options,
          fullRoute,
          method: "POST"
          /* Post */
        });
      }
      /**
       * Runs a put request from the api
       *
       * @param fullRoute - The full route to query
       * @param options - Optional request options
       */
      async put(fullRoute, options = {}) {
        return this.request({
          ...options,
          fullRoute,
          method: "PUT"
          /* Put */
        });
      }
      /**
       * Runs a patch request from the api
       *
       * @param fullRoute - The full route to query
       * @param options - Optional request options
       */
      async patch(fullRoute, options = {}) {
        return this.request({
          ...options,
          fullRoute,
          method: "PATCH"
          /* Patch */
        });
      }
      /**
       * Runs a request from the api
       *
       * @param options - Request options
       */
      async request(options) {
        const response = await this.raw(options);
        return parseResponse(response);
      }
      /**
       * Runs a request from the API, yielding the raw Response object
       *
       * @param options - Request options
       */
      async raw(options) {
        return this.requestManager.queueRequest(options);
      }
    };
    __name(REST, "REST");
    var version = "1.7.0";
  }
});

// node_modules/discord.js/src/errors/ErrorCodes.js
var require_ErrorCodes = __commonJS({
  "node_modules/discord.js/src/errors/ErrorCodes.js"(exports2, module2) {
    "use strict";
    var keys = [
      "ClientInvalidOption",
      "ClientInvalidProvidedShards",
      "ClientMissingIntents",
      "ClientNotReady",
      "TokenInvalid",
      "TokenMissing",
      "ApplicationCommandPermissionsTokenMissing",
      "WSCloseRequested",
      "WSConnectionExists",
      "WSNotOpen",
      "ManagerDestroyed",
      "BitFieldInvalid",
      "ShardingInvalid",
      "ShardingRequired",
      "InvalidIntents",
      "DisallowedIntents",
      "ShardingNoShards",
      "ShardingInProcess",
      "ShardingInvalidEvalBroadcast",
      "ShardingShardNotFound",
      "ShardingAlreadySpawned",
      "ShardingProcessExists",
      "ShardingWorkerExists",
      "ShardingReadyTimeout",
      "ShardingReadyDisconnected",
      "ShardingReadyDied",
      "ShardingNoChildExists",
      "ShardingShardMiscalculation",
      "ColorRange",
      "ColorConvert",
      "InviteOptionsMissingChannel",
      "ButtonLabel",
      "ButtonURL",
      "ButtonCustomId",
      "SelectMenuCustomId",
      "SelectMenuPlaceholder",
      "SelectOptionLabel",
      "SelectOptionValue",
      "SelectOptionDescription",
      "InteractionCollectorError",
      "FileNotFound",
      "UserBannerNotFetched",
      "UserNoDMChannel",
      "VoiceNotStageChannel",
      "VoiceStateNotOwn",
      "VoiceStateInvalidType",
      "ReqResourceType",
      "ImageFormat",
      "ImageSize",
      "MessageBulkDeleteType",
      "MessageNonceType",
      "MessageContentType",
      "SplitMaxLen",
      "BanResolveId",
      "FetchBanResolveId",
      "PruneDaysType",
      "GuildChannelResolve",
      "GuildVoiceChannelResolve",
      "GuildChannelOrphan",
      "GuildChannelUnowned",
      "GuildOwned",
      "GuildMembersTimeout",
      "GuildUncachedMe",
      "ChannelNotCached",
      "StageChannelResolve",
      "GuildScheduledEventResolve",
      "FetchOwnerId",
      "InvalidType",
      "InvalidElement",
      "MessageThreadParent",
      "MessageExistingThread",
      "ThreadInvitableType",
      "WebhookMessage",
      "WebhookTokenUnavailable",
      "WebhookURLInvalid",
      "WebhookApplication",
      "MessageReferenceMissing",
      "EmojiType",
      "EmojiManaged",
      "MissingManageEmojisAndStickersPermission",
      "NotGuildSticker",
      "ReactionResolveUser",
      "VanityURL",
      "InviteResolveCode",
      "InviteNotFound",
      "DeleteGroupDMChannel",
      "FetchGroupDMChannel",
      "MemberFetchNonceLength",
      "GlobalCommandPermissions",
      "GuildUncachedEntityResolve",
      "InteractionAlreadyReplied",
      "InteractionNotReplied",
      "InteractionEphemeralReplied",
      "CommandInteractionOptionNotFound",
      "CommandInteractionOptionType",
      "CommandInteractionOptionEmpty",
      "CommandInteractionOptionNoSubcommand",
      "CommandInteractionOptionNoSubcommandGroup",
      "CommandInteractionOptionInvalidChannelType",
      "AutocompleteInteractionOptionNoFocusedOption",
      "ModalSubmitInteractionFieldNotFound",
      "ModalSubmitInteractionFieldType",
      "InvalidMissingScopes",
      "NotImplemented",
      "SweepFilterReturn",
      "GuildForumMessageRequired"
    ];
    module2.exports = Object.fromEntries(keys.map((key) => [key, key]));
  }
});

// node_modules/discord.js/src/errors/Messages.js
var require_Messages = __commonJS({
  "node_modules/discord.js/src/errors/Messages.js"(exports2, module2) {
    "use strict";
    var DjsErrorCodes = require_ErrorCodes();
    var Messages = {
      [DjsErrorCodes.ClientInvalidOption]: (prop, must) => `The ${prop} option must be ${must}`,
      [DjsErrorCodes.ClientInvalidProvidedShards]: "None of the provided shards were valid.",
      [DjsErrorCodes.ClientMissingIntents]: "Valid intents must be provided for the Client.",
      [DjsErrorCodes.ClientNotReady]: (action) => `The client needs to be logged in to ${action}.`,
      [DjsErrorCodes.TokenInvalid]: "An invalid token was provided.",
      [DjsErrorCodes.TokenMissing]: "Request to use token, but token was unavailable to the client.",
      [DjsErrorCodes.ApplicationCommandPermissionsTokenMissing]: "Editing application command permissions requires an OAuth2 bearer token, but none was provided.",
      [DjsErrorCodes.WSCloseRequested]: "WebSocket closed due to user request.",
      [DjsErrorCodes.WSConnectionExists]: "There is already an existing WebSocket connection.",
      [DjsErrorCodes.WSNotOpen]: (data = "data") => `WebSocket not open to send ${data}`,
      [DjsErrorCodes.ManagerDestroyed]: "Manager was destroyed.",
      [DjsErrorCodes.BitFieldInvalid]: (bit) => `Invalid bitfield flag or number: ${bit}.`,
      [DjsErrorCodes.ShardingInvalid]: "Invalid shard settings were provided.",
      [DjsErrorCodes.ShardingRequired]: "This session would have handled too many guilds - Sharding is required.",
      [DjsErrorCodes.InvalidIntents]: "Invalid intent provided for WebSocket intents.",
      [DjsErrorCodes.DisallowedIntents]: "Privileged intent provided is not enabled or whitelisted.",
      [DjsErrorCodes.ShardingNoShards]: "No shards have been spawned.",
      [DjsErrorCodes.ShardingInProcess]: "Shards are still being spawned.",
      [DjsErrorCodes.ShardingInvalidEvalBroadcast]: "Script to evaluate must be a function",
      [DjsErrorCodes.ShardingShardNotFound]: (id) => `Shard ${id} could not be found.`,
      [DjsErrorCodes.ShardingAlreadySpawned]: (count) => `Already spawned ${count} shards.`,
      [DjsErrorCodes.ShardingProcessExists]: (id) => `Shard ${id} already has an active process.`,
      [DjsErrorCodes.ShardingWorkerExists]: (id) => `Shard ${id} already has an active worker.`,
      [DjsErrorCodes.ShardingReadyTimeout]: (id) => `Shard ${id}'s Client took too long to become ready.`,
      [DjsErrorCodes.ShardingReadyDisconnected]: (id) => `Shard ${id}'s Client disconnected before becoming ready.`,
      [DjsErrorCodes.ShardingReadyDied]: (id) => `Shard ${id}'s process exited before its Client became ready.`,
      [DjsErrorCodes.ShardingNoChildExists]: (id) => `Shard ${id} has no active process or worker.`,
      [DjsErrorCodes.ShardingShardMiscalculation]: (shard, guild, count) => `Calculated invalid shard ${shard} for guild ${guild} with ${count} shards.`,
      [DjsErrorCodes.ColorRange]: "Color must be within the range 0 - 16777215 (0xFFFFFF).",
      [DjsErrorCodes.ColorConvert]: "Unable to convert color to a number.",
      [DjsErrorCodes.InviteOptionsMissingChannel]: "A valid guild channel must be provided when GuildScheduledEvent is EXTERNAL.",
      [DjsErrorCodes.ButtonLabel]: "MessageButton label must be a string",
      [DjsErrorCodes.ButtonURL]: "MessageButton URL must be a string",
      [DjsErrorCodes.ButtonCustomId]: "MessageButton customId must be a string",
      [DjsErrorCodes.SelectMenuCustomId]: "MessageSelectMenu customId must be a string",
      [DjsErrorCodes.SelectMenuPlaceholder]: "MessageSelectMenu placeholder must be a string",
      [DjsErrorCodes.SelectOptionLabel]: "MessageSelectOption label must be a string",
      [DjsErrorCodes.SelectOptionValue]: "MessageSelectOption value must be a string",
      [DjsErrorCodes.SelectOptionDescription]: "MessageSelectOption description must be a string",
      [DjsErrorCodes.InteractionCollectorError]: (reason) => `Collector received no interactions before ending with reason: ${reason}`,
      [DjsErrorCodes.FileNotFound]: (file) => `File could not be found: ${file}`,
      [DjsErrorCodes.UserBannerNotFetched]: "You must fetch this user's banner before trying to generate its URL!",
      [DjsErrorCodes.UserNoDMChannel]: "No DM Channel exists!",
      [DjsErrorCodes.VoiceNotStageChannel]: "You are only allowed to do this in stage channels.",
      [DjsErrorCodes.VoiceStateNotOwn]: "You cannot self-deafen/mute/request to speak on VoiceStates that do not belong to the ClientUser.",
      [DjsErrorCodes.VoiceStateInvalidType]: (name) => `${name} must be a boolean.`,
      [DjsErrorCodes.ReqResourceType]: "The resource must be a string, Buffer or a valid file stream.",
      [DjsErrorCodes.ImageFormat]: (format2) => `Invalid image format: ${format2}`,
      [DjsErrorCodes.ImageSize]: (size) => `Invalid image size: ${size}`,
      [DjsErrorCodes.MessageBulkDeleteType]: "The messages must be an Array, Collection, or number.",
      [DjsErrorCodes.MessageNonceType]: "Message nonce must be an integer or a string.",
      [DjsErrorCodes.MessageContentType]: "Message content must be a string.",
      [DjsErrorCodes.SplitMaxLen]: "Chunk exceeds the max length and contains no split characters.",
      [DjsErrorCodes.BanResolveId]: (ban = false) => `Couldn't resolve the user id to ${ban ? "ban" : "unban"}.`,
      [DjsErrorCodes.FetchBanResolveId]: "Couldn't resolve the user id to fetch the ban.",
      [DjsErrorCodes.PruneDaysType]: "Days must be a number",
      [DjsErrorCodes.GuildChannelResolve]: "Could not resolve channel to a guild channel.",
      [DjsErrorCodes.GuildVoiceChannelResolve]: "Could not resolve channel to a guild voice channel.",
      [DjsErrorCodes.GuildChannelOrphan]: "Could not find a parent to this guild channel.",
      [DjsErrorCodes.GuildChannelUnowned]: "The fetched channel does not belong to this manager's guild.",
      [DjsErrorCodes.GuildOwned]: "Guild is owned by the client.",
      [DjsErrorCodes.GuildMembersTimeout]: "Members didn't arrive in time.",
      [DjsErrorCodes.GuildUncachedMe]: "The client user as a member of this guild is uncached.",
      [DjsErrorCodes.ChannelNotCached]: "Could not find the channel where this message came from in the cache!",
      [DjsErrorCodes.StageChannelResolve]: "Could not resolve channel to a stage channel.",
      [DjsErrorCodes.GuildScheduledEventResolve]: "Could not resolve the guild scheduled event.",
      [DjsErrorCodes.FetchOwnerId]: "Couldn't resolve the guild ownerId to fetch the member.",
      [DjsErrorCodes.InvalidType]: (name, expected, an = false) => `Supplied ${name} is not a${an ? "n" : ""} ${expected}.`,
      [DjsErrorCodes.InvalidElement]: (type, name, elem) => `Supplied ${type} ${name} includes an invalid element: ${elem}`,
      [DjsErrorCodes.MessageThreadParent]: "The message was not sent in a guild text or news channel",
      [DjsErrorCodes.MessageExistingThread]: "The message already has a thread",
      [DjsErrorCodes.ThreadInvitableType]: (type) => `Invitable cannot be edited on ${type}`,
      [DjsErrorCodes.WebhookMessage]: "The message was not sent by a webhook.",
      [DjsErrorCodes.WebhookTokenUnavailable]: "This action requires a webhook token, but none is available.",
      [DjsErrorCodes.WebhookURLInvalid]: "The provided webhook URL is not valid.",
      [DjsErrorCodes.WebhookApplication]: "This message webhook belongs to an application and cannot be fetched.",
      [DjsErrorCodes.MessageReferenceMissing]: "The message does not reference another message",
      [DjsErrorCodes.EmojiType]: "Emoji must be a string or GuildEmoji/ReactionEmoji",
      [DjsErrorCodes.EmojiManaged]: "Emoji is managed and has no Author.",
      [DjsErrorCodes.MissingManageEmojisAndStickersPermission]: (guild) => `Client must have Manage Emojis and Stickers permission in guild ${guild} to see emoji authors.`,
      [DjsErrorCodes.NotGuildSticker]: "Sticker is a standard (non-guild) sticker and has no author.",
      [DjsErrorCodes.ReactionResolveUser]: "Couldn't resolve the user id to remove from the reaction.",
      [DjsErrorCodes.VanityURL]: "This guild does not have the vanity URL feature enabled.",
      [DjsErrorCodes.InviteResolveCode]: "Could not resolve the code to fetch the invite.",
      [DjsErrorCodes.InviteNotFound]: "Could not find the requested invite.",
      [DjsErrorCodes.DeleteGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot delete them",
      [DjsErrorCodes.FetchGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot fetch them",
      [DjsErrorCodes.MemberFetchNonceLength]: "Nonce length must not exceed 32 characters.",
      [DjsErrorCodes.GlobalCommandPermissions]: "Permissions for global commands may only be fetched or modified by providing a GuildResolvable or from a guild's application command manager.",
      [DjsErrorCodes.GuildUncachedEntityResolve]: (type) => `Cannot resolve ${type} from an arbitrary guild, provide an id instead`,
      [DjsErrorCodes.InteractionAlreadyReplied]: "The reply to this interaction has already been sent or deferred.",
      [DjsErrorCodes.InteractionNotReplied]: "The reply to this interaction has not been sent or deferred.",
      [DjsErrorCodes.InteractionEphemeralReplied]: "Ephemeral responses cannot be deleted.",
      [DjsErrorCodes.CommandInteractionOptionNotFound]: (name) => `Required option "${name}" not found.`,
      [DjsErrorCodes.CommandInteractionOptionType]: (name, type, expected) => `Option "${name}" is of type: ${type}; expected ${expected}.`,
      [DjsErrorCodes.CommandInteractionOptionEmpty]: (name, type) => `Required option "${name}" is of type: ${type}; expected a non-empty value.`,
      [DjsErrorCodes.CommandInteractionOptionNoSubcommand]: "No subcommand specified for interaction.",
      [DjsErrorCodes.CommandInteractionOptionNoSubcommandGroup]: "No subcommand group specified for interaction.",
      [DjsErrorCodes.CommandInteractionOptionInvalidChannelType]: (name, type, expected) => `The type of channel of the option "${name}" is: ${type}; expected ${expected}.`,
      [DjsErrorCodes.AutocompleteInteractionOptionNoFocusedOption]: "No focused option for autocomplete interaction.",
      [DjsErrorCodes.ModalSubmitInteractionFieldNotFound]: (customId) => `Required field with custom id "${customId}" not found.`,
      [DjsErrorCodes.ModalSubmitInteractionFieldType]: (customId, type, expected) => `Field with custom id "${customId}" is of type: ${type}; expected ${expected}.`,
      [DjsErrorCodes.InvalidMissingScopes]: "At least one valid scope must be provided for the invite",
      [DjsErrorCodes.NotImplemented]: (what, name) => `Method ${what} not implemented on ${name}.`,
      [DjsErrorCodes.SweepFilterReturn]: "The return value of the sweepFilter function was not false or a Function",
      [DjsErrorCodes.GuildForumMessageRequired]: "You must provide a message to create a guild forum thread"
    };
    module2.exports = Messages;
  }
});

// node_modules/discord.js/src/errors/DJSError.js
var require_DJSError = __commonJS({
  "node_modules/discord.js/src/errors/DJSError.js"(exports2, module2) {
    "use strict";
    var ErrorCodes2 = require_ErrorCodes();
    var Messages = require_Messages();
    function makeDiscordjsError(Base) {
      return class DiscordjsError2 extends Base {
        constructor(code, ...args) {
          super(message(code, args));
          this.code = code;
          Error.captureStackTrace?.(this, DiscordjsError2);
        }
        get name() {
          return `${super.name} [${this.code}]`;
        }
      };
    }
    function message(code, args) {
      if (!(code in ErrorCodes2))
        throw new Error("Error code must be a valid DiscordjsErrorCodes");
      const msg = Messages[code];
      if (!msg)
        throw new Error(`No message associated with error code: ${code}.`);
      if (typeof msg === "function")
        return msg(...args);
      if (!args?.length)
        return msg;
      args.unshift(msg);
      return String(...args);
    }
    module2.exports = {
      DiscordjsError: makeDiscordjsError(Error),
      DiscordjsTypeError: makeDiscordjsError(TypeError),
      DiscordjsRangeError: makeDiscordjsError(RangeError)
    };
  }
});

// node_modules/discord.js/src/errors/index.js
var require_errors2 = __commonJS({
  "node_modules/discord.js/src/errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_DJSError();
    module2.exports.ErrorCodes = require_ErrorCodes();
    module2.exports.Messages = require_Messages();
  }
});

// node_modules/lodash.snakecase/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.snakecase/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      // Latin Extended-A block.
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString3(value) {
      return value == null ? "" : baseToString(value);
    }
    function deburr(string) {
      string = toString3(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? "_" : "") + word.toLowerCase();
    });
    function words(string, pattern, guard) {
      string = toString3(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    module2.exports = snakeCase;
  }
});

// node_modules/discord.js/src/util/Transformers.js
var require_Transformers = __commonJS({
  "node_modules/discord.js/src/util/Transformers.js"(exports2, module2) {
    "use strict";
    var { isJSONEncodable } = require_dist2();
    var snakeCase = require_lodash();
    function toSnakeCase(obj) {
      if (typeof obj !== "object" || !obj)
        return obj;
      if (obj instanceof Date)
        return obj;
      if (isJSONEncodable(obj))
        return toSnakeCase(obj.toJSON());
      if (Array.isArray(obj))
        return obj.map(toSnakeCase);
      return Object.fromEntries(Object.entries(obj).map(([key, value]) => [snakeCase(key), toSnakeCase(value)]));
    }
    function _transformAPIAutoModerationAction(autoModerationAction) {
      return {
        type: autoModerationAction.type,
        metadata: {
          durationSeconds: autoModerationAction.metadata.duration_seconds ?? null,
          channelId: autoModerationAction.metadata.channel_id ?? null,
          customMessage: autoModerationAction.metadata.custom_message ?? null
        }
      };
    }
    module2.exports = { toSnakeCase, _transformAPIAutoModerationAction };
  }
});

// node_modules/discord.js/package.json
var require_package2 = __commonJS({
  "node_modules/discord.js/package.json"(exports2, module2) {
    module2.exports = {
      name: "discord.js",
      version: "14.9.0",
      description: "A powerful library for interacting with the Discord API",
      scripts: {
        test: "yarn docs:test && yarn test:typescript",
        "test:typescript": "tsc --noEmit && tsd",
        lint: "prettier --check . && tslint typings/index.d.ts && eslint src --format=pretty",
        format: "prettier --write . && eslint src --fix --format=pretty",
        fmt: "yarn format",
        docs: "docgen -i './src/*.js' './src/**/*.js' -c ./docs/index.json -r ../../ -o ./docs/docs.json",
        "docs:test": "docgen -i './src/*.js' './src/**/*.js' -c ./docs/index.json -r ../../",
        prepack: "yarn lint && yarn test",
        changelog: "git cliff --prepend ./CHANGELOG.md -u -c ./cliff.toml -r ../../ --include-path 'packages/discord.js/*'",
        release: "cliff-jumper"
      },
      main: "./src/index.js",
      types: "./typings/index.d.ts",
      directories: {
        lib: "src",
        test: "test"
      },
      files: [
        "src",
        "typings"
      ],
      contributors: [
        "Crawl <icrawltogo@gmail.com>",
        "Amish Shah <amishshah.2k@gmail.com>",
        "Vlad Frangu <kingdgrizzle@gmail.com>",
        "SpaceEEC <spaceeec@yahoo.com>",
        "Aura Rom\xE1n <kyradiscord@gmail.com>"
      ],
      license: "Apache-2.0",
      keywords: [
        "discord",
        "api",
        "bot",
        "client",
        "node",
        "discordapp"
      ],
      repository: {
        type: "git",
        url: "https://github.com/discordjs/discord.js.git"
      },
      bugs: {
        url: "https://github.com/discordjs/discord.js/issues"
      },
      homepage: "https://discord.js.org",
      dependencies: {
        "@discordjs/builders": "^1.6.0",
        "@discordjs/collection": "^1.5.0",
        "@discordjs/formatters": "^0.3.0",
        "@discordjs/rest": "^1.7.0",
        "@discordjs/util": "^0.2.0",
        "@sapphire/snowflake": "^3.4.0",
        "@types/ws": "^8.5.4",
        "discord-api-types": "^0.37.37",
        "fast-deep-equal": "^3.1.3",
        "lodash.snakecase": "^4.1.1",
        tslib: "^2.5.0",
        undici: "^5.21.0",
        ws: "^8.13.0"
      },
      devDependencies: {
        "@discordjs/docgen": "^0.12.1",
        "@favware/cliff-jumper": "^2.0.0",
        "@types/node": "16.18.23",
        dtslint: "^4.2.1",
        eslint: "^8.37.0",
        "eslint-formatter-pretty": "^5.0.0",
        jest: "^29.5.0",
        prettier: "^2.8.7",
        tsd: "^0.28.1",
        tslint: "^6.1.3",
        typescript: "^5.0.3"
      },
      engines: {
        node: ">=16.9.0"
      }
    };
  }
});

// node_modules/discord.js/src/util/LimitedCollection.js
var require_LimitedCollection = __commonJS({
  "node_modules/discord.js/src/util/LimitedCollection.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var LimitedCollection = class extends Collection2 {
      constructor(options = {}, iterable) {
        if (typeof options !== "object" || options === null) {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        }
        const { maxSize = Infinity, keepOverLimit = null } = options;
        if (typeof maxSize !== "number") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "maxSize", "number");
        }
        if (keepOverLimit !== null && typeof keepOverLimit !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "keepOverLimit", "function");
        }
        super(iterable);
        this.maxSize = maxSize;
        this.keepOverLimit = keepOverLimit;
      }
      set(key, value) {
        if (this.maxSize === 0)
          return this;
        if (this.size >= this.maxSize && !this.has(key)) {
          for (const [k, v] of this.entries()) {
            const keep = this.keepOverLimit?.(v, k, this) ?? false;
            if (!keep) {
              this.delete(k);
              break;
            }
          }
        }
        return super.set(key, value);
      }
      static get [Symbol.species]() {
        return Collection2;
      }
    };
    module2.exports = LimitedCollection;
  }
});

// node_modules/discord.js/src/util/Options.js
var require_Options = __commonJS({
  "node_modules/discord.js/src/util/Options.js"(exports2, module2) {
    "use strict";
    var process2 = require("node:process");
    var { DefaultRestOptions, DefaultUserAgentAppendix } = require_dist5();
    var { toSnakeCase } = require_Transformers();
    var { version } = require_package2();
    var Options2 = class extends null {
      /**
       * The default client options.
       * @returns {ClientOptions}
       */
      static createDefault() {
        return {
          closeTimeout: 5e3,
          waitGuildTimeout: 15e3,
          shardCount: 1,
          makeCache: this.cacheWithLimits(this.DefaultMakeCacheSettings),
          partials: [],
          failIfNotExists: true,
          presence: {},
          sweepers: this.DefaultSweeperSettings,
          ws: {
            large_threshold: 50,
            compress: false,
            properties: {
              os: process2.platform,
              browser: "discord.js",
              device: "discord.js"
            },
            version: 10
          },
          rest: {
            ...DefaultRestOptions,
            userAgentAppendix: this.userAgentAppendix
          },
          jsonTransformer: toSnakeCase
        };
      }
      /**
       * Create a cache factory using predefined settings to sweep or limit.
       * @param {Object<string, LimitedCollectionOptions|number>} [settings={}] Settings passed to the relevant constructor.
       * If no setting is provided for a manager, it uses Collection.
       * If a number is provided for a manager, it uses that number as the max size for a LimitedCollection.
       * If LimitedCollectionOptions are provided for a manager, it uses those settings to form a LimitedCollection.
       * @returns {CacheFactory}
       * @example
       * // Store up to 200 messages per channel and 200 members per guild, always keeping the client member.
       * Options.cacheWithLimits({
       *    MessageManager: 200,
       *    GuildMemberManager: {
       *      maxSize: 200,
       *      keepOverLimit: (member) => member.id === client.user.id,
       *    },
       *  });
       */
      static cacheWithLimits(settings = {}) {
        const { Collection: Collection2 } = require_dist();
        const LimitedCollection = require_LimitedCollection();
        return (manager) => {
          const setting = settings[manager.name];
          if (setting == null) {
            return new Collection2();
          }
          if (typeof setting === "number") {
            if (setting === Infinity) {
              return new Collection2();
            }
            return new LimitedCollection({ maxSize: setting });
          }
          const noLimit = setting.maxSize == null || setting.maxSize === Infinity;
          if (noLimit) {
            return new Collection2();
          }
          return new LimitedCollection(setting);
        };
      }
      /**
       * Create a cache factory that always caches everything.
       * @returns {CacheFactory}
       */
      static cacheEverything() {
        const { Collection: Collection2 } = require_dist();
        return () => new Collection2();
      }
      /**
       * The default settings passed to {@link Options.cacheWithLimits}.
       * The caches that this changes are:
       * * `MessageManager` - Limit to 200 messages
       * <info>If you want to keep default behavior and add on top of it you can use this object and add on to it, e.g.
       * `makeCache: Options.cacheWithLimits({ ...Options.DefaultMakeCacheSettings, ReactionManager: 0 })`</info>
       * @type {Object<string, LimitedCollectionOptions|number>}
       */
      static get DefaultMakeCacheSettings() {
        return {
          MessageManager: 200
        };
      }
      /**
       * The default settings passed to {@link Options.sweepers} (for v14).
       * The sweepers that this changes are:
       * * `threads` - Sweep archived threads every hour, removing those archived more than 4 hours ago
       * <info>If you want to keep default behavior and add on top of it you can use this object and add on to it, e.g.
       * `sweepers: { ...Options.DefaultSweeperSettings, messages: { interval: 300, lifetime: 600 } })`</info>
       * @type {SweeperOptions}
       */
      static get DefaultSweeperSettings() {
        return {
          threads: {
            interval: 3600,
            lifetime: 14400
          }
        };
      }
    };
    /**
     * The default user agent appendix.
     * @type {string}
     * @memberof Options
     * @private
     */
    __publicField(Options2, "userAgentAppendix", `discord.js/${version} ${DefaultUserAgentAppendix}`.trimEnd());
    module2.exports = Options2;
  }
});

// node_modules/discord.js/src/util/Colors.js
var require_Colors = __commonJS({
  "node_modules/discord.js/src/util/Colors.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      Default: 0,
      White: 16777215,
      Aqua: 1752220,
      Green: 5763719,
      Blue: 3447003,
      Yellow: 16705372,
      Purple: 10181046,
      LuminousVividPink: 15277667,
      Fuchsia: 15418782,
      Gold: 15844367,
      Orange: 15105570,
      Red: 15548997,
      Grey: 9807270,
      Navy: 3426654,
      DarkAqua: 1146986,
      DarkGreen: 2067276,
      DarkBlue: 2123412,
      DarkPurple: 7419530,
      DarkVividPink: 11342935,
      DarkGold: 12745742,
      DarkOrange: 11027200,
      DarkRed: 10038562,
      DarkGrey: 9936031,
      DarkerGrey: 8359053,
      LightGrey: 12370112,
      DarkNavy: 2899536,
      Blurple: 5793266,
      Greyple: 10070709,
      DarkButNotBlack: 2895667,
      NotQuiteBlack: 2303786
    };
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray2 = Array.isArray;
    module2.exports = isArray2;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray2(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module2.exports = isKey;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject2;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject2 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction2(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction2;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports2, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports2, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports2, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    var isFunction2 = require_isFunction();
    var isMasked = require_isMasked();
    var isObject2 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports2, module2) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports2, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports2, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports2, module2) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    module2.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports2, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports2, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports2, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports2, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports2, module2) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports2, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports2, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module2.exports = memoize;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports2, module2) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports2, module2) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray2 = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray2(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports2, module2) {
    var baseToString = require_baseToString();
    function toString3(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString3;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString3 = require_toString();
    function castPath(value, object) {
      if (isArray2(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString3(value));
    }
    module2.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports2, module2) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module2.exports = baseGet;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get;
  }
});

// node_modules/fast-deep-equal/es6/index.js
var require_es6 = __commonJS({
  "node_modules/fast-deep-equal/es6/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a instanceof Map && b instanceof Map) {
          if (a.size !== b.size)
            return false;
          for (i of a.entries())
            if (!b.has(i[0]))
              return false;
          for (i of a.entries())
            if (!equal(i[1], b.get(i[0])))
              return false;
          return true;
        }
        if (a instanceof Set && b instanceof Set) {
          if (a.size !== b.size)
            return false;
          for (i of a.entries())
            if (!b.has(i[0]))
              return false;
          return true;
        }
        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (a[i] !== b[i])
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports2, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports2, module2) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports2, module2) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module2.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports2, module2) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module2.exports = baseIndexOf;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module2.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports2, module2) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports2, module2) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module2.exports = cacheHas;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports2, module2) {
    function noop2() {
    }
    module2.exports = noop2;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports2, module2) {
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports2, module2) {
    var Set2 = require_Set();
    var noop2 = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values) {
      return new Set2(values);
    };
    module2.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseUniq;
  }
});

// node_modules/lodash/uniqWith.js
var require_uniqWith = __commonJS({
  "node_modules/lodash/uniqWith.js"(exports2, module2) {
    var baseUniq = require_baseUniq();
    function uniqWith(array, comparator) {
      comparator = typeof comparator == "function" ? comparator : void 0;
      return array && array.length ? baseUniq(array, void 0, comparator) : [];
    }
    module2.exports = uniqWith;
  }
});

// node_modules/@sapphire/shapeshift/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@sapphire/shapeshift/dist/index.js"(exports2) {
    "use strict";
    var get = require_get();
    var util2 = require("util");
    var fastDeepEqual = require_es6();
    var uniqWith = require_uniqWith();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var get__default = /* @__PURE__ */ _interopDefault(get);
    var fastDeepEqual__default = /* @__PURE__ */ _interopDefault(fastDeepEqual);
    var uniqWith__default = /* @__PURE__ */ _interopDefault(uniqWith);
    var __defProp2 = Object.defineProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var validationEnabled = true;
    function setGlobalValidationEnabled(enabled) {
      validationEnabled = enabled;
    }
    __name(setGlobalValidationEnabled, "setGlobalValidationEnabled");
    function getGlobalValidationEnabled() {
      return validationEnabled;
    }
    __name(getGlobalValidationEnabled, "getGlobalValidationEnabled");
    var Result = class {
      constructor(success, value, error) {
        this.success = success;
        if (success) {
          this.value = value;
        } else {
          this.error = error;
        }
      }
      isOk() {
        return this.success;
      }
      isErr() {
        return !this.success;
      }
      unwrap() {
        if (this.isOk())
          return this.value;
        throw this.error;
      }
      static ok(value) {
        return new Result(true, value);
      }
      static err(error) {
        return new Result(false, void 0, error);
      }
    };
    __name(Result, "Result");
    function getValue(valueOrFn) {
      return typeof valueOrFn === "function" ? valueOrFn() : valueOrFn;
    }
    __name(getValue, "getValue");
    var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
    var customInspectSymbolStackLess = Symbol.for("nodejs.util.inspect.custom.stack-less");
    var BaseError = class extends Error {
      [customInspectSymbol](depth, options) {
        return `${this[customInspectSymbolStackLess](depth, options)}
${this.stack.slice(this.stack.indexOf("\n"))}`;
      }
    };
    __name(BaseError, "BaseError");
    var BaseConstraintError = class extends BaseError {
      constructor(constraint, message, given) {
        super(message);
        this.constraint = constraint;
        this.given = given;
      }
    };
    __name(BaseConstraintError, "BaseConstraintError");
    var ExpectedConstraintError = class extends BaseConstraintError {
      constructor(constraint, message, given, expected) {
        super(constraint, message, given);
        this.expected = expected;
      }
      toJSON() {
        return {
          name: this.name,
          constraint: this.constraint,
          given: this.given,
          expected: this.expected
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const constraint = options.stylize(this.constraint, "string");
        if (depth < 0) {
          return options.stylize(`[ExpectedConstraintError: ${constraint}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const given = util2.inspect(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("ExpectedConstraintError", "special")} > ${constraint}`;
        const message = options.stylize(this.message, "regexp");
        const expectedBlock = `
  ${options.stylize("Expected: ", "string")}${options.stylize(this.expected, "boolean")}`;
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
      }
    };
    __name(ExpectedConstraintError, "ExpectedConstraintError");
    function whenConstraint(key, options, validator) {
      return {
        run(input, parent) {
          if (!parent) {
            return Result.err(new ExpectedConstraintError("s.object(T.when)", "Validator has no parent", parent, "Validator to have a parent"));
          }
          const isKeyArray = Array.isArray(key);
          const value = isKeyArray ? key.map((k) => get__default.default(parent, k)) : get__default.default(parent, key);
          const predicate = resolveBooleanIs(options, value, isKeyArray) ? options.then : options.otherwise;
          if (predicate) {
            return predicate(validator).run(input);
          }
          return Result.ok(input);
        }
      };
    }
    __name(whenConstraint, "whenConstraint");
    function resolveBooleanIs(options, value, isKeyArray) {
      if (options.is === void 0) {
        return isKeyArray ? !value.some((val) => !val) : Boolean(value);
      }
      if (typeof options.is === "function") {
        return options.is(value);
      }
      return value === options.is;
    }
    __name(resolveBooleanIs, "resolveBooleanIs");
    var BaseValidator = class {
      constructor(constraints = []) {
        this.constraints = [];
        this.isValidationEnabled = null;
        this.constraints = constraints;
      }
      setParent(parent) {
        this.parent = parent;
        return this;
      }
      get optional() {
        return new UnionValidator([new LiteralValidator(void 0), this.clone()]);
      }
      get nullable() {
        return new UnionValidator([new LiteralValidator(null), this.clone()]);
      }
      get nullish() {
        return new UnionValidator([new NullishValidator(), this.clone()]);
      }
      get array() {
        return new ArrayValidator(this.clone());
      }
      get set() {
        return new SetValidator(this.clone());
      }
      or(...predicates2) {
        return new UnionValidator([this.clone(), ...predicates2]);
      }
      transform(cb) {
        return this.addConstraint({ run: (input) => Result.ok(cb(input)) });
      }
      reshape(cb) {
        return this.addConstraint({ run: cb });
      }
      default(value) {
        return new DefaultValidator(this.clone(), value);
      }
      when(key, options) {
        return this.addConstraint(whenConstraint(key, options, this));
      }
      run(value) {
        let result = this.handle(value);
        if (result.isErr())
          return result;
        for (const constraint of this.constraints) {
          result = constraint.run(result.value, this.parent);
          if (result.isErr())
            break;
        }
        return result;
      }
      parse(value) {
        if (!this.shouldRunConstraints) {
          return this.handle(value).unwrap();
        }
        return this.constraints.reduce((v, constraint) => constraint.run(v).unwrap(), this.handle(value).unwrap());
      }
      is(value) {
        return this.run(value).isOk();
      }
      /**
       * Sets if the validator should also run constraints or just do basic checks.
       * @param isValidationEnabled Whether this validator should be enabled or disabled. You can pass boolean or a function returning boolean which will be called just before parsing.
       * Set to `null` to go off of the global configuration.
       */
      setValidationEnabled(isValidationEnabled) {
        const clone = this.clone();
        clone.isValidationEnabled = isValidationEnabled;
        return clone;
      }
      getValidationEnabled() {
        return getValue(this.isValidationEnabled);
      }
      get shouldRunConstraints() {
        return getValue(this.isValidationEnabled) ?? getGlobalValidationEnabled();
      }
      clone() {
        const clone = Reflect.construct(this.constructor, [this.constraints]);
        clone.isValidationEnabled = this.isValidationEnabled;
        return clone;
      }
      addConstraint(constraint) {
        const clone = this.clone();
        clone.constraints = clone.constraints.concat(constraint);
        return clone;
      }
    };
    __name(BaseValidator, "BaseValidator");
    function isUnique(input) {
      if (input.length < 2)
        return true;
      const uniqueArray2 = uniqWith__default.default(input, fastDeepEqual__default.default);
      return uniqueArray2.length === input.length;
    }
    __name(isUnique, "isUnique");
    function lessThan(a, b) {
      return a < b;
    }
    __name(lessThan, "lessThan");
    function lessThanOrEqual(a, b) {
      return a <= b;
    }
    __name(lessThanOrEqual, "lessThanOrEqual");
    function greaterThan(a, b) {
      return a > b;
    }
    __name(greaterThan, "greaterThan");
    function greaterThanOrEqual(a, b) {
      return a >= b;
    }
    __name(greaterThanOrEqual, "greaterThanOrEqual");
    function equal(a, b) {
      return a === b;
    }
    __name(equal, "equal");
    function notEqual(a, b) {
      return a !== b;
    }
    __name(notEqual, "notEqual");
    function arrayLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthComparator, "arrayLengthComparator");
    function arrayLengthLessThan(value) {
      const expected = `expected.length < ${value}`;
      return arrayLengthComparator(lessThan, "s.array(T).lengthLessThan", expected, value);
    }
    __name(arrayLengthLessThan, "arrayLengthLessThan");
    function arrayLengthLessThanOrEqual(value) {
      const expected = `expected.length <= ${value}`;
      return arrayLengthComparator(lessThanOrEqual, "s.array(T).lengthLessThanOrEqual", expected, value);
    }
    __name(arrayLengthLessThanOrEqual, "arrayLengthLessThanOrEqual");
    function arrayLengthGreaterThan(value) {
      const expected = `expected.length > ${value}`;
      return arrayLengthComparator(greaterThan, "s.array(T).lengthGreaterThan", expected, value);
    }
    __name(arrayLengthGreaterThan, "arrayLengthGreaterThan");
    function arrayLengthGreaterThanOrEqual(value) {
      const expected = `expected.length >= ${value}`;
      return arrayLengthComparator(greaterThanOrEqual, "s.array(T).lengthGreaterThanOrEqual", expected, value);
    }
    __name(arrayLengthGreaterThanOrEqual, "arrayLengthGreaterThanOrEqual");
    function arrayLengthEqual(value) {
      const expected = `expected.length === ${value}`;
      return arrayLengthComparator(equal, "s.array(T).lengthEqual", expected, value);
    }
    __name(arrayLengthEqual, "arrayLengthEqual");
    function arrayLengthNotEqual(value) {
      const expected = `expected.length !== ${value}`;
      return arrayLengthComparator(notEqual, "s.array(T).lengthNotEqual", expected, value);
    }
    __name(arrayLengthNotEqual, "arrayLengthNotEqual");
    function arrayLengthRange(start, endBefore) {
      const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRange", "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthRange, "arrayLengthRange");
    function arrayLengthRangeInclusive(start, end) {
      const expected = `expected.length >= ${start} && expected.length <= ${end}`;
      return {
        run(input) {
          return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeInclusive", "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthRangeInclusive, "arrayLengthRangeInclusive");
    function arrayLengthRangeExclusive(startAfter, endBefore) {
      const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeExclusive", "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthRangeExclusive, "arrayLengthRangeExclusive");
    var uniqueArray = {
      run(input) {
        return isUnique(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).unique", "Array values are not unique", input, "Expected all values to be unique"));
      }
    };
    var CombinedPropertyError = class extends BaseError {
      constructor(errors) {
        super("Received one or more errors");
        this.errors = errors;
      }
      [customInspectSymbolStackLess](depth, options) {
        if (depth < 0) {
          return options.stylize("[CombinedPropertyError]", "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const header = `${options.stylize("CombinedPropertyError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
        const message = options.stylize(this.message, "regexp");
        const errors = this.errors.map(([key, error]) => {
          const property = CombinedPropertyError.formatProperty(key, options);
          const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
          return `  input${property}${padding}${body}`;
        }).join("\n\n");
        return `${header}
  ${message}

${errors}`;
      }
      static formatProperty(key, options) {
        if (typeof key === "string")
          return options.stylize(`.${key}`, "symbol");
        if (typeof key === "number")
          return `[${options.stylize(key.toString(), "number")}]`;
        return `[${options.stylize("Symbol", "symbol")}(${key.description})]`;
      }
    };
    __name(CombinedPropertyError, "CombinedPropertyError");
    var ValidationError = class extends BaseError {
      constructor(validator, message, given) {
        super(message);
        this.validator = validator;
        this.given = given;
      }
      toJSON() {
        return {
          name: this.name,
          validator: this.validator,
          given: this.given
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const validator = options.stylize(this.validator, "string");
        if (depth < 0) {
          return options.stylize(`[ValidationError: ${validator}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const given = util2.inspect(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("ValidationError", "special")} > ${validator}`;
        const message = options.stylize(this.message, "regexp");
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${givenBlock}`;
      }
    };
    __name(ValidationError, "ValidationError");
    var ArrayValidator = class extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      lengthLessThan(length) {
        return this.addConstraint(arrayLengthLessThan(length));
      }
      lengthLessThanOrEqual(length) {
        return this.addConstraint(arrayLengthLessThanOrEqual(length));
      }
      lengthGreaterThan(length) {
        return this.addConstraint(arrayLengthGreaterThan(length));
      }
      lengthGreaterThanOrEqual(length) {
        return this.addConstraint(arrayLengthGreaterThanOrEqual(length));
      }
      lengthEqual(length) {
        return this.addConstraint(arrayLengthEqual(length));
      }
      lengthNotEqual(length) {
        return this.addConstraint(arrayLengthNotEqual(length));
      }
      lengthRange(start, endBefore) {
        return this.addConstraint(arrayLengthRange(start, endBefore));
      }
      lengthRangeInclusive(startAt, endAt) {
        return this.addConstraint(arrayLengthRangeInclusive(startAt, endAt));
      }
      lengthRangeExclusive(startAfter, endBefore) {
        return this.addConstraint(arrayLengthRangeExclusive(startAfter, endBefore));
      }
      get unique() {
        return this.addConstraint(uniqueArray);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(values) {
        if (!Array.isArray(values)) {
          return Result.err(new ValidationError("s.array(T)", "Expected an array", values));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(values);
        }
        const errors = [];
        const transformed = [];
        for (let i = 0; i < values.length; i++) {
          const result = this.validator.run(values[i]);
          if (result.isOk())
            transformed.push(result.value);
          else
            errors.push([i, result.error]);
        }
        return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
      }
    };
    __name(ArrayValidator, "ArrayValidator");
    function bigintComparator(comparator, name, expected, number) {
      return {
        run(input) {
          return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid bigint value", input, expected));
        }
      };
    }
    __name(bigintComparator, "bigintComparator");
    function bigintLessThan(value) {
      const expected = `expected < ${value}n`;
      return bigintComparator(lessThan, "s.bigint.lessThan", expected, value);
    }
    __name(bigintLessThan, "bigintLessThan");
    function bigintLessThanOrEqual(value) {
      const expected = `expected <= ${value}n`;
      return bigintComparator(lessThanOrEqual, "s.bigint.lessThanOrEqual", expected, value);
    }
    __name(bigintLessThanOrEqual, "bigintLessThanOrEqual");
    function bigintGreaterThan(value) {
      const expected = `expected > ${value}n`;
      return bigintComparator(greaterThan, "s.bigint.greaterThan", expected, value);
    }
    __name(bigintGreaterThan, "bigintGreaterThan");
    function bigintGreaterThanOrEqual(value) {
      const expected = `expected >= ${value}n`;
      return bigintComparator(greaterThanOrEqual, "s.bigint.greaterThanOrEqual", expected, value);
    }
    __name(bigintGreaterThanOrEqual, "bigintGreaterThanOrEqual");
    function bigintEqual(value) {
      const expected = `expected === ${value}n`;
      return bigintComparator(equal, "s.bigint.equal", expected, value);
    }
    __name(bigintEqual, "bigintEqual");
    function bigintNotEqual(value) {
      const expected = `expected !== ${value}n`;
      return bigintComparator(notEqual, "s.bigint.notEqual", expected, value);
    }
    __name(bigintNotEqual, "bigintNotEqual");
    function bigintDivisibleBy(divider) {
      const expected = `expected % ${divider}n === 0n`;
      return {
        run(input) {
          return input % divider === 0n ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.bigint.divisibleBy", "BigInt is not divisible", input, expected));
        }
      };
    }
    __name(bigintDivisibleBy, "bigintDivisibleBy");
    var BigIntValidator = class extends BaseValidator {
      lessThan(number) {
        return this.addConstraint(bigintLessThan(number));
      }
      lessThanOrEqual(number) {
        return this.addConstraint(bigintLessThanOrEqual(number));
      }
      greaterThan(number) {
        return this.addConstraint(bigintGreaterThan(number));
      }
      greaterThanOrEqual(number) {
        return this.addConstraint(bigintGreaterThanOrEqual(number));
      }
      equal(number) {
        return this.addConstraint(bigintEqual(number));
      }
      notEqual(number) {
        return this.addConstraint(bigintNotEqual(number));
      }
      get positive() {
        return this.greaterThanOrEqual(0n);
      }
      get negative() {
        return this.lessThan(0n);
      }
      divisibleBy(number) {
        return this.addConstraint(bigintDivisibleBy(number));
      }
      get abs() {
        return this.transform((value) => value < 0 ? -value : value);
      }
      intN(bits) {
        return this.transform((value) => BigInt.asIntN(bits, value));
      }
      uintN(bits) {
        return this.transform((value) => BigInt.asUintN(bits, value));
      }
      handle(value) {
        return typeof value === "bigint" ? Result.ok(value) : Result.err(new ValidationError("s.bigint", "Expected a bigint primitive", value));
      }
    };
    __name(BigIntValidator, "BigIntValidator");
    var booleanTrue = {
      run(input) {
        return input ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.boolean.true", "Invalid boolean value", input, "true"));
      }
    };
    var booleanFalse = {
      run(input) {
        return input ? Result.err(new ExpectedConstraintError("s.boolean.false", "Invalid boolean value", input, "false")) : Result.ok(input);
      }
    };
    var BooleanValidator = class extends BaseValidator {
      get true() {
        return this.addConstraint(booleanTrue);
      }
      get false() {
        return this.addConstraint(booleanFalse);
      }
      equal(value) {
        return value ? this.true : this.false;
      }
      notEqual(value) {
        return value ? this.false : this.true;
      }
      handle(value) {
        return typeof value === "boolean" ? Result.ok(value) : Result.err(new ValidationError("s.boolean", "Expected a boolean primitive", value));
      }
    };
    __name(BooleanValidator, "BooleanValidator");
    function dateComparator(comparator, name, expected, number) {
      return {
        run(input) {
          return comparator(input.getTime(), number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Date value", input, expected));
        }
      };
    }
    __name(dateComparator, "dateComparator");
    function dateLessThan(value) {
      const expected = `expected < ${value.toISOString()}`;
      return dateComparator(lessThan, "s.date.lessThan", expected, value.getTime());
    }
    __name(dateLessThan, "dateLessThan");
    function dateLessThanOrEqual(value) {
      const expected = `expected <= ${value.toISOString()}`;
      return dateComparator(lessThanOrEqual, "s.date.lessThanOrEqual", expected, value.getTime());
    }
    __name(dateLessThanOrEqual, "dateLessThanOrEqual");
    function dateGreaterThan(value) {
      const expected = `expected > ${value.toISOString()}`;
      return dateComparator(greaterThan, "s.date.greaterThan", expected, value.getTime());
    }
    __name(dateGreaterThan, "dateGreaterThan");
    function dateGreaterThanOrEqual(value) {
      const expected = `expected >= ${value.toISOString()}`;
      return dateComparator(greaterThanOrEqual, "s.date.greaterThanOrEqual", expected, value.getTime());
    }
    __name(dateGreaterThanOrEqual, "dateGreaterThanOrEqual");
    function dateEqual(value) {
      const expected = `expected === ${value.toISOString()}`;
      return dateComparator(equal, "s.date.equal", expected, value.getTime());
    }
    __name(dateEqual, "dateEqual");
    function dateNotEqual(value) {
      const expected = `expected !== ${value.toISOString()}`;
      return dateComparator(notEqual, "s.date.notEqual", expected, value.getTime());
    }
    __name(dateNotEqual, "dateNotEqual");
    var dateInvalid = {
      run(input) {
        return Number.isNaN(input.getTime()) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.date.invalid", "Invalid Date value", input, "expected === NaN"));
      }
    };
    var dateValid = {
      run(input) {
        return Number.isNaN(input.getTime()) ? Result.err(new ExpectedConstraintError("s.date.valid", "Invalid Date value", input, "expected !== NaN")) : Result.ok(input);
      }
    };
    var DateValidator = class extends BaseValidator {
      lessThan(date) {
        return this.addConstraint(dateLessThan(new Date(date)));
      }
      lessThanOrEqual(date) {
        return this.addConstraint(dateLessThanOrEqual(new Date(date)));
      }
      greaterThan(date) {
        return this.addConstraint(dateGreaterThan(new Date(date)));
      }
      greaterThanOrEqual(date) {
        return this.addConstraint(dateGreaterThanOrEqual(new Date(date)));
      }
      equal(date) {
        const resolved = new Date(date);
        return Number.isNaN(resolved.getTime()) ? this.invalid : this.addConstraint(dateEqual(resolved));
      }
      notEqual(date) {
        const resolved = new Date(date);
        return Number.isNaN(resolved.getTime()) ? this.valid : this.addConstraint(dateNotEqual(resolved));
      }
      get valid() {
        return this.addConstraint(dateValid);
      }
      get invalid() {
        return this.addConstraint(dateInvalid);
      }
      handle(value) {
        return value instanceof Date ? Result.ok(value) : Result.err(new ValidationError("s.date", "Expected a Date", value));
      }
    };
    __name(DateValidator, "DateValidator");
    var ExpectedValidationError = class extends ValidationError {
      constructor(validator, message, given, expected) {
        super(validator, message, given);
        this.expected = expected;
      }
      toJSON() {
        return {
          name: this.name,
          validator: this.validator,
          given: this.given,
          expected: this.expected
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const validator = options.stylize(this.validator, "string");
        if (depth < 0) {
          return options.stylize(`[ExpectedValidationError: ${validator}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const expected = util2.inspect(this.expected, newOptions).replace(/\n/g, padding);
        const given = util2.inspect(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("ExpectedValidationError", "special")} > ${validator}`;
        const message = options.stylize(this.message, "regexp");
        const expectedBlock = `
  ${options.stylize("Expected:", "string")}${padding}${expected}`;
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
      }
    };
    __name(ExpectedValidationError, "ExpectedValidationError");
    var InstanceValidator = class extends BaseValidator {
      constructor(expected, constraints = []) {
        super(constraints);
        this.expected = expected;
      }
      handle(value) {
        return value instanceof this.expected ? Result.ok(value) : Result.err(new ExpectedValidationError("s.instance(V)", "Expected", value, this.expected));
      }
      clone() {
        return Reflect.construct(this.constructor, [this.expected, this.constraints]);
      }
    };
    __name(InstanceValidator, "InstanceValidator");
    var LiteralValidator = class extends BaseValidator {
      constructor(literal, constraints = []) {
        super(constraints);
        this.expected = literal;
      }
      handle(value) {
        return Object.is(value, this.expected) ? Result.ok(value) : Result.err(new ExpectedValidationError("s.literal(V)", "Expected values to be equals", value, this.expected));
      }
      clone() {
        return Reflect.construct(this.constructor, [this.expected, this.constraints]);
      }
    };
    __name(LiteralValidator, "LiteralValidator");
    var NeverValidator = class extends BaseValidator {
      handle(value) {
        return Result.err(new ValidationError("s.never", "Expected a value to not be passed", value));
      }
    };
    __name(NeverValidator, "NeverValidator");
    var NullishValidator = class extends BaseValidator {
      handle(value) {
        return value === void 0 || value === null ? Result.ok(value) : Result.err(new ValidationError("s.nullish", "Expected undefined or null", value));
      }
    };
    __name(NullishValidator, "NullishValidator");
    function numberComparator(comparator, name, expected, number) {
      return {
        run(input) {
          return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid number value", input, expected));
        }
      };
    }
    __name(numberComparator, "numberComparator");
    function numberLessThan(value) {
      const expected = `expected < ${value}`;
      return numberComparator(lessThan, "s.number.lessThan", expected, value);
    }
    __name(numberLessThan, "numberLessThan");
    function numberLessThanOrEqual(value) {
      const expected = `expected <= ${value}`;
      return numberComparator(lessThanOrEqual, "s.number.lessThanOrEqual", expected, value);
    }
    __name(numberLessThanOrEqual, "numberLessThanOrEqual");
    function numberGreaterThan(value) {
      const expected = `expected > ${value}`;
      return numberComparator(greaterThan, "s.number.greaterThan", expected, value);
    }
    __name(numberGreaterThan, "numberGreaterThan");
    function numberGreaterThanOrEqual(value) {
      const expected = `expected >= ${value}`;
      return numberComparator(greaterThanOrEqual, "s.number.greaterThanOrEqual", expected, value);
    }
    __name(numberGreaterThanOrEqual, "numberGreaterThanOrEqual");
    function numberEqual(value) {
      const expected = `expected === ${value}`;
      return numberComparator(equal, "s.number.equal", expected, value);
    }
    __name(numberEqual, "numberEqual");
    function numberNotEqual(value) {
      const expected = `expected !== ${value}`;
      return numberComparator(notEqual, "s.number.notEqual", expected, value);
    }
    __name(numberNotEqual, "numberNotEqual");
    var numberInt = {
      run(input) {
        return Number.isInteger(input) ? Result.ok(input) : Result.err(
          new ExpectedConstraintError("s.number.int", "Given value is not an integer", input, "Number.isInteger(expected) to be true")
        );
      }
    };
    var numberSafeInt = {
      run(input) {
        return Number.isSafeInteger(input) ? Result.ok(input) : Result.err(
          new ExpectedConstraintError(
            "s.number.safeInt",
            "Given value is not a safe integer",
            input,
            "Number.isSafeInteger(expected) to be true"
          )
        );
      }
    };
    var numberFinite = {
      run(input) {
        return Number.isFinite(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.finite", "Given value is not finite", input, "Number.isFinite(expected) to be true"));
      }
    };
    var numberNaN = {
      run(input) {
        return Number.isNaN(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.equal(NaN)", "Invalid number value", input, "expected === NaN"));
      }
    };
    var numberNotNaN = {
      run(input) {
        return Number.isNaN(input) ? Result.err(new ExpectedConstraintError("s.number.notEqual(NaN)", "Invalid number value", input, "expected !== NaN")) : Result.ok(input);
      }
    };
    function numberDivisibleBy(divider) {
      const expected = `expected % ${divider} === 0`;
      return {
        run(input) {
          return input % divider === 0 ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.divisibleBy", "Number is not divisible", input, expected));
        }
      };
    }
    __name(numberDivisibleBy, "numberDivisibleBy");
    var NumberValidator = class extends BaseValidator {
      lessThan(number) {
        return this.addConstraint(numberLessThan(number));
      }
      lessThanOrEqual(number) {
        return this.addConstraint(numberLessThanOrEqual(number));
      }
      greaterThan(number) {
        return this.addConstraint(numberGreaterThan(number));
      }
      greaterThanOrEqual(number) {
        return this.addConstraint(numberGreaterThanOrEqual(number));
      }
      equal(number) {
        return Number.isNaN(number) ? this.addConstraint(numberNaN) : this.addConstraint(numberEqual(number));
      }
      notEqual(number) {
        return Number.isNaN(number) ? this.addConstraint(numberNotNaN) : this.addConstraint(numberNotEqual(number));
      }
      get int() {
        return this.addConstraint(numberInt);
      }
      get safeInt() {
        return this.addConstraint(numberSafeInt);
      }
      get finite() {
        return this.addConstraint(numberFinite);
      }
      get positive() {
        return this.greaterThanOrEqual(0);
      }
      get negative() {
        return this.lessThan(0);
      }
      divisibleBy(divider) {
        return this.addConstraint(numberDivisibleBy(divider));
      }
      get abs() {
        return this.transform(Math.abs);
      }
      get sign() {
        return this.transform(Math.sign);
      }
      get trunc() {
        return this.transform(Math.trunc);
      }
      get floor() {
        return this.transform(Math.floor);
      }
      get fround() {
        return this.transform(Math.fround);
      }
      get round() {
        return this.transform(Math.round);
      }
      get ceil() {
        return this.transform(Math.ceil);
      }
      handle(value) {
        return typeof value === "number" ? Result.ok(value) : Result.err(new ValidationError("s.number", "Expected a number primitive", value));
      }
    };
    __name(NumberValidator, "NumberValidator");
    var MissingPropertyError = class extends BaseError {
      constructor(property) {
        super("A required property is missing");
        this.property = property;
      }
      toJSON() {
        return {
          name: this.name,
          property: this.property
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const property = options.stylize(this.property.toString(), "string");
        if (depth < 0) {
          return options.stylize(`[MissingPropertyError: ${property}]`, "special");
        }
        const header = `${options.stylize("MissingPropertyError", "special")} > ${property}`;
        const message = options.stylize(this.message, "regexp");
        return `${header}
  ${message}`;
      }
    };
    __name(MissingPropertyError, "MissingPropertyError");
    var UnknownPropertyError = class extends BaseError {
      constructor(property, value) {
        super("Received unexpected property");
        this.property = property;
        this.value = value;
      }
      toJSON() {
        return {
          name: this.name,
          property: this.property,
          value: this.value
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const property = options.stylize(this.property.toString(), "string");
        if (depth < 0) {
          return options.stylize(`[UnknownPropertyError: ${property}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const given = util2.inspect(this.value, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("UnknownPropertyError", "special")} > ${property}`;
        const message = options.stylize(this.message, "regexp");
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${givenBlock}`;
      }
    };
    __name(UnknownPropertyError, "UnknownPropertyError");
    var DefaultValidator = class extends BaseValidator {
      constructor(validator, value, constraints = []) {
        super(constraints);
        this.validator = validator;
        this.defaultValue = value;
      }
      default(value) {
        const clone = this.clone();
        clone.defaultValue = value;
        return clone;
      }
      handle(value) {
        return typeof value === "undefined" ? Result.ok(getValue(this.defaultValue)) : this.validator["handle"](value);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.defaultValue, this.constraints]);
      }
    };
    __name(DefaultValidator, "DefaultValidator");
    var CombinedError = class extends BaseError {
      constructor(errors) {
        super("Received one or more errors");
        this.errors = errors;
      }
      [customInspectSymbolStackLess](depth, options) {
        if (depth < 0) {
          return options.stylize("[CombinedError]", "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const header = `${options.stylize("CombinedError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
        const message = options.stylize(this.message, "regexp");
        const errors = this.errors.map((error, i) => {
          const index = options.stylize((i + 1).toString(), "number");
          const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
          return `  ${index} ${body}`;
        }).join("\n\n");
        return `${header}
  ${message}

${errors}`;
      }
    };
    __name(CombinedError, "CombinedError");
    var UnionValidator = class extends BaseValidator {
      constructor(validators3, constraints = []) {
        super(constraints);
        this.validators = validators3;
      }
      get optional() {
        if (this.validators.length === 0)
          return new UnionValidator([new LiteralValidator(void 0)], this.constraints);
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === void 0)
            return this.clone();
          if (validator.expected === null) {
            return new UnionValidator(
              [new NullishValidator(), ...this.validators.slice(1)],
              this.constraints
            );
          }
        } else if (validator instanceof NullishValidator) {
          return this.clone();
        }
        return new UnionValidator([new LiteralValidator(void 0), ...this.validators]);
      }
      get required() {
        if (this.validators.length === 0)
          return this.clone();
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === void 0)
            return new UnionValidator(this.validators.slice(1), this.constraints);
        } else if (validator instanceof NullishValidator) {
          return new UnionValidator([new LiteralValidator(null), ...this.validators.slice(1)], this.constraints);
        }
        return this.clone();
      }
      get nullable() {
        if (this.validators.length === 0)
          return new UnionValidator([new LiteralValidator(null)], this.constraints);
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === null)
            return this.clone();
          if (validator.expected === void 0) {
            return new UnionValidator(
              [new NullishValidator(), ...this.validators.slice(1)],
              this.constraints
            );
          }
        } else if (validator instanceof NullishValidator) {
          return this.clone();
        }
        return new UnionValidator([new LiteralValidator(null), ...this.validators]);
      }
      get nullish() {
        if (this.validators.length === 0)
          return new UnionValidator([new NullishValidator()], this.constraints);
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === null || validator.expected === void 0) {
            return new UnionValidator([new NullishValidator(), ...this.validators.slice(1)], this.constraints);
          }
        } else if (validator instanceof NullishValidator) {
          return this.clone();
        }
        return new UnionValidator([new NullishValidator(), ...this.validators]);
      }
      or(...predicates2) {
        return new UnionValidator([...this.validators, ...predicates2]);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validators, this.constraints]);
      }
      handle(value) {
        const errors = [];
        for (const validator of this.validators) {
          const result = validator.run(value);
          if (result.isOk())
            return result;
          errors.push(result.error);
        }
        return Result.err(new CombinedError(errors));
      }
    };
    __name(UnionValidator, "UnionValidator");
    var ObjectValidator = class extends BaseValidator {
      constructor(shape, strategy = 0, constraints = []) {
        super(constraints);
        this.keys = [];
        this.requiredKeys = /* @__PURE__ */ new Map();
        this.possiblyUndefinedKeys = /* @__PURE__ */ new Map();
        this.possiblyUndefinedKeysWithDefaults = /* @__PURE__ */ new Map();
        this.shape = shape;
        this.strategy = strategy;
        switch (this.strategy) {
          case 0:
            this.handleStrategy = (value) => this.handleIgnoreStrategy(value);
            break;
          case 1: {
            this.handleStrategy = (value) => this.handleStrictStrategy(value);
            break;
          }
          case 2:
            this.handleStrategy = (value) => this.handlePassthroughStrategy(value);
            break;
        }
        const shapeEntries = Object.entries(shape);
        this.keys = shapeEntries.map(([key]) => key);
        for (const [key, validator] of shapeEntries) {
          if (validator instanceof UnionValidator) {
            const [possiblyLiteralOrNullishPredicate] = validator["validators"];
            if (possiblyLiteralOrNullishPredicate instanceof NullishValidator) {
              this.possiblyUndefinedKeys.set(key, validator);
            } else if (possiblyLiteralOrNullishPredicate instanceof LiteralValidator) {
              if (possiblyLiteralOrNullishPredicate.expected === void 0) {
                this.possiblyUndefinedKeys.set(key, validator);
              } else {
                this.requiredKeys.set(key, validator);
              }
            } else if (validator instanceof DefaultValidator) {
              this.possiblyUndefinedKeysWithDefaults.set(key, validator);
            } else {
              this.requiredKeys.set(key, validator);
            }
          } else if (validator instanceof NullishValidator) {
            this.possiblyUndefinedKeys.set(key, validator);
          } else if (validator instanceof LiteralValidator) {
            if (validator.expected === void 0) {
              this.possiblyUndefinedKeys.set(key, validator);
            } else {
              this.requiredKeys.set(key, validator);
            }
          } else if (validator instanceof DefaultValidator) {
            this.possiblyUndefinedKeysWithDefaults.set(key, validator);
          } else {
            this.requiredKeys.set(key, validator);
          }
        }
      }
      get strict() {
        return Reflect.construct(this.constructor, [this.shape, 1, this.constraints]);
      }
      get ignore() {
        return Reflect.construct(this.constructor, [this.shape, 0, this.constraints]);
      }
      get passthrough() {
        return Reflect.construct(this.constructor, [this.shape, 2, this.constraints]);
      }
      get partial() {
        const shape = Object.fromEntries(this.keys.map((key) => [key, this.shape[key].optional]));
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      get required() {
        const shape = Object.fromEntries(
          this.keys.map((key) => {
            let validator = this.shape[key];
            if (validator instanceof UnionValidator)
              validator = validator.required;
            return [key, validator];
          })
        );
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      extend(schema) {
        const shape = { ...this.shape, ...schema instanceof ObjectValidator ? schema.shape : schema };
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      pick(keys) {
        const shape = Object.fromEntries(
          keys.filter((key) => this.keys.includes(key)).map((key) => [key, this.shape[key]])
        );
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      omit(keys) {
        const shape = Object.fromEntries(
          this.keys.filter((key) => !keys.includes(key)).map((key) => [key, this.shape[key]])
        );
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      handle(value) {
        const typeOfValue = typeof value;
        if (typeOfValue !== "object") {
          return Result.err(new ValidationError("s.object(T)", `Expected the value to be an object, but received ${typeOfValue} instead`, value));
        }
        if (value === null) {
          return Result.err(new ValidationError("s.object(T)", "Expected the value to not be null", value));
        }
        if (Array.isArray(value)) {
          return Result.err(new ValidationError("s.object(T)", "Expected the value to not be an array", value));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(value);
        }
        for (const predicate of Object.values(this.shape)) {
          predicate.setParent(this.parent ?? value);
        }
        return this.handleStrategy(value);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.shape, this.strategy, this.constraints]);
      }
      handleIgnoreStrategy(value) {
        const errors = [];
        const finalObject = {};
        const inputEntries = new Map(Object.entries(value));
        const runPredicate = /* @__PURE__ */ __name((key, predicate) => {
          const result = predicate.run(value[key]);
          if (result.isOk()) {
            finalObject[key] = result.value;
          } else {
            const error = result.error;
            errors.push([key, error]);
          }
        }, "runPredicate");
        for (const [key, predicate] of this.requiredKeys) {
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          } else {
            errors.push([key, new MissingPropertyError(key)]);
          }
        }
        for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
          inputEntries.delete(key);
          runPredicate(key, validator);
        }
        if (inputEntries.size === 0) {
          return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors));
        }
        const checkInputEntriesInsteadOfSchemaKeys = this.possiblyUndefinedKeys.size > inputEntries.size;
        if (checkInputEntriesInsteadOfSchemaKeys) {
          for (const [key] of inputEntries) {
            const predicate = this.possiblyUndefinedKeys.get(key);
            if (predicate) {
              runPredicate(key, predicate);
            }
          }
        } else {
          for (const [key, predicate] of this.possiblyUndefinedKeys) {
            if (inputEntries.delete(key)) {
              runPredicate(key, predicate);
            }
          }
        }
        return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors));
      }
      handleStrictStrategy(value) {
        const errors = [];
        const finalResult = {};
        const inputEntries = new Map(Object.entries(value));
        const runPredicate = /* @__PURE__ */ __name((key, predicate) => {
          const result = predicate.run(value[key]);
          if (result.isOk()) {
            finalResult[key] = result.value;
          } else {
            const error = result.error;
            errors.push([key, error]);
          }
        }, "runPredicate");
        for (const [key, predicate] of this.requiredKeys) {
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          } else {
            errors.push([key, new MissingPropertyError(key)]);
          }
        }
        for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
          inputEntries.delete(key);
          runPredicate(key, validator);
        }
        for (const [key, predicate] of this.possiblyUndefinedKeys) {
          if (inputEntries.size === 0) {
            break;
          }
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          }
        }
        if (inputEntries.size !== 0) {
          for (const [key, value2] of inputEntries.entries()) {
            errors.push([key, new UnknownPropertyError(key, value2)]);
          }
        }
        return errors.length === 0 ? Result.ok(finalResult) : Result.err(new CombinedPropertyError(errors));
      }
      handlePassthroughStrategy(value) {
        const result = this.handleIgnoreStrategy(value);
        return result.isErr() ? result : Result.ok({ ...value, ...result.value });
      }
    };
    __name(ObjectValidator, "ObjectValidator");
    var PassthroughValidator = class extends BaseValidator {
      handle(value) {
        return Result.ok(value);
      }
    };
    __name(PassthroughValidator, "PassthroughValidator");
    var RecordValidator = class extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(value) {
        if (typeof value !== "object") {
          return Result.err(new ValidationError("s.record(T)", "Expected an object", value));
        }
        if (value === null) {
          return Result.err(new ValidationError("s.record(T)", "Expected the value to not be null", value));
        }
        if (Array.isArray(value)) {
          return Result.err(new ValidationError("s.record(T)", "Expected the value to not be an array", value));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(value);
        }
        const errors = [];
        const transformed = {};
        for (const [key, val] of Object.entries(value)) {
          const result = this.validator.run(val);
          if (result.isOk())
            transformed[key] = result.value;
          else
            errors.push([key, result.error]);
        }
        return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
      }
    };
    __name(RecordValidator, "RecordValidator");
    var SetValidator = class extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(values) {
        if (!(values instanceof Set)) {
          return Result.err(new ValidationError("s.set(T)", "Expected a set", values));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(values);
        }
        const errors = [];
        const transformed = /* @__PURE__ */ new Set();
        for (const value of values) {
          const result = this.validator.run(value);
          if (result.isOk())
            transformed.add(result.value);
          else
            errors.push(result.error);
        }
        return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedError(errors));
      }
    };
    __name(SetValidator, "SetValidator");
    var accountRegex = /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")$/;
    function validateEmail(email) {
      if (!email)
        return false;
      const atIndex = email.indexOf("@");
      if (atIndex === -1)
        return false;
      if (atIndex > 64)
        return false;
      const domainIndex = atIndex + 1;
      if (email.includes("@", domainIndex))
        return false;
      if (email.length - domainIndex > 255)
        return false;
      let dotIndex = email.indexOf(".", domainIndex);
      if (dotIndex === -1)
        return false;
      let lastDotIndex = domainIndex;
      do {
        if (dotIndex - lastDotIndex > 63)
          return false;
        lastDotIndex = dotIndex + 1;
      } while ((dotIndex = email.indexOf(".", lastDotIndex)) !== -1);
      if (email.length - lastDotIndex > 63)
        return false;
      return accountRegex.test(email.slice(0, atIndex)) && validateEmailDomain(email.slice(domainIndex));
    }
    __name(validateEmail, "validateEmail");
    function validateEmailDomain(domain) {
      try {
        return new URL(`http://${domain}`).hostname === domain;
      } catch {
        return false;
      }
    }
    __name(validateEmailDomain, "validateEmailDomain");
    var v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
    var v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
    var IPv4Reg = new RegExp(`^${v4Str}$`);
    var v6Seg = "(?:[0-9a-fA-F]{1,4})";
    var IPv6Reg = new RegExp(
      `^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`
    );
    function isIPv4(s2) {
      return IPv4Reg.test(s2);
    }
    __name(isIPv4, "isIPv4");
    function isIPv6(s2) {
      return IPv6Reg.test(s2);
    }
    __name(isIPv6, "isIPv6");
    function isIP(s2) {
      if (isIPv4(s2))
        return 4;
      if (isIPv6(s2))
        return 6;
      return 0;
    }
    __name(isIP, "isIP");
    var phoneNumberRegex = /^((?:\+|0{0,2})\d{1,2}\s?)?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}$/;
    function validatePhoneNumber(input) {
      return phoneNumberRegex.test(input);
    }
    __name(validatePhoneNumber, "validatePhoneNumber");
    var MultiplePossibilitiesConstraintError = class extends BaseConstraintError {
      constructor(constraint, message, given, expected) {
        super(constraint, message, given);
        this.expected = expected;
      }
      toJSON() {
        return {
          name: this.name,
          constraint: this.constraint,
          given: this.given,
          expected: this.expected
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const constraint = options.stylize(this.constraint, "string");
        if (depth < 0) {
          return options.stylize(`[MultiplePossibilitiesConstraintError: ${constraint}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
        const verticalLine = options.stylize("|", "undefined");
        const padding = `
  ${verticalLine} `;
        const given = util2.inspect(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("MultiplePossibilitiesConstraintError", "special")} > ${constraint}`;
        const message = options.stylize(this.message, "regexp");
        const expectedPadding = `
  ${verticalLine} - `;
        const expectedBlock = `
  ${options.stylize("Expected any of the following:", "string")}${expectedPadding}${this.expected.map((possible) => options.stylize(possible, "boolean")).join(expectedPadding)}`;
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
      }
    };
    __name(MultiplePossibilitiesConstraintError, "MultiplePossibilitiesConstraintError");
    function combinedErrorFn(...fns) {
      switch (fns.length) {
        case 0:
          return () => null;
        case 1:
          return fns[0];
        case 2: {
          const [fn0, fn1] = fns;
          return (...params) => fn0(...params) || fn1(...params);
        }
        default: {
          return (...params) => {
            for (const fn of fns) {
              const result = fn(...params);
              if (result)
                return result;
            }
            return null;
          };
        }
      }
    }
    __name(combinedErrorFn, "combinedErrorFn");
    function createUrlValidators(options) {
      const fns = [];
      if (options?.allowedProtocols?.length)
        fns.push(allowedProtocolsFn(options.allowedProtocols));
      if (options?.allowedDomains?.length)
        fns.push(allowedDomainsFn(options.allowedDomains));
      return combinedErrorFn(...fns);
    }
    __name(createUrlValidators, "createUrlValidators");
    function allowedProtocolsFn(allowedProtocols) {
      return (input, url2) => allowedProtocols.includes(url2.protocol) ? null : new MultiplePossibilitiesConstraintError("s.string.url", "Invalid URL protocol", input, allowedProtocols);
    }
    __name(allowedProtocolsFn, "allowedProtocolsFn");
    function allowedDomainsFn(allowedDomains) {
      return (input, url2) => allowedDomains.includes(url2.hostname) ? null : new MultiplePossibilitiesConstraintError("s.string.url", "Invalid URL domain", input, allowedDomains);
    }
    __name(allowedDomainsFn, "allowedDomainsFn");
    function stringLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid string length", input, expected));
        }
      };
    }
    __name(stringLengthComparator, "stringLengthComparator");
    function stringLengthLessThan(length) {
      const expected = `expected.length < ${length}`;
      return stringLengthComparator(lessThan, "s.string.lengthLessThan", expected, length);
    }
    __name(stringLengthLessThan, "stringLengthLessThan");
    function stringLengthLessThanOrEqual(length) {
      const expected = `expected.length <= ${length}`;
      return stringLengthComparator(lessThanOrEqual, "s.string.lengthLessThanOrEqual", expected, length);
    }
    __name(stringLengthLessThanOrEqual, "stringLengthLessThanOrEqual");
    function stringLengthGreaterThan(length) {
      const expected = `expected.length > ${length}`;
      return stringLengthComparator(greaterThan, "s.string.lengthGreaterThan", expected, length);
    }
    __name(stringLengthGreaterThan, "stringLengthGreaterThan");
    function stringLengthGreaterThanOrEqual(length) {
      const expected = `expected.length >= ${length}`;
      return stringLengthComparator(greaterThanOrEqual, "s.string.lengthGreaterThanOrEqual", expected, length);
    }
    __name(stringLengthGreaterThanOrEqual, "stringLengthGreaterThanOrEqual");
    function stringLengthEqual(length) {
      const expected = `expected.length === ${length}`;
      return stringLengthComparator(equal, "s.string.lengthEqual", expected, length);
    }
    __name(stringLengthEqual, "stringLengthEqual");
    function stringLengthNotEqual(length) {
      const expected = `expected.length !== ${length}`;
      return stringLengthComparator(notEqual, "s.string.lengthNotEqual", expected, length);
    }
    __name(stringLengthNotEqual, "stringLengthNotEqual");
    function stringEmail() {
      return {
        run(input) {
          return validateEmail(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string.email", "Invalid email address", input, "expected to be an email address"));
        }
      };
    }
    __name(stringEmail, "stringEmail");
    function stringRegexValidator(type, expected, regex) {
      return {
        run(input) {
          return regex.test(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(type, "Invalid string format", input, expected));
        }
      };
    }
    __name(stringRegexValidator, "stringRegexValidator");
    function stringUrl(options) {
      const validatorFn = createUrlValidators(options);
      return {
        run(input) {
          let url2;
          try {
            url2 = new URL(input);
          } catch {
            return Result.err(new ExpectedConstraintError("s.string.url", "Invalid URL", input, "expected to match an URL"));
          }
          const validatorFnResult = validatorFn(input, url2);
          if (validatorFnResult === null)
            return Result.ok(input);
          return Result.err(validatorFnResult);
        }
      };
    }
    __name(stringUrl, "stringUrl");
    function stringIp(version) {
      const ipVersion = version ? `v${version}` : "";
      const validatorFn = version === 4 ? isIPv4 : version === 6 ? isIPv6 : isIP;
      const name = `s.string.ip${ipVersion}`;
      const message = `Invalid IP${ipVersion} address`;
      const expected = `expected to be an IP${ipVersion} address`;
      return {
        run(input) {
          return validatorFn(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, message, input, expected));
        }
      };
    }
    __name(stringIp, "stringIp");
    function stringRegex(regex) {
      return stringRegexValidator("s.string.regex", `expected ${regex}.test(expected) to be true`, regex);
    }
    __name(stringRegex, "stringRegex");
    function stringUuid({ version = 4, nullable = false } = {}) {
      version ?? (version = "1-5");
      const regex = new RegExp(
        `^(?:[0-9A-F]{8}-[0-9A-F]{4}-[${version}][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}${nullable ? "|00000000-0000-0000-0000-000000000000" : ""})$`,
        "i"
      );
      const expected = `expected to match UUID${typeof version === "number" ? `v${version}` : ` in range of ${version}`}`;
      return stringRegexValidator("s.string.uuid", expected, regex);
    }
    __name(stringUuid, "stringUuid");
    function stringDate() {
      return {
        run(input) {
          const time = Date.parse(input);
          return Number.isNaN(time) ? Result.err(
            new ExpectedConstraintError(
              "s.string.date",
              "Invalid date string",
              input,
              "expected to be a valid date string (in the ISO 8601 or ECMA-262 format)"
            )
          ) : Result.ok(input);
        }
      };
    }
    __name(stringDate, "stringDate");
    function stringPhone() {
      return {
        run(input) {
          return validatePhoneNumber(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string.phone", "Invalid phone number", input, "expected to be a phone number"));
        }
      };
    }
    __name(stringPhone, "stringPhone");
    var StringValidator = class extends BaseValidator {
      lengthLessThan(length) {
        return this.addConstraint(stringLengthLessThan(length));
      }
      lengthLessThanOrEqual(length) {
        return this.addConstraint(stringLengthLessThanOrEqual(length));
      }
      lengthGreaterThan(length) {
        return this.addConstraint(stringLengthGreaterThan(length));
      }
      lengthGreaterThanOrEqual(length) {
        return this.addConstraint(stringLengthGreaterThanOrEqual(length));
      }
      lengthEqual(length) {
        return this.addConstraint(stringLengthEqual(length));
      }
      lengthNotEqual(length) {
        return this.addConstraint(stringLengthNotEqual(length));
      }
      get email() {
        return this.addConstraint(stringEmail());
      }
      url(options) {
        return this.addConstraint(stringUrl(options));
      }
      uuid(options) {
        return this.addConstraint(stringUuid(options));
      }
      regex(regex) {
        return this.addConstraint(stringRegex(regex));
      }
      get date() {
        return this.addConstraint(stringDate());
      }
      get ipv4() {
        return this.ip(4);
      }
      get ipv6() {
        return this.ip(6);
      }
      ip(version) {
        return this.addConstraint(stringIp(version));
      }
      phone() {
        return this.addConstraint(stringPhone());
      }
      handle(value) {
        return typeof value === "string" ? Result.ok(value) : Result.err(new ValidationError("s.string", "Expected a string primitive", value));
      }
    };
    __name(StringValidator, "StringValidator");
    var TupleValidator = class extends BaseValidator {
      constructor(validators3, constraints = []) {
        super(constraints);
        this.validators = [];
        this.validators = validators3;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validators, this.constraints]);
      }
      handle(values) {
        if (!Array.isArray(values)) {
          return Result.err(new ValidationError("s.tuple(T)", "Expected an array", values));
        }
        if (values.length !== this.validators.length) {
          return Result.err(new ValidationError("s.tuple(T)", `Expected an array of length ${this.validators.length}`, values));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(values);
        }
        const errors = [];
        const transformed = [];
        for (let i = 0; i < values.length; i++) {
          const result = this.validators[i].run(values[i]);
          if (result.isOk())
            transformed.push(result.value);
          else
            errors.push([i, result.error]);
        }
        return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
      }
    };
    __name(TupleValidator, "TupleValidator");
    var MapValidator = class extends BaseValidator {
      constructor(keyValidator, valueValidator, constraints = []) {
        super(constraints);
        this.keyValidator = keyValidator;
        this.valueValidator = valueValidator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.keyValidator, this.valueValidator, this.constraints]);
      }
      handle(value) {
        if (!(value instanceof Map)) {
          return Result.err(new ValidationError("s.map(K, V)", "Expected a map", value));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(value);
        }
        const errors = [];
        const transformed = /* @__PURE__ */ new Map();
        for (const [key, val] of value.entries()) {
          const keyResult = this.keyValidator.run(key);
          const valueResult = this.valueValidator.run(val);
          const { length } = errors;
          if (keyResult.isErr())
            errors.push([key, keyResult.error]);
          if (valueResult.isErr())
            errors.push([key, valueResult.error]);
          if (errors.length === length)
            transformed.set(keyResult.value, valueResult.value);
        }
        return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
      }
    };
    __name(MapValidator, "MapValidator");
    var LazyValidator = class extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(values) {
        return this.validator(values).run(values);
      }
    };
    __name(LazyValidator, "LazyValidator");
    var UnknownEnumValueError = class extends BaseError {
      constructor(value, keys, enumMappings) {
        super("Expected the value to be one of the following enum values:");
        this.value = value;
        this.enumKeys = keys;
        this.enumMappings = enumMappings;
      }
      toJSON() {
        return {
          name: this.name,
          value: this.value,
          enumKeys: this.enumKeys,
          enumMappings: [...this.enumMappings.entries()]
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const value = options.stylize(this.value.toString(), "string");
        if (depth < 0) {
          return options.stylize(`[UnknownEnumValueError: ${value}]`, "special");
        }
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const pairs = this.enumKeys.map((key) => {
          const enumValue = this.enumMappings.get(key);
          return `${options.stylize(key, "string")} or ${options.stylize(
            enumValue.toString(),
            typeof enumValue === "number" ? "number" : "string"
          )}`;
        }).join(padding);
        const header = `${options.stylize("UnknownEnumValueError", "special")} > ${value}`;
        const message = options.stylize(this.message, "regexp");
        const pairsBlock = `${padding}${pairs}`;
        return `${header}
  ${message}
${pairsBlock}`;
      }
    };
    __name(UnknownEnumValueError, "UnknownEnumValueError");
    var NativeEnumValidator = class extends BaseValidator {
      constructor(enumShape) {
        super();
        this.hasNumericElements = false;
        this.enumMapping = /* @__PURE__ */ new Map();
        this.enumShape = enumShape;
        this.enumKeys = Object.keys(enumShape).filter((key) => {
          return typeof enumShape[enumShape[key]] !== "number";
        });
        for (const key of this.enumKeys) {
          const enumValue = enumShape[key];
          this.enumMapping.set(key, enumValue);
          this.enumMapping.set(enumValue, enumValue);
          if (typeof enumValue === "number") {
            this.hasNumericElements = true;
            this.enumMapping.set(`${enumValue}`, enumValue);
          }
        }
      }
      handle(value) {
        const typeOfValue = typeof value;
        if (typeOfValue === "number") {
          if (!this.hasNumericElements) {
            return Result.err(new ValidationError("s.nativeEnum(T)", "Expected the value to be a string", value));
          }
        } else if (typeOfValue !== "string") {
          return Result.err(new ValidationError("s.nativeEnum(T)", "Expected the value to be a string or number", value));
        }
        const casted = value;
        const possibleEnumValue = this.enumMapping.get(casted);
        return typeof possibleEnumValue === "undefined" ? Result.err(new UnknownEnumValueError(casted, this.enumKeys, this.enumMapping)) : Result.ok(possibleEnumValue);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.enumShape]);
      }
    };
    __name(NativeEnumValidator, "NativeEnumValidator");
    function typedArrayByteLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.byteLength, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Typed Array byte length", input, expected));
        }
      };
    }
    __name(typedArrayByteLengthComparator, "typedArrayByteLengthComparator");
    function typedArrayByteLengthLessThan(value) {
      const expected = `expected.byteLength < ${value}`;
      return typedArrayByteLengthComparator(lessThan, "s.typedArray(T).byteLengthLessThan", expected, value);
    }
    __name(typedArrayByteLengthLessThan, "typedArrayByteLengthLessThan");
    function typedArrayByteLengthLessThanOrEqual(value) {
      const expected = `expected.byteLength <= ${value}`;
      return typedArrayByteLengthComparator(lessThanOrEqual, "s.typedArray(T).byteLengthLessThanOrEqual", expected, value);
    }
    __name(typedArrayByteLengthLessThanOrEqual, "typedArrayByteLengthLessThanOrEqual");
    function typedArrayByteLengthGreaterThan(value) {
      const expected = `expected.byteLength > ${value}`;
      return typedArrayByteLengthComparator(greaterThan, "s.typedArray(T).byteLengthGreaterThan", expected, value);
    }
    __name(typedArrayByteLengthGreaterThan, "typedArrayByteLengthGreaterThan");
    function typedArrayByteLengthGreaterThanOrEqual(value) {
      const expected = `expected.byteLength >= ${value}`;
      return typedArrayByteLengthComparator(greaterThanOrEqual, "s.typedArray(T).byteLengthGreaterThanOrEqual", expected, value);
    }
    __name(typedArrayByteLengthGreaterThanOrEqual, "typedArrayByteLengthGreaterThanOrEqual");
    function typedArrayByteLengthEqual(value) {
      const expected = `expected.byteLength === ${value}`;
      return typedArrayByteLengthComparator(equal, "s.typedArray(T).byteLengthEqual", expected, value);
    }
    __name(typedArrayByteLengthEqual, "typedArrayByteLengthEqual");
    function typedArrayByteLengthNotEqual(value) {
      const expected = `expected.byteLength !== ${value}`;
      return typedArrayByteLengthComparator(notEqual, "s.typedArray(T).byteLengthNotEqual", expected, value);
    }
    __name(typedArrayByteLengthNotEqual, "typedArrayByteLengthNotEqual");
    function typedArrayByteLengthRange(start, endBefore) {
      const expected = `expected.byteLength >= ${start} && expected.byteLength < ${endBefore}`;
      return {
        run(input) {
          return input.byteLength >= start && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRange", "Invalid Typed Array byte length", input, expected));
        }
      };
    }
    __name(typedArrayByteLengthRange, "typedArrayByteLengthRange");
    function typedArrayByteLengthRangeInclusive(start, end) {
      const expected = `expected.byteLength >= ${start} && expected.byteLength <= ${end}`;
      return {
        run(input) {
          return input.byteLength >= start && input.byteLength <= end ? Result.ok(input) : Result.err(
            new ExpectedConstraintError("s.typedArray(T).byteLengthRangeInclusive", "Invalid Typed Array byte length", input, expected)
          );
        }
      };
    }
    __name(typedArrayByteLengthRangeInclusive, "typedArrayByteLengthRangeInclusive");
    function typedArrayByteLengthRangeExclusive(startAfter, endBefore) {
      const expected = `expected.byteLength > ${startAfter} && expected.byteLength < ${endBefore}`;
      return {
        run(input) {
          return input.byteLength > startAfter && input.byteLength < endBefore ? Result.ok(input) : Result.err(
            new ExpectedConstraintError("s.typedArray(T).byteLengthRangeExclusive", "Invalid Typed Array byte length", input, expected)
          );
        }
      };
    }
    __name(typedArrayByteLengthRangeExclusive, "typedArrayByteLengthRangeExclusive");
    function typedArrayLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthComparator, "typedArrayLengthComparator");
    function typedArrayLengthLessThan(value) {
      const expected = `expected.length < ${value}`;
      return typedArrayLengthComparator(lessThan, "s.typedArray(T).lengthLessThan", expected, value);
    }
    __name(typedArrayLengthLessThan, "typedArrayLengthLessThan");
    function typedArrayLengthLessThanOrEqual(value) {
      const expected = `expected.length <= ${value}`;
      return typedArrayLengthComparator(lessThanOrEqual, "s.typedArray(T).lengthLessThanOrEqual", expected, value);
    }
    __name(typedArrayLengthLessThanOrEqual, "typedArrayLengthLessThanOrEqual");
    function typedArrayLengthGreaterThan(value) {
      const expected = `expected.length > ${value}`;
      return typedArrayLengthComparator(greaterThan, "s.typedArray(T).lengthGreaterThan", expected, value);
    }
    __name(typedArrayLengthGreaterThan, "typedArrayLengthGreaterThan");
    function typedArrayLengthGreaterThanOrEqual(value) {
      const expected = `expected.length >= ${value}`;
      return typedArrayLengthComparator(greaterThanOrEqual, "s.typedArray(T).lengthGreaterThanOrEqual", expected, value);
    }
    __name(typedArrayLengthGreaterThanOrEqual, "typedArrayLengthGreaterThanOrEqual");
    function typedArrayLengthEqual(value) {
      const expected = `expected.length === ${value}`;
      return typedArrayLengthComparator(equal, "s.typedArray(T).lengthEqual", expected, value);
    }
    __name(typedArrayLengthEqual, "typedArrayLengthEqual");
    function typedArrayLengthNotEqual(value) {
      const expected = `expected.length !== ${value}`;
      return typedArrayLengthComparator(notEqual, "s.typedArray(T).lengthNotEqual", expected, value);
    }
    __name(typedArrayLengthNotEqual, "typedArrayLengthNotEqual");
    function typedArrayLengthRange(start, endBefore) {
      const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRange", "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthRange, "typedArrayLengthRange");
    function typedArrayLengthRangeInclusive(start, end) {
      const expected = `expected.length >= ${start} && expected.length <= ${end}`;
      return {
        run(input) {
          return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeInclusive", "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthRangeInclusive, "typedArrayLengthRangeInclusive");
    function typedArrayLengthRangeExclusive(startAfter, endBefore) {
      const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeExclusive", "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthRangeExclusive, "typedArrayLengthRangeExclusive");
    var vowels = ["a", "e", "i", "o", "u"];
    var aOrAn = /* @__PURE__ */ __name((word) => {
      return `${vowels.includes(word[0].toLowerCase()) ? "an" : "a"} ${word}`;
    }, "aOrAn");
    var TypedArrays = {
      Int8Array: (x) => x instanceof Int8Array,
      Uint8Array: (x) => x instanceof Uint8Array,
      Uint8ClampedArray: (x) => x instanceof Uint8ClampedArray,
      Int16Array: (x) => x instanceof Int16Array,
      Uint16Array: (x) => x instanceof Uint16Array,
      Int32Array: (x) => x instanceof Int32Array,
      Uint32Array: (x) => x instanceof Uint32Array,
      Float32Array: (x) => x instanceof Float32Array,
      Float64Array: (x) => x instanceof Float64Array,
      BigInt64Array: (x) => x instanceof BigInt64Array,
      BigUint64Array: (x) => x instanceof BigUint64Array,
      TypedArray: (x) => ArrayBuffer.isView(x) && !(x instanceof DataView)
    };
    var TypedArrayValidator = class extends BaseValidator {
      constructor(type, constraints = []) {
        super(constraints);
        this.type = type;
      }
      byteLengthLessThan(length) {
        return this.addConstraint(typedArrayByteLengthLessThan(length));
      }
      byteLengthLessThanOrEqual(length) {
        return this.addConstraint(typedArrayByteLengthLessThanOrEqual(length));
      }
      byteLengthGreaterThan(length) {
        return this.addConstraint(typedArrayByteLengthGreaterThan(length));
      }
      byteLengthGreaterThanOrEqual(length) {
        return this.addConstraint(typedArrayByteLengthGreaterThanOrEqual(length));
      }
      byteLengthEqual(length) {
        return this.addConstraint(typedArrayByteLengthEqual(length));
      }
      byteLengthNotEqual(length) {
        return this.addConstraint(typedArrayByteLengthNotEqual(length));
      }
      byteLengthRange(start, endBefore) {
        return this.addConstraint(typedArrayByteLengthRange(start, endBefore));
      }
      byteLengthRangeInclusive(startAt, endAt) {
        return this.addConstraint(typedArrayByteLengthRangeInclusive(startAt, endAt));
      }
      byteLengthRangeExclusive(startAfter, endBefore) {
        return this.addConstraint(typedArrayByteLengthRangeExclusive(startAfter, endBefore));
      }
      lengthLessThan(length) {
        return this.addConstraint(typedArrayLengthLessThan(length));
      }
      lengthLessThanOrEqual(length) {
        return this.addConstraint(typedArrayLengthLessThanOrEqual(length));
      }
      lengthGreaterThan(length) {
        return this.addConstraint(typedArrayLengthGreaterThan(length));
      }
      lengthGreaterThanOrEqual(length) {
        return this.addConstraint(typedArrayLengthGreaterThanOrEqual(length));
      }
      lengthEqual(length) {
        return this.addConstraint(typedArrayLengthEqual(length));
      }
      lengthNotEqual(length) {
        return this.addConstraint(typedArrayLengthNotEqual(length));
      }
      lengthRange(start, endBefore) {
        return this.addConstraint(typedArrayLengthRange(start, endBefore));
      }
      lengthRangeInclusive(startAt, endAt) {
        return this.addConstraint(typedArrayLengthRangeInclusive(startAt, endAt));
      }
      lengthRangeExclusive(startAfter, endBefore) {
        return this.addConstraint(typedArrayLengthRangeExclusive(startAfter, endBefore));
      }
      clone() {
        return Reflect.construct(this.constructor, [this.type, this.constraints]);
      }
      handle(value) {
        return TypedArrays[this.type](value) ? Result.ok(value) : Result.err(new ValidationError("s.typedArray", `Expected ${aOrAn(this.type)}`, value));
      }
    };
    __name(TypedArrayValidator, "TypedArrayValidator");
    var Shapes = class {
      get string() {
        return new StringValidator();
      }
      get number() {
        return new NumberValidator();
      }
      get bigint() {
        return new BigIntValidator();
      }
      get boolean() {
        return new BooleanValidator();
      }
      get date() {
        return new DateValidator();
      }
      object(shape) {
        return new ObjectValidator(shape);
      }
      get undefined() {
        return this.literal(void 0);
      }
      get null() {
        return this.literal(null);
      }
      get nullish() {
        return new NullishValidator();
      }
      get any() {
        return new PassthroughValidator();
      }
      get unknown() {
        return new PassthroughValidator();
      }
      get never() {
        return new NeverValidator();
      }
      enum(...values) {
        return this.union(...values.map((value) => this.literal(value)));
      }
      nativeEnum(enumShape) {
        return new NativeEnumValidator(enumShape);
      }
      literal(value) {
        if (value instanceof Date)
          return this.date.equal(value);
        return new LiteralValidator(value);
      }
      instance(expected) {
        return new InstanceValidator(expected);
      }
      union(...validators3) {
        return new UnionValidator(validators3);
      }
      array(validator) {
        return new ArrayValidator(validator);
      }
      typedArray(type = "TypedArray") {
        return new TypedArrayValidator(type);
      }
      get int8Array() {
        return this.typedArray("Int8Array");
      }
      get uint8Array() {
        return this.typedArray("Uint8Array");
      }
      get uint8ClampedArray() {
        return this.typedArray("Uint8ClampedArray");
      }
      get int16Array() {
        return this.typedArray("Int16Array");
      }
      get uint16Array() {
        return this.typedArray("Uint16Array");
      }
      get int32Array() {
        return this.typedArray("Int32Array");
      }
      get uint32Array() {
        return this.typedArray("Uint32Array");
      }
      get float32Array() {
        return this.typedArray("Float32Array");
      }
      get float64Array() {
        return this.typedArray("Float64Array");
      }
      get bigInt64Array() {
        return this.typedArray("BigInt64Array");
      }
      get bigUint64Array() {
        return this.typedArray("BigUint64Array");
      }
      tuple(validators3) {
        return new TupleValidator(validators3);
      }
      set(validator) {
        return new SetValidator(validator);
      }
      record(validator) {
        return new RecordValidator(validator);
      }
      map(keyValidator, valueValidator) {
        return new MapValidator(keyValidator, valueValidator);
      }
      lazy(validator) {
        return new LazyValidator(validator);
      }
    };
    __name(Shapes, "Shapes");
    var s = new Shapes();
    exports2.BaseError = BaseError;
    exports2.CombinedError = CombinedError;
    exports2.CombinedPropertyError = CombinedPropertyError;
    exports2.ExpectedConstraintError = ExpectedConstraintError;
    exports2.ExpectedValidationError = ExpectedValidationError;
    exports2.MissingPropertyError = MissingPropertyError;
    exports2.MultiplePossibilitiesConstraintError = MultiplePossibilitiesConstraintError;
    exports2.Result = Result;
    exports2.UnknownEnumValueError = UnknownEnumValueError;
    exports2.UnknownPropertyError = UnknownPropertyError;
    exports2.ValidationError = ValidationError;
    exports2.customInspectSymbol = customInspectSymbol;
    exports2.customInspectSymbolStackLess = customInspectSymbolStackLess;
    exports2.getGlobalValidationEnabled = getGlobalValidationEnabled;
    exports2.s = s;
    exports2.setGlobalValidationEnabled = setGlobalValidationEnabled;
  }
});

// node_modules/@discordjs/formatters/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/@discordjs/formatters/dist/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp2(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Faces: () => Faces,
      TimestampStyles: () => TimestampStyles,
      blockQuote: () => blockQuote,
      bold: () => bold,
      channelLink: () => channelLink,
      channelMention: () => channelMention,
      chatInputApplicationCommandMention: () => chatInputApplicationCommandMention,
      codeBlock: () => codeBlock,
      escapeBold: () => escapeBold,
      escapeBulletedList: () => escapeBulletedList,
      escapeCodeBlock: () => escapeCodeBlock,
      escapeEscape: () => escapeEscape,
      escapeHeading: () => escapeHeading,
      escapeInlineCode: () => escapeInlineCode,
      escapeItalic: () => escapeItalic,
      escapeMarkdown: () => escapeMarkdown,
      escapeMaskedLink: () => escapeMaskedLink,
      escapeNumberedList: () => escapeNumberedList,
      escapeSpoiler: () => escapeSpoiler,
      escapeStrikethrough: () => escapeStrikethrough,
      escapeUnderline: () => escapeUnderline,
      formatEmoji: () => formatEmoji,
      hideLinkEmbed: () => hideLinkEmbed,
      hyperlink: () => hyperlink,
      inlineCode: () => inlineCode,
      italic: () => italic,
      messageLink: () => messageLink,
      quote: () => quote,
      roleMention: () => roleMention,
      spoiler: () => spoiler,
      strikethrough: () => strikethrough,
      time: () => time,
      underscore: () => underscore,
      userMention: () => userMention
    });
    module2.exports = __toCommonJS2(src_exports);
    function escapeMarkdown(text, options = {}) {
      const {
        codeBlock: codeBlock2 = true,
        inlineCode: inlineCode2 = true,
        bold: bold2 = true,
        italic: italic2 = true,
        underline = true,
        strikethrough: strikethrough2 = true,
        spoiler: spoiler2 = true,
        codeBlockContent = true,
        inlineCodeContent = true,
        escape = true,
        heading = false,
        bulletedList = false,
        numberedList = false,
        maskedLink = false
      } = options;
      if (!codeBlockContent) {
        return text.split("```").map((subString, index, array) => {
          if (index % 2 && index !== array.length - 1)
            return subString;
          return escapeMarkdown(subString, {
            inlineCode: inlineCode2,
            bold: bold2,
            italic: italic2,
            underline,
            strikethrough: strikethrough2,
            spoiler: spoiler2,
            inlineCodeContent,
            escape,
            heading,
            bulletedList,
            numberedList,
            maskedLink
          });
        }).join(codeBlock2 ? "\\`\\`\\`" : "```");
      }
      if (!inlineCodeContent) {
        return text.split(/(?<=^|[^`])`(?=[^`]|$)/g).map((subString, index, array) => {
          if (index % 2 && index !== array.length - 1)
            return subString;
          return escapeMarkdown(subString, {
            codeBlock: codeBlock2,
            bold: bold2,
            italic: italic2,
            underline,
            strikethrough: strikethrough2,
            spoiler: spoiler2,
            escape,
            heading,
            bulletedList,
            numberedList,
            maskedLink
          });
        }).join(inlineCode2 ? "\\`" : "`");
      }
      let res = text;
      if (escape)
        res = escapeEscape(res);
      if (inlineCode2)
        res = escapeInlineCode(res);
      if (codeBlock2)
        res = escapeCodeBlock(res);
      if (italic2)
        res = escapeItalic(res);
      if (bold2)
        res = escapeBold(res);
      if (underline)
        res = escapeUnderline(res);
      if (strikethrough2)
        res = escapeStrikethrough(res);
      if (spoiler2)
        res = escapeSpoiler(res);
      if (heading)
        res = escapeHeading(res);
      if (bulletedList)
        res = escapeBulletedList(res);
      if (numberedList)
        res = escapeNumberedList(res);
      if (maskedLink)
        res = escapeMaskedLink(res);
      return res;
    }
    __name(escapeMarkdown, "escapeMarkdown");
    function escapeCodeBlock(text) {
      return text.replaceAll("```", "\\`\\`\\`");
    }
    __name(escapeCodeBlock, "escapeCodeBlock");
    function escapeInlineCode(text) {
      return text.replaceAll(/(?<=^|[^`])``?(?=[^`]|$)/g, (match) => match.length === 2 ? "\\`\\`" : "\\`");
    }
    __name(escapeInlineCode, "escapeInlineCode");
    function escapeItalic(text) {
      let idx = 0;
      const newText = text.replaceAll(/(?<=^|[^*])\*([^*]|\*\*|$)/g, (_, match) => {
        if (match === "**")
          return ++idx % 2 ? `\\*${match}` : `${match}\\*`;
        return `\\*${match}`;
      });
      idx = 0;
      return newText.replaceAll(/(?<=^|[^_])(?<!<a?:.+)_(?!:\d+>)([^_]|__|$)/g, (_, match) => {
        if (match === "__")
          return ++idx % 2 ? `\\_${match}` : `${match}\\_`;
        return `\\_${match}`;
      });
    }
    __name(escapeItalic, "escapeItalic");
    function escapeBold(text) {
      let idx = 0;
      return text.replaceAll(/\*\*(\*)?/g, (_, match) => {
        if (match)
          return ++idx % 2 ? `${match}\\*\\*` : `\\*\\*${match}`;
        return "\\*\\*";
      });
    }
    __name(escapeBold, "escapeBold");
    function escapeUnderline(text) {
      let idx = 0;
      return text.replaceAll(/(?<!<a?:.+)__(_)?(?!:\d+>)/g, (_, match) => {
        if (match)
          return ++idx % 2 ? `${match}\\_\\_` : `\\_\\_${match}`;
        return "\\_\\_";
      });
    }
    __name(escapeUnderline, "escapeUnderline");
    function escapeStrikethrough(text) {
      return text.replaceAll("~~", "\\~\\~");
    }
    __name(escapeStrikethrough, "escapeStrikethrough");
    function escapeSpoiler(text) {
      return text.replaceAll("||", "\\|\\|");
    }
    __name(escapeSpoiler, "escapeSpoiler");
    function escapeEscape(text) {
      return text.replaceAll("\\", "\\\\");
    }
    __name(escapeEscape, "escapeEscape");
    function escapeHeading(text) {
      return text.replaceAll(/^( {0,2})([*-] )?( *)(#{1,3} )/gm, "$1$2$3\\$4");
    }
    __name(escapeHeading, "escapeHeading");
    function escapeBulletedList(text) {
      return text.replaceAll(/^( *)([*-])( +)/gm, "$1\\$2$3");
    }
    __name(escapeBulletedList, "escapeBulletedList");
    function escapeNumberedList(text) {
      return text.replaceAll(/^( *\d+)\./gm, "$1\\.");
    }
    __name(escapeNumberedList, "escapeNumberedList");
    function escapeMaskedLink(text) {
      return text.replaceAll(/\[.+]\(.+\)/gm, "\\$&");
    }
    __name(escapeMaskedLink, "escapeMaskedLink");
    function codeBlock(language, content) {
      return content === void 0 ? `\`\`\`
${language}
\`\`\`` : `\`\`\`${language}
${content}
\`\`\``;
    }
    __name(codeBlock, "codeBlock");
    function inlineCode(content) {
      return `\`${content}\``;
    }
    __name(inlineCode, "inlineCode");
    function italic(content) {
      return `_${content}_`;
    }
    __name(italic, "italic");
    function bold(content) {
      return `**${content}**`;
    }
    __name(bold, "bold");
    function underscore(content) {
      return `__${content}__`;
    }
    __name(underscore, "underscore");
    function strikethrough(content) {
      return `~~${content}~~`;
    }
    __name(strikethrough, "strikethrough");
    function quote(content) {
      return `> ${content}`;
    }
    __name(quote, "quote");
    function blockQuote(content) {
      return `>>> ${content}`;
    }
    __name(blockQuote, "blockQuote");
    function hideLinkEmbed(url2) {
      return `<${url2}>`;
    }
    __name(hideLinkEmbed, "hideLinkEmbed");
    function hyperlink(content, url2, title) {
      return title ? `[${content}](${url2} "${title}")` : `[${content}](${url2})`;
    }
    __name(hyperlink, "hyperlink");
    function spoiler(content) {
      return `||${content}||`;
    }
    __name(spoiler, "spoiler");
    function userMention(userId) {
      return `<@${userId}>`;
    }
    __name(userMention, "userMention");
    function channelMention(channelId) {
      return `<#${channelId}>`;
    }
    __name(channelMention, "channelMention");
    function roleMention(roleId) {
      return `<@&${roleId}>`;
    }
    __name(roleMention, "roleMention");
    function chatInputApplicationCommandMention(commandName, subcommandGroupName, subcommandName, commandId) {
      if (commandId !== void 0) {
        return `</${commandName} ${subcommandGroupName} ${subcommandName}:${commandId}>`;
      }
      if (subcommandName !== void 0) {
        return `</${commandName} ${subcommandGroupName}:${subcommandName}>`;
      }
      return `</${commandName}:${subcommandGroupName}>`;
    }
    __name(chatInputApplicationCommandMention, "chatInputApplicationCommandMention");
    function formatEmoji(emojiId, animated = false) {
      return `<${animated ? "a" : ""}:_:${emojiId}>`;
    }
    __name(formatEmoji, "formatEmoji");
    function channelLink(channelId, guildId) {
      return `https://discord.com/channels/${guildId ?? "@me"}/${channelId}`;
    }
    __name(channelLink, "channelLink");
    function messageLink(channelId, messageId, guildId) {
      return `${guildId === void 0 ? channelLink(channelId) : channelLink(channelId, guildId)}/${messageId}`;
    }
    __name(messageLink, "messageLink");
    function time(timeOrSeconds, style) {
      if (typeof timeOrSeconds !== "number") {
        timeOrSeconds = Math.floor((timeOrSeconds?.getTime() ?? Date.now()) / 1e3);
      }
      return typeof style === "string" ? `<t:${timeOrSeconds}:${style}>` : `<t:${timeOrSeconds}>`;
    }
    __name(time, "time");
    var TimestampStyles = {
      /**
       * Short time format, consisting of hours and minutes, e.g. 16:20
       */
      ShortTime: "t",
      /**
       * Long time format, consisting of hours, minutes, and seconds, e.g. 16:20:30
       */
      LongTime: "T",
      /**
       * Short date format, consisting of day, month, and year, e.g. 20/04/2021
       */
      ShortDate: "d",
      /**
       * Long date format, consisting of day, month, and year, e.g. 20 April 2021
       */
      LongDate: "D",
      /**
       * Short date-time format, consisting of short date and short time formats, e.g. 20 April 2021 16:20
       */
      ShortDateTime: "f",
      /**
       * Long date-time format, consisting of long date and short time formats, e.g. Tuesday, 20 April 2021 16:20
       */
      LongDateTime: "F",
      /**
       * Relative time format, consisting of a relative duration format, e.g. 2 months ago
       */
      RelativeTime: "R"
    };
    var Faces = /* @__PURE__ */ ((Faces2) => {
      Faces2["Shrug"] = "\xAF\\_(\u30C4)\\_/\xAF";
      Faces2["Tableflip"] = "(\u256F\xB0\u25A1\xB0\uFF09\u256F\uFE35 \u253B\u2501\u253B";
      Faces2["Unflip"] = "\u252C\u2500\u252C \u30CE( \u309C-\u309C\u30CE)";
      return Faces2;
    })(Faces || {});
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/ts-mixer/dist/cjs/util.js
var require_util6 = __commonJS({
  "node_modules/ts-mixer/dist/cjs/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flatten = exports2.unique = exports2.hardMixProtos = exports2.nearestCommonProto = exports2.protoChain = exports2.copyProps = void 0;
    var copyProps = (dest, src, exclude = []) => {
      const props = Object.getOwnPropertyDescriptors(src);
      for (let prop of exclude)
        delete props[prop];
      Object.defineProperties(dest, props);
    };
    exports2.copyProps = copyProps;
    var protoChain = (obj, currentChain = [obj]) => {
      const proto = Object.getPrototypeOf(obj);
      if (proto === null)
        return currentChain;
      return (0, exports2.protoChain)(proto, [...currentChain, proto]);
    };
    exports2.protoChain = protoChain;
    var nearestCommonProto = (...objs) => {
      if (objs.length === 0)
        return void 0;
      let commonProto = void 0;
      const protoChains = objs.map((obj) => (0, exports2.protoChain)(obj));
      while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
        const protos = protoChains.map((protoChain2) => protoChain2.pop());
        const potentialCommonProto = protos[0];
        if (protos.every((proto) => proto === potentialCommonProto))
          commonProto = potentialCommonProto;
        else
          break;
      }
      return commonProto;
    };
    exports2.nearestCommonProto = nearestCommonProto;
    var hardMixProtos = (ingredients, constructor, exclude = []) => {
      var _a;
      const base = (_a = (0, exports2.nearestCommonProto)(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;
      const mixedProto = Object.create(base);
      const visitedProtos = (0, exports2.protoChain)(base);
      for (let prototype3 of ingredients) {
        let protos = (0, exports2.protoChain)(prototype3);
        for (let i = protos.length - 1; i >= 0; i--) {
          let newProto = protos[i];
          if (visitedProtos.indexOf(newProto) === -1) {
            (0, exports2.copyProps)(mixedProto, newProto, ["constructor", ...exclude]);
            visitedProtos.push(newProto);
          }
        }
      }
      mixedProto.constructor = constructor;
      return mixedProto;
    };
    exports2.hardMixProtos = hardMixProtos;
    var unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);
    exports2.unique = unique;
    var flatten = (arr) => arr.length === 0 ? [] : arr.length === 1 ? arr[0] : arr.reduce((a1, a2) => [...a1, ...a2]);
    exports2.flatten = flatten;
  }
});

// node_modules/ts-mixer/dist/cjs/proxy.js
var require_proxy = __commonJS({
  "node_modules/ts-mixer/dist/cjs/proxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.softMixProtos = exports2.proxyMix = exports2.getIngredientWithProp = void 0;
    var util_1 = require_util6();
    var getIngredientWithProp = (prop, ingredients) => {
      const protoChains = ingredients.map((ingredient) => (0, util_1.protoChain)(ingredient));
      let protoDepth = 0;
      let protosAreLeftToSearch = true;
      while (protosAreLeftToSearch) {
        protosAreLeftToSearch = false;
        for (let i = ingredients.length - 1; i >= 0; i--) {
          const searchTarget = protoChains[i][protoDepth];
          if (searchTarget !== void 0 && searchTarget !== null) {
            protosAreLeftToSearch = true;
            if (Object.getOwnPropertyDescriptor(searchTarget, prop) != void 0) {
              return protoChains[i][0];
            }
          }
        }
        protoDepth++;
      }
      return void 0;
    };
    exports2.getIngredientWithProp = getIngredientWithProp;
    var proxyMix = (ingredients, prototype3 = Object.prototype) => new Proxy({}, {
      getPrototypeOf() {
        return prototype3;
      },
      setPrototypeOf() {
        throw Error("Cannot set prototype of Proxies created by ts-mixer");
      },
      getOwnPropertyDescriptor(_, prop) {
        return Object.getOwnPropertyDescriptor((0, exports2.getIngredientWithProp)(prop, ingredients) || {}, prop);
      },
      defineProperty() {
        throw new Error("Cannot define new properties on Proxies created by ts-mixer");
      },
      has(_, prop) {
        return (0, exports2.getIngredientWithProp)(prop, ingredients) !== void 0 || prototype3[prop] !== void 0;
      },
      get(_, prop) {
        return ((0, exports2.getIngredientWithProp)(prop, ingredients) || prototype3)[prop];
      },
      set(_, prop, val) {
        const ingredientWithProp = (0, exports2.getIngredientWithProp)(prop, ingredients);
        if (ingredientWithProp === void 0)
          throw new Error("Cannot set new properties on Proxies created by ts-mixer");
        ingredientWithProp[prop] = val;
        return true;
      },
      deleteProperty() {
        throw new Error("Cannot delete properties on Proxies created by ts-mixer");
      },
      ownKeys() {
        return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
      }
    });
    exports2.proxyMix = proxyMix;
    var softMixProtos = (ingredients, constructor) => (0, exports2.proxyMix)([...ingredients, { constructor }]);
    exports2.softMixProtos = softMixProtos;
  }
});

// node_modules/ts-mixer/dist/cjs/settings.js
var require_settings = __commonJS({
  "node_modules/ts-mixer/dist/cjs/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.settings = void 0;
    exports2.settings = {
      initFunction: null,
      staticsStrategy: "copy",
      prototypeStrategy: "copy",
      decoratorInheritance: "deep"
    };
  }
});

// node_modules/ts-mixer/dist/cjs/mixin-tracking.js
var require_mixin_tracking = __commonJS({
  "node_modules/ts-mixer/dist/cjs/mixin-tracking.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasMixin = exports2.registerMixins = exports2.getMixinsForClass = void 0;
    var util_1 = require_util6();
    var mixins = /* @__PURE__ */ new Map();
    var getMixinsForClass = (clazz) => mixins.get(clazz);
    exports2.getMixinsForClass = getMixinsForClass;
    var registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
    exports2.registerMixins = registerMixins;
    var hasMixin = (instance, mixin) => {
      if (instance instanceof mixin)
        return true;
      const constructor = instance.constructor;
      const visited = /* @__PURE__ */ new Set();
      let frontier = /* @__PURE__ */ new Set();
      frontier.add(constructor);
      while (frontier.size > 0) {
        if (frontier.has(mixin))
          return true;
        frontier.forEach((item) => visited.add(item));
        const newFrontier = /* @__PURE__ */ new Set();
        frontier.forEach((item) => {
          var _a;
          const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : (0, util_1.protoChain)(item.prototype).map((proto) => proto.constructor).filter((item2) => item2 !== null);
          if (itemConstituents)
            itemConstituents.forEach((constituent) => {
              if (!visited.has(constituent) && !frontier.has(constituent))
                newFrontier.add(constituent);
            });
        });
        frontier = newFrontier;
      }
      return false;
    };
    exports2.hasMixin = hasMixin;
  }
});

// node_modules/ts-mixer/dist/cjs/decorator.js
var require_decorator = __commonJS({
  "node_modules/ts-mixer/dist/cjs/decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decorate = exports2.getDecoratorsForClass = exports2.directDecoratorSearch = exports2.deepDecoratorSearch = void 0;
    var util_1 = require_util6();
    var mixin_tracking_1 = require_mixin_tracking();
    var mergeObjectsOfDecorators = (o1, o2) => {
      var _a, _b;
      const allKeys = (0, util_1.unique)([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
      const mergedObject = {};
      for (let key of allKeys)
        mergedObject[key] = (0, util_1.unique)([...(_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : [], ...(_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : []]);
      return mergedObject;
    };
    var mergePropertyAndMethodDecorators = (d1, d2) => {
      var _a, _b, _c, _d;
      return {
        property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),
        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})
      };
    };
    var mergeDecorators = (d1, d2) => {
      var _a, _b, _c, _d, _e, _f;
      return {
        class: (0, util_1.unique)([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),
        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),
        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})
      };
    };
    var decorators = /* @__PURE__ */ new Map();
    var findAllConstituentClasses = (...classes) => {
      var _a;
      const allClasses = /* @__PURE__ */ new Set();
      const frontier = /* @__PURE__ */ new Set([...classes]);
      while (frontier.size > 0) {
        for (let clazz of frontier) {
          const protoChainClasses = (0, util_1.protoChain)(clazz.prototype).map((proto) => proto.constructor);
          const mixinClasses = (_a = (0, mixin_tracking_1.getMixinsForClass)(clazz)) !== null && _a !== void 0 ? _a : [];
          const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
          const newClasses = potentiallyNewClasses.filter((c) => !allClasses.has(c));
          for (let newClass of newClasses)
            frontier.add(newClass);
          allClasses.add(clazz);
          frontier.delete(clazz);
        }
      }
      return [...allClasses];
    };
    var deepDecoratorSearch = (...classes) => {
      const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
      if (decoratorsForClassChain.length == 0)
        return {};
      if (decoratorsForClassChain.length == 1)
        return decoratorsForClassChain[0];
      return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    exports2.deepDecoratorSearch = deepDecoratorSearch;
    var directDecoratorSearch = (...classes) => {
      const classDecorators = classes.map((clazz) => (0, exports2.getDecoratorsForClass)(clazz));
      if (classDecorators.length === 0)
        return {};
      if (classDecorators.length === 1)
        return classDecorators[0];
      return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    exports2.directDecoratorSearch = directDecoratorSearch;
    var getDecoratorsForClass = (clazz) => {
      let decoratorsForClass = decorators.get(clazz);
      if (!decoratorsForClass) {
        decoratorsForClass = {};
        decorators.set(clazz, decoratorsForClass);
      }
      return decoratorsForClass;
    };
    exports2.getDecoratorsForClass = getDecoratorsForClass;
    var decorateClass = (decorator) => (clazz) => {
      const decoratorsForClass = (0, exports2.getDecoratorsForClass)(clazz);
      let classDecorators = decoratorsForClass.class;
      if (!classDecorators) {
        classDecorators = [];
        decoratorsForClass.class = classDecorators;
      }
      classDecorators.push(decorator);
      return decorator(clazz);
    };
    var decorateMember = (decorator) => (object, key, ...otherArgs) => {
      var _a, _b, _c;
      const decoratorTargetType = typeof object === "function" ? "static" : "instance";
      const decoratorType = typeof object[key] === "function" ? "method" : "property";
      const clazz = decoratorTargetType === "static" ? object : object.constructor;
      const decoratorsForClass = (0, exports2.getDecoratorsForClass)(clazz);
      const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};
      decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
      let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};
      decoratorsForTargetType[decoratorType] = decoratorsForType;
      let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];
      decoratorsForType[key] = decoratorsForKey;
      decoratorsForKey.push(decorator);
      return decorator(object, key, ...otherArgs);
    };
    var decorate = (decorator) => (...args) => {
      if (args.length === 1)
        return decorateClass(decorator)(args[0]);
      return decorateMember(decorator)(...args);
    };
    exports2.decorate = decorate;
  }
});

// node_modules/ts-mixer/dist/cjs/mixins.js
var require_mixins = __commonJS({
  "node_modules/ts-mixer/dist/cjs/mixins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mix = exports2.Mixin = void 0;
    var proxy_1 = require_proxy();
    var settings_1 = require_settings();
    var util_1 = require_util6();
    var decorator_1 = require_decorator();
    var mixin_tracking_1 = require_mixin_tracking();
    function Mixin(...constructors) {
      var _a, _b, _c;
      const prototypes = constructors.map((constructor) => constructor.prototype);
      const initFunctionName = settings_1.settings.initFunction;
      if (initFunctionName !== null) {
        const initFunctions = prototypes.map((proto) => proto[initFunctionName]).filter((func) => typeof func === "function");
        const combinedInitFunction = function(...args) {
          for (let initFunction of initFunctions)
            initFunction.apply(this, args);
        };
        const extraProto = { [initFunctionName]: combinedInitFunction };
        prototypes.push(extraProto);
      }
      function MixedClass(...args) {
        for (const constructor of constructors)
          (0, util_1.copyProps)(this, new constructor(...args));
        if (initFunctionName !== null && typeof this[initFunctionName] === "function")
          this[initFunctionName].apply(this, args);
      }
      MixedClass.prototype = settings_1.settings.prototypeStrategy === "copy" ? (0, util_1.hardMixProtos)(prototypes, MixedClass) : (0, proxy_1.softMixProtos)(prototypes, MixedClass);
      Object.setPrototypeOf(MixedClass, settings_1.settings.staticsStrategy === "copy" ? (0, util_1.hardMixProtos)(constructors, null, ["prototype"]) : (0, proxy_1.proxyMix)(constructors, Function.prototype));
      let DecoratedMixedClass = MixedClass;
      if (settings_1.settings.decoratorInheritance !== "none") {
        const classDecorators = settings_1.settings.decoratorInheritance === "deep" ? (0, decorator_1.deepDecoratorSearch)(...constructors) : (0, decorator_1.directDecoratorSearch)(...constructors);
        for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {
          const result = decorator(DecoratedMixedClass);
          if (result) {
            DecoratedMixedClass = result;
          }
        }
        applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);
        applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);
      }
      (0, mixin_tracking_1.registerMixins)(DecoratedMixedClass, constructors);
      return DecoratedMixedClass;
    }
    exports2.Mixin = Mixin;
    var applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
      const propDecorators = propAndMethodDecorators.property;
      const methodDecorators = propAndMethodDecorators.method;
      if (propDecorators)
        for (let key in propDecorators)
          for (let decorator of propDecorators[key])
            decorator(target, key);
      if (methodDecorators)
        for (let key in methodDecorators)
          for (let decorator of methodDecorators[key])
            decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
    };
    var mix = (...ingredients) => (decoratedClass) => {
      const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
      Object.defineProperty(mixedClass, "name", {
        value: decoratedClass.name,
        writable: false
      });
      return mixedClass;
    };
    exports2.mix = mix;
  }
});

// node_modules/ts-mixer/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/ts-mixer/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasMixin = exports2.decorate = exports2.settings = exports2.mix = exports2.Mixin = void 0;
    var mixins_1 = require_mixins();
    Object.defineProperty(exports2, "Mixin", { enumerable: true, get: function() {
      return mixins_1.Mixin;
    } });
    Object.defineProperty(exports2, "mix", { enumerable: true, get: function() {
      return mixins_1.mix;
    } });
    var settings_1 = require_settings();
    Object.defineProperty(exports2, "settings", { enumerable: true, get: function() {
      return settings_1.settings;
    } });
    var decorator_1 = require_decorator();
    Object.defineProperty(exports2, "decorate", { enumerable: true, get: function() {
      return decorator_1.decorate;
    } });
    var mixin_tracking_1 = require_mixin_tracking();
    Object.defineProperty(exports2, "hasMixin", { enumerable: true, get: function() {
      return mixin_tracking_1.hasMixin;
    } });
  }
});

// node_modules/@discordjs/builders/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/@discordjs/builders/dist/index.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all3) => {
      for (var name in all3)
        __defProp2(target, name, { get: all3[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps2(target, mod, "default"), secondTarget && __copyProps2(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      ActionRowBuilder: () => ActionRowBuilder,
      ApplicationCommandNumericOptionMinMaxValueMixin: () => ApplicationCommandNumericOptionMinMaxValueMixin,
      ApplicationCommandOptionBase: () => ApplicationCommandOptionBase,
      ApplicationCommandOptionChannelTypesMixin: () => ApplicationCommandOptionChannelTypesMixin,
      ApplicationCommandOptionWithChoicesAndAutocompleteMixin: () => ApplicationCommandOptionWithChoicesAndAutocompleteMixin,
      BaseSelectMenuBuilder: () => BaseSelectMenuBuilder,
      ButtonBuilder: () => ButtonBuilder,
      ChannelSelectMenuBuilder: () => ChannelSelectMenuBuilder,
      ComponentAssertions: () => Assertions_exports2,
      ComponentBuilder: () => ComponentBuilder,
      ContextMenuCommandAssertions: () => Assertions_exports6,
      ContextMenuCommandBuilder: () => ContextMenuCommandBuilder,
      EmbedAssertions: () => Assertions_exports,
      EmbedBuilder: () => EmbedBuilder,
      MentionableSelectMenuBuilder: () => MentionableSelectMenuBuilder,
      ModalAssertions: () => Assertions_exports4,
      ModalBuilder: () => ModalBuilder,
      RoleSelectMenuBuilder: () => RoleSelectMenuBuilder,
      SelectMenuBuilder: () => StringSelectMenuBuilder,
      SelectMenuOptionBuilder: () => StringSelectMenuOptionBuilder,
      SharedNameAndDescription: () => SharedNameAndDescription,
      SharedSlashCommandOptions: () => SharedSlashCommandOptions,
      SlashCommandAssertions: () => Assertions_exports5,
      SlashCommandAttachmentOption: () => SlashCommandAttachmentOption,
      SlashCommandBooleanOption: () => SlashCommandBooleanOption,
      SlashCommandBuilder: () => SlashCommandBuilder,
      SlashCommandChannelOption: () => SlashCommandChannelOption,
      SlashCommandIntegerOption: () => SlashCommandIntegerOption,
      SlashCommandMentionableOption: () => SlashCommandMentionableOption,
      SlashCommandNumberOption: () => SlashCommandNumberOption,
      SlashCommandRoleOption: () => SlashCommandRoleOption,
      SlashCommandStringOption: () => SlashCommandStringOption,
      SlashCommandSubcommandBuilder: () => SlashCommandSubcommandBuilder,
      SlashCommandSubcommandGroupBuilder: () => SlashCommandSubcommandGroupBuilder,
      SlashCommandUserOption: () => SlashCommandUserOption,
      StringSelectMenuBuilder: () => StringSelectMenuBuilder,
      StringSelectMenuOptionBuilder: () => StringSelectMenuOptionBuilder,
      TextInputAssertions: () => Assertions_exports3,
      TextInputBuilder: () => TextInputBuilder,
      UserSelectMenuBuilder: () => UserSelectMenuBuilder,
      createComponentBuilder: () => createComponentBuilder,
      disableValidators: () => disableValidators,
      embedLength: () => embedLength,
      enableValidators: () => enableValidators,
      isValidationEnabled: () => isValidationEnabled,
      normalizeArray: () => normalizeArray,
      version: () => version
    });
    module2.exports = __toCommonJS2(src_exports);
    var Assertions_exports = {};
    __export2(Assertions_exports, {
      RGBPredicate: () => RGBPredicate,
      authorNamePredicate: () => authorNamePredicate,
      colorPredicate: () => colorPredicate,
      descriptionPredicate: () => descriptionPredicate,
      embedAuthorPredicate: () => embedAuthorPredicate,
      embedFieldPredicate: () => embedFieldPredicate,
      embedFieldsArrayPredicate: () => embedFieldsArrayPredicate,
      embedFooterPredicate: () => embedFooterPredicate,
      fieldInlinePredicate: () => fieldInlinePredicate,
      fieldLengthPredicate: () => fieldLengthPredicate,
      fieldNamePredicate: () => fieldNamePredicate,
      fieldValuePredicate: () => fieldValuePredicate,
      footerTextPredicate: () => footerTextPredicate,
      imageURLPredicate: () => imageURLPredicate,
      timestampPredicate: () => timestampPredicate,
      titlePredicate: () => titlePredicate,
      urlPredicate: () => urlPredicate,
      validateFieldLength: () => validateFieldLength
    });
    var import_shapeshift = require_dist6();
    var validate = true;
    var enableValidators = /* @__PURE__ */ __name(() => validate = true, "enableValidators");
    var disableValidators = /* @__PURE__ */ __name(() => validate = false, "disableValidators");
    var isValidationEnabled = /* @__PURE__ */ __name(() => validate, "isValidationEnabled");
    var fieldNamePredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(256).setValidationEnabled(isValidationEnabled);
    var fieldValuePredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(1024).setValidationEnabled(isValidationEnabled);
    var fieldInlinePredicate = import_shapeshift.s.boolean.optional;
    var embedFieldPredicate = import_shapeshift.s.object({
      name: fieldNamePredicate,
      value: fieldValuePredicate,
      inline: fieldInlinePredicate
    }).setValidationEnabled(isValidationEnabled);
    var embedFieldsArrayPredicate = embedFieldPredicate.array.setValidationEnabled(isValidationEnabled);
    var fieldLengthPredicate = import_shapeshift.s.number.lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
    function validateFieldLength(amountAdding, fields) {
      fieldLengthPredicate.parse((fields?.length ?? 0) + amountAdding);
    }
    __name(validateFieldLength, "validateFieldLength");
    var authorNamePredicate = fieldNamePredicate.nullable.setValidationEnabled(isValidationEnabled);
    var imageURLPredicate = import_shapeshift.s.string.url({
      allowedProtocols: [
        "http:",
        "https:",
        "attachment:"
      ]
    }).nullish.setValidationEnabled(isValidationEnabled);
    var urlPredicate = import_shapeshift.s.string.url({
      allowedProtocols: [
        "http:",
        "https:"
      ]
    }).nullish.setValidationEnabled(isValidationEnabled);
    var embedAuthorPredicate = import_shapeshift.s.object({
      name: authorNamePredicate,
      iconURL: imageURLPredicate,
      url: urlPredicate
    }).setValidationEnabled(isValidationEnabled);
    var RGBPredicate = import_shapeshift.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(255).setValidationEnabled(isValidationEnabled);
    var colorPredicate = import_shapeshift.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(16777215).or(import_shapeshift.s.tuple([
      RGBPredicate,
      RGBPredicate,
      RGBPredicate
    ])).nullable.setValidationEnabled(isValidationEnabled);
    var descriptionPredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(4096).nullable.setValidationEnabled(isValidationEnabled);
    var footerTextPredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(2048).nullable.setValidationEnabled(isValidationEnabled);
    var embedFooterPredicate = import_shapeshift.s.object({
      text: footerTextPredicate,
      iconURL: imageURLPredicate
    }).setValidationEnabled(isValidationEnabled);
    var timestampPredicate = import_shapeshift.s.union(import_shapeshift.s.number, import_shapeshift.s.date).nullable.setValidationEnabled(isValidationEnabled);
    var titlePredicate = fieldNamePredicate.nullable.setValidationEnabled(isValidationEnabled);
    function normalizeArray(arr) {
      if (Array.isArray(arr[0]))
        return arr[0];
      return arr;
    }
    __name(normalizeArray, "normalizeArray");
    var EmbedBuilder = class {
      data;
      constructor(data = {}) {
        this.data = {
          ...data
        };
        if (data.timestamp)
          this.data.timestamp = new Date(data.timestamp).toISOString();
      }
      /**
      * Appends fields to the embed
      *
      * @remarks
      * This method accepts either an array of fields or a variable number of field parameters.
      * The maximum amount of fields that can be added is 25.
      * @example
      * Using an array
      * ```ts
      * const fields: APIEmbedField[] = ...;
      * const embed = new EmbedBuilder()
      * 	.addFields(fields);
      * ```
      * @example
      * Using rest parameters (variadic)
      * ```ts
      * const embed = new EmbedBuilder()
      * 	.addFields(
      * 		{ name: 'Field 1', value: 'Value 1' },
      * 		{ name: 'Field 2', value: 'Value 2' },
      * 	);
      * ```
      * @param fields - The fields to add
      */
      addFields(...fields) {
        fields = normalizeArray(fields);
        validateFieldLength(fields.length, this.data.fields);
        embedFieldsArrayPredicate.parse(fields);
        if (this.data.fields)
          this.data.fields.push(...fields);
        else
          this.data.fields = fields;
        return this;
      }
      /**
      * Removes, replaces, or inserts fields in the embed.
      *
      * @remarks
      * This method behaves similarly
      * to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice | Array.prototype.splice}.
      * The maximum amount of fields that can be added is 25.
      *
      * It's useful for modifying and adjusting order of the already-existing fields of an embed.
      * @example
      * Remove the first field
      * ```ts
      * embed.spliceFields(0, 1);
      * ```
      * @example
      * Remove the first n fields
      * ```ts
      * const n = 4
      * embed.spliceFields(0, n);
      * ```
      * @example
      * Remove the last field
      * ```ts
      * embed.spliceFields(-1, 1);
      * ```
      * @param index - The index to start at
      * @param deleteCount - The number of fields to remove
      * @param fields - The replacing field objects
      */
      spliceFields(index, deleteCount, ...fields) {
        validateFieldLength(fields.length - deleteCount, this.data.fields);
        embedFieldsArrayPredicate.parse(fields);
        if (this.data.fields)
          this.data.fields.splice(index, deleteCount, ...fields);
        else
          this.data.fields = fields;
        return this;
      }
      /**
      * Sets the embed's fields
      *
      * @remarks
      * This method is an alias for {@link EmbedBuilder.spliceFields}. More specifically,
      * it splices the entire array of fields, replacing them with the provided fields.
      *
      * You can set a maximum of 25 fields.
      * @param fields - The fields to set
      */
      setFields(...fields) {
        this.spliceFields(0, this.data.fields?.length ?? 0, ...normalizeArray(fields));
        return this;
      }
      /**
      * Sets the author of this embed
      *
      * @param options - The options for the author
      */
      setAuthor(options) {
        if (options === null) {
          this.data.author = void 0;
          return this;
        }
        embedAuthorPredicate.parse(options);
        this.data.author = {
          name: options.name,
          url: options.url,
          icon_url: options.iconURL
        };
        return this;
      }
      /**
      * Sets the color of this embed
      *
      * @param color - The color of the embed
      */
      setColor(color) {
        colorPredicate.parse(color);
        if (Array.isArray(color)) {
          const [red, green, blue] = color;
          this.data.color = (red << 16) + (green << 8) + blue;
          return this;
        }
        this.data.color = color ?? void 0;
        return this;
      }
      /**
      * Sets the description of this embed
      *
      * @param description - The description
      */
      setDescription(description) {
        descriptionPredicate.parse(description);
        this.data.description = description ?? void 0;
        return this;
      }
      /**
      * Sets the footer of this embed
      *
      * @param options - The options for the footer
      */
      setFooter(options) {
        if (options === null) {
          this.data.footer = void 0;
          return this;
        }
        embedFooterPredicate.parse(options);
        this.data.footer = {
          text: options.text,
          icon_url: options.iconURL
        };
        return this;
      }
      /**
      * Sets the image of this embed
      *
      * @param url - The URL of the image
      */
      setImage(url2) {
        imageURLPredicate.parse(url2);
        this.data.image = url2 ? {
          url: url2
        } : void 0;
        return this;
      }
      /**
      * Sets the thumbnail of this embed
      *
      * @param url - The URL of the thumbnail
      */
      setThumbnail(url2) {
        imageURLPredicate.parse(url2);
        this.data.thumbnail = url2 ? {
          url: url2
        } : void 0;
        return this;
      }
      /**
      * Sets the timestamp of this embed
      *
      * @param timestamp - The timestamp or date
      */
      setTimestamp(timestamp2 = Date.now()) {
        timestampPredicate.parse(timestamp2);
        this.data.timestamp = timestamp2 ? new Date(timestamp2).toISOString() : void 0;
        return this;
      }
      /**
      * Sets the title of this embed
      *
      * @param title - The title
      */
      setTitle(title) {
        titlePredicate.parse(title);
        this.data.title = title ?? void 0;
        return this;
      }
      /**
      * Sets the URL of this embed
      *
      * @param url - The URL
      */
      setURL(url2) {
        urlPredicate.parse(url2);
        this.data.url = url2 ?? void 0;
        return this;
      }
      /**
      * Transforms the embed to a plain object
      */
      toJSON() {
        return {
          ...this.data
        };
      }
    };
    __name(EmbedBuilder, "EmbedBuilder");
    __reExport(src_exports, require_dist7(), module2.exports);
    var Assertions_exports2 = {};
    __export2(Assertions_exports2, {
      buttonLabelValidator: () => buttonLabelValidator,
      buttonStyleValidator: () => buttonStyleValidator,
      channelTypesValidator: () => channelTypesValidator,
      customIdValidator: () => customIdValidator,
      defaultValidator: () => defaultValidator,
      disabledValidator: () => disabledValidator,
      emojiValidator: () => emojiValidator,
      jsonOptionValidator: () => jsonOptionValidator,
      labelValueDescriptionValidator: () => labelValueDescriptionValidator,
      minMaxValidator: () => minMaxValidator,
      optionValidator: () => optionValidator,
      optionsLengthValidator: () => optionsLengthValidator,
      optionsValidator: () => optionsValidator,
      placeholderValidator: () => placeholderValidator,
      urlValidator: () => urlValidator,
      validateRequiredButtonParameters: () => validateRequiredButtonParameters,
      validateRequiredSelectMenuOptionParameters: () => validateRequiredSelectMenuOptionParameters,
      validateRequiredSelectMenuParameters: () => validateRequiredSelectMenuParameters
    });
    var import_shapeshift2 = require_dist6();
    var import_v10 = require_v106();
    var StringSelectMenuOptionBuilder = class {
      data;
      /**
      * Creates a new string select menu option from API data
      *
      * @param data - The API data to create this string select menu option with
      * @example
      * Creating a string select menu option from an API data object
      * ```ts
      * const selectMenuOption = new SelectMenuOptionBuilder({
      * 	label: 'catchy label',
      * 	value: '1',
      * });
      * ```
      * @example
      * Creating a string select menu option using setters and API data
      * ```ts
      * const selectMenuOption = new SelectMenuOptionBuilder({
      * 	default: true,
      * 	value: '1',
      * })
      * 	.setLabel('woah')
      * ```
      */
      constructor(data = {}) {
        this.data = data;
      }
      /**
      * Sets the label of this option
      *
      * @param label - The label to show on this option
      */
      setLabel(label) {
        this.data.label = labelValueDescriptionValidator.parse(label);
        return this;
      }
      /**
      * Sets the value of this option
      *
      * @param value - The value of this option
      */
      setValue(value) {
        this.data.value = labelValueDescriptionValidator.parse(value);
        return this;
      }
      /**
      * Sets the description of this option
      *
      * @param description - The description of this option
      */
      setDescription(description) {
        this.data.description = labelValueDescriptionValidator.parse(description);
        return this;
      }
      /**
      * Sets whether this option is selected by default
      *
      * @param isDefault - Whether this option is selected by default
      */
      setDefault(isDefault = true) {
        this.data.default = defaultValidator.parse(isDefault);
        return this;
      }
      /**
      * Sets the emoji to display on this option
      *
      * @param emoji - The emoji to display on this option
      */
      setEmoji(emoji) {
        this.data.emoji = emojiValidator.parse(emoji);
        return this;
      }
      /**
      * {@inheritDoc ComponentBuilder.toJSON}
      */
      toJSON() {
        validateRequiredSelectMenuOptionParameters(this.data.label, this.data.value);
        return {
          ...this.data
        };
      }
    };
    __name(StringSelectMenuOptionBuilder, "StringSelectMenuOptionBuilder");
    var customIdValidator = import_shapeshift2.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
    var emojiValidator = import_shapeshift2.s.object({
      id: import_shapeshift2.s.string,
      name: import_shapeshift2.s.string,
      animated: import_shapeshift2.s.boolean
    }).partial.strict.setValidationEnabled(isValidationEnabled);
    var disabledValidator = import_shapeshift2.s.boolean;
    var buttonLabelValidator = import_shapeshift2.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(80).setValidationEnabled(isValidationEnabled);
    var buttonStyleValidator = import_shapeshift2.s.nativeEnum(import_v10.ButtonStyle);
    var placeholderValidator = import_shapeshift2.s.string.lengthLessThanOrEqual(150).setValidationEnabled(isValidationEnabled);
    var minMaxValidator = import_shapeshift2.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
    var labelValueDescriptionValidator = import_shapeshift2.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
    var jsonOptionValidator = import_shapeshift2.s.object({
      label: labelValueDescriptionValidator,
      value: labelValueDescriptionValidator,
      description: labelValueDescriptionValidator.optional,
      emoji: emojiValidator.optional,
      default: import_shapeshift2.s.boolean.optional
    }).setValidationEnabled(isValidationEnabled);
    var optionValidator = import_shapeshift2.s.instance(StringSelectMenuOptionBuilder).setValidationEnabled(isValidationEnabled);
    var optionsValidator = optionValidator.array.lengthGreaterThanOrEqual(0).setValidationEnabled(isValidationEnabled);
    var optionsLengthValidator = import_shapeshift2.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
    function validateRequiredSelectMenuParameters(options, customId) {
      customIdValidator.parse(customId);
      optionsValidator.parse(options);
    }
    __name(validateRequiredSelectMenuParameters, "validateRequiredSelectMenuParameters");
    var defaultValidator = import_shapeshift2.s.boolean;
    function validateRequiredSelectMenuOptionParameters(label, value) {
      labelValueDescriptionValidator.parse(label);
      labelValueDescriptionValidator.parse(value);
    }
    __name(validateRequiredSelectMenuOptionParameters, "validateRequiredSelectMenuOptionParameters");
    var channelTypesValidator = import_shapeshift2.s.nativeEnum(import_v10.ChannelType).array.setValidationEnabled(isValidationEnabled);
    var urlValidator = import_shapeshift2.s.string.url({
      allowedProtocols: [
        "http:",
        "https:",
        "discord:"
      ]
    }).setValidationEnabled(isValidationEnabled);
    function validateRequiredButtonParameters(style, label, emoji, customId, url2) {
      if (url2 && customId) {
        throw new RangeError("URL and custom id are mutually exclusive");
      }
      if (!label && !emoji) {
        throw new RangeError("Buttons must have a label and/or an emoji");
      }
      if (style === import_v10.ButtonStyle.Link) {
        if (!url2) {
          throw new RangeError("Link buttons must have a url");
        }
      } else if (url2) {
        throw new RangeError("Non-link buttons cannot have a url");
      }
    }
    __name(validateRequiredButtonParameters, "validateRequiredButtonParameters");
    var import_v1011 = require_v106();
    var ComponentBuilder = class {
      /**
      * The API data associated with this component
      */
      data;
      constructor(data) {
        this.data = data;
      }
    };
    __name(ComponentBuilder, "ComponentBuilder");
    var import_v1010 = require_v106();
    var import_v102 = require_v106();
    var ButtonBuilder = class extends ComponentBuilder {
      /**
      * Creates a new button from API data
      *
      * @param data - The API data to create this button with
      * @example
      * Creating a button from an API data object
      * ```ts
      * const button = new ButtonBuilder({
      * 	custom_id: 'a cool button',
      * 	style: ButtonStyle.Primary,
      * 	label: 'Click Me',
      * 	emoji: {
      * 		name: 'smile',
      * 		id: '123456789012345678',
      * 	},
      * });
      * ```
      * @example
      * Creating a button using setters and API data
      * ```ts
      * const button = new ButtonBuilder({
      * 	style: ButtonStyle.Secondary,
      * 	label: 'Click Me',
      * })
      * 	.setEmoji({ name: '🙂' })
      * 	.setCustomId('another cool button');
      * ```
      */
      constructor(data) {
        super({
          type: import_v102.ComponentType.Button,
          ...data
        });
      }
      /**
      * Sets the style of this button
      *
      * @param style - The style of the button
      */
      setStyle(style) {
        this.data.style = buttonStyleValidator.parse(style);
        return this;
      }
      /**
      * Sets the URL for this button
      *
      * @remarks
      * This method is only available to buttons using the `Link` button style.
      * Only three types of URL schemes are currently supported: `https://`, `http://` and `discord://`
      * @param url - The URL to open when this button is clicked
      */
      setURL(url2) {
        this.data.url = urlValidator.parse(url2);
        return this;
      }
      /**
      * Sets the custom id for this button
      *
      * @remarks
      * This method is only applicable to buttons that are not using the `Link` button style.
      * @param customId - The custom id to use for this button
      */
      setCustomId(customId) {
        this.data.custom_id = customIdValidator.parse(customId);
        return this;
      }
      /**
      * Sets the emoji to display on this button
      *
      * @param emoji - The emoji to display on this button
      */
      setEmoji(emoji) {
        this.data.emoji = emojiValidator.parse(emoji);
        return this;
      }
      /**
      * Sets whether this button is disabled
      *
      * @param disabled - Whether to disable this button
      */
      setDisabled(disabled = true) {
        this.data.disabled = disabledValidator.parse(disabled);
        return this;
      }
      /**
      * Sets the label for this button
      *
      * @param label - The label to display on this button
      */
      setLabel(label) {
        this.data.label = buttonLabelValidator.parse(label);
        return this;
      }
      /**
      * {@inheritDoc ComponentBuilder.toJSON}
      */
      toJSON() {
        validateRequiredButtonParameters(this.data.style, this.data.label, this.data.emoji, this.data.custom_id, this.data.url);
        return {
          ...this.data
        };
      }
    };
    __name(ButtonBuilder, "ButtonBuilder");
    var import_v103 = require_v106();
    var BaseSelectMenuBuilder = class extends ComponentBuilder {
      /**
      * Sets the placeholder for this select menu
      *
      * @param placeholder - The placeholder to use for this select menu
      */
      setPlaceholder(placeholder) {
        this.data.placeholder = placeholderValidator.parse(placeholder);
        return this;
      }
      /**
      * Sets the minimum values that must be selected in the select menu
      *
      * @param minValues - The minimum values that must be selected
      */
      setMinValues(minValues) {
        this.data.min_values = minMaxValidator.parse(minValues);
        return this;
      }
      /**
      * Sets the maximum values that must be selected in the select menu
      *
      * @param maxValues - The maximum values that must be selected
      */
      setMaxValues(maxValues) {
        this.data.max_values = minMaxValidator.parse(maxValues);
        return this;
      }
      /**
      * Sets the custom id for this select menu
      *
      * @param customId - The custom id to use for this select menu
      */
      setCustomId(customId) {
        this.data.custom_id = customIdValidator.parse(customId);
        return this;
      }
      /**
      * Sets whether this select menu is disabled
      *
      * @param disabled - Whether this select menu is disabled
      */
      setDisabled(disabled = true) {
        this.data.disabled = disabledValidator.parse(disabled);
        return this;
      }
      toJSON() {
        customIdValidator.parse(this.data.custom_id);
        return {
          ...this.data
        };
      }
    };
    __name(BaseSelectMenuBuilder, "BaseSelectMenuBuilder");
    var ChannelSelectMenuBuilder = class extends BaseSelectMenuBuilder {
      /**
      * Creates a new select menu from API data
      *
      * @param data - The API data to create this select menu with
      * @example
      * Creating a select menu from an API data object
      * ```ts
      * const selectMenu = new ChannelSelectMenuBuilder({
      * 	custom_id: 'a cool select menu',
      * 	placeholder: 'select an option',
      * 	max_values: 2,
      * });
      * ```
      * @example
      * Creating a select menu using setters and API data
      * ```ts
      * const selectMenu = new ChannelSelectMenuBuilder({
      * 	custom_id: 'a cool select menu',
      * })
      * 	.addChannelTypes(ChannelType.GuildText, ChannelType.GuildAnnouncement)
      * 	.setMinValues(2)
      * ```
      */
      constructor(data) {
        super({
          ...data,
          type: import_v103.ComponentType.ChannelSelect
        });
      }
      addChannelTypes(...types) {
        types = normalizeArray(types);
        this.data.channel_types ??= [];
        this.data.channel_types.push(...channelTypesValidator.parse(types));
        return this;
      }
      setChannelTypes(...types) {
        types = normalizeArray(types);
        this.data.channel_types ??= [];
        this.data.channel_types.splice(0, this.data.channel_types.length, ...channelTypesValidator.parse(types));
        return this;
      }
      /**
      * {@inheritDoc ComponentBuilder.toJSON}
      */
      toJSON() {
        customIdValidator.parse(this.data.custom_id);
        return {
          ...this.data
        };
      }
    };
    __name(ChannelSelectMenuBuilder, "ChannelSelectMenuBuilder");
    var import_v104 = require_v106();
    var MentionableSelectMenuBuilder = class extends BaseSelectMenuBuilder {
      /**
      * Creates a new select menu from API data
      *
      * @param data - The API data to create this select menu with
      * @example
      * Creating a select menu from an API data object
      * ```ts
      * const selectMenu = new MentionableSelectMenuBuilder({
      * 	custom_id: 'a cool select menu',
      * 	placeholder: 'select an option',
      * 	max_values: 2,
      * });
      * ```
      * @example
      * Creating a select menu using setters and API data
      * ```ts
      * const selectMenu = new MentionableSelectMenuBuilder({
      * 	custom_id: 'a cool select menu',
      * })
      * 	.setMinValues(1)
      * ```
      */
      constructor(data) {
        super({
          ...data,
          type: import_v104.ComponentType.MentionableSelect
        });
      }
    };
    __name(MentionableSelectMenuBuilder, "MentionableSelectMenuBuilder");
    var import_v105 = require_v106();
    var RoleSelectMenuBuilder = class extends BaseSelectMenuBuilder {
      /**
      * Creates a new select menu from API data
      *
      * @param data - The API data to create this select menu with
      * @example
      * Creating a select menu from an API data object
      * ```ts
      * const selectMenu = new RoleSelectMenuBuilder({
      * 	custom_id: 'a cool select menu',
      * 	placeholder: 'select an option',
      * 	max_values: 2,
      * });
      * ```
      * @example
      * Creating a select menu using setters and API data
      * ```ts
      * const selectMenu = new RoleSelectMenuBuilder({
      * 	custom_id: 'a cool select menu',
      * })
      * 	.setMinValues(1)
      * ```
      */
      constructor(data) {
        super({
          ...data,
          type: import_v105.ComponentType.RoleSelect
        });
      }
    };
    __name(RoleSelectMenuBuilder, "RoleSelectMenuBuilder");
    var import_v106 = require_v106();
    var StringSelectMenuBuilder = class extends BaseSelectMenuBuilder {
      /**
      * The options within this select menu
      */
      options;
      /**
      * Creates a new select menu from API data
      *
      * @param data - The API data to create this select menu with
      * @example
      * Creating a select menu from an API data object
      * ```ts
      * const selectMenu = new StringSelectMenuBuilder({
      * 	custom_id: 'a cool select menu',
      * 	placeholder: 'select an option',
      * 	max_values: 2,
      * 	options: [
      * 		{ label: 'option 1', value: '1' },
      * 		{ label: 'option 2', value: '2' },
      * 		{ label: 'option 3', value: '3' },
      * 	],
      * });
      * ```
      * @example
      * Creating a select menu using setters and API data
      * ```ts
      * const selectMenu = new StringSelectMenuBuilder({
      * 	custom_id: 'a cool select menu',
      * })
      * 	.setMinValues(1)
      * 	.addOptions({
      * 		label: 'Catchy',
      * 		value: 'catch',
      * 	});
      * ```
      */
      constructor(data) {
        const { options, ...initData } = data ?? {};
        super({
          ...initData,
          type: import_v106.ComponentType.StringSelect
        });
        this.options = options?.map((option) => new StringSelectMenuOptionBuilder(option)) ?? [];
      }
      /**
      * Adds options to this select menu
      *
      * @param options - The options to add to this select menu
      * @returns
      */
      addOptions(...options) {
        options = normalizeArray(options);
        optionsLengthValidator.parse(this.options.length + options.length);
        this.options.push(...options.map((option) => option instanceof StringSelectMenuOptionBuilder ? option : new StringSelectMenuOptionBuilder(jsonOptionValidator.parse(option))));
        return this;
      }
      /**
      * Sets the options on this select menu
      *
      * @param options - The options to set on this select menu
      */
      setOptions(...options) {
        return this.spliceOptions(0, this.options.length, ...options);
      }
      /**
      * Removes, replaces, or inserts options in the string select menu.
      *
      * @remarks
      * This method behaves similarly
      * to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice | Array.prototype.splice}.
      *
      * It's useful for modifying and adjusting order of the already-existing options of a string select menu.
      * @example
      * Remove the first option
      * ```ts
      * selectMenu.spliceOptions(0, 1);
      * ```
      * @example
      * Remove the first n option
      * ```ts
      * const n = 4
      * selectMenu.spliceOptions(0, n);
      * ```
      * @example
      * Remove the last option
      * ```ts
      * selectMenu.spliceOptions(-1, 1);
      * ```
      * @param index - The index to start at
      * @param deleteCount - The number of options to remove
      * @param options - The replacing option objects or builders
      */
      spliceOptions(index, deleteCount, ...options) {
        options = normalizeArray(options);
        const clone = [
          ...this.options
        ];
        clone.splice(index, deleteCount, ...options.map((option) => option instanceof StringSelectMenuOptionBuilder ? option : new StringSelectMenuOptionBuilder(jsonOptionValidator.parse(option))));
        optionsLengthValidator.parse(clone.length);
        this.options.splice(0, this.options.length, ...clone);
        return this;
      }
      /**
      * {@inheritDoc ComponentBuilder.toJSON}
      */
      toJSON() {
        validateRequiredSelectMenuParameters(this.options, this.data.custom_id);
        return {
          ...this.data,
          options: this.options.map((option) => option.toJSON())
        };
      }
    };
    __name(StringSelectMenuBuilder, "StringSelectMenuBuilder");
    var import_v107 = require_v106();
    var UserSelectMenuBuilder = class extends BaseSelectMenuBuilder {
      /**
      * Creates a new select menu from API data
      *
      * @param data - The API data to create this select menu with
      * @example
      * Creating a select menu from an API data object
      * ```ts
      * const selectMenu = new UserSelectMenuBuilder({
      * 	custom_id: 'a cool select menu',
      * 	placeholder: 'select an option',
      * 	max_values: 2,
      * });
      * ```
      * @example
      * Creating a select menu using setters and API data
      * ```ts
      * const selectMenu = new UserSelectMenuBuilder({
      * 	custom_id: 'a cool select menu',
      * })
      * 	.setMinValues(1)
      * ```
      */
      constructor(data) {
        super({
          ...data,
          type: import_v107.ComponentType.UserSelect
        });
      }
    };
    __name(UserSelectMenuBuilder, "UserSelectMenuBuilder");
    var import_util4 = require_dist2();
    var import_v109 = require_v106();
    var import_fast_deep_equal = __toESM2(require_fast_deep_equal());
    var Assertions_exports3 = {};
    __export2(Assertions_exports3, {
      labelValidator: () => labelValidator,
      maxLengthValidator: () => maxLengthValidator,
      minLengthValidator: () => minLengthValidator,
      placeholderValidator: () => placeholderValidator2,
      requiredValidator: () => requiredValidator,
      textInputStyleValidator: () => textInputStyleValidator,
      validateRequiredParameters: () => validateRequiredParameters,
      valueValidator: () => valueValidator
    });
    var import_shapeshift3 = require_dist6();
    var import_v108 = require_v106();
    var textInputStyleValidator = import_shapeshift3.s.nativeEnum(import_v108.TextInputStyle);
    var minLengthValidator = import_shapeshift3.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(4e3).setValidationEnabled(isValidationEnabled);
    var maxLengthValidator = import_shapeshift3.s.number.int.greaterThanOrEqual(1).lessThanOrEqual(4e3).setValidationEnabled(isValidationEnabled);
    var requiredValidator = import_shapeshift3.s.boolean;
    var valueValidator = import_shapeshift3.s.string.lengthLessThanOrEqual(4e3).setValidationEnabled(isValidationEnabled);
    var placeholderValidator2 = import_shapeshift3.s.string.lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
    var labelValidator = import_shapeshift3.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
    function validateRequiredParameters(customId, style, label) {
      customIdValidator.parse(customId);
      textInputStyleValidator.parse(style);
      labelValidator.parse(label);
    }
    __name(validateRequiredParameters, "validateRequiredParameters");
    var TextInputBuilder = class extends ComponentBuilder {
      /**
      * Creates a new text input from API data
      *
      * @param data - The API data to create this text input with
      * @example
      * Creating a select menu option from an API data object
      * ```ts
      * const textInput = new TextInputBuilder({
      * 	custom_id: 'a cool select menu',
      * 	label: 'Type something',
      * 	style: TextInputStyle.Short,
      * });
      * ```
      * @example
      * Creating a select menu option using setters and API data
      * ```ts
      * const textInput = new TextInputBuilder({
      * 	label: 'Type something else',
      * })
      * 	.setCustomId('woah')
      * 	.setStyle(TextInputStyle.Paragraph);
      * ```
      */
      constructor(data) {
        super({
          type: import_v109.ComponentType.TextInput,
          ...data
        });
      }
      /**
      * Sets the custom id for this text input
      *
      * @param customId - The custom id of this text input
      */
      setCustomId(customId) {
        this.data.custom_id = customIdValidator.parse(customId);
        return this;
      }
      /**
      * Sets the label for this text input
      *
      * @param label - The label for this text input
      */
      setLabel(label) {
        this.data.label = labelValidator.parse(label);
        return this;
      }
      /**
      * Sets the style for this text input
      *
      * @param style - The style for this text input
      */
      setStyle(style) {
        this.data.style = textInputStyleValidator.parse(style);
        return this;
      }
      /**
      * Sets the minimum length of text for this text input
      *
      * @param minLength - The minimum length of text for this text input
      */
      setMinLength(minLength) {
        this.data.min_length = minLengthValidator.parse(minLength);
        return this;
      }
      /**
      * Sets the maximum length of text for this text input
      *
      * @param maxLength - The maximum length of text for this text input
      */
      setMaxLength(maxLength) {
        this.data.max_length = maxLengthValidator.parse(maxLength);
        return this;
      }
      /**
      * Sets the placeholder of this text input
      *
      * @param placeholder - The placeholder of this text input
      */
      setPlaceholder(placeholder) {
        this.data.placeholder = placeholderValidator2.parse(placeholder);
        return this;
      }
      /**
      * Sets the value of this text input
      *
      * @param value - The value for this text input
      */
      setValue(value) {
        this.data.value = valueValidator.parse(value);
        return this;
      }
      /**
      * Sets whether this text input is required
      *
      * @param required - Whether this text input is required
      */
      setRequired(required = true) {
        this.data.required = requiredValidator.parse(required);
        return this;
      }
      /**
      * {@inheritDoc ComponentBuilder.toJSON}
      */
      toJSON() {
        validateRequiredParameters(this.data.custom_id, this.data.style, this.data.label);
        return {
          ...this.data
        };
      }
      /**
      * {@inheritDoc Equatable.equals}
      */
      equals(other) {
        if ((0, import_util4.isJSONEncodable)(other)) {
          return (0, import_fast_deep_equal.default)(other.toJSON(), this.data);
        }
        return (0, import_fast_deep_equal.default)(other, this.data);
      }
    };
    __name(TextInputBuilder, "TextInputBuilder");
    function createComponentBuilder(data) {
      if (data instanceof ComponentBuilder) {
        return data;
      }
      switch (data.type) {
        case import_v1010.ComponentType.ActionRow:
          return new ActionRowBuilder(data);
        case import_v1010.ComponentType.Button:
          return new ButtonBuilder(data);
        case import_v1010.ComponentType.StringSelect:
          return new StringSelectMenuBuilder(data);
        case import_v1010.ComponentType.TextInput:
          return new TextInputBuilder(data);
        case import_v1010.ComponentType.UserSelect:
          return new UserSelectMenuBuilder(data);
        case import_v1010.ComponentType.RoleSelect:
          return new RoleSelectMenuBuilder(data);
        case import_v1010.ComponentType.MentionableSelect:
          return new MentionableSelectMenuBuilder(data);
        case import_v1010.ComponentType.ChannelSelect:
          return new ChannelSelectMenuBuilder(data);
        default:
          throw new Error(`Cannot properly serialize component type: ${data.type}`);
      }
    }
    __name(createComponentBuilder, "createComponentBuilder");
    var ActionRowBuilder = class extends ComponentBuilder {
      /**
      * The components within this action row
      */
      components;
      /**
      * Creates a new action row from API data
      *
      * @param data - The API data to create this action row with
      * @example
      * Creating an action row from an API data object
      * ```ts
      * const actionRow = new ActionRowBuilder({
      * 	components: [
      * 		{
      * 			custom_id: "custom id",
      * 			label: "Type something",
      * 			style: TextInputStyle.Short,
      * 			type: ComponentType.TextInput,
      * 		},
      * 	],
      * });
      * ```
      * @example
      * Creating an action row using setters and API data
      * ```ts
      * const actionRow = new ActionRowBuilder({
      * 	components: [
      * 		{
      * 			custom_id: "custom id",
      * 			label: "Click me",
      * 			style: ButtonStyle.Primary,
      * 			type: ComponentType.Button,
      * 		},
      * 	],
      * })
      * 	.addComponents(button2, button3);
      * ```
      */
      constructor({ components, ...data } = {}) {
        super({
          type: import_v1011.ComponentType.ActionRow,
          ...data
        });
        this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
      }
      /**
      * Adds components to this action row.
      *
      * @param components - The components to add to this action row.
      */
      addComponents(...components) {
        this.components.push(...normalizeArray(components));
        return this;
      }
      /**
      * Sets the components in this action row
      *
      * @param components - The components to set this row to
      */
      setComponents(...components) {
        this.components.splice(0, this.components.length, ...normalizeArray(components));
        return this;
      }
      /**
      * {@inheritDoc ComponentBuilder.toJSON}
      */
      toJSON() {
        return {
          ...this.data,
          components: this.components.map((component) => component.toJSON())
        };
      }
    };
    __name(ActionRowBuilder, "ActionRowBuilder");
    var Assertions_exports4 = {};
    __export2(Assertions_exports4, {
      componentsValidator: () => componentsValidator,
      titleValidator: () => titleValidator,
      validateRequiredParameters: () => validateRequiredParameters2
    });
    var import_shapeshift4 = require_dist6();
    var titleValidator = import_shapeshift4.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
    var componentsValidator = import_shapeshift4.s.instance(ActionRowBuilder).array.lengthGreaterThanOrEqual(1).setValidationEnabled(isValidationEnabled);
    function validateRequiredParameters2(customId, title, components) {
      customIdValidator.parse(customId);
      titleValidator.parse(title);
      componentsValidator.parse(components);
    }
    __name(validateRequiredParameters2, "validateRequiredParameters");
    var ModalBuilder = class {
      data;
      components = [];
      constructor({ components, ...data } = {}) {
        this.data = {
          ...data
        };
        this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
      }
      /**
      * Sets the title of the modal
      *
      * @param title - The title of the modal
      */
      setTitle(title) {
        this.data.title = titleValidator.parse(title);
        return this;
      }
      /**
      * Sets the custom id of the modal
      *
      * @param customId - The custom id of this modal
      */
      setCustomId(customId) {
        this.data.custom_id = customIdValidator.parse(customId);
        return this;
      }
      /**
      * Adds components to this modal
      *
      * @param components - The components to add to this modal
      */
      addComponents(...components) {
        this.components.push(...normalizeArray(components).map((component) => component instanceof ActionRowBuilder ? component : new ActionRowBuilder(component)));
        return this;
      }
      /**
      * Sets the components in this modal
      *
      * @param components - The components to set this modal to
      */
      setComponents(...components) {
        this.components.splice(0, this.components.length, ...normalizeArray(components));
        return this;
      }
      /**
      * {@inheritDoc ComponentBuilder.toJSON}
      */
      toJSON() {
        validateRequiredParameters2(this.data.custom_id, this.data.title, this.components);
        return {
          ...this.data,
          components: this.components.map((component) => component.toJSON())
        };
      }
    };
    __name(ModalBuilder, "ModalBuilder");
    var Assertions_exports5 = {};
    __export2(Assertions_exports5, {
      assertReturnOfBuilder: () => assertReturnOfBuilder,
      localizationMapPredicate: () => localizationMapPredicate,
      validateChoicesLength: () => validateChoicesLength,
      validateDMPermission: () => validateDMPermission,
      validateDefaultMemberPermissions: () => validateDefaultMemberPermissions,
      validateDefaultPermission: () => validateDefaultPermission,
      validateDescription: () => validateDescription,
      validateLocale: () => validateLocale,
      validateLocalizationMap: () => validateLocalizationMap,
      validateMaxOptionsLength: () => validateMaxOptionsLength,
      validateNSFW: () => validateNSFW,
      validateName: () => validateName,
      validateRequired: () => validateRequired,
      validateRequiredParameters: () => validateRequiredParameters3
    });
    var import_shapeshift5 = require_dist6();
    var import_v1012 = require_v106();
    var namePredicate = import_shapeshift5.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^[\p{Ll}\p{Lm}\p{Lo}\p{N}\p{sc=Devanagari}\p{sc=Thai}_-]+$/u).setValidationEnabled(isValidationEnabled);
    function validateName(name) {
      namePredicate.parse(name);
    }
    __name(validateName, "validateName");
    var descriptionPredicate2 = import_shapeshift5.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
    var localePredicate = import_shapeshift5.s.nativeEnum(import_v1012.Locale);
    function validateDescription(description) {
      descriptionPredicate2.parse(description);
    }
    __name(validateDescription, "validateDescription");
    var maxArrayLengthPredicate = import_shapeshift5.s.unknown.array.lengthLessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
    function validateLocale(locale) {
      return localePredicate.parse(locale);
    }
    __name(validateLocale, "validateLocale");
    function validateMaxOptionsLength(options) {
      maxArrayLengthPredicate.parse(options);
    }
    __name(validateMaxOptionsLength, "validateMaxOptionsLength");
    function validateRequiredParameters3(name, description, options) {
      validateName(name);
      validateDescription(description);
      validateMaxOptionsLength(options);
    }
    __name(validateRequiredParameters3, "validateRequiredParameters");
    var booleanPredicate = import_shapeshift5.s.boolean;
    function validateDefaultPermission(value) {
      booleanPredicate.parse(value);
    }
    __name(validateDefaultPermission, "validateDefaultPermission");
    function validateRequired(required) {
      booleanPredicate.parse(required);
    }
    __name(validateRequired, "validateRequired");
    var choicesLengthPredicate = import_shapeshift5.s.number.lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
    function validateChoicesLength(amountAdding, choices) {
      choicesLengthPredicate.parse((choices?.length ?? 0) + amountAdding);
    }
    __name(validateChoicesLength, "validateChoicesLength");
    function assertReturnOfBuilder(input, ExpectedInstanceOf) {
      import_shapeshift5.s.instance(ExpectedInstanceOf).parse(input);
    }
    __name(assertReturnOfBuilder, "assertReturnOfBuilder");
    var localizationMapPredicate = import_shapeshift5.s.object(Object.fromEntries(Object.values(import_v1012.Locale).map((locale) => [
      locale,
      import_shapeshift5.s.string.nullish
    ]))).strict.nullish.setValidationEnabled(isValidationEnabled);
    function validateLocalizationMap(value) {
      localizationMapPredicate.parse(value);
    }
    __name(validateLocalizationMap, "validateLocalizationMap");
    var dmPermissionPredicate = import_shapeshift5.s.boolean.nullish;
    function validateDMPermission(value) {
      dmPermissionPredicate.parse(value);
    }
    __name(validateDMPermission, "validateDMPermission");
    var memberPermissionPredicate = import_shapeshift5.s.union(import_shapeshift5.s.bigint.transform((value) => value.toString()), import_shapeshift5.s.number.safeInt.transform((value) => value.toString()), import_shapeshift5.s.string.regex(/^\d+$/)).nullish;
    function validateDefaultMemberPermissions(permissions) {
      return memberPermissionPredicate.parse(permissions);
    }
    __name(validateDefaultMemberPermissions, "validateDefaultMemberPermissions");
    function validateNSFW(value) {
      booleanPredicate.parse(value);
    }
    __name(validateNSFW, "validateNSFW");
    var import_ts_mixer6 = require_cjs();
    var import_v1024 = require_v106();
    var import_ts_mixer5 = require_cjs();
    var SharedNameAndDescription = class {
      name;
      name_localizations;
      description;
      description_localizations;
      /**
      * Sets the name
      *
      * @param name - The name
      */
      setName(name) {
        validateName(name);
        Reflect.set(this, "name", name);
        return this;
      }
      /**
      * Sets the description
      *
      * @param description - The description
      */
      setDescription(description) {
        validateDescription(description);
        Reflect.set(this, "description", description);
        return this;
      }
      /**
      * Sets a name localization
      *
      * @param locale - The locale to set a description for
      * @param localizedName - The localized description for the given locale
      */
      setNameLocalization(locale, localizedName) {
        if (!this.name_localizations) {
          Reflect.set(this, "name_localizations", {});
        }
        const parsedLocale = validateLocale(locale);
        if (localizedName === null) {
          this.name_localizations[parsedLocale] = null;
          return this;
        }
        validateName(localizedName);
        this.name_localizations[parsedLocale] = localizedName;
        return this;
      }
      /**
      * Sets the name localizations
      *
      * @param localizedNames - The dictionary of localized descriptions to set
      */
      setNameLocalizations(localizedNames) {
        if (localizedNames === null) {
          Reflect.set(this, "name_localizations", null);
          return this;
        }
        Reflect.set(this, "name_localizations", {});
        for (const args of Object.entries(localizedNames)) {
          this.setNameLocalization(...args);
        }
        return this;
      }
      /**
      * Sets a description localization
      *
      * @param locale - The locale to set a description for
      * @param localizedDescription - The localized description for the given locale
      */
      setDescriptionLocalization(locale, localizedDescription) {
        if (!this.description_localizations) {
          Reflect.set(this, "description_localizations", {});
        }
        const parsedLocale = validateLocale(locale);
        if (localizedDescription === null) {
          this.description_localizations[parsedLocale] = null;
          return this;
        }
        validateDescription(localizedDescription);
        this.description_localizations[parsedLocale] = localizedDescription;
        return this;
      }
      /**
      * Sets the description localizations
      *
      * @param localizedDescriptions - The dictionary of localized descriptions to set
      */
      setDescriptionLocalizations(localizedDescriptions) {
        if (localizedDescriptions === null) {
          Reflect.set(this, "description_localizations", null);
          return this;
        }
        Reflect.set(this, "description_localizations", {});
        for (const args of Object.entries(localizedDescriptions)) {
          this.setDescriptionLocalization(...args);
        }
        return this;
      }
    };
    __name(SharedNameAndDescription, "SharedNameAndDescription");
    var import_v1013 = require_v106();
    var ApplicationCommandOptionBase = class extends SharedNameAndDescription {
      required = false;
      /**
      * Marks the option as required
      *
      * @param required - If this option should be required
      */
      setRequired(required) {
        validateRequired(required);
        Reflect.set(this, "required", required);
        return this;
      }
      runRequiredValidations() {
        validateRequiredParameters3(this.name, this.description, []);
        validateLocalizationMap(this.name_localizations);
        validateLocalizationMap(this.description_localizations);
        validateRequired(this.required);
      }
    };
    __name(ApplicationCommandOptionBase, "ApplicationCommandOptionBase");
    var SlashCommandAttachmentOption = class extends ApplicationCommandOptionBase {
      type = import_v1013.ApplicationCommandOptionType.Attachment;
      toJSON() {
        this.runRequiredValidations();
        return {
          ...this
        };
      }
    };
    __name(SlashCommandAttachmentOption, "SlashCommandAttachmentOption");
    var import_v1014 = require_v106();
    var SlashCommandBooleanOption = class extends ApplicationCommandOptionBase {
      type = import_v1014.ApplicationCommandOptionType.Boolean;
      toJSON() {
        this.runRequiredValidations();
        return {
          ...this
        };
      }
    };
    __name(SlashCommandBooleanOption, "SlashCommandBooleanOption");
    var import_v1016 = require_v106();
    var import_ts_mixer = require_cjs();
    var import_shapeshift6 = require_dist6();
    var import_v1015 = require_v106();
    var allowedChannelTypes = [
      import_v1015.ChannelType.GuildText,
      import_v1015.ChannelType.GuildVoice,
      import_v1015.ChannelType.GuildCategory,
      import_v1015.ChannelType.GuildAnnouncement,
      import_v1015.ChannelType.AnnouncementThread,
      import_v1015.ChannelType.PublicThread,
      import_v1015.ChannelType.PrivateThread,
      import_v1015.ChannelType.GuildStageVoice,
      import_v1015.ChannelType.GuildForum
    ];
    var channelTypesPredicate = import_shapeshift6.s.array(import_shapeshift6.s.union(...allowedChannelTypes.map((type) => import_shapeshift6.s.literal(type))));
    var ApplicationCommandOptionChannelTypesMixin = class {
      channel_types;
      /**
      * Adds channel types to this option
      *
      * @param channelTypes - The channel types to add
      */
      addChannelTypes(...channelTypes) {
        if (this.channel_types === void 0) {
          Reflect.set(this, "channel_types", []);
        }
        this.channel_types.push(...channelTypesPredicate.parse(channelTypes));
        return this;
      }
    };
    __name(ApplicationCommandOptionChannelTypesMixin, "ApplicationCommandOptionChannelTypesMixin");
    var __decorate2 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var SlashCommandChannelOption = /* @__PURE__ */ __name(class SlashCommandChannelOption2 extends ApplicationCommandOptionBase {
      type = import_v1016.ApplicationCommandOptionType.Channel;
      toJSON() {
        this.runRequiredValidations();
        return {
          ...this
        };
      }
    }, "SlashCommandChannelOption");
    SlashCommandChannelOption = __decorate2([
      (0, import_ts_mixer.mix)(ApplicationCommandOptionChannelTypesMixin)
    ], SlashCommandChannelOption);
    var import_shapeshift8 = require_dist6();
    var import_v1018 = require_v106();
    var import_ts_mixer2 = require_cjs();
    var ApplicationCommandNumericOptionMinMaxValueMixin = class {
      max_value;
      min_value;
    };
    __name(ApplicationCommandNumericOptionMinMaxValueMixin, "ApplicationCommandNumericOptionMinMaxValueMixin");
    var import_shapeshift7 = require_dist6();
    var import_v1017 = require_v106();
    var stringPredicate = import_shapeshift7.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100);
    var numberPredicate = import_shapeshift7.s.number.greaterThan(Number.NEGATIVE_INFINITY).lessThan(Number.POSITIVE_INFINITY);
    var choicesPredicate = import_shapeshift7.s.object({
      name: stringPredicate,
      name_localizations: localizationMapPredicate,
      value: import_shapeshift7.s.union(stringPredicate, numberPredicate)
    }).array;
    var booleanPredicate2 = import_shapeshift7.s.boolean;
    var ApplicationCommandOptionWithChoicesAndAutocompleteMixin = class {
      choices;
      autocomplete;
      // Since this is present and this is a mixin, this is needed
      type;
      /**
      * Adds multiple choices for this option
      *
      * @param choices - The choices to add
      */
      addChoices(...choices) {
        if (choices.length > 0 && this.autocomplete) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        choicesPredicate.parse(choices);
        if (this.choices === void 0) {
          Reflect.set(this, "choices", []);
        }
        validateChoicesLength(choices.length, this.choices);
        for (const { name, name_localizations, value } of choices) {
          if (this.type === import_v1017.ApplicationCommandOptionType.String) {
            stringPredicate.parse(value);
          } else {
            numberPredicate.parse(value);
          }
          this.choices.push({
            name,
            name_localizations,
            value
          });
        }
        return this;
      }
      setChoices(...choices) {
        if (choices.length > 0 && this.autocomplete) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        choicesPredicate.parse(choices);
        Reflect.set(this, "choices", []);
        this.addChoices(...choices);
        return this;
      }
      /**
      * Marks the option as autocompletable
      *
      * @param autocomplete - If this option should be autocompletable
      */
      setAutocomplete(autocomplete) {
        booleanPredicate2.parse(autocomplete);
        if (autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        Reflect.set(this, "autocomplete", autocomplete);
        return this;
      }
    };
    __name(ApplicationCommandOptionWithChoicesAndAutocompleteMixin, "ApplicationCommandOptionWithChoicesAndAutocompleteMixin");
    var __decorate22 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var numberValidator = import_shapeshift8.s.number.int;
    var SlashCommandIntegerOption = /* @__PURE__ */ __name(class SlashCommandIntegerOption2 extends ApplicationCommandOptionBase {
      type = import_v1018.ApplicationCommandOptionType.Integer;
      /**
      * {@inheritDoc ApplicationCommandNumericOptionMinMaxValueMixin.setMaxValue}
      */
      setMaxValue(max) {
        numberValidator.parse(max);
        Reflect.set(this, "max_value", max);
        return this;
      }
      /**
      * {@inheritDoc ApplicationCommandNumericOptionMinMaxValueMixin.setMinValue}
      */
      setMinValue(min) {
        numberValidator.parse(min);
        Reflect.set(this, "min_value", min);
        return this;
      }
      toJSON() {
        this.runRequiredValidations();
        if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        return {
          ...this
        };
      }
    }, "SlashCommandIntegerOption");
    SlashCommandIntegerOption = __decorate22([
      (0, import_ts_mixer2.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithChoicesAndAutocompleteMixin)
    ], SlashCommandIntegerOption);
    var import_v1019 = require_v106();
    var SlashCommandMentionableOption = class extends ApplicationCommandOptionBase {
      type = import_v1019.ApplicationCommandOptionType.Mentionable;
      toJSON() {
        this.runRequiredValidations();
        return {
          ...this
        };
      }
    };
    __name(SlashCommandMentionableOption, "SlashCommandMentionableOption");
    var import_shapeshift9 = require_dist6();
    var import_v1020 = require_v106();
    var import_ts_mixer3 = require_cjs();
    var __decorate3 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var numberValidator2 = import_shapeshift9.s.number;
    var SlashCommandNumberOption = /* @__PURE__ */ __name(class SlashCommandNumberOption2 extends ApplicationCommandOptionBase {
      type = import_v1020.ApplicationCommandOptionType.Number;
      /**
      * {@inheritDoc ApplicationCommandNumericOptionMinMaxValueMixin.setMaxValue}
      */
      setMaxValue(max) {
        numberValidator2.parse(max);
        Reflect.set(this, "max_value", max);
        return this;
      }
      /**
      * {@inheritDoc ApplicationCommandNumericOptionMinMaxValueMixin.setMinValue}
      */
      setMinValue(min) {
        numberValidator2.parse(min);
        Reflect.set(this, "min_value", min);
        return this;
      }
      toJSON() {
        this.runRequiredValidations();
        if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        return {
          ...this
        };
      }
    }, "SlashCommandNumberOption");
    SlashCommandNumberOption = __decorate3([
      (0, import_ts_mixer3.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithChoicesAndAutocompleteMixin)
    ], SlashCommandNumberOption);
    var import_v1021 = require_v106();
    var SlashCommandRoleOption = class extends ApplicationCommandOptionBase {
      type = import_v1021.ApplicationCommandOptionType.Role;
      toJSON() {
        this.runRequiredValidations();
        return {
          ...this
        };
      }
    };
    __name(SlashCommandRoleOption, "SlashCommandRoleOption");
    var import_shapeshift10 = require_dist6();
    var import_v1022 = require_v106();
    var import_ts_mixer4 = require_cjs();
    var __decorate4 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var minLengthValidator2 = import_shapeshift10.s.number.greaterThanOrEqual(0).lessThanOrEqual(6e3);
    var maxLengthValidator2 = import_shapeshift10.s.number.greaterThanOrEqual(1).lessThanOrEqual(6e3);
    var SlashCommandStringOption = /* @__PURE__ */ __name(class SlashCommandStringOption2 extends ApplicationCommandOptionBase {
      type = import_v1022.ApplicationCommandOptionType.String;
      max_length;
      min_length;
      /**
      * Sets the maximum length of this string option.
      *
      * @param max - The maximum length this option can be
      */
      setMaxLength(max) {
        maxLengthValidator2.parse(max);
        Reflect.set(this, "max_length", max);
        return this;
      }
      /**
      * Sets the minimum length of this string option.
      *
      * @param min - The minimum length this option can be
      */
      setMinLength(min) {
        minLengthValidator2.parse(min);
        Reflect.set(this, "min_length", min);
        return this;
      }
      toJSON() {
        this.runRequiredValidations();
        if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        return {
          ...this
        };
      }
    }, "SlashCommandStringOption");
    SlashCommandStringOption = __decorate4([
      (0, import_ts_mixer4.mix)(ApplicationCommandOptionWithChoicesAndAutocompleteMixin)
    ], SlashCommandStringOption);
    var import_v1023 = require_v106();
    var SlashCommandUserOption = class extends ApplicationCommandOptionBase {
      type = import_v1023.ApplicationCommandOptionType.User;
      toJSON() {
        this.runRequiredValidations();
        return {
          ...this
        };
      }
    };
    __name(SlashCommandUserOption, "SlashCommandUserOption");
    var SharedSlashCommandOptions = class {
      options;
      /**
      * Adds a boolean option
      *
      * @param input - A function that returns an option builder, or an already built builder
      */
      addBooleanOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandBooleanOption);
      }
      /**
      * Adds a user option
      *
      * @param input - A function that returns an option builder, or an already built builder
      */
      addUserOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandUserOption);
      }
      /**
      * Adds a channel option
      *
      * @param input - A function that returns an option builder, or an already built builder
      */
      addChannelOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandChannelOption);
      }
      /**
      * Adds a role option
      *
      * @param input - A function that returns an option builder, or an already built builder
      */
      addRoleOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandRoleOption);
      }
      /**
      * Adds an attachment option
      *
      * @param input - A function that returns an option builder, or an already built builder
      */
      addAttachmentOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandAttachmentOption);
      }
      /**
      * Adds a mentionable option
      *
      * @param input - A function that returns an option builder, or an already built builder
      */
      addMentionableOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandMentionableOption);
      }
      /**
      * Adds a string option
      *
      * @param input - A function that returns an option builder, or an already built builder
      */
      addStringOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandStringOption);
      }
      /**
      * Adds an integer option
      *
      * @param input - A function that returns an option builder, or an already built builder
      */
      addIntegerOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandIntegerOption);
      }
      /**
      * Adds a number option
      *
      * @param input - A function that returns an option builder, or an already built builder
      */
      addNumberOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandNumberOption);
      }
      _sharedAddOptionMethod(input, Instance) {
        const { options } = this;
        validateMaxOptionsLength(options);
        const result = typeof input === "function" ? input(new Instance()) : input;
        assertReturnOfBuilder(result, Instance);
        options.push(result);
        return this;
      }
    };
    __name(SharedSlashCommandOptions, "SharedSlashCommandOptions");
    var __decorate5 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var SlashCommandSubcommandGroupBuilder = /* @__PURE__ */ __name(class SlashCommandSubcommandGroupBuilder2 {
      /**
      * The name of this subcommand group
      */
      name = void 0;
      /**
      * The description of this subcommand group
      */
      description = void 0;
      /**
      * The subcommands part of this subcommand group
      */
      options = [];
      /**
      * Adds a new subcommand to this group
      *
      * @param input - A function that returns a subcommand builder, or an already built builder
      */
      addSubcommand(input) {
        const { options } = this;
        validateMaxOptionsLength(options);
        const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder()) : input;
        assertReturnOfBuilder(result, SlashCommandSubcommandBuilder);
        options.push(result);
        return this;
      }
      toJSON() {
        validateRequiredParameters3(this.name, this.description, this.options);
        return {
          type: import_v1024.ApplicationCommandOptionType.SubcommandGroup,
          name: this.name,
          name_localizations: this.name_localizations,
          description: this.description,
          description_localizations: this.description_localizations,
          options: this.options.map((option) => option.toJSON())
        };
      }
    }, "SlashCommandSubcommandGroupBuilder");
    SlashCommandSubcommandGroupBuilder = __decorate5([
      (0, import_ts_mixer5.mix)(SharedNameAndDescription)
    ], SlashCommandSubcommandGroupBuilder);
    var SlashCommandSubcommandBuilder = /* @__PURE__ */ __name(class SlashCommandSubcommandBuilder2 {
      /**
      * The name of this subcommand
      */
      name = void 0;
      /**
      * The description of this subcommand
      */
      description = void 0;
      /**
      * The options of this subcommand
      */
      options = [];
      toJSON() {
        validateRequiredParameters3(this.name, this.description, this.options);
        return {
          type: import_v1024.ApplicationCommandOptionType.Subcommand,
          name: this.name,
          name_localizations: this.name_localizations,
          description: this.description,
          description_localizations: this.description_localizations,
          options: this.options.map((option) => option.toJSON())
        };
      }
    }, "SlashCommandSubcommandBuilder");
    SlashCommandSubcommandBuilder = __decorate5([
      (0, import_ts_mixer5.mix)(SharedNameAndDescription, SharedSlashCommandOptions)
    ], SlashCommandSubcommandBuilder);
    var __decorate6 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var SlashCommandBuilder = /* @__PURE__ */ __name(class SlashCommandBuilder2 {
      /**
      * The name of this slash command
      */
      name = void 0;
      /**
      * The localized names for this command
      */
      name_localizations;
      /**
      * The description of this slash command
      */
      description = void 0;
      /**
      * The localized descriptions for this command
      */
      description_localizations;
      /**
      * The options of this slash command
      */
      options = [];
      /**
      * Whether the command is enabled by default when the app is added to a guild
      *
      * @deprecated This property is deprecated and will be removed in the future.
      * You should use {@link (SlashCommandBuilder:class).setDefaultMemberPermissions} or {@link (SlashCommandBuilder:class).setDMPermission} instead.
      */
      default_permission = void 0;
      /**
      * Set of permissions represented as a bit set for the command
      */
      default_member_permissions = void 0;
      /**
      * Indicates whether the command is available in DMs with the application, only for globally-scoped commands.
      * By default, commands are visible.
      */
      dm_permission = void 0;
      /**
      * Whether this command is NSFW
      */
      nsfw = void 0;
      /**
      * Returns the final data that should be sent to Discord.
      *
      * @remarks
      * This method runs validations on the data before serializing it.
      * As such, it may throw an error if the data is invalid.
      */
      toJSON() {
        validateRequiredParameters3(this.name, this.description, this.options);
        validateLocalizationMap(this.name_localizations);
        validateLocalizationMap(this.description_localizations);
        return {
          ...this,
          options: this.options.map((option) => option.toJSON())
        };
      }
      /**
      * Sets whether the command is enabled by default when the application is added to a guild.
      *
      * @remarks
      * If set to `false`, you will have to later `PUT` the permissions for this command.
      * @param value - Whether or not to enable this command by default
      * @see https://discord.com/developers/docs/interactions/application-commands#permissions
      * @deprecated Use {@link (SlashCommandBuilder:class).setDefaultMemberPermissions} or {@link (SlashCommandBuilder:class).setDMPermission} instead.
      */
      setDefaultPermission(value) {
        validateDefaultPermission(value);
        Reflect.set(this, "default_permission", value);
        return this;
      }
      /**
      * Sets the default permissions a member should have in order to run the command.
      *
      * @remarks
      * You can set this to `'0'` to disable the command by default.
      * @param permissions - The permissions bit field to set
      * @see https://discord.com/developers/docs/interactions/application-commands#permissions
      */
      setDefaultMemberPermissions(permissions) {
        const permissionValue = validateDefaultMemberPermissions(permissions);
        Reflect.set(this, "default_member_permissions", permissionValue);
        return this;
      }
      /**
      * Sets if the command is available in DMs with the application, only for globally-scoped commands.
      * By default, commands are visible.
      *
      * @param enabled - If the command should be enabled in DMs
      * @see https://discord.com/developers/docs/interactions/application-commands#permissions
      */
      setDMPermission(enabled) {
        validateDMPermission(enabled);
        Reflect.set(this, "dm_permission", enabled);
        return this;
      }
      /**
      * Sets whether this command is NSFW
      *
      * @param nsfw - Whether this command is NSFW
      */
      setNSFW(nsfw = true) {
        validateNSFW(nsfw);
        Reflect.set(this, "nsfw", nsfw);
        return this;
      }
      /**
      * Adds a new subcommand group to this command
      *
      * @param input - A function that returns a subcommand group builder, or an already built builder
      */
      addSubcommandGroup(input) {
        const { options } = this;
        validateMaxOptionsLength(options);
        const result = typeof input === "function" ? input(new SlashCommandSubcommandGroupBuilder()) : input;
        assertReturnOfBuilder(result, SlashCommandSubcommandGroupBuilder);
        options.push(result);
        return this;
      }
      /**
      * Adds a new subcommand to this command
      *
      * @param input - A function that returns a subcommand builder, or an already built builder
      */
      addSubcommand(input) {
        const { options } = this;
        validateMaxOptionsLength(options);
        const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder()) : input;
        assertReturnOfBuilder(result, SlashCommandSubcommandBuilder);
        options.push(result);
        return this;
      }
    }, "SlashCommandBuilder");
    SlashCommandBuilder = __decorate6([
      (0, import_ts_mixer6.mix)(SharedSlashCommandOptions, SharedNameAndDescription)
    ], SlashCommandBuilder);
    var Assertions_exports6 = {};
    __export2(Assertions_exports6, {
      validateDMPermission: () => validateDMPermission2,
      validateDefaultMemberPermissions: () => validateDefaultMemberPermissions2,
      validateDefaultPermission: () => validateDefaultPermission2,
      validateName: () => validateName2,
      validateRequiredParameters: () => validateRequiredParameters4,
      validateType: () => validateType
    });
    var import_shapeshift11 = require_dist6();
    var import_v1025 = require_v106();
    var namePredicate2 = import_shapeshift11.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^( *[\p{P}\p{L}\p{N}\p{sc=Devanagari}\p{sc=Thai}]+ *)+$/u).setValidationEnabled(isValidationEnabled);
    var typePredicate = import_shapeshift11.s.union(import_shapeshift11.s.literal(import_v1025.ApplicationCommandType.User), import_shapeshift11.s.literal(import_v1025.ApplicationCommandType.Message)).setValidationEnabled(isValidationEnabled);
    var booleanPredicate3 = import_shapeshift11.s.boolean;
    function validateDefaultPermission2(value) {
      booleanPredicate3.parse(value);
    }
    __name(validateDefaultPermission2, "validateDefaultPermission");
    function validateName2(name) {
      namePredicate2.parse(name);
    }
    __name(validateName2, "validateName");
    function validateType(type) {
      typePredicate.parse(type);
    }
    __name(validateType, "validateType");
    function validateRequiredParameters4(name, type) {
      validateName2(name);
      validateType(type);
    }
    __name(validateRequiredParameters4, "validateRequiredParameters");
    var dmPermissionPredicate2 = import_shapeshift11.s.boolean.nullish;
    function validateDMPermission2(value) {
      dmPermissionPredicate2.parse(value);
    }
    __name(validateDMPermission2, "validateDMPermission");
    var memberPermissionPredicate2 = import_shapeshift11.s.union(import_shapeshift11.s.bigint.transform((value) => value.toString()), import_shapeshift11.s.number.safeInt.transform((value) => value.toString()), import_shapeshift11.s.string.regex(/^\d+$/)).nullish;
    function validateDefaultMemberPermissions2(permissions) {
      return memberPermissionPredicate2.parse(permissions);
    }
    __name(validateDefaultMemberPermissions2, "validateDefaultMemberPermissions");
    var ContextMenuCommandBuilder = class {
      /**
      * The name of this context menu command
      */
      name = void 0;
      /**
      * The localized names for this command
      */
      name_localizations;
      /**
      * The type of this context menu command
      */
      type = void 0;
      /**
      * Whether the command is enabled by default when the app is added to a guild
      *
      * @deprecated This property is deprecated and will be removed in the future.
      * You should use {@link ContextMenuCommandBuilder.setDefaultMemberPermissions} or {@link ContextMenuCommandBuilder.setDMPermission} instead.
      */
      default_permission = void 0;
      /**
      * Set of permissions represented as a bit set for the command
      */
      default_member_permissions = void 0;
      /**
      * Indicates whether the command is available in DMs with the application, only for globally-scoped commands.
      * By default, commands are visible.
      */
      dm_permission = void 0;
      /**
      * Sets the name
      *
      * @param name - The name
      */
      setName(name) {
        validateName2(name);
        Reflect.set(this, "name", name);
        return this;
      }
      /**
      * Sets the type
      *
      * @param type - The type
      */
      setType(type) {
        validateType(type);
        Reflect.set(this, "type", type);
        return this;
      }
      /**
      * Sets whether the command is enabled by default when the application is added to a guild.
      *
      * @remarks
      * If set to `false`, you will have to later `PUT` the permissions for this command.
      * @param value - Whether or not to enable this command by default
      * @see https://discord.com/developers/docs/interactions/application-commands#permissions
      * @deprecated Use {@link ContextMenuCommandBuilder.setDefaultMemberPermissions} or {@link ContextMenuCommandBuilder.setDMPermission} instead.
      */
      setDefaultPermission(value) {
        validateDefaultPermission2(value);
        Reflect.set(this, "default_permission", value);
        return this;
      }
      /**
      * Sets the default permissions a member should have in order to run the command.
      *
      * @remarks
      * You can set this to `'0'` to disable the command by default.
      * @param permissions - The permissions bit field to set
      * @see https://discord.com/developers/docs/interactions/application-commands#permissions
      */
      setDefaultMemberPermissions(permissions) {
        const permissionValue = validateDefaultMemberPermissions2(permissions);
        Reflect.set(this, "default_member_permissions", permissionValue);
        return this;
      }
      /**
      * Sets if the command is available in DMs with the application, only for globally-scoped commands.
      * By default, commands are visible.
      *
      * @param enabled - If the command should be enabled in DMs
      * @see https://discord.com/developers/docs/interactions/application-commands#permissions
      */
      setDMPermission(enabled) {
        validateDMPermission2(enabled);
        Reflect.set(this, "dm_permission", enabled);
        return this;
      }
      /**
      * Sets a name localization
      *
      * @param locale - The locale to set a description for
      * @param localizedName - The localized description for the given locale
      */
      setNameLocalization(locale, localizedName) {
        if (!this.name_localizations) {
          Reflect.set(this, "name_localizations", {});
        }
        const parsedLocale = validateLocale(locale);
        if (localizedName === null) {
          this.name_localizations[parsedLocale] = null;
          return this;
        }
        validateName2(localizedName);
        this.name_localizations[parsedLocale] = localizedName;
        return this;
      }
      /**
      * Sets the name localizations
      *
      * @param localizedNames - The dictionary of localized descriptions to set
      */
      setNameLocalizations(localizedNames) {
        if (localizedNames === null) {
          Reflect.set(this, "name_localizations", null);
          return this;
        }
        Reflect.set(this, "name_localizations", {});
        for (const args of Object.entries(localizedNames))
          this.setNameLocalization(...args);
        return this;
      }
      /**
      * Returns the final data that should be sent to Discord.
      *
      * @remarks
      * This method runs validations on the data before serializing it.
      * As such, it may throw an error if the data is invalid.
      */
      toJSON() {
        validateRequiredParameters4(this.name, this.type);
        validateLocalizationMap(this.name_localizations);
        return {
          ...this
        };
      }
    };
    __name(ContextMenuCommandBuilder, "ContextMenuCommandBuilder");
    function embedLength(data) {
      return (data.title?.length ?? 0) + (data.description?.length ?? 0) + (data.fields?.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0) ?? 0) + (data.footer?.text.length ?? 0) + (data.author?.name.length ?? 0);
    }
    __name(embedLength, "embedLength");
    __reExport(src_exports, require_dist2(), module2.exports);
    var version = "1.6.1";
  }
});

// node_modules/discord.js/src/structures/Base.js
var require_Base = __commonJS({
  "node_modules/discord.js/src/structures/Base.js"(exports2, module2) {
    "use strict";
    var { flatten } = require_Util();
    var Base = class {
      constructor(client) {
        Object.defineProperty(this, "client", { value: client });
      }
      _clone() {
        return Object.assign(Object.create(this), this);
      }
      _patch(data) {
        return data;
      }
      _update(data) {
        const clone = this._clone();
        this._patch(data);
        return clone;
      }
      toJSON(...props) {
        return flatten(this, ...props);
      }
      valueOf() {
        return this.id;
      }
    };
    module2.exports = Base;
  }
});

// node_modules/discord.js/src/util/BitField.js
var require_BitField = __commonJS({
  "node_modules/discord.js/src/util/BitField.js"(exports2, module2) {
    "use strict";
    var { DiscordjsRangeError: DiscordjsRangeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var _BitField = class {
      /**
       * @param {BitFieldResolvable} [bits=this.constructor.DefaultBit] Bit(s) to read from
       */
      constructor(bits = this.constructor.DefaultBit) {
        this.bitfield = this.constructor.resolve(bits);
      }
      /**
       * Checks whether the bitfield has a bit, or any of multiple bits.
       * @param {BitFieldResolvable} bit Bit(s) to check for
       * @returns {boolean}
       */
      any(bit) {
        return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.DefaultBit;
      }
      /**
       * Checks if this bitfield equals another
       * @param {BitFieldResolvable} bit Bit(s) to check for
       * @returns {boolean}
       */
      equals(bit) {
        return this.bitfield === this.constructor.resolve(bit);
      }
      /**
       * Checks whether the bitfield has a bit, or multiple bits.
       * @param {BitFieldResolvable} bit Bit(s) to check for
       * @returns {boolean}
       */
      has(bit) {
        bit = this.constructor.resolve(bit);
        return (this.bitfield & bit) === bit;
      }
      /**
       * Gets all given bits that are missing from the bitfield.
       * @param {BitFieldResolvable} bits Bit(s) to check for
       * @param {...*} hasParams Additional parameters for the has method, if any
       * @returns {string[]}
       */
      missing(bits, ...hasParams) {
        return new this.constructor(bits).remove(this).toArray(...hasParams);
      }
      /**
       * Freezes these bits, making them immutable.
       * @returns {Readonly<BitField>}
       */
      freeze() {
        return Object.freeze(this);
      }
      /**
       * Adds bits to these ones.
       * @param {...BitFieldResolvable} [bits] Bits to add
       * @returns {BitField} These bits or new BitField if the instance is frozen.
       */
      add(...bits) {
        let total = this.constructor.DefaultBit;
        for (const bit of bits) {
          total |= this.constructor.resolve(bit);
        }
        if (Object.isFrozen(this))
          return new this.constructor(this.bitfield | total);
        this.bitfield |= total;
        return this;
      }
      /**
       * Removes bits from these.
       * @param {...BitFieldResolvable} [bits] Bits to remove
       * @returns {BitField} These bits or new BitField if the instance is frozen.
       */
      remove(...bits) {
        let total = this.constructor.DefaultBit;
        for (const bit of bits) {
          total |= this.constructor.resolve(bit);
        }
        if (Object.isFrozen(this))
          return new this.constructor(this.bitfield & ~total);
        this.bitfield &= ~total;
        return this;
      }
      /**
       * Gets an object mapping field names to a {@link boolean} indicating whether the
       * bit is available.
       * @param {...*} hasParams Additional parameters for the has method, if any
       * @returns {Object}
       */
      serialize(...hasParams) {
        const serialized = {};
        for (const [flag, bit] of Object.entries(this.constructor.Flags))
          serialized[flag] = this.has(bit, ...hasParams);
        return serialized;
      }
      /**
       * Gets an {@link Array} of bitfield names based on the bits available.
       * @param {...*} hasParams Additional parameters for the has method, if any
       * @returns {string[]}
       */
      toArray(...hasParams) {
        return [...this[Symbol.iterator](...hasParams)];
      }
      toJSON() {
        return typeof this.bitfield === "number" ? this.bitfield : this.bitfield.toString();
      }
      valueOf() {
        return this.bitfield;
      }
      *[Symbol.iterator](...hasParams) {
        for (const bitName of Object.keys(this.constructor.Flags)) {
          if (this.has(bitName, ...hasParams))
            yield bitName;
        }
      }
      /**
       * Data that can be resolved to give a bitfield. This can be:
       * * A bit number (this can be a number literal or a value taken from {@link BitField.Flags})
       * * A string bit number
       * * An instance of BitField
       * * An Array of BitFieldResolvable
       * @typedef {number|string|bigint|BitField|BitFieldResolvable[]} BitFieldResolvable
       */
      /**
       * Resolves bitfields to their numeric form.
       * @param {BitFieldResolvable} [bit] bit(s) to resolve
       * @returns {number|bigint}
       */
      static resolve(bit) {
        const { DefaultBit } = this;
        if (typeof DefaultBit === typeof bit && bit >= DefaultBit)
          return bit;
        if (bit instanceof _BitField)
          return bit.bitfield;
        if (Array.isArray(bit))
          return bit.map((p) => this.resolve(p)).reduce((prev, p) => prev | p, DefaultBit);
        if (typeof bit === "string") {
          if (!isNaN(bit))
            return typeof DefaultBit === "bigint" ? BigInt(bit) : Number(bit);
          if (this.Flags[bit] !== void 0)
            return this.Flags[bit];
        }
        throw new DiscordjsRangeError2(ErrorCodes2.BitFieldInvalid, bit);
      }
    };
    var BitField = _BitField;
    /**
     * Numeric bitfield flags.
     * <info>Defined in extension classes</info>
     * @type {Object}
     * @memberof BitField
     * @abstract
     */
    __publicField(BitField, "Flags", {});
    /**
     * @type {number|bigint}
     * @memberof BitField
     * @private
     */
    __publicField(BitField, "DefaultBit", 0);
    module2.exports = BitField;
  }
});

// node_modules/discord.js/src/util/ChannelFlagsBitField.js
var require_ChannelFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/ChannelFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { ChannelFlags } = require_v106();
    var BitField = require_BitField();
    var ChannelFlagsBitField = class extends BitField {
    };
    /**
     * Numeric guild channel flags.
     * @type {ChannelFlags}
     * @memberof ChannelFlagsBitField
     */
    __publicField(ChannelFlagsBitField, "Flags", ChannelFlags);
    module2.exports = ChannelFlagsBitField;
  }
});

// node_modules/discord.js/src/util/Constants.js
var require_Constants = __commonJS({
  "node_modules/discord.js/src/util/Constants.js"(exports2) {
    "use strict";
    var { ChannelType, MessageType, ComponentType, ImageFormat, StickerFormatType } = require_v106();
    exports2.MaxBulkDeletableMessageAge = 12096e5;
    exports2.SweeperKeys = [
      "autoModerationRules",
      "applicationCommands",
      "bans",
      "emojis",
      "invites",
      "guildMembers",
      "messages",
      "presences",
      "reactions",
      "stageInstances",
      "stickers",
      "threadMembers",
      "threads",
      "users",
      "voiceStates"
    ];
    exports2.NonSystemMessageTypes = [
      MessageType.Default,
      MessageType.Reply,
      MessageType.ChatInputCommand,
      MessageType.ContextMenuCommand
    ];
    exports2.GuildTextBasedChannelTypes = [
      ChannelType.GuildText,
      ChannelType.GuildAnnouncement,
      ChannelType.AnnouncementThread,
      ChannelType.PublicThread,
      ChannelType.PrivateThread,
      ChannelType.GuildVoice,
      ChannelType.GuildStageVoice
    ];
    exports2.TextBasedChannelTypes = [...exports2.GuildTextBasedChannelTypes, ChannelType.DM];
    exports2.ThreadChannelTypes = [ChannelType.AnnouncementThread, ChannelType.PublicThread, ChannelType.PrivateThread];
    exports2.VoiceBasedChannelTypes = [ChannelType.GuildVoice, ChannelType.GuildStageVoice];
    exports2.SelectMenuTypes = [
      ComponentType.StringSelect,
      ComponentType.UserSelect,
      ComponentType.RoleSelect,
      ComponentType.MentionableSelect,
      ComponentType.ChannelSelect
    ];
    exports2.DeletableMessageTypes = [
      MessageType.AutoModerationAction,
      MessageType.ChannelFollowAdd,
      MessageType.ChannelPinnedMessage,
      MessageType.ChatInputCommand,
      MessageType.ContextMenuCommand,
      MessageType.Default,
      MessageType.GuildBoost,
      MessageType.GuildBoostTier1,
      MessageType.GuildBoostTier2,
      MessageType.GuildBoostTier3,
      MessageType.GuildInviteReminder,
      MessageType.InteractionPremiumUpsell,
      MessageType.Reply,
      MessageType.RoleSubscriptionPurchase,
      MessageType.StageEnd,
      MessageType.StageRaiseHand,
      MessageType.StageSpeaker,
      MessageType.StageStart,
      MessageType.StageTopic,
      MessageType.ThreadCreated,
      MessageType.UserJoin
    ];
    exports2.StickerFormatExtensionMap = {
      [StickerFormatType.PNG]: ImageFormat.PNG,
      [StickerFormatType.APNG]: ImageFormat.PNG,
      [StickerFormatType.Lottie]: ImageFormat.Lottie,
      [StickerFormatType.GIF]: ImageFormat.GIF
    };
  }
});

// node_modules/discord.js/src/structures/BaseChannel.js
var require_BaseChannel = __commonJS({
  "node_modules/discord.js/src/structures/BaseChannel.js"(exports2) {
    "use strict";
    var { channelLink } = require_dist8();
    var { DiscordSnowflake } = require_dist3();
    var { ChannelType, Routes: Routes2 } = require_v106();
    var Base = require_Base();
    var ChannelFlagsBitField = require_ChannelFlagsBitField();
    var { ThreadChannelTypes } = require_Constants();
    var BaseChannel = class extends Base {
      constructor(client, data, immediatePatch = true) {
        super(client);
        this.type = data.type;
        if (data && immediatePatch)
          this._patch(data);
      }
      _patch(data) {
        if ("flags" in data) {
          this.flags = new ChannelFlagsBitField(data.flags).freeze();
        } else {
          this.flags ??= new ChannelFlagsBitField().freeze();
        }
        this.id = data.id;
      }
      /**
       * The timestamp the channel was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the channel was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The URL to the channel
       * @type {string}
       * @readonly
       */
      get url() {
        return this.isDMBased() ? channelLink(this.id) : channelLink(this.id, this.guildId);
      }
      /**
       * Whether this Channel is a partial
       * <info>This is always false outside of DM channels.</info>
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return false;
      }
      /**
       * When concatenated with a string, this automatically returns the channel's mention instead of the Channel object.
       * @returns {string}
       * @example
       * // Logs: Hello from <#123456789012345678>!
       * console.log(`Hello from ${channel}!`);
       */
      toString() {
        return `<#${this.id}>`;
      }
      /**
       * Deletes this channel.
       * @returns {Promise<BaseChannel>}
       * @example
       * // Delete the channel
       * channel.delete()
       *   .then(console.log)
       *   .catch(console.error);
       */
      async delete() {
        await this.client.rest.delete(Routes2.channel(this.id));
        return this;
      }
      /**
       * Fetches this channel.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<BaseChannel>}
       */
      fetch(force = true) {
        return this.client.channels.fetch(this.id, { force });
      }
      /**
       * Indicates whether this channel is a {@link ThreadChannel}.
       * @returns {boolean}
       */
      isThread() {
        return ThreadChannelTypes.includes(this.type);
      }
      /**
       * Indicates whether this channel is {@link TextBasedChannels text-based}.
       * @returns {boolean}
       */
      isTextBased() {
        return "messages" in this;
      }
      /**
       * Indicates whether this channel is DM-based (either a {@link DMChannel} or a {@link PartialGroupDMChannel}).
       * @returns {boolean}
       */
      isDMBased() {
        return [ChannelType.DM, ChannelType.GroupDM].includes(this.type);
      }
      /**
       * Indicates whether this channel is {@link BaseGuildVoiceChannel voice-based}.
       * @returns {boolean}
       */
      isVoiceBased() {
        return "bitrate" in this;
      }
      toJSON(...props) {
        return super.toJSON({ createdTimestamp: true }, ...props);
      }
    };
    exports2.BaseChannel = BaseChannel;
  }
});

// node_modules/discord.js/src/managers/BaseManager.js
var require_BaseManager = __commonJS({
  "node_modules/discord.js/src/managers/BaseManager.js"(exports2, module2) {
    "use strict";
    var BaseManager = class {
      constructor(client) {
        Object.defineProperty(this, "client", { value: client });
      }
    };
    module2.exports = BaseManager;
  }
});

// node_modules/discord.js/src/managers/DataManager.js
var require_DataManager = __commonJS({
  "node_modules/discord.js/src/managers/DataManager.js"(exports2, module2) {
    "use strict";
    var BaseManager = require_BaseManager();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var DataManager = class extends BaseManager {
      constructor(client, holds) {
        super(client);
        Object.defineProperty(this, "holds", { value: holds });
      }
      /**
       * The cache of items for this manager.
       * @type {Collection}
       * @abstract
       */
      get cache() {
        throw new DiscordjsError2(ErrorCodes2.NotImplemented, "get cache", this.constructor.name);
      }
      /**
       * Resolves a data entry to a data Object.
       * @param {string|Object} idOrInstance The id or instance of something in this Manager
       * @returns {?Object} An instance from this Manager
       */
      resolve(idOrInstance) {
        if (idOrInstance instanceof this.holds)
          return idOrInstance;
        if (typeof idOrInstance === "string")
          return this.cache.get(idOrInstance) ?? null;
        return null;
      }
      /**
       * Resolves a data entry to an instance id.
       * @param {string|Object} idOrInstance The id or instance of something in this Manager
       * @returns {?Snowflake}
       */
      resolveId(idOrInstance) {
        if (idOrInstance instanceof this.holds)
          return idOrInstance.id;
        if (typeof idOrInstance === "string")
          return idOrInstance;
        return null;
      }
      valueOf() {
        return this.cache;
      }
    };
    module2.exports = DataManager;
  }
});

// node_modules/discord.js/src/managers/CachedManager.js
var require_CachedManager = __commonJS({
  "node_modules/discord.js/src/managers/CachedManager.js"(exports2, module2) {
    "use strict";
    var DataManager = require_DataManager();
    var CachedManager = class extends DataManager {
      constructor(client, holds, iterable) {
        super(client, holds);
        Object.defineProperty(this, "_cache", { value: this.client.options.makeCache(this.constructor, this.holds) });
        if (iterable) {
          for (const item of iterable) {
            this._add(item);
          }
        }
      }
      /**
       * The cache of items for this manager.
       * @type {Collection}
       * @abstract
       */
      get cache() {
        return this._cache;
      }
      _add(data, cache = true, { id, extras = [] } = {}) {
        const existing = this.cache.get(id ?? data.id);
        if (existing) {
          if (cache) {
            existing._patch(data);
            return existing;
          }
          const clone = existing._clone();
          clone._patch(data);
          return clone;
        }
        const entry = this.holds ? new this.holds(this.client, data, ...extras) : data;
        if (cache)
          this.cache.set(id ?? entry.id, entry);
        return entry;
      }
    };
    module2.exports = CachedManager;
  }
});

// node_modules/discord.js/src/util/PermissionsBitField.js
var require_PermissionsBitField = __commonJS({
  "node_modules/discord.js/src/util/PermissionsBitField.js"(exports2, module2) {
    "use strict";
    var { PermissionFlagsBits } = require_v106();
    var BitField = require_BitField();
    var PermissionsBitField2 = class extends BitField {
      /**
       * Bitfield of the packed bits
       * @type {bigint}
       * @name PermissionsBitField#bitfield
       */
      /**
       * Data that can be resolved to give a permission number. This can be:
       * * A string (see {@link PermissionsBitField.Flags})
       * * A permission number
       * * An instance of {@link PermissionsBitField}
       * * An Array of PermissionResolvable
       * @typedef {string|bigint|PermissionsBitField|PermissionResolvable[]} PermissionResolvable
       */
      /**
       * Gets all given bits that are missing from the bitfield.
       * @param {BitFieldResolvable} bits Bit(s) to check for
       * @param {boolean} [checkAdmin=true] Whether to allow the administrator permission to override
       * @returns {string[]}
       */
      missing(bits, checkAdmin = true) {
        return checkAdmin && this.has(PermissionFlagsBits.Administrator) ? [] : super.missing(bits);
      }
      /**
       * Checks whether the bitfield has a permission, or any of multiple permissions.
       * @param {PermissionResolvable} permission Permission(s) to check for
       * @param {boolean} [checkAdmin=true] Whether to allow the administrator permission to override
       * @returns {boolean}
       */
      any(permission, checkAdmin = true) {
        return checkAdmin && super.has(PermissionFlagsBits.Administrator) || super.any(permission);
      }
      /**
       * Checks whether the bitfield has a permission, or multiple permissions.
       * @param {PermissionResolvable} permission Permission(s) to check for
       * @param {boolean} [checkAdmin=true] Whether to allow the administrator permission to override
       * @returns {boolean}
       */
      has(permission, checkAdmin = true) {
        return checkAdmin && super.has(PermissionFlagsBits.Administrator) || super.has(permission);
      }
      /**
       * Gets an {@link Array} of bitfield names based on the permissions available.
       * @returns {string[]}
       */
      toArray() {
        return super.toArray(false);
      }
    };
    /**
     * Numeric permission flags.
     * @type {PermissionFlagsBits}
     * @memberof PermissionsBitField
     * @see {@link https://discord.com/developers/docs/topics/permissions#permissions-bitwise-permission-flags}
     */
    __publicField(PermissionsBitField2, "Flags", PermissionFlagsBits);
    /**
     * Bitfield representing every permission combined
     * @type {bigint}
     * @memberof PermissionsBitField
     */
    __publicField(PermissionsBitField2, "All", Object.values(PermissionFlagsBits).reduce((all3, p) => all3 | p, 0n));
    /**
     * Bitfield representing the default permissions for users
     * @type {bigint}
     * @memberof PermissionsBitField
     */
    __publicField(PermissionsBitField2, "Default", BigInt(104324673));
    /**
     * Bitfield representing the permissions required for moderators of stage channels
     * @type {bigint}
     * @memberof PermissionsBitField
     */
    __publicField(PermissionsBitField2, "StageModerator", PermissionFlagsBits.ManageChannels | PermissionFlagsBits.MuteMembers | PermissionFlagsBits.MoveMembers);
    /**
     * @type {bigint}
     * @memberof PermissionsBitField
     * @private
     */
    __publicField(PermissionsBitField2, "DefaultBit", BigInt(0));
    module2.exports = PermissionsBitField2;
  }
});

// node_modules/discord.js/src/structures/Role.js
var require_Role = __commonJS({
  "node_modules/discord.js/src/structures/Role.js"(exports2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { PermissionFlagsBits } = require_v106();
    var Base = require_Base();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var PermissionsBitField2 = require_PermissionsBitField();
    var Role = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this.icon = null;
        this.unicodeEmoji = null;
        if (data)
          this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("color" in data) {
          this.color = data.color;
        }
        if ("hoist" in data) {
          this.hoist = data.hoist;
        }
        if ("position" in data) {
          this.rawPosition = data.position;
        }
        if ("permissions" in data) {
          this.permissions = new PermissionsBitField2(BigInt(data.permissions)).freeze();
        }
        if ("managed" in data) {
          this.managed = data.managed;
        }
        if ("mentionable" in data) {
          this.mentionable = data.mentionable;
        }
        if ("icon" in data)
          this.icon = data.icon;
        if ("unicode_emoji" in data)
          this.unicodeEmoji = data.unicode_emoji;
        this.tags = data.tags ? {} : null;
        if (data.tags) {
          if ("bot_id" in data.tags) {
            this.tags.botId = data.tags.bot_id;
          }
          if ("integration_id" in data.tags) {
            this.tags.integrationId = data.tags.integration_id;
          }
          if ("premium_subscriber" in data.tags) {
            this.tags.premiumSubscriberRole = true;
          }
          if ("subscription_listing_id" in data.tags) {
            this.tags.subscriptionListingId = data.tags.subscription_listing_id;
          }
          if ("available_for_purchase" in data.tags) {
            this.tags.availableForPurchase = true;
          }
        }
      }
      /**
       * The timestamp the role was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the role was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The hexadecimal version of the role color, with a leading hashtag
       * @type {string}
       * @readonly
       */
      get hexColor() {
        return `#${this.color.toString(16).padStart(6, "0")}`;
      }
      /**
       * The cached guild members that have this role
       * @type {Collection<Snowflake, GuildMember>}
       * @readonly
       */
      get members() {
        return this.guild.members.cache.filter((m) => m.roles.cache.has(this.id));
      }
      /**
       * Whether the role is editable by the client user
       * @type {boolean}
       * @readonly
       */
      get editable() {
        if (this.managed)
          return false;
        const clientMember = this.guild.members.resolve(this.client.user);
        if (!clientMember.permissions.has(PermissionFlagsBits.ManageRoles))
          return false;
        return clientMember.roles.highest.comparePositionTo(this) > 0;
      }
      /**
       * The position of the role in the role manager
       * @type {number}
       * @readonly
       */
      get position() {
        const sorted = this.guild._sortedRoles();
        return [...sorted.values()].indexOf(sorted.get(this.id));
      }
      /**
       * Compares this role's position to another role's.
       * @param {RoleResolvable} role Role to compare to this one
       * @returns {number} Negative number if this role's position is lower (other role's is higher),
       * positive number if this one is higher (other's is lower), 0 if equal
       * @example
       * // Compare the position of a role to another
       * const roleCompare = role.comparePositionTo(otherRole);
       * if (roleCompare >= 1) console.log(`${role.name} is higher than ${otherRole.name}`);
       */
      comparePositionTo(role) {
        return this.guild.roles.comparePositions(this, role);
      }
      /**
       * The data for a role.
       * @typedef {Object} RoleData
       * @property {string} [name] The name of the role
       * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number
       * @property {boolean} [hoist] Whether or not the role should be hoisted
       * @property {number} [position] The position of the role
       * @property {PermissionResolvable} [permissions] The permissions of the role
       * @property {boolean} [mentionable] Whether or not the role should be mentionable
       * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role
       * <warn>The `EmojiResolvable` should belong to the same guild as the role.
       * If not, pass the emoji's URL directly</warn>
       * @property {?string} [unicodeEmoji] The unicode emoji for the role
       */
      /**
       * Edits the role.
       * @param {RoleEditOptions} options The options to provide
       * @returns {Promise<Role>}
       * @example
       * // Edit a role
       * role.edit({ name: 'new role' })
       *   .then(updated => console.log(`Edited role name to ${updated.name}`))
       *   .catch(console.error);
       */
      edit(options) {
        return this.guild.roles.edit(this, options);
      }
      /**
       * Returns `channel.permissionsFor(role)`. Returns permissions for a role in a guild channel,
       * taking into account permission overwrites.
       * @param {GuildChannel|Snowflake} channel The guild channel to use as context
       * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission
       * will return all permissions
       * @returns {Readonly<PermissionsBitField>}
       */
      permissionsIn(channel, checkAdmin = true) {
        channel = this.guild.channels.resolve(channel);
        if (!channel)
          throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        return channel.rolePermissions(this, checkAdmin);
      }
      /**
       * Sets a new name for the role.
       * @param {string} name The new name of the role
       * @param {string} [reason] Reason for changing the role's name
       * @returns {Promise<Role>}
       * @example
       * // Set the name of the role
       * role.setName('new role')
       *   .then(updated => console.log(`Updated role name to ${updated.name}`))
       *   .catch(console.error);
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Sets a new color for the role.
       * @param {ColorResolvable} color The color of the role
       * @param {string} [reason] Reason for changing the role's color
       * @returns {Promise<Role>}
       * @example
       * // Set the color of a role
       * role.setColor('#FF0000')
       *   .then(updated => console.log(`Set color of role to ${updated.color}`))
       *   .catch(console.error);
       */
      setColor(color, reason) {
        return this.edit({ color, reason });
      }
      /**
       * Sets whether or not the role should be hoisted.
       * @param {boolean} [hoist=true] Whether or not to hoist the role
       * @param {string} [reason] Reason for setting whether or not the role should be hoisted
       * @returns {Promise<Role>}
       * @example
       * // Set the hoist of the role
       * role.setHoist(true)
       *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))
       *   .catch(console.error);
       */
      setHoist(hoist = true, reason) {
        return this.edit({ hoist, reason });
      }
      /**
       * Sets the permissions of the role.
       * @param {PermissionResolvable} permissions The permissions of the role
       * @param {string} [reason] Reason for changing the role's permissions
       * @returns {Promise<Role>}
       * @example
       * // Set the permissions of the role
       * role.setPermissions([PermissionFlagsBits.KickMembers, PermissionFlagsBits.BanMembers])
       *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))
       *   .catch(console.error);
       * @example
       * // Remove all permissions from a role
       * role.setPermissions(0n)
       *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))
       *   .catch(console.error);
       */
      setPermissions(permissions, reason) {
        return this.edit({ permissions, reason });
      }
      /**
       * Sets whether this role is mentionable.
       * @param {boolean} [mentionable=true] Whether this role should be mentionable
       * @param {string} [reason] Reason for setting whether or not this role should be mentionable
       * @returns {Promise<Role>}
       * @example
       * // Make the role mentionable
       * role.setMentionable(true)
       *   .then(updated => console.log(`Role updated ${updated.name}`))
       *   .catch(console.error);
       */
      setMentionable(mentionable = true, reason) {
        return this.edit({ mentionable, reason });
      }
      /**
       * Sets a new icon for the role.
       * @param {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} icon The icon for the role
       * <warn>The `EmojiResolvable` should belong to the same guild as the role.
       * If not, pass the emoji's URL directly</warn>
       * @param {string} [reason] Reason for changing the role's icon
       * @returns {Promise<Role>}
       */
      setIcon(icon, reason) {
        return this.edit({ icon, reason });
      }
      /**
       * Sets a new unicode emoji for the role.
       * @param {?string} unicodeEmoji The new unicode emoji for the role
       * @param {string} [reason] Reason for changing the role's unicode emoji
       * @returns {Promise<Role>}
       * @example
       * // Set a new unicode emoji for the role
       * role.setUnicodeEmoji('🤖')
       *   .then(updated => console.log(`Set unicode emoji for the role to ${updated.unicodeEmoji}`))
       *   .catch(console.error);
       */
      setUnicodeEmoji(unicodeEmoji, reason) {
        return this.edit({ unicodeEmoji, reason });
      }
      /**
       * Options used to set the position of a role.
       * @typedef {Object} SetRolePositionOptions
       * @property {boolean} [relative=false] Whether to change the position relative to its current value or not
       * @property {string} [reason] The reason for changing the position
       */
      /**
       * Sets the new position of the role.
       * @param {number} position The new position for the role
       * @param {SetRolePositionOptions} [options] Options for setting the position
       * @returns {Promise<Role>}
       * @example
       * // Set the position of the role
       * role.setPosition(1)
       *   .then(updated => console.log(`Role position: ${updated.position}`))
       *   .catch(console.error);
       */
      setPosition(position, options = {}) {
        return this.guild.roles.setPosition(this, position, options);
      }
      /**
       * Deletes the role.
       * @param {string} [reason] Reason for deleting this role
       * @returns {Promise<Role>}
       * @example
       * // Delete a role
       * role.delete('The role needed to go')
       *   .then(deleted => console.log(`Deleted role ${deleted.name}`))
       *   .catch(console.error);
       */
      async delete(reason) {
        await this.guild.roles.delete(this.id, reason);
        return this;
      }
      /**
       * A link to the role's icon
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.roleIcon(this.id, this.icon, options);
      }
      /**
       * Whether this role equals another role. It compares all properties, so for most operations
       * it is advisable to just compare `role.id === role2.id` as it is much faster and is often
       * what most users need.
       * @param {Role} role Role to compare with
       * @returns {boolean}
       */
      equals(role) {
        return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed && this.icon === role.icon && this.unicodeEmoji === role.unicodeEmoji;
      }
      /**
       * When concatenated with a string, this automatically returns the role's mention instead of the Role object.
       * @returns {string}
       * @example
       * // Logs: Role: <@&123456789012345678>
       * console.log(`Role: ${role}`);
       */
      toString() {
        if (this.id === this.guild.id)
          return "@everyone";
        return `<@&${this.id}>`;
      }
      toJSON() {
        return {
          ...super.toJSON({ createdTimestamp: true }),
          permissions: this.permissions.toJSON()
        };
      }
    };
    exports2.Role = Role;
  }
});

// node_modules/discord.js/src/structures/PermissionOverwrites.js
var require_PermissionOverwrites = __commonJS({
  "node_modules/discord.js/src/structures/PermissionOverwrites.js"(exports2, module2) {
    "use strict";
    var { OverwriteType } = require_v106();
    var Base = require_Base();
    var { Role } = require_Role();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var PermissionsBitField2 = require_PermissionsBitField();
    var PermissionOverwrites = class extends Base {
      constructor(client, data, channel) {
        super(client);
        Object.defineProperty(this, "channel", { value: channel });
        if (data)
          this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("type" in data) {
          this.type = data.type;
        }
        if ("deny" in data) {
          this.deny = new PermissionsBitField2(BigInt(data.deny)).freeze();
        }
        if ("allow" in data) {
          this.allow = new PermissionsBitField2(BigInt(data.allow)).freeze();
        }
      }
      /**
       * Edits this Permission Overwrite.
       * @param {PermissionOverwriteOptions} options The options for the update
       * @param {string} [reason] Reason for creating/editing this overwrite
       * @returns {Promise<PermissionOverwrites>}
       * @example
       * // Update permission overwrites
       * permissionOverwrites.edit({
       *   SendMessages: false
       * })
       *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))
       *   .catch(console.error);
       */
      async edit(options, reason) {
        await this.channel.permissionOverwrites.upsert(this.id, options, { type: this.type, reason }, this);
        return this;
      }
      /**
       * Deletes this Permission Overwrite.
       * @param {string} [reason] Reason for deleting this overwrite
       * @returns {Promise<PermissionOverwrites>}
       */
      async delete(reason) {
        await this.channel.permissionOverwrites.delete(this.id, reason);
        return this;
      }
      toJSON() {
        return {
          id: this.id,
          type: this.type,
          allow: this.allow,
          deny: this.deny
        };
      }
      /**
       * An object mapping permission flags to `true` (enabled), `null` (unset) or `false` (disabled).
       * ```js
       * {
       *  'SendMessages': true,
       *  'EmbedLinks': null,
       *  'AttachFiles': false,
       * }
       * ```
       * @typedef {Object} PermissionOverwriteOptions
       */
      /**
       * @typedef {Object} ResolvedOverwriteOptions
       * @property {PermissionsBitField} allow The allowed permissions
       * @property {PermissionsBitField} deny The denied permissions
       */
      /**
       * Resolves bitfield permissions overwrites from an object.
       * @param {PermissionOverwriteOptions} options The options for the update
       * @param {ResolvedOverwriteOptions} initialPermissions The initial permissions
       * @returns {ResolvedOverwriteOptions}
       */
      static resolveOverwriteOptions(options, { allow, deny } = {}) {
        allow = new PermissionsBitField2(allow);
        deny = new PermissionsBitField2(deny);
        for (const [perm, value] of Object.entries(options)) {
          if (value === true) {
            allow.add(perm);
            deny.remove(perm);
          } else if (value === false) {
            allow.remove(perm);
            deny.add(perm);
          } else if (value === null) {
            allow.remove(perm);
            deny.remove(perm);
          }
        }
        return { allow, deny };
      }
      /**
       * The raw data for a permission overwrite
       * @typedef {Object} RawOverwriteData
       * @property {Snowflake} id The id of the {@link Role} or {@link User} this overwrite belongs to
       * @property {string} allow The permissions to allow
       * @property {string} deny The permissions to deny
       * @property {number} type The type of this OverwriteData
       */
      /**
       * Data that can be resolved into {@link RawOverwriteData}. This can be:
       * * PermissionOverwrites
       * * OverwriteData
       * @typedef {PermissionOverwrites|OverwriteData} OverwriteResolvable
       */
      /**
       * Data that can be used for a permission overwrite
       * @typedef {Object} OverwriteData
       * @property {GuildMemberResolvable|RoleResolvable} id Member or role this overwrite is for
       * @property {PermissionResolvable} [allow] The permissions to allow
       * @property {PermissionResolvable} [deny] The permissions to deny
       * @property {OverwriteType} [type] The type of this OverwriteData
       */
      /**
       * Resolves an overwrite into {@link RawOverwriteData}.
       * @param {OverwriteResolvable} overwrite The overwrite-like data to resolve
       * @param {Guild} [guild] The guild to resolve from
       * @returns {RawOverwriteData}
       */
      static resolve(overwrite, guild) {
        if (overwrite instanceof this)
          return overwrite.toJSON();
        if (typeof overwrite.id === "string" && overwrite.type in OverwriteType) {
          return {
            id: overwrite.id,
            type: overwrite.type,
            allow: PermissionsBitField2.resolve(overwrite.allow ?? PermissionsBitField2.DefaultBit).toString(),
            deny: PermissionsBitField2.resolve(overwrite.deny ?? PermissionsBitField2.DefaultBit).toString()
          };
        }
        const userOrRole = guild.roles.resolve(overwrite.id) ?? guild.client.users.resolve(overwrite.id);
        if (!userOrRole)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "parameter", "User nor a Role");
        const type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
        return {
          id: userOrRole.id,
          type,
          allow: PermissionsBitField2.resolve(overwrite.allow ?? PermissionsBitField2.DefaultBit).toString(),
          deny: PermissionsBitField2.resolve(overwrite.deny ?? PermissionsBitField2.DefaultBit).toString()
        };
      }
    };
    module2.exports = PermissionOverwrites;
  }
});

// node_modules/discord.js/src/managers/PermissionOverwriteManager.js
var require_PermissionOverwriteManager = __commonJS({
  "node_modules/discord.js/src/managers/PermissionOverwriteManager.js"(exports2, module2) {
    "use strict";
    var process2 = require("node:process");
    var { Collection: Collection2 } = require_dist();
    var { OverwriteType, Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var PermissionOverwrites = require_PermissionOverwrites();
    var { Role } = require_Role();
    var cacheWarningEmitted = false;
    var PermissionOverwriteManager = class extends CachedManager {
      constructor(channel, iterable) {
        super(channel.client, PermissionOverwrites);
        if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
          cacheWarningEmitted = true;
          process2.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
        this.channel = channel;
        if (iterable) {
          for (const item of iterable) {
            this._add(item);
          }
        }
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, PermissionOverwrites>}
       * @name PermissionOverwriteManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.channel] });
      }
      /**
       * Replaces the permission overwrites in this channel.
       * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} overwrites
       * Permission overwrites the channel gets updated with
       * @param {string} [reason] Reason for updating the channel overwrites
       * @returns {Promise<GuildChannel>}
       * @example
       * message.channel.permissionOverwrites.set([
       *   {
       *      id: message.author.id,
       *      deny: [PermissionsFlagsBit.ViewChannel],
       *   },
       * ], 'Needed to change permissions');
       */
      set(overwrites, reason) {
        if (!Array.isArray(overwrites) && !(overwrites instanceof Collection2)) {
          return Promise.reject(
            new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "overwrites",
              "Array or Collection of Permission Overwrites",
              true
            )
          );
        }
        return this.channel.edit({ permissionOverwrites: overwrites, reason });
      }
      /**
       * Extra information about the overwrite.
       * @typedef {Object} GuildChannelOverwriteOptions
       * @property {string} [reason] The reason for creating/editing this overwrite
       * @property {OverwriteType} [type] The type of overwrite. Use this to bypass automatic resolution of `type`
       * that results in an error for an uncached structure
       */
      /**
       * Creates or edits permission overwrites for a user or role in this channel.
       * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update
       * @param {PermissionOverwriteOptions} options The options for the update
       * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update
       * @param {PermissionOverwrites} [existing] The existing overwrites to merge with this update
       * @returns {Promise<GuildChannel>}
       * @private
       */
      async upsert(userOrRole, options, overwriteOptions = {}, existing) {
        let userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
        let { type, reason } = overwriteOptions;
        if (typeof type !== "number") {
          userOrRole = this.channel.guild.roles.resolve(userOrRole) ?? this.client.users.resolve(userOrRole);
          if (!userOrRole)
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "parameter", "User nor a Role");
          type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
        }
        const { allow, deny } = PermissionOverwrites.resolveOverwriteOptions(options, existing);
        await this.client.rest.put(Routes2.channelPermission(this.channel.id, userOrRoleId), {
          body: { id: userOrRoleId, type, allow, deny },
          reason
        });
        return this.channel;
      }
      /**
       * Creates permission overwrites for a user or role in this channel, or replaces them if already present.
       * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update
       * @param {PermissionOverwriteOptions} options The options for the update
       * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update
       * @returns {Promise<GuildChannel>}
       * @example
       * // Create or Replace permission overwrites for a message author
       * message.channel.permissionOverwrites.create(message.author, {
       *   SendMessages: false
       * })
       *   .then(channel => console.log(channel.permissionOverwrites.cache.get(message.author.id)))
       *   .catch(console.error);
       */
      create(userOrRole, options, overwriteOptions) {
        return this.upsert(userOrRole, options, overwriteOptions);
      }
      /**
       * Edits permission overwrites for a user or role in this channel, or creates an entry if not already present.
       * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update
       * @param {PermissionOverwriteOptions} options The options for the update
       * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update
       * @returns {Promise<GuildChannel>}
       * @example
       * // Edit or Create permission overwrites for a message author
       * message.channel.permissionOverwrites.edit(message.author, {
       *   SendMessages: false
       * })
       *   .then(channel => console.log(channel.permissionOverwrites.cache.get(message.author.id)))
       *   .catch(console.error);
       */
      edit(userOrRole, options, overwriteOptions) {
        const existing = this.cache.get(
          this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole)
        );
        return this.upsert(userOrRole, options, overwriteOptions, existing);
      }
      /**
       * Deletes permission overwrites for a user or role in this channel.
       * @param {UserResolvable|RoleResolvable} userOrRole The user or role to delete
       * @param {string} [reason] The reason for deleting the overwrite
       * @returns {Promise<GuildChannel>}
       */
      async delete(userOrRole, reason) {
        const userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
        if (!userOrRoleId)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "parameter", "User nor a Role");
        await this.client.rest.delete(Routes2.channelPermission(this.channel.id, userOrRoleId), { reason });
        return this.channel;
      }
    };
    module2.exports = PermissionOverwriteManager;
  }
});

// node_modules/discord.js/src/structures/GuildChannel.js
var require_GuildChannel = __commonJS({
  "node_modules/discord.js/src/structures/GuildChannel.js"(exports2, module2) {
    "use strict";
    var { PermissionFlagsBits } = require_v106();
    var { BaseChannel } = require_BaseChannel();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var PermissionOverwriteManager = require_PermissionOverwriteManager();
    var { VoiceBasedChannelTypes } = require_Constants();
    var PermissionsBitField2 = require_PermissionsBitField();
    var GuildChannel = class extends BaseChannel {
      constructor(guild, data, client, immediatePatch = true) {
        super(guild?.client ?? client, data, false);
        this.guild = guild;
        this.guildId = guild?.id ?? data.guild_id;
        this.parentId = this.parentId ?? null;
        this.permissionOverwrites = new PermissionOverwriteManager(this);
        if (data && immediatePatch)
          this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("name" in data) {
          this.name = data.name;
        }
        if ("position" in data) {
          this.rawPosition = data.position;
        }
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("parent_id" in data) {
          this.parentId = data.parent_id;
        }
        if ("permission_overwrites" in data) {
          this.permissionOverwrites.cache.clear();
          for (const overwrite of data.permission_overwrites) {
            this.permissionOverwrites._add(overwrite);
          }
        }
      }
      _clone() {
        const clone = super._clone();
        clone.permissionOverwrites = new PermissionOverwriteManager(clone, this.permissionOverwrites.cache.values());
        return clone;
      }
      /**
       * The category parent of this channel
       * @type {?CategoryChannel}
       * @readonly
       */
      get parent() {
        return this.guild.channels.resolve(this.parentId);
      }
      /**
       * If the permissionOverwrites match the parent channel, null if no parent
       * @type {?boolean}
       * @readonly
       */
      get permissionsLocked() {
        if (!this.parent)
          return null;
        const overwriteIds = /* @__PURE__ */ new Set([
          ...this.permissionOverwrites.cache.keys(),
          ...this.parent.permissionOverwrites.cache.keys()
        ]);
        return [...overwriteIds].every((key) => {
          const channelVal = this.permissionOverwrites.cache.get(key);
          const parentVal = this.parent.permissionOverwrites.cache.get(key);
          if (!channelVal && parentVal.deny.bitfield === PermissionsBitField2.DefaultBit && parentVal.allow.bitfield === PermissionsBitField2.DefaultBit || !parentVal && channelVal.deny.bitfield === PermissionsBitField2.DefaultBit && channelVal.allow.bitfield === PermissionsBitField2.DefaultBit) {
            return true;
          }
          return channelVal !== void 0 && parentVal !== void 0 && channelVal.deny.bitfield === parentVal.deny.bitfield && channelVal.allow.bitfield === parentVal.allow.bitfield;
        });
      }
      /**
       * The position of the channel
       * @type {number}
       * @readonly
       */
      get position() {
        const sorted = this.guild._sortedChannels(this);
        return [...sorted.values()].indexOf(sorted.get(this.id));
      }
      /**
       * Gets the overall set of permissions for a member or role in this channel, taking into account channel overwrites.
       * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for
       * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission
       * will return all permissions
       * @returns {?Readonly<PermissionsBitField>}
       */
      permissionsFor(memberOrRole, checkAdmin = true) {
        const member = this.guild.members.resolve(memberOrRole);
        if (member)
          return this.memberPermissions(member, checkAdmin);
        const role = this.guild.roles.resolve(memberOrRole);
        return role && this.rolePermissions(role, checkAdmin);
      }
      overwritesFor(member, verified = false, roles = null) {
        if (!verified)
          member = this.guild.members.resolve(member);
        if (!member)
          return [];
        roles ??= member.roles.cache;
        const roleOverwrites = [];
        let memberOverwrites;
        let everyoneOverwrites;
        for (const overwrite of this.permissionOverwrites.cache.values()) {
          if (overwrite.id === this.guild.id) {
            everyoneOverwrites = overwrite;
          } else if (roles.has(overwrite.id)) {
            roleOverwrites.push(overwrite);
          } else if (overwrite.id === member.id) {
            memberOverwrites = overwrite;
          }
        }
        return {
          everyone: everyoneOverwrites,
          roles: roleOverwrites,
          member: memberOverwrites
        };
      }
      /**
       * Gets the overall set of permissions for a member in this channel, taking into account channel overwrites.
       * @param {GuildMember} member The member to obtain the overall permissions for
       * @param {boolean} checkAdmin Whether having the {@link PermissionFlagsBits.Administrator} permission
       * will return all permissions
       * @returns {Readonly<PermissionsBitField>}
       * @private
       */
      memberPermissions(member, checkAdmin) {
        if (checkAdmin && member.id === this.guild.ownerId) {
          return new PermissionsBitField2(PermissionsBitField2.All).freeze();
        }
        const roles = member.roles.cache;
        const permissions = new PermissionsBitField2(roles.map((role) => role.permissions));
        if (checkAdmin && permissions.has(PermissionFlagsBits.Administrator)) {
          return new PermissionsBitField2(PermissionsBitField2.All).freeze();
        }
        const overwrites = this.overwritesFor(member, true, roles);
        return permissions.remove(overwrites.everyone?.deny ?? PermissionsBitField2.DefaultBit).add(overwrites.everyone?.allow ?? PermissionsBitField2.DefaultBit).remove(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.deny) : PermissionsBitField2.DefaultBit).add(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.allow) : PermissionsBitField2.DefaultBit).remove(overwrites.member?.deny ?? PermissionsBitField2.DefaultBit).add(overwrites.member?.allow ?? PermissionsBitField2.DefaultBit).freeze();
      }
      /**
       * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.
       * @param {Role} role The role to obtain the overall permissions for
       * @param {boolean} checkAdmin Whether having the {@link PermissionFlagsBits.Administrator} permission
       * will return all permissions
       * @returns {Readonly<PermissionsBitField>}
       * @private
       */
      rolePermissions(role, checkAdmin) {
        if (checkAdmin && role.permissions.has(PermissionFlagsBits.Administrator)) {
          return new PermissionsBitField2(PermissionsBitField2.All).freeze();
        }
        const everyoneOverwrites = this.permissionOverwrites.cache.get(this.guild.id);
        const roleOverwrites = this.permissionOverwrites.cache.get(role.id);
        return role.permissions.remove(everyoneOverwrites?.deny ?? PermissionsBitField2.DefaultBit).add(everyoneOverwrites?.allow ?? PermissionsBitField2.DefaultBit).remove(roleOverwrites?.deny ?? PermissionsBitField2.DefaultBit).add(roleOverwrites?.allow ?? PermissionsBitField2.DefaultBit).freeze();
      }
      /**
       * Locks in the permission overwrites from the parent channel.
       * @returns {Promise<GuildChannel>}
       */
      lockPermissions() {
        if (!this.parent)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.GuildChannelOrphan));
        const permissionOverwrites = this.parent.permissionOverwrites.cache.map((overwrite) => overwrite.toJSON());
        return this.edit({ permissionOverwrites });
      }
      /**
       * A collection of cached members of this channel, mapped by their ids.
       * Members that can view this channel, if the channel is text-based.
       * Members in the channel, if the channel is voice-based.
       * @type {Collection<Snowflake, GuildMember>}
       * @readonly
       */
      get members() {
        return this.guild.members.cache.filter((m) => this.permissionsFor(m).has(PermissionFlagsBits.ViewChannel, false));
      }
      /**
       * Edits the channel.
       * @param {GuildChannelEditOptions} options The options to provide
       * @returns {Promise<GuildChannel>}
       * @example
       * // Edit a channel
       * channel.edit({ name: 'new-channel' })
       *   .then(console.log)
       *   .catch(console.error);
       */
      edit(options) {
        return this.guild.channels.edit(this, options);
      }
      /**
       * Sets a new name for the guild channel.
       * @param {string} name The new name for the guild channel
       * @param {string} [reason] Reason for changing the guild channel's name
       * @returns {Promise<GuildChannel>}
       * @example
       * // Set a new channel name
       * channel.setName('not_general')
       *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))
       *   .catch(console.error);
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Options used to set the parent of a channel.
       * @typedef {Object} SetParentOptions
       * @property {boolean} [lockPermissions=true] Whether to lock the permissions to what the parent's permissions are
       * @property {string} [reason] The reason for modifying the parent of the channel
       */
      /**
       * Sets the parent of this channel.
       * @param {?CategoryChannelResolvable} channel The category channel to set as the parent
       * @param {SetParentOptions} [options={}] The options for setting the parent
       * @returns {Promise<GuildChannel>}
       * @example
       * // Add a parent to a channel
       * message.channel.setParent('355908108431917066', { lockPermissions: false })
       *   .then(channel => console.log(`New parent of ${message.channel.name}: ${channel.name}`))
       *   .catch(console.error);
       */
      setParent(channel, { lockPermissions = true, reason } = {}) {
        return this.edit({
          parent: channel ?? null,
          lockPermissions,
          reason
        });
      }
      /**
       * Options used to set the position of a channel.
       * @typedef {Object} SetChannelPositionOptions
       * @property {boolean} [relative=false] Whether or not to change the position relative to its current value
       * @property {string} [reason] The reason for changing the position
       */
      /**
       * Sets a new position for the guild channel.
       * @param {number} position The new position for the guild channel
       * @param {SetChannelPositionOptions} [options] Options for setting position
       * @returns {Promise<GuildChannel>}
       * @example
       * // Set a new channel position
       * channel.setPosition(2)
       *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))
       *   .catch(console.error);
       */
      setPosition(position, options = {}) {
        return this.guild.channels.setPosition(this, position, options);
      }
      /**
       * Options used to clone a guild channel.
       * @typedef {GuildChannelCreateOptions} GuildChannelCloneOptions
       * @property {string} [name=this.name] Name of the new channel
       */
      /**
       * Clones this channel.
       * @param {GuildChannelCloneOptions} [options] The options for cloning this channel
       * @returns {Promise<GuildChannel>}
       */
      clone(options = {}) {
        return this.guild.channels.create({
          name: options.name ?? this.name,
          permissionOverwrites: this.permissionOverwrites.cache,
          topic: this.topic,
          type: this.type,
          nsfw: this.nsfw,
          parent: this.parent,
          bitrate: this.bitrate,
          userLimit: this.userLimit,
          rateLimitPerUser: this.rateLimitPerUser,
          position: this.rawPosition,
          reason: null,
          ...options
        });
      }
      /**
       * Checks if this channel has the same type, topic, position, name, overwrites, and id as another channel.
       * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.
       * @param {GuildChannel} channel Channel to compare with
       * @returns {boolean}
       */
      equals(channel) {
        let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;
        if (equal) {
          if (this.permissionOverwrites && channel.permissionOverwrites) {
            equal = this.permissionOverwrites.cache.equals(channel.permissionOverwrites.cache);
          } else {
            equal = !this.permissionOverwrites && !channel.permissionOverwrites;
          }
        }
        return equal;
      }
      /**
       * Whether the channel is deletable by the client user
       * @type {boolean}
       * @readonly
       */
      get deletable() {
        return this.manageable && this.guild.rulesChannelId !== this.id && this.guild.publicUpdatesChannelId !== this.id;
      }
      /**
       * Whether the channel is manageable by the client user
       * @type {boolean}
       * @readonly
       */
      get manageable() {
        if (this.client.user.id === this.guild.ownerId)
          return true;
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        if (permissions.has(PermissionFlagsBits.Administrator, false))
          return true;
        if (this.guild.members.me.communicationDisabledUntilTimestamp > Date.now())
          return false;
        const bitfield = VoiceBasedChannelTypes.includes(this.type) ? PermissionFlagsBits.ManageChannels | PermissionFlagsBits.Connect : PermissionFlagsBits.ViewChannel | PermissionFlagsBits.ManageChannels;
        return permissions.has(bitfield, false);
      }
      /**
       * Whether the channel is viewable by the client user
       * @type {boolean}
       * @readonly
       */
      get viewable() {
        if (this.client.user.id === this.guild.ownerId)
          return true;
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        return permissions.has(PermissionFlagsBits.ViewChannel, false);
      }
      /**
       * Deletes this channel.
       * @param {string} [reason] Reason for deleting this channel
       * @returns {Promise<GuildChannel>}
       * @example
       * // Delete the channel
       * channel.delete('making room for new channels')
       *   .then(console.log)
       *   .catch(console.error);
       */
      async delete(reason) {
        await this.guild.channels.delete(this.id, reason);
        return this;
      }
    };
    module2.exports = GuildChannel;
  }
});

// node_modules/discord.js/src/util/Util.js
var require_Util = __commonJS({
  "node_modules/discord.js/src/util/Util.js"(exports2, module2) {
    "use strict";
    var { parse } = require("node:path");
    var { Collection: Collection2 } = require_dist();
    var { ChannelType, RouteBases, Routes: Routes2 } = require_v106();
    var { fetch } = require_undici();
    var Colors = require_Colors();
    var { DiscordjsError: DiscordjsError2, DiscordjsRangeError: DiscordjsRangeError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var isObject2 = (d) => typeof d === "object" && d !== null;
    function flatten(obj, ...props) {
      if (!isObject2(obj))
        return obj;
      const objProps = Object.keys(obj).filter((k) => !k.startsWith("_")).map((k) => ({ [k]: true }));
      props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);
      const out = {};
      for (let [prop, newProp] of Object.entries(props)) {
        if (!newProp)
          continue;
        newProp = newProp === true ? prop : newProp;
        const element = obj[prop];
        const elemIsObj = isObject2(element);
        const valueOf = elemIsObj && typeof element.valueOf === "function" ? element.valueOf() : null;
        const hasToJSON = elemIsObj && typeof element.toJSON === "function";
        if (element instanceof Collection2)
          out[newProp] = Array.from(element.keys());
        else if (valueOf instanceof Collection2)
          out[newProp] = Array.from(valueOf.keys());
        else if (Array.isArray(element))
          out[newProp] = element.map((e) => e.toJSON?.() ?? flatten(e));
        else if (typeof valueOf !== "object")
          out[newProp] = valueOf;
        else if (hasToJSON)
          out[newProp] = element.toJSON();
        else if (typeof element === "object")
          out[newProp] = flatten(element);
        else if (!elemIsObj)
          out[newProp] = element;
      }
      return out;
    }
    async function fetchRecommendedShardCount(token, { guildsPerShard = 1e3, multipleOf = 1 } = {}) {
      if (!token)
        throw new DiscordjsError2(ErrorCodes2.TokenMissing);
      const response = await fetch(RouteBases.api + Routes2.gatewayBot(), {
        method: "GET",
        headers: { Authorization: `Bot ${token.replace(/^Bot\s*/i, "")}` }
      });
      if (!response.ok) {
        if (response.status === 401)
          throw new DiscordjsError2(ErrorCodes2.TokenInvalid);
        throw response;
      }
      const { shards } = await response.json();
      return Math.ceil(shards * (1e3 / guildsPerShard) / multipleOf) * multipleOf;
    }
    function parseEmoji(text) {
      if (text.includes("%"))
        text = decodeURIComponent(text);
      if (!text.includes(":"))
        return { animated: false, name: text, id: void 0 };
      const match = text.match(/<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/);
      return match && { animated: Boolean(match[1]), name: match[2], id: match[3] };
    }
    function resolvePartialEmoji(emoji) {
      if (!emoji)
        return null;
      if (typeof emoji === "string")
        return /^\d{17,19}$/.test(emoji) ? { id: emoji } : parseEmoji(emoji);
      const { id, name, animated } = emoji;
      if (!id && !name)
        return null;
      return { id, name, animated: Boolean(animated) };
    }
    function mergeDefault(def, given) {
      if (!given)
        return def;
      for (const key in def) {
        if (!Object.hasOwn(given, key) || given[key] === void 0) {
          given[key] = def[key];
        } else if (given[key] === Object(given[key])) {
          given[key] = mergeDefault(def[key], given[key]);
        }
      }
      return given;
    }
    function makeError(obj) {
      const err = new Error(obj.message);
      err.name = obj.name;
      err.stack = obj.stack;
      return err;
    }
    function makePlainError(err) {
      return {
        name: err.name,
        message: err.message,
        stack: err.stack
      };
    }
    function moveElementInArray(array, element, newIndex, offset = false) {
      const index = array.indexOf(element);
      newIndex = (offset ? index : 0) + newIndex;
      if (newIndex > -1 && newIndex < array.length) {
        const removedElement = array.splice(index, 1)[0];
        array.splice(newIndex, 0, removedElement);
      }
      return array.indexOf(element);
    }
    function verifyString(data, error = Error, errorMessage = `Expected a string, got ${data} instead.`, allowEmpty = true) {
      if (typeof data !== "string")
        throw new error(errorMessage);
      if (!allowEmpty && data.length === 0)
        throw new error(errorMessage);
      return data;
    }
    function resolveColor(color) {
      if (typeof color === "string") {
        if (color === "Random")
          return Math.floor(Math.random() * (16777215 + 1));
        if (color === "Default")
          return 0;
        if (/^#?[\da-f]{6}$/i.test(color))
          return parseInt(color.replace("#", ""), 16);
        color = Colors[color];
      } else if (Array.isArray(color)) {
        color = (color[0] << 16) + (color[1] << 8) + color[2];
      }
      if (color < 0 || color > 16777215)
        throw new DiscordjsRangeError2(ErrorCodes2.ColorRange);
      if (typeof color !== "number" || Number.isNaN(color))
        throw new DiscordjsTypeError2(ErrorCodes2.ColorConvert);
      return color;
    }
    function discordSort(collection) {
      const isGuildChannel = collection.first() instanceof GuildChannel;
      return collection.sorted(
        isGuildChannel ? (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(a.id) - BigInt(b.id)) : (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(b.id) - BigInt(a.id))
      );
    }
    async function setPosition(item, position, relative, sorted, client, route, reason) {
      let updatedItems = [...sorted.values()];
      moveElementInArray(updatedItems, item, position, relative);
      updatedItems = updatedItems.map((r, i) => ({ id: r.id, position: i }));
      await client.rest.patch(route, { body: updatedItems, reason });
      return updatedItems;
    }
    function basename(path, ext) {
      const res = parse(path);
      return ext && res.ext.startsWith(ext) ? res.name : res.base.split("?")[0];
    }
    function cleanContent(str, channel) {
      return str.replaceAll(/<(@[!&]?|#)(\d{17,19})>/g, (match, type, id) => {
        switch (type) {
          case "@":
          case "@!": {
            const member = channel.guild?.members.cache.get(id);
            if (member) {
              return `@${member.displayName}`;
            }
            const user = channel.client.users.cache.get(id);
            return user ? `@${user.username}` : match;
          }
          case "@&": {
            if (channel.type === ChannelType.DM)
              return match;
            const role = channel.guild.roles.cache.get(id);
            return role ? `@${role.name}` : match;
          }
          case "#": {
            const mentionedChannel = channel.client.channels.cache.get(id);
            return mentionedChannel ? `#${mentionedChannel.name}` : match;
          }
          default: {
            return match;
          }
        }
      });
    }
    function cleanCodeBlockContent(text) {
      return text.replaceAll("```", "`\u200B``");
    }
    function parseWebhookURL(url2) {
      const matches = url2.match(
        /https?:\/\/(?:ptb\.|canary\.)?discord\.com\/api(?:\/v\d{1,2})?\/webhooks\/(\d{17,19})\/([\w-]{68})/i
      );
      if (!matches || matches.length <= 2)
        return null;
      const [, id, token] = matches;
      return {
        id,
        token
      };
    }
    module2.exports = {
      flatten,
      fetchRecommendedShardCount,
      parseEmoji,
      resolvePartialEmoji,
      mergeDefault,
      makeError,
      makePlainError,
      moveElementInArray,
      verifyString,
      resolveColor,
      discordSort,
      setPosition,
      basename,
      cleanContent,
      cleanCodeBlockContent,
      parseWebhookURL
    };
    var GuildChannel = require_GuildChannel();
  }
});

// node_modules/discord.js/src/client/BaseClient.js
var require_BaseClient = __commonJS({
  "node_modules/discord.js/src/client/BaseClient.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("node:events");
    var { REST } = require_dist5();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Options2 = require_Options();
    var { mergeDefault, flatten } = require_Util();
    var BaseClient2 = class extends EventEmitter2 {
      constructor(options = {}) {
        super({ captureRejections: true });
        if (typeof options !== "object" || options === null) {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        }
        if (options.rest?.userAgentAppendix) {
          options.rest.userAgentAppendix = `${Options2.userAgentAppendix} ${options.rest.userAgentAppendix}`;
        }
        this.options = mergeDefault(Options2.createDefault(), options);
        this.rest = new REST(this.options.rest);
      }
      /**
       * Destroys all assets used by the base client.
       * @returns {void}
       */
      destroy() {
        this.rest.requestManager.clearHashSweeper();
        this.rest.requestManager.clearHandlerSweeper();
      }
      /**
       * Increments max listeners by one, if they are not zero.
       * @private
       */
      incrementMaxListeners() {
        const maxListeners = this.getMaxListeners();
        if (maxListeners !== 0) {
          this.setMaxListeners(maxListeners + 1);
        }
      }
      /**
       * Decrements max listeners by one, if they are not zero.
       * @private
       */
      decrementMaxListeners() {
        const maxListeners = this.getMaxListeners();
        if (maxListeners !== 0) {
          this.setMaxListeners(maxListeners - 1);
        }
      }
      toJSON(...props) {
        return flatten(this, ...props);
      }
    };
    module2.exports = BaseClient2;
  }
});

// node_modules/discord.js/src/util/Enums.js
var require_Enums = __commonJS({
  "node_modules/discord.js/src/util/Enums.js"(exports2, module2) {
    "use strict";
    function createEnum(keys) {
      const obj = {};
      for (const [index, key] of keys.entries()) {
        if (key === null)
          continue;
        obj[key] = index;
        obj[index] = key;
      }
      return obj;
    }
    module2.exports = { createEnum };
  }
});

// node_modules/discord.js/src/util/Partials.js
var require_Partials = __commonJS({
  "node_modules/discord.js/src/util/Partials.js"(exports2, module2) {
    "use strict";
    var { createEnum } = require_Enums();
    module2.exports = createEnum([
      "User",
      "Channel",
      "GuildMember",
      "Message",
      "Reaction",
      "GuildScheduledEvent",
      "ThreadMember"
    ]);
  }
});

// node_modules/discord.js/src/client/actions/Action.js
var require_Action = __commonJS({
  "node_modules/discord.js/src/client/actions/Action.js"(exports2, module2) {
    "use strict";
    var Partials = require_Partials();
    var GenericAction = class {
      constructor(client) {
        this.client = client;
      }
      handle(data) {
        return data;
      }
      getPayload(data, manager, id, partialType, cache) {
        const existing = manager.cache.get(id);
        if (!existing && this.client.options.partials.includes(partialType)) {
          return manager._add(data, cache);
        }
        return existing;
      }
      getChannel(data) {
        const id = data.channel_id ?? data.id;
        return data[this.client.actions.injectedChannel] ?? this.getPayload(
          {
            id,
            guild_id: data.guild_id,
            recipients: [data.author ?? data.user ?? { id: data.user_id }]
          },
          this.client.channels,
          id,
          Partials.Channel
        );
      }
      getMessage(data, channel, cache) {
        const id = data.message_id ?? data.id;
        return data[this.client.actions.injectedMessage] ?? this.getPayload(
          {
            id,
            channel_id: channel.id,
            guild_id: data.guild_id ?? channel.guild?.id
          },
          channel.messages,
          id,
          Partials.Message,
          cache
        );
      }
      getReaction(data, message, user) {
        const id = data.emoji.id ?? decodeURIComponent(data.emoji.name);
        return this.getPayload(
          {
            emoji: data.emoji,
            count: message.partial ? null : 0,
            me: user?.id === this.client.user.id
          },
          message.reactions,
          id,
          Partials.Reaction
        );
      }
      getMember(data, guild) {
        return this.getPayload(data, guild.members, data.user.id, Partials.GuildMember);
      }
      getUser(data) {
        const id = data.user_id;
        return data[this.client.actions.injectedUser] ?? this.getPayload({ id }, this.client.users, id, Partials.User);
      }
      getUserFromMember(data) {
        if (data.guild_id && data.member?.user) {
          const guild = this.client.guilds.cache.get(data.guild_id);
          if (guild) {
            return guild.members._add(data.member).user;
          } else {
            return this.client.users._add(data.member.user);
          }
        }
        return this.getUser(data);
      }
      getScheduledEvent(data, guild) {
        const id = data.guild_scheduled_event_id ?? data.id;
        return this.getPayload(
          { id, guild_id: data.guild_id ?? guild.id },
          guild.scheduledEvents,
          id,
          Partials.GuildScheduledEvent
        );
      }
      getThreadMember(id, manager) {
        return this.getPayload({ user_id: id }, manager, id, Partials.ThreadMember, false);
      }
    };
    module2.exports = GenericAction;
  }
});

// node_modules/discord.js/src/util/Events.js
var require_Events = __commonJS({
  "node_modules/discord.js/src/util/Events.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      ApplicationCommandPermissionsUpdate: "applicationCommandPermissionsUpdate",
      AutoModerationActionExecution: "autoModerationActionExecution",
      AutoModerationRuleCreate: "autoModerationRuleCreate",
      AutoModerationRuleDelete: "autoModerationRuleDelete",
      AutoModerationRuleUpdate: "autoModerationRuleUpdate",
      CacheSweep: "cacheSweep",
      ChannelCreate: "channelCreate",
      ChannelDelete: "channelDelete",
      ChannelPinsUpdate: "channelPinsUpdate",
      ChannelUpdate: "channelUpdate",
      ClientReady: "ready",
      Debug: "debug",
      Error: "error",
      GuildAuditLogEntryCreate: "guildAuditLogEntryCreate",
      GuildBanAdd: "guildBanAdd",
      GuildBanRemove: "guildBanRemove",
      GuildCreate: "guildCreate",
      GuildDelete: "guildDelete",
      GuildEmojiCreate: "emojiCreate",
      GuildEmojiDelete: "emojiDelete",
      GuildEmojiUpdate: "emojiUpdate",
      GuildIntegrationsUpdate: "guildIntegrationsUpdate",
      GuildMemberAdd: "guildMemberAdd",
      GuildMemberAvailable: "guildMemberAvailable",
      GuildMemberRemove: "guildMemberRemove",
      GuildMembersChunk: "guildMembersChunk",
      GuildMemberUpdate: "guildMemberUpdate",
      GuildRoleCreate: "roleCreate",
      GuildRoleDelete: "roleDelete",
      GuildRoleUpdate: "roleUpdate",
      GuildScheduledEventCreate: "guildScheduledEventCreate",
      GuildScheduledEventDelete: "guildScheduledEventDelete",
      GuildScheduledEventUpdate: "guildScheduledEventUpdate",
      GuildScheduledEventUserAdd: "guildScheduledEventUserAdd",
      GuildScheduledEventUserRemove: "guildScheduledEventUserRemove",
      GuildStickerCreate: "stickerCreate",
      GuildStickerDelete: "stickerDelete",
      GuildStickerUpdate: "stickerUpdate",
      GuildUnavailable: "guildUnavailable",
      GuildUpdate: "guildUpdate",
      InteractionCreate: "interactionCreate",
      Invalidated: "invalidated",
      InviteCreate: "inviteCreate",
      InviteDelete: "inviteDelete",
      MessageBulkDelete: "messageDeleteBulk",
      MessageCreate: "messageCreate",
      MessageDelete: "messageDelete",
      MessageReactionAdd: "messageReactionAdd",
      MessageReactionRemove: "messageReactionRemove",
      MessageReactionRemoveAll: "messageReactionRemoveAll",
      MessageReactionRemoveEmoji: "messageReactionRemoveEmoji",
      MessageUpdate: "messageUpdate",
      PresenceUpdate: "presenceUpdate",
      Raw: "raw",
      ShardDisconnect: "shardDisconnect",
      ShardError: "shardError",
      ShardReady: "shardReady",
      ShardReconnecting: "shardReconnecting",
      ShardResume: "shardResume",
      StageInstanceCreate: "stageInstanceCreate",
      StageInstanceDelete: "stageInstanceDelete",
      StageInstanceUpdate: "stageInstanceUpdate",
      ThreadCreate: "threadCreate",
      ThreadDelete: "threadDelete",
      ThreadListSync: "threadListSync",
      ThreadMembersUpdate: "threadMembersUpdate",
      ThreadMemberUpdate: "threadMemberUpdate",
      ThreadUpdate: "threadUpdate",
      TypingStart: "typingStart",
      UserUpdate: "userUpdate",
      VoiceServerUpdate: "voiceServerUpdate",
      VoiceStateUpdate: "voiceStateUpdate",
      Warn: "warn",
      WebhooksUpdate: "webhookUpdate"
    };
  }
});

// node_modules/discord.js/src/client/actions/ApplicationCommandPermissionsUpdate.js
var require_ApplicationCommandPermissionsUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/ApplicationCommandPermissionsUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var ApplicationCommandPermissionsUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        client.emit(Events3.ApplicationCommandPermissionsUpdate, {
          permissions: data.permissions,
          id: data.id,
          guildId: data.guild_id,
          applicationId: data.application_id
        });
      }
    };
    module2.exports = ApplicationCommandPermissionsUpdateAction;
  }
});

// node_modules/discord.js/src/structures/AutoModerationActionExecution.js
var require_AutoModerationActionExecution = __commonJS({
  "node_modules/discord.js/src/structures/AutoModerationActionExecution.js"(exports2, module2) {
    "use strict";
    var { _transformAPIAutoModerationAction } = require_Transformers();
    var AutoModerationActionExecution = class {
      constructor(data, guild) {
        this.guild = guild;
        this.action = _transformAPIAutoModerationAction(data.action);
        this.ruleId = data.rule_id;
        this.ruleTriggerType = data.rule_trigger_type;
        this.userId = data.user_id;
        this.channelId = data.channel_id ?? null;
        this.messageId = data.message_id ?? null;
        this.alertSystemMessageId = data.alert_system_message_id ?? null;
        this.content = data.content;
        this.matchedKeyword = data.matched_keyword ?? null;
        this.matchedContent = data.matched_content ?? null;
      }
      /**
       * The auto moderation rule this action belongs to.
       * @type {?AutoModerationRule}
       * @readonly
       */
      get autoModerationRule() {
        return this.guild.autoModerationRules.cache.get(this.ruleId) ?? null;
      }
      /**
       * The channel where this action was triggered from.
       * @type {?TextBasedChannel}
       * @readonly
       */
      get channel() {
        return this.guild.channels.cache.get(this.channelId) ?? null;
      }
      /**
       * The user that triggered this action.
       * @type {?User}
       * @readonly
       */
      get user() {
        return this.guild.client.users.cache.get(this.userId) ?? null;
      }
      /**
       * The guild member that triggered this action.
       * @type {?GuildMember}
       * @readonly
       */
      get member() {
        return this.guild.members.cache.get(this.userId) ?? null;
      }
    };
    module2.exports = AutoModerationActionExecution;
  }
});

// node_modules/discord.js/src/client/actions/AutoModerationActionExecution.js
var require_AutoModerationActionExecution2 = __commonJS({
  "node_modules/discord.js/src/client/actions/AutoModerationActionExecution.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var AutoModerationActionExecution = require_AutoModerationActionExecution();
    var Events3 = require_Events();
    var AutoModerationActionExecutionAction = class extends Action {
      handle(data) {
        const { client } = this;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          client.emit(Events3.AutoModerationActionExecution, new AutoModerationActionExecution(data, guild));
        }
        return {};
      }
    };
    module2.exports = AutoModerationActionExecutionAction;
  }
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleCreate.js
var require_AutoModerationRuleCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/AutoModerationRuleCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var AutoModerationRuleCreateAction = class extends Action {
      handle(data) {
        const { client } = this;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const autoModerationRule = guild.autoModerationRules._add(data);
          client.emit(Events3.AutoModerationRuleCreate, autoModerationRule);
        }
        return {};
      }
    };
    module2.exports = AutoModerationRuleCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleDelete.js
var require_AutoModerationRuleDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/AutoModerationRuleDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var AutoModerationRuleDeleteAction = class extends Action {
      handle(data) {
        const { client } = this;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const autoModerationRule = guild.autoModerationRules.cache.get(data.id);
          if (autoModerationRule) {
            guild.autoModerationRules.cache.delete(autoModerationRule.id);
            client.emit(Events3.AutoModerationRuleDelete, autoModerationRule);
          }
        }
        return {};
      }
    };
    module2.exports = AutoModerationRuleDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleUpdate.js
var require_AutoModerationRuleUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/AutoModerationRuleUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var AutoModerationRuleUpdateAction = class extends Action {
      handle(data) {
        const { client } = this;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const oldAutoModerationRule = guild.autoModerationRules.cache.get(data.id)?._clone() ?? null;
          const newAutoModerationRule = guild.autoModerationRules._add(data);
          client.emit(Events3.AutoModerationRuleUpdate, oldAutoModerationRule, newAutoModerationRule);
        }
        return {};
      }
    };
    module2.exports = AutoModerationRuleUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/ChannelCreate.js
var require_ChannelCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/ChannelCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var ChannelCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const existing = client.channels.cache.has(data.id);
        const channel = client.channels._add(data);
        if (!existing && channel) {
          client.emit(Events3.ChannelCreate, channel);
        }
        return { channel };
      }
    };
    module2.exports = ChannelCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/ChannelDelete.js
var require_ChannelDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/ChannelDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var ChannelDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.id);
        if (channel) {
          client.channels._remove(channel.id);
          client.emit(Events3.ChannelDelete, channel);
        }
      }
    };
    module2.exports = ChannelDeleteAction;
  }
});

// node_modules/discord.js/src/managers/CategoryChannelChildManager.js
var require_CategoryChannelChildManager = __commonJS({
  "node_modules/discord.js/src/managers/CategoryChannelChildManager.js"(exports2, module2) {
    "use strict";
    var DataManager = require_DataManager();
    var GuildChannel = require_GuildChannel();
    var CategoryChannelChildManager = class extends DataManager {
      constructor(channel) {
        super(channel.client, GuildChannel);
        this.channel = channel;
      }
      /**
       * The channels that are a part of this category
       * @type {Collection<Snowflake, GuildChannel>}
       * @readonly
       */
      get cache() {
        return this.guild.channels.cache.filter((c) => c.parentId === this.channel.id);
      }
      /**
       * The guild this manager belongs to
       * @type {Guild}
       * @readonly
       */
      get guild() {
        return this.channel.guild;
      }
      /**
       * Options for creating a channel using {@link CategoryChannel#createChannel}.
       * @typedef {Object} CategoryCreateChannelOptions
       * @property {string} name The name for the new channel
       * @property {ChannelType} [type=ChannelType.GuildText] The type of the new channel.
       * @property {string} [topic] The topic for the new channel
       * @property {boolean} [nsfw] Whether the new channel is NSFW
       * @property {number} [bitrate] Bitrate of the new channel in bits (only voice)
       * @property {number} [userLimit] Maximum amount of users allowed in the new channel (only voice)
       * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]
       * Permission overwrites of the new channel
       * @property {number} [position] Position of the new channel
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the new channel in seconds
       * @property {string} [rtcRegion] The specific region of the new channel.
       * @property {VideoQualityMode} [videoQualityMode] The camera video quality mode of the voice channel
       * @property {GuildForumTagData[]} [availableTags] The tags that can be used in this channel (forum only).
       * @property {DefaultReactionEmoji} [defaultReactionEmoji]
       * The emoji to show in the add reaction button on a thread in a guild forum channel.
       * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]
       * The default auto archive duration for all new threads in this channel
       * @property {SortOrderType} [defaultSortOrder] The default sort order mode used to order posts (forum only).
       * @property {ForumLayoutType} [defaultForumLayout] The default layout used to display posts (forum only).
       * @property {string} [reason] Reason for creating the new channel
       */
      /**
       * Creates a new channel within this category.
       * <info>You cannot create a channel of type {@link ChannelType.GuildCategory} inside a CategoryChannel.</info>
       * @param {CategoryCreateChannelOptions} options Options for creating the new channel
       * @returns {Promise<GuildChannel>}
       */
      create(options) {
        return this.guild.channels.create({
          ...options,
          parent: this.channel.id
        });
      }
    };
    module2.exports = CategoryChannelChildManager;
  }
});

// node_modules/discord.js/src/structures/CategoryChannel.js
var require_CategoryChannel = __commonJS({
  "node_modules/discord.js/src/structures/CategoryChannel.js"(exports2, module2) {
    "use strict";
    var GuildChannel = require_GuildChannel();
    var CategoryChannelChildManager = require_CategoryChannelChildManager();
    var CategoryChannel = class extends GuildChannel {
      /**
       * Sets the category parent of this channel.
       * <warn>It is not currently possible to set the parent of a CategoryChannel.</warn>
       * @method setParent
       * @memberof CategoryChannel
       * @instance
       * @param {?CategoryChannelResolvable} channel The channel to set as parent
       * @param {SetParentOptions} [options={}] The options for setting the parent
       * @returns {Promise<GuildChannel>}
       */
      /**
       * A manager of the channels belonging to this category
       * @type {CategoryChannelChildManager}
       * @readonly
       */
      get children() {
        return new CategoryChannelChildManager(this);
      }
    };
    module2.exports = CategoryChannel;
  }
});

// node_modules/discord.js/src/structures/interfaces/Collector.js
var require_Collector = __commonJS({
  "node_modules/discord.js/src/structures/interfaces/Collector.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("node:events");
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require("node:timers");
    var { Collection: Collection2 } = require_dist();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { flatten } = require_Util();
    var Collector = class extends EventEmitter2 {
      constructor(client, options = {}) {
        super();
        Object.defineProperty(this, "client", { value: client });
        this.filter = options.filter ?? (() => true);
        this.options = options;
        this.collected = new Collection2();
        this.ended = false;
        this._timeout = null;
        this._idletimeout = null;
        this._endReason = null;
        if (typeof this.filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options.filter", "function");
        }
        this.handleCollect = this.handleCollect.bind(this);
        this.handleDispose = this.handleDispose.bind(this);
        if (options.time)
          this._timeout = setTimeout2(() => this.stop("time"), options.time).unref();
        if (options.idle)
          this._idletimeout = setTimeout2(() => this.stop("idle"), options.idle).unref();
        this.lastCollectedTimestamp = null;
      }
      /**
       * The Date at which this collector last collected an item
       * @type {?Date}
       */
      get lastCollectedAt() {
        return this.lastCollectedTimestamp && new Date(this.lastCollectedTimestamp);
      }
      /**
       * Call this to handle an event as a collectable element. Accepts any event data as parameters.
       * @param {...*} args The arguments emitted by the listener
       * @returns {Promise<void>}
       * @emits Collector#collect
       */
      async handleCollect(...args) {
        const collectedId = await this.collect(...args);
        if (collectedId) {
          const filterResult = await this.filter(...args, this.collected);
          if (filterResult) {
            this.collected.set(collectedId, args[0]);
            this.emit("collect", ...args);
            this.lastCollectedTimestamp = Date.now();
            if (this._idletimeout) {
              clearTimeout2(this._idletimeout);
              this._idletimeout = setTimeout2(() => this.stop("idle"), this.options.idle).unref();
            }
          } else {
            this.emit("ignore", ...args);
          }
        }
        this.checkEnd();
      }
      /**
       * Call this to remove an element from the collection. Accepts any event data as parameters.
       * @param {...*} args The arguments emitted by the listener
       * @returns {Promise<void>}
       * @emits Collector#dispose
       */
      async handleDispose(...args) {
        if (!this.options.dispose)
          return;
        const dispose = this.dispose(...args);
        if (!dispose || !await this.filter(...args) || !this.collected.has(dispose))
          return;
        this.collected.delete(dispose);
        this.emit("dispose", ...args);
        this.checkEnd();
      }
      /**
       * Returns a promise that resolves with the next collected element;
       * rejects with collected elements if the collector finishes without receiving a next element
       * @type {Promise}
       * @readonly
       */
      get next() {
        return new Promise((resolve, reject) => {
          if (this.ended) {
            reject(this.collected);
            return;
          }
          const cleanup = () => {
            this.removeListener("collect", onCollect);
            this.removeListener("end", onEnd);
          };
          const onCollect = (item) => {
            cleanup();
            resolve(item);
          };
          const onEnd = () => {
            cleanup();
            reject(this.collected);
          };
          this.on("collect", onCollect);
          this.on("end", onEnd);
        });
      }
      /**
       * Stops this collector and emits the `end` event.
       * @param {string} [reason='user'] The reason this collector is ending
       * @emits Collector#end
       */
      stop(reason = "user") {
        if (this.ended)
          return;
        if (this._timeout) {
          clearTimeout2(this._timeout);
          this._timeout = null;
        }
        if (this._idletimeout) {
          clearTimeout2(this._idletimeout);
          this._idletimeout = null;
        }
        this._endReason = reason;
        this.ended = true;
        this.emit("end", this.collected, reason);
      }
      /**
       * Options used to reset the timeout and idle timer of a {@link Collector}.
       * @typedef {Object} CollectorResetTimerOptions
       * @property {number} [time] How long to run the collector for (in milliseconds)
       * @property {number} [idle] How long to wait to stop the collector after inactivity (in milliseconds)
       */
      /**
       * Resets the collector's timeout and idle timer.
       * @param {CollectorResetTimerOptions} [options] Options for resetting
       */
      resetTimer({ time, idle } = {}) {
        if (this._timeout) {
          clearTimeout2(this._timeout);
          this._timeout = setTimeout2(() => this.stop("time"), time ?? this.options.time).unref();
        }
        if (this._idletimeout) {
          clearTimeout2(this._idletimeout);
          this._idletimeout = setTimeout2(() => this.stop("idle"), idle ?? this.options.idle).unref();
        }
      }
      /**
       * Checks whether the collector should end, and if so, ends it.
       * @returns {boolean} Whether the collector ended or not
       */
      checkEnd() {
        const reason = this.endReason;
        if (reason)
          this.stop(reason);
        return Boolean(reason);
      }
      /**
       * Allows collectors to be consumed with for-await-of loops
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}
       */
      async *[Symbol.asyncIterator]() {
        const queue = [];
        const onCollect = (...item) => queue.push(item);
        this.on("collect", onCollect);
        try {
          while (queue.length || !this.ended) {
            if (queue.length) {
              yield queue.shift();
            } else {
              await new Promise((resolve) => {
                const tick = () => {
                  this.removeListener("collect", tick);
                  this.removeListener("end", tick);
                  return resolve();
                };
                this.on("collect", tick);
                this.on("end", tick);
              });
            }
          }
        } finally {
          this.removeListener("collect", onCollect);
        }
      }
      toJSON() {
        return flatten(this);
      }
      /* eslint-disable no-empty-function */
      /**
       * The reason this collector has ended with, or null if it hasn't ended yet
       * @type {?string}
       * @readonly
       */
      get endReason() {
        return this._endReason;
      }
      /**
       * Handles incoming events from the `handleCollect` function. Returns null if the event should not
       * be collected, or returns an object describing the data that should be stored.
       * @see Collector#handleCollect
       * @param {...*} args Any args the event listener emits
       * @returns {?(*|Promise<?*>)} Data to insert into collection, if any
       * @abstract
       */
      collect() {
      }
      /**
       * Handles incoming events from the `handleDispose`. Returns null if the event should not
       * be disposed, or returns the key that should be removed.
       * @see Collector#handleDispose
       * @param {...*} args Any args the event listener emits
       * @returns {?*} Key to remove from the collection, if any
       * @abstract
       */
      dispose() {
      }
      /* eslint-enable no-empty-function */
    };
    module2.exports = Collector;
  }
});

// node_modules/discord.js/src/structures/InteractionCollector.js
var require_InteractionCollector = __commonJS({
  "node_modules/discord.js/src/structures/InteractionCollector.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Collector = require_Collector();
    var Events3 = require_Events();
    var InteractionCollector = class extends Collector {
      /**
       * @param {Client} client The client on which to collect interactions
       * @param {InteractionCollectorOptions} [options={}] The options to apply to this collector
       */
      constructor(client, options = {}) {
        super(client, options);
        this.messageId = options.message?.id ?? null;
        this.messageInteractionId = options.interactionResponse?.id ?? null;
        this.channelId = options.interactionResponse?.interaction.channelId ?? options.message?.channelId ?? options.message?.channel_id ?? this.client.channels.resolveId(options.channel);
        this.guildId = options.interactionResponse?.interaction.guildId ?? options.message?.guildId ?? options.message?.guild_id ?? this.client.guilds.resolveId(options.channel?.guild) ?? this.client.guilds.resolveId(options.guild);
        this.interactionType = options.interactionType ?? null;
        this.componentType = options.componentType ?? null;
        this.users = new Collection2();
        this.total = 0;
        this.client.incrementMaxListeners();
        const bulkDeleteListener = (messages) => {
          if (messages.has(this.messageId))
            this.stop("messageDelete");
        };
        if (this.messageId || this.messageInteractionId) {
          this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
          this.client.on(Events3.MessageDelete, this._handleMessageDeletion);
          this.client.on(Events3.MessageBulkDelete, bulkDeleteListener);
        }
        if (this.channelId) {
          this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
          this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
          this.client.on(Events3.ChannelDelete, this._handleChannelDeletion);
          this.client.on(Events3.ThreadDelete, this._handleThreadDeletion);
        }
        if (this.guildId) {
          this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
          this.client.on(Events3.GuildDelete, this._handleGuildDeletion);
        }
        this.client.on(Events3.InteractionCreate, this.handleCollect);
        this.once("end", () => {
          this.client.removeListener(Events3.InteractionCreate, this.handleCollect);
          this.client.removeListener(Events3.MessageDelete, this._handleMessageDeletion);
          this.client.removeListener(Events3.MessageBulkDelete, bulkDeleteListener);
          this.client.removeListener(Events3.ChannelDelete, this._handleChannelDeletion);
          this.client.removeListener(Events3.ThreadDelete, this._handleThreadDeletion);
          this.client.removeListener(Events3.GuildDelete, this._handleGuildDeletion);
          this.client.decrementMaxListeners();
        });
        this.on("collect", (interaction) => {
          this.total++;
          this.users.set(interaction.user.id, interaction.user);
        });
      }
      /**
       * Handles an incoming interaction for possible collection.
       * @param {BaseInteraction} interaction The interaction to possibly collect
       * @returns {?Snowflake}
       * @private
       */
      collect(interaction) {
        if (this.interactionType && interaction.type !== this.interactionType)
          return null;
        if (this.componentType && interaction.componentType !== this.componentType)
          return null;
        if (this.messageId && interaction.message?.id !== this.messageId)
          return null;
        if (this.messageInteractionId && interaction.message?.interaction?.id && interaction.message.interaction.id !== this.messageInteractionId) {
          return null;
        }
        if (this.channelId && interaction.channelId !== this.channelId)
          return null;
        if (this.guildId && interaction.guildId !== this.guildId)
          return null;
        return interaction.id;
      }
      /**
       * Handles an interaction for possible disposal.
       * @param {BaseInteraction} interaction The interaction that could be disposed of
       * @returns {?Snowflake}
       */
      dispose(interaction) {
        if (this.type && interaction.type !== this.type)
          return null;
        if (this.componentType && interaction.componentType !== this.componentType)
          return null;
        if (this.messageId && interaction.message?.id !== this.messageId)
          return null;
        if (this.messageInteractionId && interaction.message?.interaction?.id !== this.messageInteractionId)
          return null;
        if (this.channelId && interaction.channelId !== this.channelId)
          return null;
        if (this.guildId && interaction.guildId !== this.guildId)
          return null;
        return interaction.id;
      }
      /**
       * Empties this interaction collector.
       */
      empty() {
        this.total = 0;
        this.collected.clear();
        this.users.clear();
        this.checkEnd();
      }
      /**
       * The reason this collector has ended with, or null if it hasn't ended yet
       * @type {?string}
       * @readonly
       */
      get endReason() {
        if (this.options.max && this.total >= this.options.max)
          return "limit";
        if (this.options.maxComponents && this.collected.size >= this.options.maxComponents)
          return "componentLimit";
        if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
          return "userLimit";
        return super.endReason;
      }
      /**
       * Handles checking if the message has been deleted, and if so, stops the collector with the reason 'messageDelete'.
       * @private
       * @param {Message} message The message that was deleted
       * @returns {void}
       */
      _handleMessageDeletion(message) {
        if (message.id === this.messageId) {
          this.stop("messageDelete");
        }
        if (message.interaction?.id === this.messageInteractionId) {
          this.stop("messageDelete");
        }
      }
      /**
       * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.
       * @private
       * @param {GuildChannel} channel The channel that was deleted
       * @returns {void}
       */
      _handleChannelDeletion(channel) {
        if (channel.id === this.channelId || channel.threads?.cache.has(this.channelId)) {
          this.stop("channelDelete");
        }
      }
      /**
       * Handles checking if the thread has been deleted, and if so, stops the collector with the reason 'threadDelete'.
       * @private
       * @param {ThreadChannel} thread The thread that was deleted
       * @returns {void}
       */
      _handleThreadDeletion(thread) {
        if (thread.id === this.channelId) {
          this.stop("threadDelete");
        }
      }
      /**
       * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.
       * @private
       * @param {Guild} guild The guild that was deleted
       * @returns {void}
       */
      _handleGuildDeletion(guild) {
        if (guild.id === this.guildId) {
          this.stop("guildDelete");
        }
      }
    };
    module2.exports = InteractionCollector;
  }
});

// node_modules/discord.js/src/structures/MessageCollector.js
var require_MessageCollector = __commonJS({
  "node_modules/discord.js/src/structures/MessageCollector.js"(exports2, module2) {
    "use strict";
    var Collector = require_Collector();
    var Events3 = require_Events();
    var MessageCollector = class extends Collector {
      /**
       * @param {TextBasedChannels} channel The channel
       * @param {MessageCollectorOptions} options The options to be applied to this collector
       * @emits MessageCollector#message
       */
      constructor(channel, options = {}) {
        super(channel.client, options);
        this.channel = channel;
        this.received = 0;
        const bulkDeleteListener = (messages) => {
          for (const message of messages.values())
            this.handleDispose(message);
        };
        this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
        this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
        this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
        this.client.incrementMaxListeners();
        this.client.on(Events3.MessageCreate, this.handleCollect);
        this.client.on(Events3.MessageDelete, this.handleDispose);
        this.client.on(Events3.MessageBulkDelete, bulkDeleteListener);
        this.client.on(Events3.ChannelDelete, this._handleChannelDeletion);
        this.client.on(Events3.ThreadDelete, this._handleThreadDeletion);
        this.client.on(Events3.GuildDelete, this._handleGuildDeletion);
        this.once("end", () => {
          this.client.removeListener(Events3.MessageCreate, this.handleCollect);
          this.client.removeListener(Events3.MessageDelete, this.handleDispose);
          this.client.removeListener(Events3.MessageBulkDelete, bulkDeleteListener);
          this.client.removeListener(Events3.ChannelDelete, this._handleChannelDeletion);
          this.client.removeListener(Events3.ThreadDelete, this._handleThreadDeletion);
          this.client.removeListener(Events3.GuildDelete, this._handleGuildDeletion);
          this.client.decrementMaxListeners();
        });
      }
      /**
       * Handles a message for possible collection.
       * @param {Message} message The message that could be collected
       * @returns {?Snowflake}
       * @private
       */
      collect(message) {
        if (message.channelId !== this.channel.id)
          return null;
        this.received++;
        return message.id;
      }
      /**
       * Handles a message for possible disposal.
       * @param {Message} message The message that could be disposed of
       * @returns {?Snowflake}
       */
      dispose(message) {
        return message.channelId === this.channel.id ? message.id : null;
      }
      /**
       * The reason this collector has ended with, or null if it hasn't ended yet
       * @type {?string}
       * @readonly
       */
      get endReason() {
        if (this.options.max && this.collected.size >= this.options.max)
          return "limit";
        if (this.options.maxProcessed && this.received === this.options.maxProcessed)
          return "processedLimit";
        return super.endReason;
      }
      /**
       * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.
       * @private
       * @param {GuildChannel} channel The channel that was deleted
       * @returns {void}
       */
      _handleChannelDeletion(channel) {
        if (channel.id === this.channel.id || channel.id === this.channel.parentId) {
          this.stop("channelDelete");
        }
      }
      /**
       * Handles checking if the thread has been deleted, and if so, stops the collector with the reason 'threadDelete'.
       * @private
       * @param {ThreadChannel} thread The thread that was deleted
       * @returns {void}
       */
      _handleThreadDeletion(thread) {
        if (thread.id === this.channel.id) {
          this.stop("threadDelete");
        }
      }
      /**
       * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.
       * @private
       * @param {Guild} guild The guild that was deleted
       * @returns {void}
       */
      _handleGuildDeletion(guild) {
        if (guild.id === this.channel.guild?.id) {
          this.stop("guildDelete");
        }
      }
    };
    module2.exports = MessageCollector;
  }
});

// node_modules/discord.js/src/structures/Component.js
var require_Component = __commonJS({
  "node_modules/discord.js/src/structures/Component.js"(exports2, module2) {
    "use strict";
    var isEqual = require_fast_deep_equal();
    var Component = class {
      constructor(data) {
        this.data = data;
      }
      /**
       * The type of the component
       * @type {ComponentType}
       * @readonly
       */
      get type() {
        return this.data.type;
      }
      /**
       * Whether or not the given components are equal
       * @param {Component|APIMessageComponent} other The component to compare against
       * @returns {boolean}
       */
      equals(other) {
        if (other instanceof Component) {
          return isEqual(other.data, this.data);
        }
        return isEqual(other, this.data);
      }
      /**
       * Returns the API-compatible JSON for this component
       * @returns {APIMessageComponent}
       */
      toJSON() {
        return { ...this.data };
      }
    };
    module2.exports = Component;
  }
});

// node_modules/discord.js/src/structures/ActionRow.js
var require_ActionRow = __commonJS({
  "node_modules/discord.js/src/structures/ActionRow.js"(exports2, module2) {
    "use strict";
    var { deprecate } = require("node:util");
    var { isJSONEncodable } = require_dist8();
    var Component = require_Component();
    var { createComponent } = require_Components();
    var _ActionRow = class extends Component {
      constructor({ components, ...data }) {
        super(data);
        this.components = components.map((c) => createComponent(c));
      }
      /**
       * Returns the API-compatible JSON for this component
       * @returns {APIActionRowComponent}
       */
      toJSON() {
        return { ...this.data, components: this.components.map((c) => c.toJSON()) };
      }
    };
    var ActionRow = _ActionRow;
    /**
     * Creates a new action row builder from JSON data
     * @method from
     * @memberof ActionRow
     * @param {JSONEncodable<APIActionRowComponent>|APIActionRowComponent} other The other data
     * @returns {ActionRowBuilder}
     * @deprecated Use {@link ActionRowBuilder.from} instead.
     */
    __publicField(ActionRow, "from", deprecate(
      (other) => new _ActionRow(isJSONEncodable(other) ? other.toJSON() : other),
      "ActionRow.from() is deprecated. Use ActionRowBuilder.from() instead."
    ));
    module2.exports = ActionRow;
  }
});

// node_modules/discord.js/src/structures/ButtonBuilder.js
var require_ButtonBuilder = __commonJS({
  "node_modules/discord.js/src/structures/ButtonBuilder.js"(exports2, module2) {
    "use strict";
    var { ButtonBuilder: BuildersButton, isJSONEncodable } = require_dist8();
    var { toSnakeCase } = require_Transformers();
    var { resolvePartialEmoji } = require_Util();
    var ButtonBuilder = class extends BuildersButton {
      constructor({ emoji, ...data } = {}) {
        super(toSnakeCase({ ...data, emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji }));
      }
      /**
       * Sets the emoji to display on this button
       * @param {string|APIMessageComponentEmoji} emoji The emoji to display on this button
       * @returns {ButtonBuilder}
       */
      setEmoji(emoji) {
        if (typeof emoji === "string") {
          return super.setEmoji(resolvePartialEmoji(emoji));
        }
        return super.setEmoji(emoji);
      }
      /**
       * Creates a new button builder from JSON data
       * @param {JSONEncodable<APIButtonComponent>|APIButtonComponent} other The other data
       * @returns {ButtonBuilder}
       */
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = ButtonBuilder;
  }
});

// node_modules/discord.js/src/structures/ButtonComponent.js
var require_ButtonComponent = __commonJS({
  "node_modules/discord.js/src/structures/ButtonComponent.js"(exports2, module2) {
    "use strict";
    var Component = require_Component();
    var ButtonComponent = class extends Component {
      /**
       * The style of this button
       * @type {ButtonStyle}
       * @readonly
       */
      get style() {
        return this.data.style;
      }
      /**
       * The label of this button
       * @type {?string}
       * @readonly
       */
      get label() {
        return this.data.label ?? null;
      }
      /**
       * The emoji used in this button
       * @type {?APIMessageComponentEmoji}
       * @readonly
       */
      get emoji() {
        return this.data.emoji ?? null;
      }
      /**
       * Whether this button is disabled
       * @type {boolean}
       * @readonly
       */
      get disabled() {
        return this.data.disabled ?? false;
      }
      /**
       * The custom id of this button (only defined on non-link buttons)
       * @type {?string}
       * @readonly
       */
      get customId() {
        return this.data.custom_id ?? null;
      }
      /**
       * The URL of this button (only defined on link buttons)
       * @type {?string}
       * @readonly
       */
      get url() {
        return this.data.url ?? null;
      }
    };
    module2.exports = ButtonComponent;
  }
});

// node_modules/discord.js/src/structures/ChannelSelectMenuBuilder.js
var require_ChannelSelectMenuBuilder = __commonJS({
  "node_modules/discord.js/src/structures/ChannelSelectMenuBuilder.js"(exports2, module2) {
    "use strict";
    var { ChannelSelectMenuBuilder: BuildersChannelSelectMenu, isJSONEncodable } = require_dist8();
    var { toSnakeCase } = require_Transformers();
    var ChannelSelectMenuBuilder = class extends BuildersChannelSelectMenu {
      constructor(data = {}) {
        super(toSnakeCase(data));
      }
      /**
       * Creates a new select menu builder from json data
       * @param {JSONEncodable<APISelectMenuComponent> | APISelectMenuComponent} other The other data
       * @returns {ChannelSelectMenuBuilder}
       */
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = ChannelSelectMenuBuilder;
  }
});

// node_modules/discord.js/src/structures/BaseSelectMenuComponent.js
var require_BaseSelectMenuComponent = __commonJS({
  "node_modules/discord.js/src/structures/BaseSelectMenuComponent.js"(exports2, module2) {
    "use strict";
    var Component = require_Component();
    var BaseSelectMenuComponent = class extends Component {
      /**
       * The placeholder for this select menu
       * @type {?string}
       * @readonly
       */
      get placeholder() {
        return this.data.placeholder ?? null;
      }
      /**
       * The maximum amount of options that can be selected
       * @type {?number}
       * @readonly
       */
      get maxValues() {
        return this.data.max_values ?? null;
      }
      /**
       * The minimum amount of options that must be selected
       * @type {?number}
       * @readonly
       */
      get minValues() {
        return this.data.min_values ?? null;
      }
      /**
       * The custom id of this select menu
       * @type {string}
       * @readonly
       */
      get customId() {
        return this.data.custom_id;
      }
      /**
       * Whether this select menu is disabled
       * @type {boolean}
       * @readonly
       */
      get disabled() {
        return this.data.disabled ?? false;
      }
    };
    module2.exports = BaseSelectMenuComponent;
  }
});

// node_modules/discord.js/src/structures/ChannelSelectMenuComponent.js
var require_ChannelSelectMenuComponent = __commonJS({
  "node_modules/discord.js/src/structures/ChannelSelectMenuComponent.js"(exports2, module2) {
    "use strict";
    var BaseSelectMenuComponent = require_BaseSelectMenuComponent();
    var ChannelSelectMenuComponent = class extends BaseSelectMenuComponent {
      /**
       * The options in this select menu
       * @type {?(ChannelType[])}
       * @readonly
       */
      get channelTypes() {
        return this.data.channel_types ?? null;
      }
    };
    module2.exports = ChannelSelectMenuComponent;
  }
});

// node_modules/discord.js/src/structures/MentionableSelectMenuBuilder.js
var require_MentionableSelectMenuBuilder = __commonJS({
  "node_modules/discord.js/src/structures/MentionableSelectMenuBuilder.js"(exports2, module2) {
    "use strict";
    var { MentionableSelectMenuBuilder: BuildersMentionableSelectMenu, isJSONEncodable } = require_dist8();
    var { toSnakeCase } = require_Transformers();
    var MentionableSelectMenuBuilder = class extends BuildersMentionableSelectMenu {
      constructor(data = {}) {
        super(toSnakeCase(data));
      }
      /**
       * Creates a new select menu builder from json data
       * @param {JSONEncodable<APISelectMenuComponent> | APISelectMenuComponent} other The other data
       * @returns {MentionableSelectMenuBuilder}
       */
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = MentionableSelectMenuBuilder;
  }
});

// node_modules/discord.js/src/structures/MentionableSelectMenuComponent.js
var require_MentionableSelectMenuComponent = __commonJS({
  "node_modules/discord.js/src/structures/MentionableSelectMenuComponent.js"(exports2, module2) {
    "use strict";
    var BaseSelectMenuComponent = require_BaseSelectMenuComponent();
    var MentionableSelectMenuComponent = class extends BaseSelectMenuComponent {
    };
    module2.exports = MentionableSelectMenuComponent;
  }
});

// node_modules/discord.js/src/structures/RoleSelectMenuBuilder.js
var require_RoleSelectMenuBuilder = __commonJS({
  "node_modules/discord.js/src/structures/RoleSelectMenuBuilder.js"(exports2, module2) {
    "use strict";
    var { RoleSelectMenuBuilder: BuildersRoleSelectMenu, isJSONEncodable } = require_dist8();
    var { toSnakeCase } = require_Transformers();
    var RoleSelectMenuBuilder = class extends BuildersRoleSelectMenu {
      constructor(data = {}) {
        super(toSnakeCase(data));
      }
      /**
       * Creates a new select menu builder from json data
       * @param {JSONEncodable<APISelectMenuComponent> | APISelectMenuComponent} other The other data
       * @returns {RoleSelectMenuBuilder}
       */
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = RoleSelectMenuBuilder;
  }
});

// node_modules/discord.js/src/structures/RoleSelectMenuComponent.js
var require_RoleSelectMenuComponent = __commonJS({
  "node_modules/discord.js/src/structures/RoleSelectMenuComponent.js"(exports2, module2) {
    "use strict";
    var BaseSelectMenuComponent = require_BaseSelectMenuComponent();
    var RoleSelectMenuComponent = class extends BaseSelectMenuComponent {
    };
    module2.exports = RoleSelectMenuComponent;
  }
});

// node_modules/discord.js/src/structures/StringSelectMenuBuilder.js
var require_StringSelectMenuBuilder = __commonJS({
  "node_modules/discord.js/src/structures/StringSelectMenuBuilder.js"(exports2, module2) {
    "use strict";
    var { SelectMenuBuilder: BuildersSelectMenu, isJSONEncodable, normalizeArray } = require_dist8();
    var { toSnakeCase } = require_Transformers();
    var { resolvePartialEmoji } = require_Util();
    var StringSelectMenuBuilder = class extends BuildersSelectMenu {
      constructor({ options, ...data } = {}) {
        super(
          toSnakeCase({
            ...data,
            options: options?.map(({ emoji, ...option }) => ({
              ...option,
              emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
            }))
          })
        );
      }
      /**
       * Normalizes a select menu option emoji
       * @param {SelectMenuOptionData|JSONEncodable<APISelectMenuOption>} selectMenuOption The option to normalize
       * @returns {SelectMenuOptionBuilder|APISelectMenuOption}
       * @private
       */
      static normalizeEmoji(selectMenuOption) {
        if (isJSONEncodable(selectMenuOption)) {
          return selectMenuOption;
        }
        const { emoji, ...option } = selectMenuOption;
        return {
          ...option,
          emoji: typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
        };
      }
      /**
       * Adds options to this select menu
       * @param {RestOrArray<APISelectMenuOption>} options The options to add to this select menu
       * @returns {StringSelectMenuBuilder}
       */
      addOptions(...options) {
        return super.addOptions(normalizeArray(options).map((option) => StringSelectMenuBuilder.normalizeEmoji(option)));
      }
      /**
       * Sets the options on this select menu
       * @param {RestOrArray<APISelectMenuOption>} options The options to set on this select menu
       * @returns {StringSelectMenuBuilder}
       */
      setOptions(...options) {
        return super.setOptions(normalizeArray(options).map((option) => StringSelectMenuBuilder.normalizeEmoji(option)));
      }
      /**
       * Creates a new select menu builder from json data
       * @param {JSONEncodable<APISelectMenuComponent> | APISelectMenuComponent} other The other data
       * @returns {StringSelectMenuBuilder}
       */
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = StringSelectMenuBuilder;
  }
});

// node_modules/discord.js/src/structures/StringSelectMenuComponent.js
var require_StringSelectMenuComponent = __commonJS({
  "node_modules/discord.js/src/structures/StringSelectMenuComponent.js"(exports2, module2) {
    "use strict";
    var BaseSelectMenuComponent = require_BaseSelectMenuComponent();
    var StringSelectMenuComponent = class extends BaseSelectMenuComponent {
      /**
       * The options in this select menu
       * @type {APISelectMenuOption[]}
       * @readonly
       */
      get options() {
        return this.data.options;
      }
    };
    module2.exports = StringSelectMenuComponent;
  }
});

// node_modules/discord.js/src/structures/TextInputBuilder.js
var require_TextInputBuilder = __commonJS({
  "node_modules/discord.js/src/structures/TextInputBuilder.js"(exports2, module2) {
    "use strict";
    var { TextInputBuilder: BuildersTextInput, isJSONEncodable } = require_dist8();
    var { toSnakeCase } = require_Transformers();
    var TextInputBuilder = class extends BuildersTextInput {
      constructor(data) {
        super(toSnakeCase(data));
      }
      /**
       * Creates a new text input builder from JSON data
       * @param {JSONEncodable<APITextInputComponent>|APITextInputComponent} other The other data
       * @returns {TextInputBuilder}
       */
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = TextInputBuilder;
  }
});

// node_modules/discord.js/src/structures/TextInputComponent.js
var require_TextInputComponent = __commonJS({
  "node_modules/discord.js/src/structures/TextInputComponent.js"(exports2, module2) {
    "use strict";
    var Component = require_Component();
    var TextInputComponent = class extends Component {
      /**
       * The custom id of this text input
       * @type {string}
       * @readonly
       */
      get customId() {
        return this.data.custom_id;
      }
      /**
       * The value for this text input
       * @type {string}
       * @readonly
       */
      get value() {
        return this.data.value;
      }
    };
    module2.exports = TextInputComponent;
  }
});

// node_modules/discord.js/src/structures/UserSelectMenuBuilder.js
var require_UserSelectMenuBuilder = __commonJS({
  "node_modules/discord.js/src/structures/UserSelectMenuBuilder.js"(exports2, module2) {
    "use strict";
    var { UserSelectMenuBuilder: BuildersUserSelectMenu, isJSONEncodable } = require_dist8();
    var { toSnakeCase } = require_Transformers();
    var UserSelectMenuBuilder = class extends BuildersUserSelectMenu {
      constructor(data = {}) {
        super(toSnakeCase(data));
      }
      /**
       * Creates a new select menu builder from json data
       * @param {JSONEncodable<APISelectMenuComponent> | APISelectMenuComponent} other The other data
       * @returns {UserSelectMenuBuilder}
       */
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = UserSelectMenuBuilder;
  }
});

// node_modules/discord.js/src/structures/UserSelectMenuComponent.js
var require_UserSelectMenuComponent = __commonJS({
  "node_modules/discord.js/src/structures/UserSelectMenuComponent.js"(exports2, module2) {
    "use strict";
    var BaseSelectMenuComponent = require_BaseSelectMenuComponent();
    var UserSelectMenuComponent = class extends BaseSelectMenuComponent {
    };
    module2.exports = UserSelectMenuComponent;
  }
});

// node_modules/discord.js/src/util/Components.js
var require_Components = __commonJS({
  "node_modules/discord.js/src/util/Components.js"(exports2, module2) {
    "use strict";
    var { ComponentBuilder } = require_dist8();
    var { ComponentType } = require_v106();
    function createComponent(data) {
      if (data instanceof Component) {
        return data;
      }
      switch (data.type) {
        case ComponentType.ActionRow:
          return new ActionRow(data);
        case ComponentType.Button:
          return new ButtonComponent(data);
        case ComponentType.StringSelect:
          return new StringSelectMenuComponent(data);
        case ComponentType.TextInput:
          return new TextInputComponent(data);
        case ComponentType.UserSelect:
          return new UserSelectMenuComponent(data);
        case ComponentType.RoleSelect:
          return new RoleSelectMenuComponent(data);
        case ComponentType.MentionableSelect:
          return new MentionableSelectMenuComponent(data);
        case ComponentType.ChannelSelect:
          return new ChannelSelectMenuComponent(data);
        default:
          return new Component(data);
      }
    }
    function createComponentBuilder(data) {
      if (data instanceof ComponentBuilder) {
        return data;
      }
      switch (data.type) {
        case ComponentType.ActionRow:
          return new ActionRowBuilder(data);
        case ComponentType.Button:
          return new ButtonBuilder(data);
        case ComponentType.StringSelect:
          return new StringSelectMenuBuilder(data);
        case ComponentType.TextInput:
          return new TextInputBuilder(data);
        case ComponentType.UserSelect:
          return new UserSelectMenuBuilder(data);
        case ComponentType.RoleSelect:
          return new RoleSelectMenuBuilder(data);
        case ComponentType.MentionableSelect:
          return new MentionableSelectMenuBuilder(data);
        case ComponentType.ChannelSelect:
          return new ChannelSelectMenuBuilder(data);
        default:
          return new ComponentBuilder(data);
      }
    }
    module2.exports = { createComponent, createComponentBuilder };
    var ActionRow = require_ActionRow();
    var ActionRowBuilder = require_ActionRowBuilder();
    var ButtonBuilder = require_ButtonBuilder();
    var ButtonComponent = require_ButtonComponent();
    var ChannelSelectMenuBuilder = require_ChannelSelectMenuBuilder();
    var ChannelSelectMenuComponent = require_ChannelSelectMenuComponent();
    var Component = require_Component();
    var MentionableSelectMenuBuilder = require_MentionableSelectMenuBuilder();
    var MentionableSelectMenuComponent = require_MentionableSelectMenuComponent();
    var RoleSelectMenuBuilder = require_RoleSelectMenuBuilder();
    var RoleSelectMenuComponent = require_RoleSelectMenuComponent();
    var StringSelectMenuBuilder = require_StringSelectMenuBuilder();
    var StringSelectMenuComponent = require_StringSelectMenuComponent();
    var TextInputBuilder = require_TextInputBuilder();
    var TextInputComponent = require_TextInputComponent();
    var UserSelectMenuBuilder = require_UserSelectMenuBuilder();
    var UserSelectMenuComponent = require_UserSelectMenuComponent();
  }
});

// node_modules/discord.js/src/structures/ActionRowBuilder.js
var require_ActionRowBuilder = __commonJS({
  "node_modules/discord.js/src/structures/ActionRowBuilder.js"(exports2, module2) {
    "use strict";
    var { ActionRowBuilder: BuildersActionRow, isJSONEncodable } = require_dist8();
    var { createComponentBuilder } = require_Components();
    var { toSnakeCase } = require_Transformers();
    var ActionRowBuilder = class extends BuildersActionRow {
      constructor({ components, ...data } = {}) {
        super({
          ...toSnakeCase(data),
          components: components?.map((c) => createComponentBuilder(c))
        });
      }
      /**
       * Creates a new action row builder from JSON data
       * @param {JSONEncodable<APIActionRowComponent<APIActionRowComponentTypes>>
       * |APIActionRowComponent<APIActionRowComponentTypes>} other The other data
       * @returns {ActionRowBuilder}
       */
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = ActionRowBuilder;
  }
});

// node_modules/discord.js/src/structures/GuildScheduledEvent.js
var require_GuildScheduledEvent = __commonJS({
  "node_modules/discord.js/src/structures/GuildScheduledEvent.js"(exports2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { GuildScheduledEventStatus, GuildScheduledEventEntityType, RouteBases } = require_v106();
    var Base = require_Base();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var GuildScheduledEvent = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.guildId = data.guild_id;
        this._patch(data);
      }
      _patch(data) {
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        } else {
          this.channelId ??= null;
        }
        if ("creator_id" in data) {
          this.creatorId = data.creator_id;
        } else {
          this.creatorId ??= null;
        }
        this.name = data.name;
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ??= null;
        }
        this.scheduledStartTimestamp = data.scheduled_start_time ? Date.parse(data.scheduled_start_time) : null;
        this.scheduledEndTimestamp = data.scheduled_end_time ? Date.parse(data.scheduled_end_time) : null;
        this.privacyLevel = data.privacy_level;
        this.status = data.status;
        this.entityType = data.entity_type;
        if ("entity_id" in data) {
          this.entityId = data.entity_id;
        } else {
          this.entityId ??= null;
        }
        if ("user_count" in data) {
          this.userCount = data.user_count;
        } else {
          this.userCount ??= null;
        }
        if ("creator" in data) {
          this.creator = this.client.users._add(data.creator);
        } else {
          this.creator ??= this.client.users.resolve(this.creatorId);
        }
        if ("entity_metadata" in data) {
          if (data.entity_metadata) {
            this.entityMetadata = {
              location: data.entity_metadata.location ?? this.entityMetadata?.location ?? null
            };
          } else {
            this.entityMetadata = null;
          }
        } else {
          this.entityMetadata ??= null;
        }
        if ("image" in data) {
          this.image = data.image;
        } else {
          this.image ??= null;
        }
      }
      /**
       * The URL of this scheduled event's cover image
       * @param {BaseImageURLOptions} [options={}] Options for image URL
       * @returns {?string}
       */
      coverImageURL(options = {}) {
        return this.image && this.client.rest.cdn.guildScheduledEventCover(this.id, this.image, options);
      }
      /**
       * The timestamp the guild scheduled event was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the guild scheduled event was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The time the guild scheduled event will start at
       * <info>This can be potentially `null` only when it's an {@link AuditLogEntryTarget}</info>
       * @type {?Date}
       * @readonly
       */
      get scheduledStartAt() {
        return this.scheduledStartTimestamp && new Date(this.scheduledStartTimestamp);
      }
      /**
       * The time the guild scheduled event will end at,
       * or `null` if the event does not have a scheduled time to end
       * @type {?Date}
       * @readonly
       */
      get scheduledEndAt() {
        return this.scheduledEndTimestamp && new Date(this.scheduledEndTimestamp);
      }
      /**
       * The channel associated with this scheduled event
       * @type {?(VoiceChannel|StageChannel)}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * The guild this scheduled event belongs to
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      /**
       * The URL to the guild scheduled event
       * @type {string}
       * @readonly
       */
      get url() {
        return `${RouteBases.scheduledEvent}/${this.guildId}/${this.id}`;
      }
      /**
       * Options used to create an invite URL to a {@link GuildScheduledEvent}
       * @typedef {InviteCreateOptions} GuildScheduledEventInviteURLCreateOptions
       * @property {GuildInvitableChannelResolvable} [channel] The channel to create the invite in.
       * <warn>This is required when the `entityType` of `GuildScheduledEvent` is
       * {@link GuildScheduledEventEntityType.External}, gets ignored otherwise</warn>
       */
      /**
       * Creates an invite URL to this guild scheduled event.
       * @param {GuildScheduledEventInviteURLCreateOptions} [options] The options to create the invite
       * @returns {Promise<string>}
       */
      async createInviteURL(options) {
        let channelId = this.channelId;
        if (this.entityType === GuildScheduledEventEntityType.External) {
          if (!options?.channel)
            throw new DiscordjsError2(ErrorCodes2.InviteOptionsMissingChannel);
          channelId = this.guild.channels.resolveId(options.channel);
          if (!channelId)
            throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        }
        const invite = await this.guild.invites.create(channelId, options);
        return `${RouteBases.invite}/${invite.code}?event=${this.id}`;
      }
      /**
       * Edits this guild scheduled event.
       * @param {GuildScheduledEventEditOptions} options The options to edit the guild scheduled event
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Edit a guild scheduled event
       * guildScheduledEvent.edit({ name: 'Party' })
       *  .then(guildScheduledEvent => console.log(guildScheduledEvent))
       *  .catch(console.error);
       */
      edit(options) {
        return this.guild.scheduledEvents.edit(this.id, options);
      }
      /**
       * Deletes this guild scheduled event.
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Delete a guild scheduled event
       * guildScheduledEvent.delete()
       *  .then(guildScheduledEvent => console.log(guildScheduledEvent))
       *  .catch(console.error);
       */
      async delete() {
        await this.guild.scheduledEvents.delete(this.id);
        return this;
      }
      /**
       * Sets a new name for the guild scheduled event.
       * @param {string} name The new name of the guild scheduled event
       * @param {string} [reason] The reason for changing the name
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set name of a guild scheduled event
       * guildScheduledEvent.setName('Birthday Party')
       *  .then(guildScheduledEvent => console.log(`Set the name to: ${guildScheduledEvent.name}`))
       *  .catch(console.error);
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Sets a new time to schedule the event at.
       * @param {DateResolvable} scheduledStartTime The time to schedule the event at
       * @param {string} [reason] The reason for changing the scheduled start time
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set start time of a guild scheduled event
       * guildScheduledEvent.setScheduledStartTime('2022-09-24T00:00:00+05:30')
       *  .then(guildScheduledEvent => console.log(`Set the start time to: ${guildScheduledEvent.scheduledStartTime}`))
       *  .catch(console.error);
       */
      setScheduledStartTime(scheduledStartTime, reason) {
        return this.edit({ scheduledStartTime, reason });
      }
      // TODO: scheduledEndTime gets reset on passing null but it hasn't been documented
      /**
       * Sets a new time to end the event at.
       * @param {DateResolvable} scheduledEndTime The time to end the event at
       * @param {string} [reason] The reason for changing the scheduled end time
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set end time of a guild scheduled event
       * guildScheduledEvent.setScheduledEndTime('2022-09-25T00:00:00+05:30')
       *  .then(guildScheduledEvent => console.log(`Set the end time to: ${guildScheduledEvent.scheduledEndTime}`))
       *  .catch(console.error);
       */
      setScheduledEndTime(scheduledEndTime, reason) {
        return this.edit({ scheduledEndTime, reason });
      }
      /**
       * Sets the new description of the guild scheduled event.
       * @param {string} description The description of the guild scheduled event
       * @param {string} [reason] The reason for changing the description
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set description of a guild scheduled event
       * guildScheduledEvent.setDescription('A virtual birthday party')
       *  .then(guildScheduledEvent => console.log(`Set the description to: ${guildScheduledEvent.description}`))
       *  .catch(console.error);
       */
      setDescription(description, reason) {
        return this.edit({ description, reason });
      }
      /**
       * Sets the new status of the guild scheduled event.
       * <info>If you're working with TypeScript, use this method in conjunction with status type-guards
       * like {@link GuildScheduledEvent#isScheduled} to get only valid status as suggestion</info>
       * @param {GuildScheduledEventStatus} status The status of the guild scheduled event
       * @param {string} [reason] The reason for changing the status
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set status of a guild scheduled event
       * guildScheduledEvent.setStatus(GuildScheduledEventStatus.Active)
       *  .then(guildScheduledEvent => console.log(`Set the status to: ${guildScheduledEvent.status}`))
       *  .catch(console.error);
       */
      setStatus(status, reason) {
        return this.edit({ status, reason });
      }
      /**
       * Sets the new location of the guild scheduled event.
       * @param {string} location The location of the guild scheduled event
       * @param {string} [reason] The reason for changing the location
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set location of a guild scheduled event
       * guildScheduledEvent.setLocation('Earth')
       *  .then(guildScheduledEvent => console.log(`Set the location to: ${guildScheduledEvent.entityMetadata.location}`))
       *  .catch(console.error);
       */
      setLocation(location, reason) {
        return this.edit({ entityMetadata: { location }, reason });
      }
      /**
       * Fetches subscribers of this guild scheduled event.
       * @param {FetchGuildScheduledEventSubscribersOptions} [options] Options for fetching the subscribers
       * @returns {Promise<Collection<Snowflake, GuildScheduledEventUser>>}
       */
      fetchSubscribers(options) {
        return this.guild.scheduledEvents.fetchSubscribers(this.id, options);
      }
      /**
       * When concatenated with a string, this automatically concatenates the event's URL instead of the object.
       * @returns {string}
       * @example
       * // Logs: Event: https://discord.com/events/412345678901234567/499876543211234567
       * console.log(`Event: ${guildScheduledEvent}`);
       */
      toString() {
        return this.url;
      }
      /**
       * Indicates whether this guild scheduled event has an {@link GuildScheduledEventStatus.Active} status.
       * @returns {boolean}
       */
      isActive() {
        return this.status === GuildScheduledEventStatus.Active;
      }
      /**
       * Indicates whether this guild scheduled event has a {@link GuildScheduledEventStatus.Canceled} status.
       * @returns {boolean}
       */
      isCanceled() {
        return this.status === GuildScheduledEventStatus.Canceled;
      }
      /**
       * Indicates whether this guild scheduled event has a {@link GuildScheduledEventStatus.Completed} status.
       * @returns {boolean}
       */
      isCompleted() {
        return this.status === GuildScheduledEventStatus.Completed;
      }
      /**
       * Indicates whether this guild scheduled event has a {@link GuildScheduledEventStatus.Scheduled} status.
       * @returns {boolean}
       */
      isScheduled() {
        return this.status === GuildScheduledEventStatus.Scheduled;
      }
    };
    exports2.GuildScheduledEvent = GuildScheduledEvent;
  }
});

// node_modules/discord.js/src/structures/interfaces/Application.js
var require_Application = __commonJS({
  "node_modules/discord.js/src/structures/interfaces/Application.js"(exports2, module2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var Application = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        } else {
          this.name ??= null;
        }
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ??= null;
        }
        if ("icon" in data) {
          this.icon = data.icon;
        } else {
          this.icon ??= null;
        }
      }
      /**
       * The timestamp the application was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the application was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * A link to the application's icon.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.appIcon(this.id, this.icon, options);
      }
      /**
       * A link to this application's cover image.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      coverURL(options = {}) {
        return this.cover && this.client.rest.cdn.appIcon(this.id, this.cover, options);
      }
      /**
       * When concatenated with a string, this automatically returns the application's name instead of the
       * Application object.
       * @returns {?string}
       * @example
       * // Logs: Application name: My App
       * console.log(`Application name: ${application}`);
       */
      toString() {
        return this.name;
      }
      toJSON() {
        return super.toJSON({ createdTimestamp: true });
      }
    };
    module2.exports = Application;
  }
});

// node_modules/discord.js/src/structures/IntegrationApplication.js
var require_IntegrationApplication = __commonJS({
  "node_modules/discord.js/src/structures/IntegrationApplication.js"(exports2, module2) {
    "use strict";
    var Application = require_Application();
    var IntegrationApplication = class extends Application {
      _patch(data) {
        super._patch(data);
        if ("bot" in data) {
          this.bot = this.client.users._add(data.bot);
        } else {
          this.bot ??= null;
        }
        if ("terms_of_service_url" in data) {
          this.termsOfServiceURL = data.terms_of_service_url;
        } else {
          this.termsOfServiceURL ??= null;
        }
        if ("privacy_policy_url" in data) {
          this.privacyPolicyURL = data.privacy_policy_url;
        } else {
          this.privacyPolicyURL ??= null;
        }
        if ("rpc_origins" in data) {
          this.rpcOrigins = data.rpc_origins;
        } else {
          this.rpcOrigins ??= [];
        }
        if ("hook" in data) {
          this.hook = data.hook;
        } else {
          this.hook ??= null;
        }
        if ("cover_image" in data) {
          this.cover = data.cover_image;
        } else {
          this.cover ??= null;
        }
        if ("verify_key" in data) {
          this.verifyKey = data.verify_key;
        } else {
          this.verifyKey ??= null;
        }
      }
    };
    module2.exports = IntegrationApplication;
  }
});

// node_modules/discord.js/src/structures/InviteStageInstance.js
var require_InviteStageInstance = __commonJS({
  "node_modules/discord.js/src/structures/InviteStageInstance.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Base = require_Base();
    var InviteStageInstance = class extends Base {
      constructor(client, data, channelId, guildId) {
        super(client);
        this.channelId = channelId;
        this.guildId = guildId;
        this.members = new Collection2();
        this._patch(data);
      }
      _patch(data) {
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("participant_count" in data) {
          this.participantCount = data.participant_count;
        }
        if ("speaker_count" in data) {
          this.speakerCount = data.speaker_count;
        }
        this.members.clear();
        for (const rawMember of data.members) {
          const member = this.guild.members._add(rawMember);
          this.members.set(member.id, member);
        }
      }
      /**
       * The stage channel this invite is for
       * @type {?StageChannel}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * The guild of the stage channel this invite is for
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
    };
    module2.exports = InviteStageInstance;
  }
});

// node_modules/discord.js/src/structures/BaseGuild.js
var require_BaseGuild = __commonJS({
  "node_modules/discord.js/src/structures/BaseGuild.js"(exports2, module2) {
    "use strict";
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { DiscordSnowflake } = require_dist3();
    var { Routes: Routes2, GuildFeature } = require_v106();
    var Base = require_Base();
    var BaseGuild = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.name = data.name;
        this.icon = data.icon;
        this.features = data.features;
      }
      /**
       * The timestamp this guild was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time this guild was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The acronym that shows up in place of a guild icon
       * @type {string}
       * @readonly
       */
      get nameAcronym() {
        return this.name.replace(/'s /g, " ").replace(/\w+/g, (e) => e[0]).replace(/\s/g, "");
      }
      /**
       * Whether this guild is partnered
       * @type {boolean}
       * @readonly
       */
      get partnered() {
        return this.features.includes(GuildFeature.Partnered);
      }
      /**
       * Whether this guild is verified
       * @type {boolean}
       * @readonly
       */
      get verified() {
        return this.features.includes(GuildFeature.Verified);
      }
      /**
       * The URL to this guild's icon.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
      }
      /**
       * Fetches this guild.
       * @returns {Promise<Guild>}
       */
      async fetch() {
        const data = await this.client.rest.get(Routes2.guild(this.id), {
          query: makeURLSearchParams2({ with_counts: true })
        });
        return this.client.guilds._add(data);
      }
      /**
       * When concatenated with a string, this automatically returns the guild's name instead of the Guild object.
       * @returns {string}
       */
      toString() {
        return this.name;
      }
    };
    module2.exports = BaseGuild;
  }
});

// node_modules/discord.js/src/structures/AnonymousGuild.js
var require_AnonymousGuild = __commonJS({
  "node_modules/discord.js/src/structures/AnonymousGuild.js"(exports2, module2) {
    "use strict";
    var BaseGuild = require_BaseGuild();
    var AnonymousGuild = class extends BaseGuild {
      constructor(client, data, immediatePatch = true) {
        super(client, data);
        if (immediatePatch)
          this._patch(data);
      }
      _patch(data) {
        if ("features" in data)
          this.features = data.features;
        if ("splash" in data) {
          this.splash = data.splash;
        }
        if ("banner" in data) {
          this.banner = data.banner;
        }
        if ("description" in data) {
          this.description = data.description;
        }
        if ("verification_level" in data) {
          this.verificationLevel = data.verification_level;
        }
        if ("vanity_url_code" in data) {
          this.vanityURLCode = data.vanity_url_code;
        }
        if ("nsfw_level" in data) {
          this.nsfwLevel = data.nsfw_level;
        }
        if ("premium_subscription_count" in data) {
          this.premiumSubscriptionCount = data.premium_subscription_count;
        } else {
          this.premiumSubscriptionCount ??= null;
        }
      }
      /**
       * The URL to this guild's banner.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      bannerURL(options = {}) {
        return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
      }
      /**
       * The URL to this guild's invite splash image.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      splashURL(options = {}) {
        return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
      }
    };
    module2.exports = AnonymousGuild;
  }
});

// node_modules/discord.js/src/structures/Emoji.js
var require_Emoji = __commonJS({
  "node_modules/discord.js/src/structures/Emoji.js"(exports2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var Emoji = class extends Base {
      constructor(client, emoji) {
        super(client);
        this.animated = emoji.animated ?? null;
        this.name = emoji.name ?? null;
        this.id = emoji.id;
      }
      /**
       * The identifier of this emoji, used for message reactions
       * @type {string}
       * @readonly
       */
      get identifier() {
        if (this.id)
          return `${this.animated ? "a:" : ""}${this.name}:${this.id}`;
        return encodeURIComponent(this.name);
      }
      /**
       * The URL to the emoji file if it's a custom emoji
       * @type {?string}
       * @readonly
       */
      get url() {
        return this.id && this.client.rest.cdn.emoji(this.id, this.animated ? "gif" : "png");
      }
      /**
       * The timestamp the emoji was created at, or null if unicode
       * @type {?number}
       * @readonly
       */
      get createdTimestamp() {
        return this.id && DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the emoji was created at, or null if unicode
       * @type {?Date}
       * @readonly
       */
      get createdAt() {
        return this.id && new Date(this.createdTimestamp);
      }
      /**
       * When concatenated with a string, this automatically returns the text required to form a graphical emoji on Discord
       * instead of the Emoji object.
       * @returns {string}
       * @example
       * // Send a custom emoji from a guild:
       * const emoji = guild.emojis.cache.first();
       * msg.channel.send(`Hello! ${emoji}`);
       * @example
       * // Send the emoji used in a reaction to the channel the reaction is part of
       * reaction.message.channel.send(`The emoji used was: ${reaction.emoji}`);
       */
      toString() {
        return this.id ? `<${this.animated ? "a" : ""}:${this.name}:${this.id}>` : this.name;
      }
      toJSON() {
        return super.toJSON({
          guild: "guildId",
          createdTimestamp: true,
          url: true,
          identifier: true
        });
      }
    };
    exports2.Emoji = Emoji;
  }
});

// node_modules/discord.js/src/structures/WelcomeChannel.js
var require_WelcomeChannel = __commonJS({
  "node_modules/discord.js/src/structures/WelcomeChannel.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var { Emoji } = require_Emoji();
    var WelcomeChannel = class extends Base {
      constructor(guild, data) {
        super(guild.client);
        this.guild = guild;
        this.description = data.description;
        this._emoji = {
          name: data.emoji_name,
          id: data.emoji_id
        };
        this.channelId = data.channel_id;
      }
      /**
       * The channel of this welcome channel
       * @type {?(TextChannel|NewsChannel|ForumChannel)}
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * The emoji of this welcome channel
       * @type {GuildEmoji|Emoji}
       */
      get emoji() {
        return this.client.emojis.resolve(this._emoji.id) ?? new Emoji(this.client, this._emoji);
      }
    };
    module2.exports = WelcomeChannel;
  }
});

// node_modules/discord.js/src/structures/WelcomeScreen.js
var require_WelcomeScreen = __commonJS({
  "node_modules/discord.js/src/structures/WelcomeScreen.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { GuildFeature } = require_v106();
    var Base = require_Base();
    var WelcomeChannel = require_WelcomeChannel();
    var WelcomeScreen = class extends Base {
      constructor(guild, data) {
        super(guild.client);
        this.guild = guild;
        this.description = data.description ?? null;
        this.welcomeChannels = new Collection2();
        for (const channel of data.welcome_channels) {
          const welcomeChannel = new WelcomeChannel(this.guild, channel);
          this.welcomeChannels.set(welcomeChannel.channelId, welcomeChannel);
        }
      }
      /**
       * Whether the welcome screen is enabled on the guild
       * @type {boolean}
       */
      get enabled() {
        return this.guild.features.includes(GuildFeature.WelcomeScreenEnabled);
      }
    };
    module2.exports = WelcomeScreen;
  }
});

// node_modules/discord.js/src/structures/InviteGuild.js
var require_InviteGuild = __commonJS({
  "node_modules/discord.js/src/structures/InviteGuild.js"(exports2, module2) {
    "use strict";
    var AnonymousGuild = require_AnonymousGuild();
    var WelcomeScreen = require_WelcomeScreen();
    var InviteGuild = class extends AnonymousGuild {
      constructor(client, data) {
        super(client, data);
        this.welcomeScreen = data.welcome_screen !== void 0 ? new WelcomeScreen(this, data.welcome_screen) : null;
      }
    };
    module2.exports = InviteGuild;
  }
});

// node_modules/discord.js/src/structures/Invite.js
var require_Invite = __commonJS({
  "node_modules/discord.js/src/structures/Invite.js"(exports2, module2) {
    "use strict";
    var { RouteBases, Routes: Routes2, PermissionFlagsBits } = require_v106();
    var Base = require_Base();
    var { GuildScheduledEvent } = require_GuildScheduledEvent();
    var IntegrationApplication = require_IntegrationApplication();
    var InviteStageInstance = require_InviteStageInstance();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Invite2 = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        const InviteGuild = require_InviteGuild();
        this.guild ??= null;
        if (data.guild) {
          this.guild = this.client.guilds.resolve(data.guild.id) ?? new InviteGuild(this.client, data.guild);
        }
        if ("code" in data) {
          this.code = data.code;
        }
        if ("approximate_presence_count" in data) {
          this.presenceCount = data.approximate_presence_count;
        } else {
          this.presenceCount ??= null;
        }
        if ("approximate_member_count" in data) {
          this.memberCount = data.approximate_member_count;
        } else {
          this.memberCount ??= null;
        }
        if ("temporary" in data) {
          this.temporary = data.temporary ?? null;
        } else {
          this.temporary ??= null;
        }
        if ("max_age" in data) {
          this.maxAge = data.max_age;
        } else {
          this.maxAge ??= null;
        }
        if ("uses" in data) {
          this.uses = data.uses;
        } else {
          this.uses ??= null;
        }
        if ("max_uses" in data) {
          this.maxUses = data.max_uses;
        } else {
          this.maxUses ??= null;
        }
        if ("inviter_id" in data) {
          this.inviterId = data.inviter_id;
        } else {
          this.inviterId ??= null;
        }
        if ("inviter" in data) {
          this.client.users._add(data.inviter);
          this.inviterId = data.inviter.id;
        }
        if ("target_user" in data) {
          this.targetUser = this.client.users._add(data.target_user);
        } else {
          this.targetUser ??= null;
        }
        if ("target_application" in data) {
          this.targetApplication = new IntegrationApplication(this.client, data.target_application);
        } else {
          this.targetApplication ??= null;
        }
        if ("target_type" in data) {
          this.targetType = data.target_type;
        } else {
          this.targetType ??= null;
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        }
        if ("channel" in data) {
          this.channel = this.client.channels._add(data.channel, this.guild, { cache: false }) ?? this.client.channels.resolve(this.channelId);
          this.channelId ??= data.channel.id;
        }
        if ("created_at" in data) {
          this.createdTimestamp = Date.parse(data.created_at);
        } else {
          this.createdTimestamp ??= null;
        }
        if ("expires_at" in data) {
          this._expiresTimestamp = data.expires_at && Date.parse(data.expires_at);
        } else {
          this._expiresTimestamp ??= null;
        }
        if ("stage_instance" in data) {
          this.stageInstance = new InviteStageInstance(this.client, data.stage_instance, this.channel.id, this.guild.id);
        } else {
          this.stageInstance ??= null;
        }
        if ("guild_scheduled_event" in data) {
          this.guildScheduledEvent = new GuildScheduledEvent(this.client, data.guild_scheduled_event);
        } else {
          this.guildScheduledEvent ??= null;
        }
      }
      /**
       * The time the invite was created at
       * @type {?Date}
       * @readonly
       */
      get createdAt() {
        return this.createdTimestamp && new Date(this.createdTimestamp);
      }
      /**
       * Whether the invite is deletable by the client user
       * @type {boolean}
       * @readonly
       */
      get deletable() {
        const guild = this.guild;
        if (!guild || !this.client.guilds.cache.has(guild.id))
          return false;
        if (!guild.members.me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        return Boolean(
          this.channel?.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageChannels, false) || guild.members.me.permissions.has(PermissionFlagsBits.ManageGuild)
        );
      }
      /**
       * The timestamp the invite will expire at
       * @type {?number}
       * @readonly
       */
      get expiresTimestamp() {
        return this._expiresTimestamp ?? (this.createdTimestamp && this.maxAge ? this.createdTimestamp + this.maxAge * 1e3 : null);
      }
      /**
       * The time the invite will expire at
       * @type {?Date}
       * @readonly
       */
      get expiresAt() {
        return this.expiresTimestamp && new Date(this.expiresTimestamp);
      }
      /**
       * The user who created this invite
       * @type {?User}
       * @readonly
       */
      get inviter() {
        return this.inviterId && this.client.users.resolve(this.inviterId);
      }
      /**
       * The URL to the invite
       * @type {string}
       * @readonly
       */
      get url() {
        return `${RouteBases.invite}/${this.code}`;
      }
      /**
       * Deletes this invite.
       * @param {string} [reason] Reason for deleting this invite
       * @returns {Promise<Invite>}
       */
      async delete(reason) {
        await this.client.rest.delete(Routes2.invite(this.code), { reason });
        return this;
      }
      /**
       * When concatenated with a string, this automatically concatenates the invite's URL instead of the object.
       * @returns {string}
       * @example
       * // Logs: Invite: https://discord.gg/A1b2C3
       * console.log(`Invite: ${invite}`);
       */
      toString() {
        return this.url;
      }
      toJSON() {
        return super.toJSON({
          url: true,
          expiresTimestamp: true,
          presenceCount: false,
          memberCount: false,
          uses: false,
          channel: "channelId",
          inviter: "inviterId",
          guild: "guildId"
        });
      }
      valueOf() {
        return this.code;
      }
    };
    /**
     * A regular expression that matches Discord invite links.
     * The `code` group property is present on the `exec()` result of this expression.
     * @type {RegExp}
     * @memberof Invite
     */
    __publicField(Invite2, "InvitesPattern", /discord(?:(?:app)?\.com\/invite|\.gg(?:\/invite)?)\/(?<code>[\w-]{2,255})/i);
    module2.exports = Invite2;
  }
});

// node_modules/discord.js/src/structures/GuildTemplate.js
var require_GuildTemplate = __commonJS({
  "node_modules/discord.js/src/structures/GuildTemplate.js"(exports2, module2) {
    "use strict";
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require("node:timers");
    var { RouteBases, Routes: Routes2 } = require_v106();
    var Base = require_Base();
    var DataResolver2 = require_DataResolver();
    var Events3 = require_Events();
    var GuildTemplate2 = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        if ("code" in data) {
          this.code = data.code;
        }
        if ("name" in data) {
          this.name = data.name;
        }
        if ("description" in data) {
          this.description = data.description;
        }
        if ("usage_count" in data) {
          this.usageCount = data.usage_count;
        }
        if ("creator_id" in data) {
          this.creatorId = data.creator_id;
        }
        if ("creator" in data) {
          this.creator = this.client.users._add(data.creator);
        }
        if ("created_at" in data) {
          this.createdTimestamp = Date.parse(data.created_at);
        }
        if ("updated_at" in data) {
          this.updatedTimestamp = Date.parse(data.updated_at);
        }
        if ("source_guild_id" in data) {
          this.guildId = data.source_guild_id;
        }
        if ("serialized_source_guild" in data) {
          this.serializedGuild = data.serialized_source_guild;
        }
        this.unSynced = "is_dirty" in data ? Boolean(data.is_dirty) : null;
        return this;
      }
      /**
       * Creates a guild based on this template.
       * <warn>This is only available to bots in fewer than 10 guilds.</warn>
       * @param {string} name The name of the guild
       * @param {BufferResolvable|Base64Resolvable} [icon] The icon for the guild
       * @returns {Promise<Guild>}
       */
      async createGuild(name, icon) {
        const { client } = this;
        const data = await client.rest.post(Routes2.template(this.code), {
          body: {
            name,
            icon: await DataResolver2.resolveImage(icon)
          }
        });
        if (client.guilds.cache.has(data.id))
          return client.guilds.cache.get(data.id);
        return new Promise((resolve) => {
          const resolveGuild = (guild) => {
            client.off(Events3.GuildCreate, handleGuild);
            client.decrementMaxListeners();
            resolve(guild);
          };
          const handleGuild = (guild) => {
            if (guild.id === data.id) {
              clearTimeout2(timeout);
              resolveGuild(guild);
            }
          };
          client.incrementMaxListeners();
          client.on(Events3.GuildCreate, handleGuild);
          const timeout = setTimeout2(() => resolveGuild(client.guilds._add(data)), 1e4).unref();
        });
      }
      /**
       * Options used to edit a guild template.
       * @typedef {Object} GuildTemplateEditOptions
       * @property {string} [name] The name of this template
       * @property {string} [description] The description of this template
       */
      /**
       * Updates the metadata of this template.
       * @param {GuildTemplateEditOptions} [options] Options for editing the template
       * @returns {Promise<GuildTemplate>}
       */
      async edit({ name, description } = {}) {
        const data = await this.client.rest.patch(Routes2.guildTemplate(this.guildId, this.code), {
          body: { name, description }
        });
        return this._patch(data);
      }
      /**
       * Deletes this template.
       * @returns {Promise<GuildTemplate>}
       */
      async delete() {
        await this.client.rest.delete(Routes2.guildTemplate(this.guildId, this.code));
        return this;
      }
      /**
       * Syncs this template to the current state of the guild.
       * @returns {Promise<GuildTemplate>}
       */
      async sync() {
        const data = await this.client.rest.put(Routes2.guildTemplate(this.guildId, this.code));
        return this._patch(data);
      }
      /**
       * The time when this template was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The time when this template was last synced to the guild
       * @type {Date}
       * @readonly
       */
      get updatedAt() {
        return new Date(this.updatedTimestamp);
      }
      /**
       * The guild that this template belongs to
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      /**
       * The URL of this template
       * @type {string}
       * @readonly
       */
      get url() {
        return `${RouteBases.template}/${this.code}`;
      }
      /**
       * When concatenated with a string, this automatically returns the template's code instead of the template object.
       * @returns {string}
       * @example
       * // Logs: Template: FKvmczH2HyUf
       * console.log(`Template: ${guildTemplate}!`);
       */
      toString() {
        return this.code;
      }
    };
    /**
     * A regular expression that matches guild template links.
     * The `code` group property is present on the `exec()` result of this expression.
     * @type {RegExp}
     * @memberof GuildTemplate
     */
    __publicField(GuildTemplate2, "GuildTemplatesPattern", /discord(?:app)?\.(?:com\/template|new)\/(?<code>[\w-]{2,255})/i);
    module2.exports = GuildTemplate2;
  }
});

// node_modules/discord.js/src/util/DataResolver.js
var require_DataResolver = __commonJS({
  "node_modules/discord.js/src/util/DataResolver.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer5 } = require("node:buffer");
    var fs2 = require("node:fs/promises");
    var path = require("node:path");
    var { fetch } = require_undici();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Invite2 = require_Invite();
    var DataResolver2 = class extends null {
      /**
       * Data that can be resolved to give an invite code. This can be:
       * * An invite code
       * * An invite URL
       * @typedef {string} InviteResolvable
       */
      /**
       * Data that can be resolved to give a template code. This can be:
       * * A template code
       * * A template URL
       * @typedef {string} GuildTemplateResolvable
       */
      /**
       * Resolves the string to a code based on the passed regex.
       * @param {string} data The string to resolve
       * @param {RegExp} regex The RegExp used to extract the code
       * @returns {string}
       */
      static resolveCode(data, regex) {
        return regex.exec(data)?.[1] ?? data;
      }
      /**
       * Resolves InviteResolvable to an invite code.
       * @param {InviteResolvable} data The invite resolvable to resolve
       * @returns {string}
       */
      static resolveInviteCode(data) {
        return this.resolveCode(data, Invite2.InvitesPattern);
      }
      /**
       * Resolves GuildTemplateResolvable to a template code.
       * @param {GuildTemplateResolvable} data The template resolvable to resolve
       * @returns {string}
       */
      static resolveGuildTemplateCode(data) {
        const GuildTemplate2 = require_GuildTemplate();
        return this.resolveCode(data, GuildTemplate2.GuildTemplatesPattern);
      }
      /**
       * Resolves a Base64Resolvable, a string, or a BufferResolvable to a Base 64 image.
       * @param {BufferResolvable|Base64Resolvable} image The image to be resolved
       * @returns {Promise<?string>}
       */
      static async resolveImage(image) {
        if (!image)
          return null;
        if (typeof image === "string" && image.startsWith("data:")) {
          return image;
        }
        const file = await this.resolveFile(image);
        return this.resolveBase64(file.data);
      }
      /**
       * Data that resolves to give a Base64 string, typically for image uploading. This can be:
       * * A Buffer
       * * A base64 string
       * @typedef {Buffer|string} Base64Resolvable
       */
      /**
       * Resolves a Base64Resolvable to a Base 64 image.
       * @param {Base64Resolvable} data The base 64 resolvable you want to resolve
       * @returns {?string}
       */
      static resolveBase64(data) {
        if (Buffer5.isBuffer(data))
          return `data:image/jpg;base64,${data.toString("base64")}`;
        return data;
      }
      /**
       * Data that can be resolved to give a Buffer. This can be:
       * * A Buffer
       * * The path to a local file
       * * A URL <warn>When provided a URL, discord.js will fetch the URL internally in order to create a Buffer.
       * This can pose a security risk when the URL has not been sanitized</warn>
       * @typedef {string|Buffer} BufferResolvable
       */
      /**
       * @external Stream
       * @see {@link https://nodejs.org/api/stream.html}
       */
      /**
       * @typedef {Object} ResolvedFile
       * @property {Buffer} data Buffer containing the file data
       * @property {string} [contentType] Content type of the file
       */
      /**
       * Resolves a BufferResolvable to a Buffer.
       * @param {BufferResolvable|Stream} resource The buffer or stream resolvable to resolve
       * @returns {Promise<ResolvedFile>}
       */
      static async resolveFile(resource) {
        if (Buffer5.isBuffer(resource))
          return { data: resource };
        if (typeof resource[Symbol.asyncIterator] === "function") {
          const buffers = [];
          for await (const data of resource)
            buffers.push(Buffer5.from(data));
          return { data: Buffer5.concat(buffers) };
        }
        if (typeof resource === "string") {
          if (/^https?:\/\//.test(resource)) {
            const res = await fetch(resource);
            return { data: Buffer5.from(await res.arrayBuffer()), contentType: res.headers.get("content-type") };
          }
          const file = path.resolve(resource);
          const stats = await fs2.stat(file);
          if (!stats.isFile())
            throw new DiscordjsError2(ErrorCodes2.FileNotFound, file);
          return { data: await fs2.readFile(file) };
        }
        throw new DiscordjsTypeError2(ErrorCodes2.ReqResourceType);
      }
    };
    module2.exports = DataResolver2;
  }
});

// node_modules/discord.js/src/util/MessageFlagsBitField.js
var require_MessageFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/MessageFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { MessageFlags } = require_v106();
    var BitField = require_BitField();
    var MessageFlagsBitField = class extends BitField {
    };
    /**
     * Numeric message flags.
     * @type {MessageFlags}
     * @memberof MessageFlagsBitField
     */
    __publicField(MessageFlagsBitField, "Flags", MessageFlags);
    module2.exports = MessageFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/BaseInteraction.js
var require_BaseInteraction = __commonJS({
  "node_modules/discord.js/src/structures/BaseInteraction.js"(exports2, module2) {
    "use strict";
    var { deprecate } = require("node:util");
    var { DiscordSnowflake } = require_dist3();
    var { InteractionType, ApplicationCommandType, ComponentType } = require_v106();
    var Base = require_Base();
    var { SelectMenuTypes } = require_Constants();
    var PermissionsBitField2 = require_PermissionsBitField();
    var BaseInteraction = class extends Base {
      constructor(client, data) {
        super(client);
        this.type = data.type;
        this.id = data.id;
        Object.defineProperty(this, "token", { value: data.token });
        this.applicationId = data.application_id;
        this.channelId = data.channel_id ?? null;
        this.guildId = data.guild_id ?? null;
        this.user = this.client.users._add(data.user ?? data.member.user);
        this.member = data.member ? this.guild?.members._add(data.member) ?? data.member : null;
        this.version = data.version;
        this.appPermissions = data.app_permissions ? new PermissionsBitField2(data.app_permissions).freeze() : null;
        this.memberPermissions = data.member?.permissions ? new PermissionsBitField2(data.member.permissions).freeze() : null;
        this.locale = data.locale;
        this.guildLocale = data.guild_locale ?? null;
      }
      /**
       * The timestamp the interaction was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the interaction was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The channel this interaction was sent in
       * @type {?TextBasedChannels}
       * @readonly
       */
      get channel() {
        return this.client.channels.cache.get(this.channelId) ?? null;
      }
      /**
       * The guild this interaction was sent in
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.cache.get(this.guildId) ?? null;
      }
      /**
       * Indicates whether this interaction is received from a guild.
       * @returns {boolean}
       */
      inGuild() {
        return Boolean(this.guildId && this.member);
      }
      /**
       * Indicates whether or not this interaction is both cached and received from a guild.
       * @returns {boolean}
       */
      inCachedGuild() {
        return Boolean(this.guild && this.member);
      }
      /**
       * Indicates whether or not this interaction is received from an uncached guild.
       * @returns {boolean}
       */
      inRawGuild() {
        return Boolean(this.guildId && !this.guild && this.member);
      }
      /**
       * Indicates whether this interaction is an {@link AutocompleteInteraction}
       * @returns {boolean}
       */
      isAutocomplete() {
        return this.type === InteractionType.ApplicationCommandAutocomplete;
      }
      /**
       * Indicates whether this interaction is a {@link CommandInteraction}
       * @returns {boolean}
       */
      isCommand() {
        return this.type === InteractionType.ApplicationCommand;
      }
      /**
       * Indicates whether this interaction is a {@link ChatInputCommandInteraction}.
       * @returns {boolean}
       */
      isChatInputCommand() {
        return this.type === InteractionType.ApplicationCommand && this.commandType === ApplicationCommandType.ChatInput;
      }
      /**
       * Indicates whether this interaction is a {@link ContextMenuCommandInteraction}
       * @returns {boolean}
       */
      isContextMenuCommand() {
        return this.type === InteractionType.ApplicationCommand && [ApplicationCommandType.User, ApplicationCommandType.Message].includes(this.commandType);
      }
      /**
       * Indicates whether this interaction is a {@link MessageComponentInteraction}
       * @returns {boolean}
       */
      isMessageComponent() {
        return this.type === InteractionType.MessageComponent;
      }
      /**
       * Indicates whether this interaction is a {@link ModalSubmitInteraction}
       * @returns {boolean}
       */
      isModalSubmit() {
        return this.type === InteractionType.ModalSubmit;
      }
      /**
       * Indicates whether this interaction is a {@link UserContextMenuCommandInteraction}
       * @returns {boolean}
       */
      isUserContextMenuCommand() {
        return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.User;
      }
      /**
       * Indicates whether this interaction is a {@link MessageContextMenuCommandInteraction}
       * @returns {boolean}
       */
      isMessageContextMenuCommand() {
        return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.Message;
      }
      /**
       * Indicates whether this interaction is a {@link ButtonInteraction}.
       * @returns {boolean}
       */
      isButton() {
        return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.Button;
      }
      /**
       * Indicates whether this interaction is a {@link StringSelectMenuInteraction}.
       * @returns {boolean}
       * @deprecated Use {@link BaseInteraction#isStringSelectMenu} instead.
       */
      isSelectMenu() {
        return this.isStringSelectMenu();
      }
      /**
       * Indicates whether this interaction is a select menu of any known type.
       * @returns {boolean}
       */
      isAnySelectMenu() {
        return this.type === InteractionType.MessageComponent && SelectMenuTypes.includes(this.componentType);
      }
      /**
       * Indicates whether this interaction is a {@link StringSelectMenuInteraction}.
       * @returns {boolean}
       */
      isStringSelectMenu() {
        return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.StringSelect;
      }
      /**
       * Indicates whether this interaction is a {@link UserSelectMenuInteraction}
       * @returns {boolean}
       */
      isUserSelectMenu() {
        return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.UserSelect;
      }
      /**
       * Indicates whether this interaction is a {@link RoleSelectMenuInteraction}
       * @returns {boolean}
       */
      isRoleSelectMenu() {
        return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.RoleSelect;
      }
      /**
       * Indicates whether this interaction is a {@link ChannelSelectMenuInteraction}
       * @returns {boolean}
       */
      isChannelSelectMenu() {
        return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.ChannelSelect;
      }
      /**
       * Indicates whether this interaction is a {@link MentionableSelectMenuInteraction}
       * @returns {boolean}
       */
      isMentionableSelectMenu() {
        return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.MentionableSelect;
      }
      /**
       * Indicates whether this interaction can be replied to.
       * @returns {boolean}
       */
      isRepliable() {
        return ![InteractionType.Ping, InteractionType.ApplicationCommandAutocomplete].includes(this.type);
      }
    };
    BaseInteraction.prototype.isSelectMenu = deprecate(
      BaseInteraction.prototype.isSelectMenu,
      "BaseInteraction#isSelectMenu() is deprecated. Use BaseInteraction#isStringSelectMenu() instead."
    );
    module2.exports = BaseInteraction;
  }
});

// node_modules/discord.js/src/structures/Attachment.js
var require_Attachment = __commonJS({
  "node_modules/discord.js/src/structures/Attachment.js"(exports2, module2) {
    "use strict";
    var { basename, flatten } = require_Util();
    var Attachment = class {
      constructor(data) {
        this.attachment = data.url;
        this.name = data.filename;
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("size" in data) {
          this.size = data.size;
        }
        if ("url" in data) {
          this.url = data.url;
        }
        if ("proxy_url" in data) {
          this.proxyURL = data.proxy_url;
        }
        if ("height" in data) {
          this.height = data.height;
        } else {
          this.height ??= null;
        }
        if ("width" in data) {
          this.width = data.width;
        } else {
          this.width ??= null;
        }
        if ("content_type" in data) {
          this.contentType = data.content_type;
        } else {
          this.contentType ??= null;
        }
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ??= null;
        }
        this.ephemeral = data.ephemeral ?? false;
      }
      /**
       * Whether or not this attachment has been marked as a spoiler
       * @type {boolean}
       * @readonly
       */
      get spoiler() {
        return basename(this.url ?? this.name).startsWith("SPOILER_");
      }
      toJSON() {
        return flatten(this);
      }
    };
    module2.exports = Attachment;
  }
});

// node_modules/discord.js/src/structures/ApplicationRoleConnectionMetadata.js
var require_ApplicationRoleConnectionMetadata = __commonJS({
  "node_modules/discord.js/src/structures/ApplicationRoleConnectionMetadata.js"(exports2) {
    "use strict";
    var ApplicationRoleConnectionMetadata = class {
      constructor(data) {
        this.name = data.name;
        this.nameLocalizations = data.name_localizations ?? null;
        this.description = data.description;
        this.descriptionLocalizations = data.description_localizations ?? null;
        this.key = data.key;
        this.type = data.type;
      }
    };
    exports2.ApplicationRoleConnectionMetadata = ApplicationRoleConnectionMetadata;
  }
});

// node_modules/discord.js/src/structures/TeamMember.js
var require_TeamMember = __commonJS({
  "node_modules/discord.js/src/structures/TeamMember.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var TeamMember = class extends Base {
      constructor(team, data) {
        super(team.client);
        this.team = team;
        this._patch(data);
      }
      _patch(data) {
        if ("permissions" in data) {
          this.permissions = data.permissions;
        }
        if ("membership_state" in data) {
          this.membershipState = data.membership_state;
        }
        if ("user" in data) {
          this.user = this.client.users._add(data.user);
        }
      }
      /**
       * The Team Member's id
       * @type {Snowflake}
       * @readonly
       */
      get id() {
        return this.user.id;
      }
      /**
       * When concatenated with a string, this automatically returns the team member's mention instead of the
       * TeamMember object.
       * @returns {string}
       * @example
       * // Logs: Team Member's mention: <@123456789012345678>
       * console.log(`Team Member's mention: ${teamMember}`);
       */
      toString() {
        return this.user.toString();
      }
    };
    module2.exports = TeamMember;
  }
});

// node_modules/discord.js/src/structures/Team.js
var require_Team = __commonJS({
  "node_modules/discord.js/src/structures/Team.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var TeamMember = require_TeamMember();
    var Team = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("icon" in data) {
          this.icon = data.icon;
        } else {
          this.icon ??= null;
        }
        if ("owner_user_id" in data) {
          this.ownerId = data.owner_user_id;
        } else {
          this.ownerId ??= null;
        }
        this.members = new Collection2();
        for (const memberData of data.members) {
          const member = new TeamMember(this, memberData);
          this.members.set(member.id, member);
        }
      }
      /**
       * The owner of this team
       * @type {?TeamMember}
       * @readonly
       */
      get owner() {
        return this.members.get(this.ownerId) ?? null;
      }
      /**
       * The timestamp the team was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the team was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * A link to the team's icon.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.teamIcon(this.id, this.icon, options);
      }
      /**
       * When concatenated with a string, this automatically returns the Team's name instead of the
       * Team object.
       * @returns {string}
       * @example
       * // Logs: Team name: My Team
       * console.log(`Team name: ${team}`);
       */
      toString() {
        return this.name;
      }
      toJSON() {
        return super.toJSON({ createdTimestamp: true });
      }
    };
    module2.exports = Team;
  }
});

// node_modules/discord.js/src/managers/ApplicationCommandPermissionsManager.js
var require_ApplicationCommandPermissionsManager = __commonJS({
  "node_modules/discord.js/src/managers/ApplicationCommandPermissionsManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { ApplicationCommandPermissionType, RESTJSONErrorCodes, Routes: Routes2 } = require_v106();
    var BaseManager = require_BaseManager();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ApplicationCommandPermissionsManager = class extends BaseManager {
      constructor(manager) {
        super(manager.client);
        this.manager = manager;
        this.guild = manager.guild ?? null;
        this.guildId = manager.guildId ?? manager.guild?.id ?? null;
        this.commandId = manager.id ?? null;
      }
      /**
       * The APIRouter path to the commands
       * @param {Snowflake} guildId The guild's id to use in the path,
       * @param {Snowflake} [commandId] The application command's id
       * @returns {string}
       * @private
       */
      permissionsPath(guildId, commandId) {
        if (commandId) {
          return Routes2.applicationCommandPermissions(this.client.application.id, guildId, commandId);
        }
        return Routes2.guildApplicationCommandsPermissions(this.client.application.id, guildId);
      }
      /* eslint-disable max-len */
      /**
       * The object returned when fetching permissions for an application command.
       * @typedef {Object} ApplicationCommandPermissions
       * @property {Snowflake} id The role, user, or channel's id. Can also be a
       * {@link https://discord.com/developers/docs/interactions/application-commands#application-command-permissions-object-application-command-permissions-constants permission constant}.
       * @property {ApplicationCommandPermissionType} type Whether this permission is for a role or a user
       * @property {boolean} permission Whether the role or user has the permission to use this command
       */
      /* eslint-enable max-len */
      /**
       * Options for managing permissions for one or more Application Commands
       * <warn>When passing these options to a manager where `guildId` is `null`,
       * `guild` is a required parameter</warn>
       * @typedef {Object} BaseApplicationCommandPermissionsOptions
       * @property {GuildResolvable} [guild] The guild to modify / check permissions for
       * <warn>Ignored when the manager has a non-null `guildId` property</warn>
       * @property {ApplicationCommandResolvable} [command] The command to modify / check permissions for
       * <warn>Ignored when the manager has a non-null `commandId` property</warn>
       */
      /**
       * Fetches the permissions for one or multiple commands. Providing the client's id as the "command id" will fetch
       * *only* the guild level permissions
       * @param {BaseApplicationCommandPermissionsOptions} [options] Options used to fetch permissions
       * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}
       * @example
       * // Fetch permissions for one command
       * guild.commands.permissions.fetch({ command: '123456789012345678' })
       *   .then(perms => console.log(`Fetched ${perms.length} overwrites`))
       *   .catch(console.error);
       * @example
       * // Fetch permissions for all commands in a guild
       * client.application.commands.permissions.fetch({ guild: '123456789012345678' })
       *   .then(perms => console.log(`Fetched permissions for ${perms.size} commands`))
       *   .catch(console.error);
       * @example
       * // Fetch guild level permissions
       * guild.commands.permissions.fetch({ command: client.user.id })
       *   .then(perms => console.log(`Fetched ${perms.length} guild level permissions`))
       *   .catch(console.error);
       */
      async fetch({ guild, command } = {}) {
        const { guildId, commandId } = this._validateOptions(guild, command);
        if (commandId) {
          const data2 = await this.client.rest.get(this.permissionsPath(guildId, commandId));
          return data2.permissions;
        }
        const data = await this.client.rest.get(this.permissionsPath(guildId));
        return data.reduce((coll, perm) => coll.set(perm.id, perm.permissions), new Collection2());
      }
      /**
       * Options used to set permissions for one or more Application Commands in a guild
       * <warn>Omitting the `command` parameter edits the guild wide permissions
       * when the manager's `commandId` is `null`</warn>
       * @typedef {BaseApplicationCommandPermissionsOptions} ApplicationCommandPermissionsEditOptions
       * @property {ApplicationCommandPermissions[]} permissions The new permissions for the guild or overwrite
       * @property {string} token The bearer token to use that authorizes the permission edit
       */
      /**
       * Sets the permissions for the guild or a command overwrite.
       * @param {ApplicationCommandPermissionsEditOptions} options Options used to set permissions
       * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}
       * @example
       * // Set a permission overwrite for a command
       * client.application.commands.permissions.set({
       *  guild: '892455839386304532',
       *  command: '123456789012345678',
       *  token: 'TotallyRealToken',
       *  permissions: [
       *    {
       *      id: '876543210987654321',
       *      type: ApplicationCommandPermissionType.User,
       *      permission: false,
       *    },
       * ]})
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Set the permissions used for the guild (commands without overwrites)
       * guild.commands.permissions.set({ token: 'TotallyRealToken', permissions: [
       *   {
       *     id: '123456789012345678',
       *     permissions: [{
       *       id: '876543210987654321',
       *       type: ApplicationCommandPermissionType.User,
       *       permission: false,
       *     }],
       *   },
       * ]})
       *   .then(console.log)
       *   .catch(console.error);
       */
      async set({ guild, command, permissions, token } = {}) {
        if (!token) {
          throw new DiscordjsError2(ErrorCodes2.ApplicationCommandPermissionsTokenMissing);
        }
        let { guildId, commandId } = this._validateOptions(guild, command);
        if (!Array.isArray(permissions)) {
          throw new DiscordjsTypeError2(
            ErrorCodes2.InvalidType,
            "permissions",
            "Array of ApplicationCommandPermissions",
            true
          );
        }
        if (!commandId) {
          commandId = this.client.user.id;
        }
        const data = await this.client.rest.put(this.permissionsPath(guildId, commandId), {
          body: { permissions },
          auth: false,
          headers: { Authorization: `Bearer ${token}` }
        });
        return data.permissions;
      }
      /**
       * Add permissions to a command.
       * @param {ApplicationCommandPermissionsEditOptions} options Options used to add permissions
       * @returns {Promise<ApplicationCommandPermissions[]>}
       * @example
       * // Add a rule to block a role from using a command
       * guild.commands.permissions.add({ command: '123456789012345678', token: 'TotallyRealToken', permissions: [
       *   {
       *     id: '876543211234567890',
       *     type: ApplicationCommandPermissionType.Role,
       *     permission: false
       *   },
       * ]})
       *   .then(console.log)
       *   .catch(console.error);
       */
      async add({ guild, command, permissions, token } = {}) {
        if (!token) {
          throw new DiscordjsError2(ErrorCodes2.ApplicationCommandPermissionsTokenMissing);
        }
        let { guildId, commandId } = this._validateOptions(guild, command);
        if (!commandId) {
          commandId = this.client.user.id;
        }
        if (!Array.isArray(permissions)) {
          throw new DiscordjsTypeError2(
            ErrorCodes2.InvalidType,
            "permissions",
            "Array of ApplicationCommandPermissions",
            true
          );
        }
        let existing = [];
        try {
          existing = await this.fetch({ guild: guildId, command: commandId });
        } catch (error) {
          if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
            throw error;
        }
        const newPermissions = permissions.slice();
        for (const perm of existing) {
          if (!newPermissions.some((x) => x.id === perm.id)) {
            newPermissions.push(perm);
          }
        }
        return this.set({ guild: guildId, command: commandId, permissions: newPermissions, token });
      }
      /**
       * A static snowflake that identifies the everyone role for application command permissions.
       * It is the same as the guild id
       * @typedef {Snowflake} RolePermissionConstant
       */
      /**
       * A static snowflake that identifies the "all channels" entity for application command permissions.
       * It will be the result of the calculation `guildId - 1`
       * @typedef {Snowflake} ChannelPermissionConstant
       */
      /**
       * Options used to remove permissions from a command
       * <warn>Omitting the `command` parameter removes from the guild wide permissions
       * when the managers `commandId` is `null`</warn>
       * <warn>At least one of `users`, `roles`, and `channels` is required</warn>
       * @typedef {BaseApplicationCommandPermissionsOptions} RemoveApplicationCommandPermissionsOptions
       * @property {string} token The bearer token to use that authorizes the permission removal
       * @property {UserResolvable[]} [users] The user(s) to remove
       * @property {Array<RoleResolvable|RolePermissionConstant>} [roles] The role(s) to remove
       * @property {Array<GuildChannelResolvable|ChannelPermissionConstant>} [channels] The channel(s) to remove
       */
      /**
       * Remove permissions from a command.
       * @param {RemoveApplicationCommandPermissionsOptions} options Options used to remove permissions
       * @returns {Promise<ApplicationCommandPermissions[]>}
       * @example
       * // Remove a user permission from this command
       * guild.commands.permissions.remove({
       *  command: '123456789012345678', users: '876543210123456789', token: 'TotallyRealToken',
       * })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Remove multiple roles from this command
       * guild.commands.permissions.remove({
       *   command: '123456789012345678', roles: ['876543210123456789', '765432101234567890'], token: 'TotallyRealToken',
       * })
       *    .then(console.log)
       *    .catch(console.error);
       */
      async remove({ guild, command, users, roles, channels, token } = {}) {
        if (!token) {
          throw new DiscordjsError2(ErrorCodes2.ApplicationCommandPermissionsTokenMissing);
        }
        let { guildId, commandId } = this._validateOptions(guild, command);
        if (!commandId) {
          commandId = this.client.user.id;
        }
        if (!users && !roles && !channels) {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "users OR roles OR channels", "Array or Resolvable", true);
        }
        let resolvedUserIds = [];
        if (Array.isArray(users)) {
          for (const user of users) {
            const userId = this.client.users.resolveId(user);
            if (!userId)
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array", "users", user);
            resolvedUserIds.push(userId);
          }
        }
        let resolvedRoleIds = [];
        if (Array.isArray(roles)) {
          for (const role of roles) {
            if (typeof role === "string") {
              resolvedRoleIds.push(role);
              continue;
            }
            if (!this.guild)
              throw new DiscordjsError2(ErrorCodes2.GuildUncachedEntityResolve, "roles");
            const roleId = this.guild.roles.resolveId(role);
            if (!roleId)
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array", "users", role);
            resolvedRoleIds.push(roleId);
          }
        }
        let resolvedChannelIds = [];
        if (Array.isArray(channels)) {
          for (const channel of channels) {
            if (typeof channel === "string") {
              resolvedChannelIds.push(channel);
              continue;
            }
            if (!this.guild)
              throw new DiscordjsError2(ErrorCodes2.GuildUncachedEntityResolve, "channels");
            const channelId = this.guild.channels.resolveId(channel);
            if (!channelId)
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array", "channels", channel);
            resolvedChannelIds.push(channelId);
          }
        }
        let existing = [];
        try {
          existing = await this.fetch({ guild: guildId, command: commandId });
        } catch (error) {
          if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
            throw error;
        }
        const permissions = existing.filter((perm) => {
          switch (perm.type) {
            case ApplicationCommandPermissionType.Role:
              return !resolvedRoleIds.includes(perm.id);
            case ApplicationCommandPermissionType.User:
              return !resolvedUserIds.includes(perm.id);
            case ApplicationCommandPermissionType.Channel:
              return !resolvedChannelIds.includes(perm.id);
          }
          return true;
        });
        return this.set({ guild: guildId, command: commandId, permissions, token });
      }
      /**
       * Options used to check the existence of permissions on a command
       * <warn>The `command` parameter is not optional when the managers `commandId` is `null`</warn>
       * @typedef {BaseApplicationCommandPermissionsOptions} HasApplicationCommandPermissionsOptions
       * @property {ApplicationCommandPermissionIdResolvable} permissionId The entity to check if a permission exists for
       * on this command.
       * @property {ApplicationCommandPermissionType} [permissionType] Check for a specific type of permission
       */
      /**
       * Check whether a permission exists for a user, role, or channel
       * @param {HasApplicationCommandPermissionsOptions} options Options used to check permissions
       * @returns {Promise<boolean>}
       * @example
       * // Check whether a user has permission to use a command
       * guild.commands.permissions.has({ command: '123456789012345678', permissionId: '876543210123456789' })
       *  .then(console.log)
       *  .catch(console.error);
       */
      async has({ guild, command, permissionId, permissionType }) {
        const { guildId, commandId } = this._validateOptions(guild, command);
        if (!commandId)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "command", "ApplicationCommandResolvable");
        if (!permissionId) {
          throw new DiscordjsTypeError2(
            ErrorCodes2.InvalidType,
            "permissionId",
            "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant"
          );
        }
        let resolvedId = permissionId;
        if (typeof permissionId !== "string") {
          resolvedId = this.client.users.resolveId(permissionId);
          if (!resolvedId) {
            if (!this.guild)
              throw new DiscordjsError2(ErrorCodes2.GuildUncachedEntityResolve, "roles");
            resolvedId = this.guild.roles.resolveId(permissionId);
          }
          if (!resolvedId) {
            resolvedId = this.guild.channels.resolveId(permissionId);
          }
          if (!resolvedId) {
            throw new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "permissionId",
              "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant"
            );
          }
        }
        let existing = [];
        try {
          existing = await this.fetch({ guild: guildId, command: commandId });
        } catch (error) {
          if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
            throw error;
        }
        return existing.some((perm) => perm.id === resolvedId && (permissionType ?? perm.type) === perm.type);
      }
      _validateOptions(guild, command) {
        const guildId = this.guildId ?? this.client.guilds.resolveId(guild);
        if (!guildId)
          throw new DiscordjsError2(ErrorCodes2.GlobalCommandPermissions);
        let commandId = this.commandId;
        if (command && !commandId) {
          commandId = this.manager.resolveId?.(command);
          if (!commandId && this.guild) {
            commandId = this.guild.commands.resolveId(command);
          }
          commandId ??= this.client.application?.commands.resolveId(command);
          if (!commandId) {
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "command", "ApplicationCommandResolvable", true);
          }
        }
        return { guildId, commandId };
      }
    };
    module2.exports = ApplicationCommandPermissionsManager;
  }
});

// node_modules/discord.js/src/structures/ApplicationCommand.js
var require_ApplicationCommand = __commonJS({
  "node_modules/discord.js/src/structures/ApplicationCommand.js"(exports2, module2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { ApplicationCommandOptionType } = require_v106();
    var isEqual = require_fast_deep_equal();
    var Base = require_Base();
    var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
    var PermissionsBitField2 = require_PermissionsBitField();
    var ApplicationCommand = class extends Base {
      constructor(client, data, guild, guildId) {
        super(client);
        this.id = data.id;
        this.applicationId = data.application_id;
        this.guild = guild ?? null;
        this.guildId = guild?.id ?? guildId ?? null;
        this.permissions = new ApplicationCommandPermissionsManager(this);
        this.type = data.type;
        this.nsfw = data.nsfw ?? false;
        this._patch(data);
      }
      _patch(data) {
        if ("name" in data) {
          this.name = data.name;
        }
        if ("name_localizations" in data) {
          this.nameLocalizations = data.name_localizations;
        } else {
          this.nameLocalizations ??= null;
        }
        if ("name_localized" in data) {
          this.nameLocalized = data.name_localized;
        } else {
          this.nameLocalized ??= null;
        }
        if ("description" in data) {
          this.description = data.description;
        }
        if ("description_localizations" in data) {
          this.descriptionLocalizations = data.description_localizations;
        } else {
          this.descriptionLocalizations ??= null;
        }
        if ("description_localized" in data) {
          this.descriptionLocalized = data.description_localized;
        } else {
          this.descriptionLocalized ??= null;
        }
        if ("options" in data) {
          this.options = data.options.map((o) => this.constructor.transformOption(o, true));
        } else {
          this.options ??= [];
        }
        if ("default_member_permissions" in data) {
          this.defaultMemberPermissions = data.default_member_permissions ? new PermissionsBitField2(BigInt(data.default_member_permissions)).freeze() : null;
        } else {
          this.defaultMemberPermissions ??= null;
        }
        if ("dm_permission" in data) {
          this.dmPermission = data.dm_permission;
        } else {
          this.dmPermission ??= null;
        }
        if ("version" in data) {
          this.version = data.version;
        }
      }
      /**
       * The timestamp the command was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the command was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The manager that this command belongs to
       * @type {ApplicationCommandManager}
       * @readonly
       */
      get manager() {
        return (this.guild ?? this.client.application).commands;
      }
      /**
       * Data for creating or editing an application command.
       * @typedef {Object} ApplicationCommandData
       * @property {string} name The name of the command, must be in all lowercase if type is
       * {@link ApplicationCommandType.ChatInput}
       * @property {Object<Locale, string>} [nameLocalizations] The localizations for the command name
       * @property {string} description The description of the command, if type is {@link ApplicationCommandType.ChatInput}
       * @property {boolean} [nsfw] Whether the command is age-restricted
       * @property {Object<Locale, string>} [descriptionLocalizations] The localizations for the command description,
       * if type is {@link ApplicationCommandType.ChatInput}
       * @property {ApplicationCommandType} [type=ApplicationCommandType.ChatInput] The type of the command
       * @property {ApplicationCommandOptionData[]} [options] Options for the command
       * @property {?PermissionResolvable} [defaultMemberPermissions] The bitfield used to determine the default permissions
       * a member needs in order to run the command
       * @property {boolean} [dmPermission] Whether the command is enabled in DMs
       */
      /**
       * An option for an application command or subcommand.
       * <info>In addition to the listed properties, when used as a parameter,
       * API style `snake_case` properties can be used for compatibility with generators like `@discordjs/builders`.</info>
       * <warn>Note that providing a value for the `camelCase` counterpart for any `snake_case` property
       * will discard the provided `snake_case` property.</warn>
       * @typedef {Object} ApplicationCommandOptionData
       * @property {ApplicationCommandOptionType} type The type of the option
       * @property {string} name The name of the option
       * @property {Object<Locale, string>} [nameLocalizations] The name localizations for the option
       * @property {string} description The description of the option
       * @property {Object<Locale, string>} [descriptionLocalizations] The description localizations for the option
       * @property {boolean} [autocomplete] Whether the autocomplete interaction is enabled for a
       * {@link ApplicationCommandOptionType.String}, {@link ApplicationCommandOptionType.Integer} or
       * {@link ApplicationCommandOptionType.Number} option
       * @property {boolean} [required] Whether the option is required
       * @property {ApplicationCommandOptionChoiceData[]} [choices] The choices of the option for the user to pick from
       * @property {ApplicationCommandOptionData[]} [options] Additional options if this option is a subcommand (group)
       * @property {ChannelType[]} [channelTypes] When the option type is channel,
       * the allowed types of channels that can be selected
       * @property {number} [minValue] The minimum value for an {@link ApplicationCommandOptionType.Integer} or
       * {@link ApplicationCommandOptionType.Number} option
       * @property {number} [maxValue] The maximum value for an {@link ApplicationCommandOptionType.Integer} or
       * {@link ApplicationCommandOptionType.Number} option
       * @property {number} [minLength] The minimum length for an {@link ApplicationCommandOptionType.String} option
       * (maximum of `6000`)
       * @property {number} [maxLength] The maximum length for an {@link ApplicationCommandOptionType.String} option
       * (maximum of `6000`)
       */
      /**
       * @typedef {Object} ApplicationCommandOptionChoiceData
       * @property {string} name The name of the choice
       * @property {Object<Locale, string>} [nameLocalizations] The localized names for this choice
       * @property {string|number} value The value of the choice
       */
      /**
       * Edits this application command.
       * @param {Partial<ApplicationCommandData>} data The data to update the command with
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Edit the description of this command
       * command.edit({
       *   description: 'New description',
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      edit(data) {
        return this.manager.edit(this, data, this.guildId);
      }
      /**
       * Edits the name of this ApplicationCommand
       * @param {string} name The new name of the command
       * @returns {Promise<ApplicationCommand>}
       */
      setName(name) {
        return this.edit({ name });
      }
      /**
       * Edits the localized names of this ApplicationCommand
       * @param {Object<Locale, string>} nameLocalizations The new localized names for the command
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Edit the name localizations of this command
       * command.setLocalizedNames({
       *   'en-GB': 'test',
       *   'pt-BR': 'teste',
       * })
       *   .then(console.log)
       *   .catch(console.error)
       */
      setNameLocalizations(nameLocalizations) {
        return this.edit({ nameLocalizations });
      }
      /**
       * Edits the description of this ApplicationCommand
       * @param {string} description The new description of the command
       * @returns {Promise<ApplicationCommand>}
       */
      setDescription(description) {
        return this.edit({ description });
      }
      /**
       * Edits the localized descriptions of this ApplicationCommand
       * @param {Object<Locale, string>} descriptionLocalizations The new localized descriptions for the command
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Edit the description localizations of this command
       * command.setDescriptionLocalizations({
       *   'en-GB': 'A test command',
       *   'pt-BR': 'Um comando de teste',
       * })
       *   .then(console.log)
       *   .catch(console.error)
       */
      setDescriptionLocalizations(descriptionLocalizations) {
        return this.edit({ descriptionLocalizations });
      }
      /**
       * Edits the default member permissions of this ApplicationCommand
       * @param {?PermissionResolvable} defaultMemberPermissions The default member permissions required to run this command
       * @returns {Promise<ApplicationCommand>}
       */
      setDefaultMemberPermissions(defaultMemberPermissions) {
        return this.edit({ defaultMemberPermissions });
      }
      /**
       * Edits the DM permission of this ApplicationCommand
       * @param {boolean} [dmPermission=true] Whether the command can be used in DMs
       * @returns {Promise<ApplicationCommand>}
       */
      setDMPermission(dmPermission = true) {
        return this.edit({ dmPermission });
      }
      /**
       * Edits the options of this ApplicationCommand
       * @param {ApplicationCommandOptionData[]} options The options to set for this command
       * @returns {Promise<ApplicationCommand>}
       */
      setOptions(options) {
        return this.edit({ options });
      }
      /**
       * Deletes this command.
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Delete this command
       * command.delete()
       *   .then(console.log)
       *   .catch(console.error);
       */
      delete() {
        return this.manager.delete(this, this.guildId);
      }
      /**
       * Whether this command equals another command. It compares all properties, so for most operations
       * it is advisable to just compare `command.id === command2.id` as it is much faster and is often
       * what most users need.
       * @param {ApplicationCommand|ApplicationCommandData|APIApplicationCommand} command The command to compare with
       * @param {boolean} [enforceOptionOrder=false] Whether to strictly check that options and choices are in the same
       * order in the array <info>The client may not always respect this ordering!</info>
       * @returns {boolean}
       */
      equals(command, enforceOptionOrder = false) {
        if (command.id && this.id !== command.id)
          return false;
        let defaultMemberPermissions = null;
        let dmPermission = command.dmPermission ?? command.dm_permission;
        if ("default_member_permissions" in command) {
          defaultMemberPermissions = command.default_member_permissions ? new PermissionsBitField2(BigInt(command.default_member_permissions)).bitfield : null;
        }
        if ("defaultMemberPermissions" in command) {
          defaultMemberPermissions = command.defaultMemberPermissions !== null ? new PermissionsBitField2(command.defaultMemberPermissions).bitfield : null;
        }
        if (command.name !== this.name || "description" in command && command.description !== this.description || "version" in command && command.version !== this.version || command.type && command.type !== this.type || "nsfw" in command && command.nsfw !== this.nsfw || // Future proof for options being nullable
        // TODO: remove ?? 0 on each when nullable
        (command.options?.length ?? 0) !== (this.options?.length ?? 0) || defaultMemberPermissions !== (this.defaultMemberPermissions?.bitfield ?? null) || dmPermission !== void 0 && dmPermission !== this.dmPermission || !isEqual(command.nameLocalizations ?? command.name_localizations ?? {}, this.nameLocalizations ?? {}) || !isEqual(
          command.descriptionLocalizations ?? command.description_localizations ?? {},
          this.descriptionLocalizations ?? {}
        )) {
          return false;
        }
        if (command.options) {
          return this.constructor.optionsEqual(this.options, command.options, enforceOptionOrder);
        }
        return true;
      }
      /**
       * Recursively checks that all options for an {@link ApplicationCommand} are equal to the provided options.
       * In most cases it is better to compare using {@link ApplicationCommand#equals}
       * @param {ApplicationCommandOptionData[]} existing The options on the existing command,
       * should be {@link ApplicationCommand#options}
       * @param {ApplicationCommandOptionData[]|APIApplicationCommandOption[]} options The options to compare against
       * @param {boolean} [enforceOptionOrder=false] Whether to strictly check that options and choices are in the same
       * order in the array <info>The client may not always respect this ordering!</info>
       * @returns {boolean}
       */
      static optionsEqual(existing, options, enforceOptionOrder = false) {
        if (existing.length !== options.length)
          return false;
        if (enforceOptionOrder) {
          return existing.every((option, index) => this._optionEquals(option, options[index], enforceOptionOrder));
        }
        const newOptions = new Map(options.map((option) => [option.name, option]));
        for (const option of existing) {
          const foundOption = newOptions.get(option.name);
          if (!foundOption || !this._optionEquals(option, foundOption))
            return false;
        }
        return true;
      }
      /**
       * Checks that an option for an {@link ApplicationCommand} is equal to the provided option
       * In most cases it is better to compare using {@link ApplicationCommand#equals}
       * @param {ApplicationCommandOptionData} existing The option on the existing command,
       * should be from {@link ApplicationCommand#options}
       * @param {ApplicationCommandOptionData|APIApplicationCommandOption} option The option to compare against
       * @param {boolean} [enforceOptionOrder=false] Whether to strictly check that options or choices are in the same
       * order in their array <info>The client may not always respect this ordering!</info>
       * @returns {boolean}
       * @private
       */
      static _optionEquals(existing, option, enforceOptionOrder = false) {
        if (option.name !== existing.name || option.type !== existing.type || option.description !== existing.description || option.autocomplete !== existing.autocomplete || (option.required ?? ([ApplicationCommandOptionType.Subcommand, ApplicationCommandOptionType.SubcommandGroup].includes(option.type) ? void 0 : false)) !== existing.required || option.choices?.length !== existing.choices?.length || option.options?.length !== existing.options?.length || (option.channelTypes ?? option.channel_types)?.length !== existing.channelTypes?.length || (option.minValue ?? option.min_value) !== existing.minValue || (option.maxValue ?? option.max_value) !== existing.maxValue || (option.minLength ?? option.min_length) !== existing.minLength || (option.maxLength ?? option.max_length) !== existing.maxLength || !isEqual(option.nameLocalizations ?? option.name_localizations ?? {}, existing.nameLocalizations ?? {}) || !isEqual(
          option.descriptionLocalizations ?? option.description_localizations ?? {},
          existing.descriptionLocalizations ?? {}
        )) {
          return false;
        }
        if (existing.choices) {
          if (enforceOptionOrder && !existing.choices.every(
            (choice, index) => choice.name === option.choices[index].name && choice.value === option.choices[index].value && isEqual(
              choice.nameLocalizations ?? {},
              option.choices[index].nameLocalizations ?? option.choices[index].name_localizations ?? {}
            )
          )) {
            return false;
          }
          if (!enforceOptionOrder) {
            const newChoices = new Map(option.choices.map((choice) => [choice.name, choice]));
            for (const choice of existing.choices) {
              const foundChoice = newChoices.get(choice.name);
              if (!foundChoice || foundChoice.value !== choice.value)
                return false;
            }
          }
        }
        if (existing.channelTypes) {
          const newTypes = option.channelTypes ?? option.channel_types;
          for (const type of existing.channelTypes) {
            if (!newTypes.includes(type))
              return false;
          }
        }
        if (existing.options) {
          return this.optionsEqual(existing.options, option.options, enforceOptionOrder);
        }
        return true;
      }
      /**
       * An option for an application command or subcommand.
       * @typedef {Object} ApplicationCommandOption
       * @property {ApplicationCommandOptionType} type The type of the option
       * @property {string} name The name of the option
       * @property {Object<Locale, string>} [nameLocalizations] The localizations for the option name
       * @property {string} [nameLocalized] The localized name for this option
       * @property {string} description The description of the option
       * @property {Object<Locale, string>} [descriptionLocalizations] The localizations for the option description
       * @property {string} [descriptionLocalized] The localized description for this option
       * @property {boolean} [required] Whether the option is required
       * @property {boolean} [autocomplete] Whether the autocomplete interaction is enabled for a
       * {@link ApplicationCommandOptionType.String}, {@link ApplicationCommandOptionType.Integer} or
       * {@link ApplicationCommandOptionType.Number} option
       * @property {ApplicationCommandOptionChoice[]} [choices] The choices of the option for the user to pick from
       * @property {ApplicationCommandOption[]} [options] Additional options if this option is a subcommand (group)
       * @property {ApplicationCommandOptionAllowedChannelTypes[]} [channelTypes] When the option type is channel,
       * the allowed types of channels that can be selected
       * @property {number} [minValue] The minimum value for an {@link ApplicationCommandOptionType.Integer} or
       * {@link ApplicationCommandOptionType.Number} option
       * @property {number} [maxValue] The maximum value for an {@link ApplicationCommandOptionType.Integer} or
       * {@link ApplicationCommandOptionType.Number} option
       * @property {number} [minLength] The minimum length for an {@link ApplicationCommandOptionType.String} option
       * (maximum of `6000`)
       * @property {number} [maxLength] The maximum length for an {@link ApplicationCommandOptionType.String} option
       * (maximum of `6000`)
       */
      /**
       * A choice for an application command option.
       * @typedef {Object} ApplicationCommandOptionChoice
       * @property {string} name The name of the choice
       * @property {?string} nameLocalized The localized name of the choice in the provided locale, if any
       * @property {?Object<string, string>} [nameLocalizations] The localized names for this choice
       * @property {string|number} value The value of the choice
       */
      /**
       * Transforms an {@link ApplicationCommandOptionData} object into something that can be used with the API.
       * @param {ApplicationCommandOptionData|ApplicationCommandOption} option The option to transform
       * @param {boolean} [received] Whether this option has been received from Discord
       * @returns {APIApplicationCommandOption}
       * @private
       */
      static transformOption(option, received) {
        const channelTypesKey = received ? "channelTypes" : "channel_types";
        const minValueKey = received ? "minValue" : "min_value";
        const maxValueKey = received ? "maxValue" : "max_value";
        const minLengthKey = received ? "minLength" : "min_length";
        const maxLengthKey = received ? "maxLength" : "max_length";
        const nameLocalizationsKey = received ? "nameLocalizations" : "name_localizations";
        const nameLocalizedKey = received ? "nameLocalized" : "name_localized";
        const descriptionLocalizationsKey = received ? "descriptionLocalizations" : "description_localizations";
        const descriptionLocalizedKey = received ? "descriptionLocalized" : "description_localized";
        return {
          type: option.type,
          name: option.name,
          [nameLocalizationsKey]: option.nameLocalizations ?? option.name_localizations,
          [nameLocalizedKey]: option.nameLocalized ?? option.name_localized,
          description: option.description,
          [descriptionLocalizationsKey]: option.descriptionLocalizations ?? option.description_localizations,
          [descriptionLocalizedKey]: option.descriptionLocalized ?? option.description_localized,
          required: option.required ?? (option.type === ApplicationCommandOptionType.Subcommand || option.type === ApplicationCommandOptionType.SubcommandGroup ? void 0 : false),
          autocomplete: option.autocomplete,
          choices: option.choices?.map((choice) => ({
            name: choice.name,
            [nameLocalizedKey]: choice.nameLocalized ?? choice.name_localized,
            [nameLocalizationsKey]: choice.nameLocalizations ?? choice.name_localizations,
            value: choice.value
          })),
          options: option.options?.map((o) => this.transformOption(o, received)),
          [channelTypesKey]: option.channelTypes ?? option.channel_types,
          [minValueKey]: option.minValue ?? option.min_value,
          [maxValueKey]: option.maxValue ?? option.max_value,
          [minLengthKey]: option.minLength ?? option.min_length,
          [maxLengthKey]: option.maxLength ?? option.max_length
        };
      }
    };
    module2.exports = ApplicationCommand;
  }
});

// node_modules/discord.js/src/managers/ApplicationCommandManager.js
var require_ApplicationCommandManager = __commonJS({
  "node_modules/discord.js/src/managers/ApplicationCommandManager.js"(exports2, module2) {
    "use strict";
    var { isJSONEncodable } = require_dist8();
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { Routes: Routes2 } = require_v106();
    var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ApplicationCommand = require_ApplicationCommand();
    var PermissionsBitField2 = require_PermissionsBitField();
    var ApplicationCommandManager = class extends CachedManager {
      constructor(client, iterable) {
        super(client, ApplicationCommand, iterable);
        this.permissions = new ApplicationCommandPermissionsManager(this);
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, ApplicationCommand>}
       * @name ApplicationCommandManager#cache
       */
      _add(data, cache, guildId) {
        return super._add(data, cache, { extras: [this.guild, guildId] });
      }
      /**
       * The APIRouter path to the commands
       * @param {Snowflake} [options.id] The application command's id
       * @param {Snowflake} [options.guildId] The guild's id to use in the path,
       * ignored when using a {@link GuildApplicationCommandManager}
       * @returns {string}
       * @private
       */
      commandPath({ id, guildId } = {}) {
        if (this.guild ?? guildId) {
          if (id) {
            return Routes2.applicationGuildCommand(this.client.application.id, this.guild?.id ?? guildId, id);
          }
          return Routes2.applicationGuildCommands(this.client.application.id, this.guild?.id ?? guildId);
        }
        if (id) {
          return Routes2.applicationCommand(this.client.application.id, id);
        }
        return Routes2.applicationCommands(this.client.application.id);
      }
      /**
       * Data that resolves to give an ApplicationCommand object. This can be:
       * * An ApplicationCommand object
       * * A Snowflake
       * @typedef {ApplicationCommand|Snowflake} ApplicationCommandResolvable
       */
      /* eslint-disable max-len */
      /**
       * Data that resolves to the data of an ApplicationCommand
       * @typedef {ApplicationCommandData|APIApplicationCommand|JSONEncodable<APIApplicationCommand>} ApplicationCommandDataResolvable
       */
      /* eslint-enable max-len */
      /**
       * Options used to fetch data from Discord
       * @typedef {Object} BaseFetchOptions
       * @property {boolean} [cache=true] Whether to cache the fetched data if it wasn't already
       * @property {boolean} [force=false] Whether to skip the cache check and request the API
       */
      /**
       * Options used to fetch Application Commands from Discord
       * @typedef {BaseFetchOptions} FetchApplicationCommandOptions
       * @property {Snowflake} [guildId] The guild's id to fetch commands for, for when the guild is not cached
       * @property {LocaleString} [locale] The locale to use when fetching this command
       * @property {boolean} [withLocalizations] Whether to fetch all localization data
       */
      /**
       * Obtains one or multiple application commands from Discord, or the cache if it's already available.
       * @param {Snowflake} [id] The application command's id
       * @param {FetchApplicationCommandOptions} [options] Additional options for this fetch
       * @returns {Promise<ApplicationCommand|Collection<Snowflake, ApplicationCommand>>}
       * @example
       * // Fetch a single command
       * client.application.commands.fetch('123456789012345678')
       *   .then(command => console.log(`Fetched command ${command.name}`))
       *   .catch(console.error);
       * @example
       * // Fetch all commands
       * guild.commands.fetch()
       *   .then(commands => console.log(`Fetched ${commands.size} commands`))
       *   .catch(console.error);
       */
      async fetch(id, { guildId, cache = true, force = false, locale, withLocalizations } = {}) {
        if (typeof id === "object") {
          ({ guildId, cache = true, locale, withLocalizations } = id);
        } else if (id) {
          if (!force) {
            const existing = this.cache.get(id);
            if (existing)
              return existing;
          }
          const command = await this.client.rest.get(this.commandPath({ id, guildId }));
          return this._add(command, cache);
        }
        const data = await this.client.rest.get(this.commandPath({ guildId }), {
          headers: {
            "X-Discord-Locale": locale
          },
          query: makeURLSearchParams2({ with_localizations: withLocalizations })
        });
        return data.reduce((coll, command) => coll.set(command.id, this._add(command, cache, guildId)), new Collection2());
      }
      /**
       * Creates an application command.
       * @param {ApplicationCommandDataResolvable} command The command
       * @param {Snowflake} [guildId] The guild's id to create this command in,
       * ignored when using a {@link GuildApplicationCommandManager}
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Create a new command
       * client.application.commands.create({
       *   name: 'test',
       *   description: 'A test command',
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async create(command, guildId) {
        const data = await this.client.rest.post(this.commandPath({ guildId }), {
          body: this.constructor.transformCommand(command)
        });
        return this._add(data, true, guildId);
      }
      /**
       * Sets all the commands for this application or guild.
       * @param {ApplicationCommandDataResolvable[]} commands The commands
       * @param {Snowflake} [guildId] The guild's id to create the commands in,
       * ignored when using a {@link GuildApplicationCommandManager}
       * @returns {Promise<Collection<Snowflake, ApplicationCommand>>}
       * @example
       * // Set all commands to just this one
       * client.application.commands.set([
       *   {
       *     name: 'test',
       *     description: 'A test command',
       *   },
       * ])
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Remove all commands
       * guild.commands.set([])
       *   .then(console.log)
       *   .catch(console.error);
       */
      async set(commands, guildId) {
        const data = await this.client.rest.put(this.commandPath({ guildId }), {
          body: commands.map((c) => this.constructor.transformCommand(c))
        });
        return data.reduce((coll, command) => coll.set(command.id, this._add(command, true, guildId)), new Collection2());
      }
      /**
       * Edits an application command.
       * @param {ApplicationCommandResolvable} command The command to edit
       * @param {Partial<ApplicationCommandDataResolvable>} data The data to update the command with
       * @param {Snowflake} [guildId] The guild's id where the command registered,
       * ignored when using a {@link GuildApplicationCommandManager}
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Edit an existing command
       * client.application.commands.edit('123456789012345678', {
       *   description: 'New description',
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async edit(command, data, guildId) {
        const id = this.resolveId(command);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "command", "ApplicationCommandResolvable");
        const patched = await this.client.rest.patch(this.commandPath({ id, guildId }), {
          body: this.constructor.transformCommand(data)
        });
        return this._add(patched, true, guildId);
      }
      /**
       * Deletes an application command.
       * @param {ApplicationCommandResolvable} command The command to delete
       * @param {Snowflake} [guildId] The guild's id where the command is registered,
       * ignored when using a {@link GuildApplicationCommandManager}
       * @returns {Promise<?ApplicationCommand>}
       * @example
       * // Delete a command
       * guild.commands.delete('123456789012345678')
       *   .then(console.log)
       *   .catch(console.error);
       */
      async delete(command, guildId) {
        const id = this.resolveId(command);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "command", "ApplicationCommandResolvable");
        await this.client.rest.delete(this.commandPath({ id, guildId }));
        const cached = this.cache.get(id);
        this.cache.delete(id);
        return cached ?? null;
      }
      /**
       * Transforms an {@link ApplicationCommandData} object into something that can be used with the API.
       * @param {ApplicationCommandDataResolvable} command The command to transform
       * @returns {APIApplicationCommand}
       * @private
       */
      static transformCommand(command) {
        if (isJSONEncodable(command))
          return command.toJSON();
        let default_member_permissions;
        if ("default_member_permissions" in command) {
          default_member_permissions = command.default_member_permissions ? new PermissionsBitField2(BigInt(command.default_member_permissions)).bitfield.toString() : command.default_member_permissions;
        }
        if ("defaultMemberPermissions" in command) {
          default_member_permissions = command.defaultMemberPermissions !== null ? new PermissionsBitField2(command.defaultMemberPermissions).bitfield.toString() : command.defaultMemberPermissions;
        }
        return {
          name: command.name,
          name_localizations: command.nameLocalizations ?? command.name_localizations,
          description: command.description,
          nsfw: command.nsfw,
          description_localizations: command.descriptionLocalizations ?? command.description_localizations,
          type: command.type,
          options: command.options?.map((o) => ApplicationCommand.transformOption(o)),
          default_member_permissions,
          dm_permission: command.dmPermission ?? command.dm_permission
        };
      }
    };
    module2.exports = ApplicationCommandManager;
  }
});

// node_modules/discord.js/src/util/ApplicationFlagsBitField.js
var require_ApplicationFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/ApplicationFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { ApplicationFlags } = require_v106();
    var BitField = require_BitField();
    var ApplicationFlagsBitField = class extends BitField {
    };
    /**
     * Numeric application flags. All available properties:
     * @type {ApplicationFlags}
     * @memberof ApplicationFlagsBitField
     */
    __publicField(ApplicationFlagsBitField, "Flags", ApplicationFlags);
    module2.exports = ApplicationFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/ClientApplication.js
var require_ClientApplication = __commonJS({
  "node_modules/discord.js/src/structures/ClientApplication.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var { ApplicationRoleConnectionMetadata } = require_ApplicationRoleConnectionMetadata();
    var Team = require_Team();
    var Application = require_Application();
    var ApplicationCommandManager = require_ApplicationCommandManager();
    var ApplicationFlagsBitField = require_ApplicationFlagsBitField();
    var PermissionsBitField2 = require_PermissionsBitField();
    var ClientApplication = class extends Application {
      constructor(client, data) {
        super(client, data);
        this.commands = new ApplicationCommandManager(this.client);
      }
      _patch(data) {
        super._patch(data);
        this.tags = data.tags ?? [];
        if ("install_params" in data) {
          this.installParams = {
            scopes: data.install_params.scopes,
            permissions: new PermissionsBitField2(data.install_params.permissions).freeze()
          };
        } else {
          this.installParams ??= null;
        }
        if ("custom_install_url" in data) {
          this.customInstallURL = data.custom_install_url;
        } else {
          this.customInstallURL = null;
        }
        if ("flags" in data) {
          this.flags = new ApplicationFlagsBitField(data.flags).freeze();
        }
        if ("cover_image" in data) {
          this.cover = data.cover_image;
        } else {
          this.cover ??= null;
        }
        if ("rpc_origins" in data) {
          this.rpcOrigins = data.rpc_origins;
        } else {
          this.rpcOrigins ??= [];
        }
        if ("bot_require_code_grant" in data) {
          this.botRequireCodeGrant = data.bot_require_code_grant;
        } else {
          this.botRequireCodeGrant ??= null;
        }
        if ("bot_public" in data) {
          this.botPublic = data.bot_public;
        } else {
          this.botPublic ??= null;
        }
        if ("role_connections_verification_url" in data) {
          this.roleConnectionsVerificationURL = data.role_connections_verification_url;
        } else {
          this.roleConnectionsVerificationURL ??= null;
        }
        this.owner = data.team ? new Team(this.client, data.team) : data.owner ? this.client.users._add(data.owner) : this.owner ?? null;
      }
      /**
       * Whether this application is partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return !this.name;
      }
      /**
       * Obtains this application from Discord.
       * @returns {Promise<ClientApplication>}
       */
      async fetch() {
        const app = await this.client.rest.get(Routes2.oauth2CurrentApplication());
        this._patch(app);
        return this;
      }
      /**
       * Gets this application's role connection metadata records
       * @returns {Promise<ApplicationRoleConnectionMetadata[]>}
       */
      async fetchRoleConnectionMetadataRecords() {
        const metadata = await this.client.rest.get(Routes2.applicationRoleConnectionMetadata(this.client.user.id));
        return metadata.map((data) => new ApplicationRoleConnectionMetadata(data));
      }
      /**
       * Data for creating or editing an application role connection metadata.
       * @typedef {Object} ApplicationRoleConnectionMetadataEditOptions
       * @property {string} name The name of the metadata field
       * @property {?Object<Locale, string>} [nameLocalizations] The name localizations for the metadata field
       * @property {string} description The description of the metadata field
       * @property {?Object<Locale, string>} [descriptionLocalizations] The description localizations for the metadata field
       * @property {string} key The dictionary key of the metadata field
       * @property {ApplicationRoleConnectionMetadataType} type The type of the metadata field
       */
      /**
       * Updates this application's role connection metadata records
       * @param {ApplicationRoleConnectionMetadataEditOptions[]} records The new role connection metadata records
       * @returns {Promise<ApplicationRoleConnectionMetadata[]>}
       */
      async editRoleConnectionMetadataRecords(records) {
        const newRecords = await this.client.rest.put(Routes2.applicationRoleConnectionMetadata(this.client.user.id), {
          body: records.map((record) => ({
            type: record.type,
            key: record.key,
            name: record.name,
            name_localizations: record.nameLocalizations,
            description: record.description,
            description_localizations: record.descriptionLocalizations
          }))
        });
        return newRecords.map((data) => new ApplicationRoleConnectionMetadata(data));
      }
    };
    module2.exports = ClientApplication;
  }
});

// node_modules/discord.js/src/structures/Embed.js
var require_Embed = __commonJS({
  "node_modules/discord.js/src/structures/Embed.js"(exports2, module2) {
    "use strict";
    var { embedLength } = require_dist8();
    var isEqual = require_fast_deep_equal();
    var Embed = class {
      constructor(data) {
        this.data = { ...data };
      }
      /**
       * An array of fields of this embed.
       * @type {Array<APIEmbedField>}
       * @readonly
       */
      get fields() {
        return this.data.fields ?? [];
      }
      /**
       * The title of this embed.
       * @type {?string}
       * @readonly
       */
      get title() {
        return this.data.title ?? null;
      }
      /**
       * The description of this embed.
       * @type {?string}
       * @readonly
       */
      get description() {
        return this.data.description ?? null;
      }
      /**
       * The URL of this embed.
       * @type {?string}
       * @readonly
       */
      get url() {
        return this.data.url ?? null;
      }
      /**
       * The color of this embed.
       * @type {?number}
       * @readonly
       */
      get color() {
        return this.data.color ?? null;
      }
      /**
       * The timestamp of this embed. This is in an ISO 8601 format.
       * @type {?string}
       * @readonly
       */
      get timestamp() {
        return this.data.timestamp ?? null;
      }
      /**
       * @typedef {Object} EmbedAssetData
       * @property {?string} url The URL of the image
       * @property {?string} proxyURL The proxy URL of the image
       * @property {?number} height The height of the image
       * @property {?number} width The width of the image
       */
      /**
       * The thumbnail of this embed.
       * @type {?EmbedAssetData}
       * @readonly
       */
      get thumbnail() {
        if (!this.data.thumbnail)
          return null;
        return {
          url: this.data.thumbnail.url,
          proxyURL: this.data.thumbnail.proxy_url,
          height: this.data.thumbnail.height,
          width: this.data.thumbnail.width
        };
      }
      /**
       * The image of this embed.
       * @type {?EmbedAssetData}
       * @readonly
       */
      get image() {
        if (!this.data.image)
          return null;
        return {
          url: this.data.image.url,
          proxyURL: this.data.image.proxy_url,
          height: this.data.image.height,
          width: this.data.image.width
        };
      }
      /**
       * The video of this embed.
       * @type {?EmbedAssetData}
       * @readonly
       */
      get video() {
        if (!this.data.video)
          return null;
        return {
          url: this.data.video.url,
          proxyURL: this.data.video.proxy_url,
          height: this.data.video.height,
          width: this.data.video.width
        };
      }
      /**
       * @typedef {Object} EmbedAuthorData
       * @property {string} name The name of the author
       * @property {?string} url The URL of the author
       * @property {?string} iconURL The icon URL of the author
       * @property {?string} proxyIconURL The proxy icon URL of the author
       */
      /**
       * The author of this embed.
       * @type {?EmbedAuthorData}
       * @readonly
       */
      get author() {
        if (!this.data.author)
          return null;
        return {
          name: this.data.author.name,
          url: this.data.author.url,
          iconURL: this.data.author.icon_url,
          proxyIconURL: this.data.author.proxy_icon_url
        };
      }
      /**
       * The provider of this embed.
       * @type {?APIEmbedProvider}
       * @readonly
       */
      get provider() {
        return this.data.provider ?? null;
      }
      /**
       * @typedef {Object} EmbedFooterData
       * @property {string} text The text of the footer
       * @property {?string} iconURL The URL of the icon
       * @property {?string} proxyIconURL The proxy URL of the icon
       */
      /**
       * The footer of this embed.
       * @type {?EmbedFooterData}
       * @readonly
       */
      get footer() {
        if (!this.data.footer)
          return null;
        return {
          text: this.data.footer.text,
          iconURL: this.data.footer.icon_url,
          proxyIconURL: this.data.footer.proxy_icon_url
        };
      }
      /**
       * The accumulated length for the embed title, description, fields, footer text, and author name.
       * @type {number}
       * @readonly
       */
      get length() {
        return embedLength(this.data);
      }
      /**
       * The hex color of this embed.
       * @type {?string}
       * @readonly
       */
      get hexColor() {
        return typeof this.data.color === "number" ? `#${this.data.color.toString(16).padStart(6, "0")}` : this.data.color ?? null;
      }
      /**
       * Returns the API-compatible JSON for this embed.
       * @returns {APIEmbed}
       */
      toJSON() {
        return { ...this.data };
      }
      /**
       * Whether the given embeds are equal.
       * @param {Embed|APIEmbed} other The embed to compare against
       * @returns {boolean}
       */
      equals(other) {
        if (other instanceof Embed) {
          return isEqual(other.data, this.data);
        }
        return isEqual(other, this.data);
      }
    };
    module2.exports = Embed;
  }
});

// node_modules/discord.js/src/structures/MessageMentions.js
var require_MessageMentions = __commonJS({
  "node_modules/discord.js/src/structures/MessageMentions.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { FormattingPatterns } = require_v106();
    var { flatten } = require_Util();
    var _MessageMentions = class {
      constructor(message, users, roles, everyone, crosspostedChannels, repliedUser) {
        Object.defineProperty(this, "client", { value: message.client });
        Object.defineProperty(this, "guild", { value: message.guild });
        Object.defineProperty(this, "_content", { value: message.content });
        this.everyone = Boolean(everyone);
        if (users) {
          if (users instanceof Collection2) {
            this.users = new Collection2(users);
          } else {
            this.users = new Collection2();
            for (const mention of users) {
              if (mention.member && message.guild) {
                message.guild.members._add(Object.assign(mention.member, { user: mention }));
              }
              const user = message.client.users._add(mention);
              this.users.set(user.id, user);
            }
          }
        } else {
          this.users = new Collection2();
        }
        if (roles instanceof Collection2) {
          this.roles = new Collection2(roles);
        } else if (roles) {
          this.roles = new Collection2();
          const guild = message.guild;
          if (guild) {
            for (const mention of roles) {
              const role = guild.roles.cache.get(mention);
              if (role)
                this.roles.set(role.id, role);
            }
          }
        } else {
          this.roles = new Collection2();
        }
        this._members = null;
        this._channels = null;
        this._parsedUsers = null;
        if (crosspostedChannels) {
          if (crosspostedChannels instanceof Collection2) {
            this.crosspostedChannels = new Collection2(crosspostedChannels);
          } else {
            this.crosspostedChannels = new Collection2();
            for (const d of crosspostedChannels) {
              this.crosspostedChannels.set(d.id, {
                channelId: d.id,
                guildId: d.guild_id,
                type: d.type,
                name: d.name
              });
            }
          }
        } else {
          this.crosspostedChannels = new Collection2();
        }
        this.repliedUser = repliedUser ? this.client.users._add(repliedUser) : null;
      }
      /**
       * Any members that were mentioned (only in {@link Guild}s)
       * <info>Order as received from the API, not as they appear in the message content</info>
       * @type {?Collection<Snowflake, GuildMember>}
       * @readonly
       */
      get members() {
        if (this._members)
          return this._members;
        if (!this.guild)
          return null;
        this._members = new Collection2();
        this.users.forEach((user) => {
          const member = this.guild.members.resolve(user);
          if (member)
            this._members.set(member.user.id, member);
        });
        return this._members;
      }
      /**
       * Any channels that were mentioned
       * <info>Order as they appear first in the message content</info>
       * @type {Collection<Snowflake, BaseChannel>}
       * @readonly
       */
      get channels() {
        if (this._channels)
          return this._channels;
        this._channels = new Collection2();
        let matches;
        while ((matches = this.constructor.GlobalChannelsPattern.exec(this._content)) !== null) {
          const channel = this.client.channels.cache.get(matches.groups.id);
          if (channel)
            this._channels.set(channel.id, channel);
        }
        return this._channels;
      }
      /**
       * Any user mentions that were included in the message content
       * <info>Order as they appear first in the message content</info>
       * @type {Collection<Snowflake, User>}
       * @readonly
       */
      get parsedUsers() {
        if (this._parsedUsers)
          return this._parsedUsers;
        this._parsedUsers = new Collection2();
        let matches;
        while ((matches = this.constructor.GlobalUsersPattern.exec(this._content)) !== null) {
          const user = this.client.users.cache.get(matches[1]);
          if (user)
            this._parsedUsers.set(user.id, user);
        }
        return this._parsedUsers;
      }
      /**
       * Options used to check for a mention.
       * @typedef {Object} MessageMentionsHasOptions
       * @property {boolean} [ignoreDirect=false] Whether to ignore direct mentions to the item
       * @property {boolean} [ignoreRoles=false] Whether to ignore role mentions to a guild member
       * @property {boolean} [ignoreRepliedUser=false] Whether to ignore replied user mention to an user
       * @property {boolean} [ignoreEveryone=false] Whether to ignore `@everyone`/`@here` mentions
       */
      /**
       * Checks if a user, guild member, thread member, role, or channel is mentioned.
       * Takes into account user mentions, role mentions, channel mentions,
       * replied user mention, and `@everyone`/`@here` mentions.
       * @param {UserResolvable|RoleResolvable|ChannelResolvable} data The User/Role/Channel to check for
       * @param {MessageMentionsHasOptions} [options] The options for the check
       * @returns {boolean}
       */
      has(data, { ignoreDirect = false, ignoreRoles = false, ignoreRepliedUser = false, ignoreEveryone = false } = {}) {
        const user = this.client.users.resolve(data);
        if (!ignoreEveryone && user && this.everyone)
          return true;
        const userWasRepliedTo = user && this.repliedUser?.id === user.id;
        if (!ignoreRepliedUser && userWasRepliedTo && this.users.has(user.id))
          return true;
        if (!ignoreDirect) {
          if (user && (!ignoreRepliedUser || this.parsedUsers.has(user.id)) && this.users.has(user.id))
            return true;
          const role = this.guild?.roles.resolve(data);
          if (role && this.roles.has(role.id))
            return true;
          const channel = this.client.channels.resolve(data);
          if (channel && this.channels.has(channel.id))
            return true;
        }
        if (!ignoreRoles) {
          const member = this.guild?.members.resolve(data);
          if (member) {
            for (const mentionedRole of this.roles.values())
              if (member.roles.cache.has(mentionedRole.id))
                return true;
          }
        }
        return false;
      }
      toJSON() {
        return flatten(this, {
          members: true,
          channels: true
        });
      }
    };
    var MessageMentions = _MessageMentions;
    /**
     * A regular expression that matches `@everyone` and `@here`.
     * The `mention` group property is present on the `exec` result of this expression.
     * @type {RegExp}
     * @memberof MessageMentions
     */
    __publicField(MessageMentions, "EveryonePattern", /@(?<mention>everyone|here)/);
    /**
     * A regular expression that matches user mentions like `<@81440962496172032>`.
     * The `id` group property is present on the `exec` result of this expression.
     * @type {RegExp}
     * @memberof MessageMentions
     */
    __publicField(MessageMentions, "UsersPattern", FormattingPatterns.UserWithOptionalNickname);
    /**
     * A regular expression that matches role mentions like `<@&297577916114403338>`.
     * The `id` group property is present on the `exec` result of this expression.
     * @type {RegExp}
     * @memberof MessageMentions
     */
    __publicField(MessageMentions, "RolesPattern", FormattingPatterns.Role);
    /**
     * A regular expression that matches channel mentions like `<#222079895583457280>`.
     * The `id` group property is present on the `exec` result of this expression.
     * @type {RegExp}
     * @memberof MessageMentions
     */
    __publicField(MessageMentions, "ChannelsPattern", FormattingPatterns.Channel);
    /**
     * A global regular expression variant of {@link MessageMentions.ChannelsPattern}.
     * @type {RegExp}
     * @memberof MessageMentions
     * @private
     */
    __publicField(MessageMentions, "GlobalChannelsPattern", new RegExp(_MessageMentions.ChannelsPattern.source, "g"));
    /**
     * A global regular expression variant of {@link MessageMentions.UsersPattern}.
     * @type {RegExp}
     * @memberof MessageMentions
     * @private
     */
    __publicField(MessageMentions, "GlobalUsersPattern", new RegExp(_MessageMentions.UsersPattern.source, "g"));
    module2.exports = MessageMentions;
  }
});

// node_modules/discord.js/src/structures/ReactionCollector.js
var require_ReactionCollector = __commonJS({
  "node_modules/discord.js/src/structures/ReactionCollector.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Collector = require_Collector();
    var Events3 = require_Events();
    var ReactionCollector = class extends Collector {
      /**
       * @param {Message} message The message upon which to collect reactions
       * @param {ReactionCollectorOptions} [options={}] The options to apply to this collector
       */
      constructor(message, options = {}) {
        super(message.client, options);
        this.message = message;
        this.users = new Collection2();
        this.total = 0;
        this.empty = this.empty.bind(this);
        this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
        this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
        this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
        this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
        const bulkDeleteListener = (messages) => {
          if (messages.has(this.message.id))
            this.stop("messageDelete");
        };
        this.client.incrementMaxListeners();
        this.client.on(Events3.MessageReactionAdd, this.handleCollect);
        this.client.on(Events3.MessageReactionRemove, this.handleDispose);
        this.client.on(Events3.MessageReactionRemoveAll, this.empty);
        this.client.on(Events3.MessageDelete, this._handleMessageDeletion);
        this.client.on(Events3.MessageBulkDelete, bulkDeleteListener);
        this.client.on(Events3.ChannelDelete, this._handleChannelDeletion);
        this.client.on(Events3.ThreadDelete, this._handleThreadDeletion);
        this.client.on(Events3.GuildDelete, this._handleGuildDeletion);
        this.once("end", () => {
          this.client.removeListener(Events3.MessageReactionAdd, this.handleCollect);
          this.client.removeListener(Events3.MessageReactionRemove, this.handleDispose);
          this.client.removeListener(Events3.MessageReactionRemoveAll, this.empty);
          this.client.removeListener(Events3.MessageDelete, this._handleMessageDeletion);
          this.client.removeListener(Events3.MessageBulkDelete, bulkDeleteListener);
          this.client.removeListener(Events3.ChannelDelete, this._handleChannelDeletion);
          this.client.removeListener(Events3.ThreadDelete, this._handleThreadDeletion);
          this.client.removeListener(Events3.GuildDelete, this._handleGuildDeletion);
          this.client.decrementMaxListeners();
        });
        this.on("collect", (reaction, user) => {
          if (reaction.count === 1) {
            this.emit("create", reaction, user);
          }
          this.total++;
          this.users.set(user.id, user);
        });
        this.on("remove", (reaction, user) => {
          this.total--;
          if (!this.collected.some((r) => r.users.cache.has(user.id)))
            this.users.delete(user.id);
        });
      }
      /**
       * Handles an incoming reaction for possible collection.
       * @param {MessageReaction} reaction The reaction to possibly collect
       * @param {User} user The user that added the reaction
       * @returns {?(Snowflake|string)}
       * @private
       */
      collect(reaction) {
        if (reaction.message.id !== this.message.id)
          return null;
        return ReactionCollector.key(reaction);
      }
      /**
       * Handles a reaction deletion for possible disposal.
       * @param {MessageReaction} reaction The reaction to possibly dispose of
       * @param {User} user The user that removed the reaction
       * @returns {?(Snowflake|string)}
       */
      dispose(reaction, user) {
        if (reaction.message.id !== this.message.id)
          return null;
        if (this.collected.has(ReactionCollector.key(reaction)) && this.users.has(user.id)) {
          this.emit("remove", reaction, user);
        }
        return reaction.count ? null : ReactionCollector.key(reaction);
      }
      /**
       * Empties this reaction collector.
       */
      empty() {
        this.total = 0;
        this.collected.clear();
        this.users.clear();
        this.checkEnd();
      }
      /**
       * The reason this collector has ended with, or null if it hasn't ended yet
       * @type {?string}
       * @readonly
       */
      get endReason() {
        if (this.options.max && this.total >= this.options.max)
          return "limit";
        if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis)
          return "emojiLimit";
        if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
          return "userLimit";
        return super.endReason;
      }
      /**
       * Handles checking if the message has been deleted, and if so, stops the collector with the reason 'messageDelete'.
       * @private
       * @param {Message} message The message that was deleted
       * @returns {void}
       */
      _handleMessageDeletion(message) {
        if (message.id === this.message.id) {
          this.stop("messageDelete");
        }
      }
      /**
       * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.
       * @private
       * @param {GuildChannel} channel The channel that was deleted
       * @returns {void}
       */
      _handleChannelDeletion(channel) {
        if (channel.id === this.message.channelId || channel.threads?.cache.has(this.message.channelId)) {
          this.stop("channelDelete");
        }
      }
      /**
       * Handles checking if the thread has been deleted, and if so, stops the collector with the reason 'threadDelete'.
       * @private
       * @param {ThreadChannel} thread The thread that was deleted
       * @returns {void}
       */
      _handleThreadDeletion(thread) {
        if (thread.id === this.message.channelId) {
          this.stop("threadDelete");
        }
      }
      /**
       * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.
       * @private
       * @param {Guild} guild The guild that was deleted
       * @returns {void}
       */
      _handleGuildDeletion(guild) {
        if (guild.id === this.message.guild?.id) {
          this.stop("guildDelete");
        }
      }
      /**
       * Gets the collector key for a reaction.
       * @param {MessageReaction} reaction The message reaction to get the key for
       * @returns {Snowflake|string}
       */
      static key(reaction) {
        return reaction.emoji.id ?? reaction.emoji.name;
      }
    };
    module2.exports = ReactionCollector;
  }
});

// node_modules/discord.js/src/structures/Sticker.js
var require_Sticker = __commonJS({
  "node_modules/discord.js/src/structures/Sticker.js"(exports2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { Routes: Routes2 } = require_v106();
    var Base = require_Base();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { StickerFormatExtensionMap } = require_Constants();
    var Sticker2 = class extends Base {
      constructor(client, sticker) {
        super(client);
        this._patch(sticker);
      }
      _patch(sticker) {
        this.id = sticker.id;
        if ("description" in sticker) {
          this.description = sticker.description;
        } else {
          this.description ??= null;
        }
        if ("type" in sticker) {
          this.type = sticker.type;
        } else {
          this.type ??= null;
        }
        if ("format_type" in sticker) {
          this.format = sticker.format_type;
        }
        if ("name" in sticker) {
          this.name = sticker.name;
        }
        if ("pack_id" in sticker) {
          this.packId = sticker.pack_id;
        } else {
          this.packId ??= null;
        }
        if ("tags" in sticker) {
          this.tags = sticker.tags;
        } else {
          this.tags ??= null;
        }
        if ("available" in sticker) {
          this.available = sticker.available;
        } else {
          this.available ??= null;
        }
        if ("guild_id" in sticker) {
          this.guildId = sticker.guild_id;
        } else {
          this.guildId ??= null;
        }
        if ("user" in sticker) {
          this.user = this.client.users._add(sticker.user);
        } else {
          this.user ??= null;
        }
        if ("sort_value" in sticker) {
          this.sortValue = sticker.sort_value;
        } else {
          this.sortValue ??= null;
        }
      }
      /**
       * The timestamp the sticker was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the sticker was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * Whether this sticker is partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return !this.type;
      }
      /**
       * The guild that owns this sticker
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      /**
       * A link to the sticker
       * <info>If the sticker's format is {@link StickerFormatType.Lottie}, it returns
       * the URL of the Lottie JSON file.</info>
       * @type {string}
       * @readonly
       */
      get url() {
        return this.client.rest.cdn.sticker(this.id, StickerFormatExtensionMap[this.format]);
      }
      /**
       * Fetches this sticker.
       * @returns {Promise<Sticker>}
       */
      async fetch() {
        const data = await this.client.rest.get(Routes2.sticker(this.id));
        this._patch(data);
        return this;
      }
      /**
       * Fetches the pack this sticker is part of from Discord, if this is a Nitro sticker.
       * @returns {Promise<?StickerPack>}
       */
      async fetchPack() {
        return (this.packId && (await this.client.fetchPremiumStickerPacks()).get(this.packId)) ?? null;
      }
      /**
       * Fetches the user who uploaded this sticker, if this is a guild sticker.
       * @returns {Promise<?User>}
       */
      async fetchUser() {
        if (this.partial)
          await this.fetch();
        if (!this.guildId)
          throw new DiscordjsError2(ErrorCodes2.NotGuildSticker);
        return this.guild.stickers.fetchUser(this);
      }
      /**
       * Data for editing a sticker.
       * @typedef {Object} GuildStickerEditOptions
       * @property {string} [name] The name of the sticker
       * @property {?string} [description] The description of the sticker
       * @property {string} [tags] The Discord name of a unicode emoji representing the sticker's expression
       * @property {string} [reason] Reason for editing this sticker
       */
      /**
       * Edits the sticker.
       * @param {GuildStickerEditOptions} options The options to provide
       * @returns {Promise<Sticker>}
       * @example
       * // Update the name of a sticker
       * sticker.edit({ name: 'new name' })
       *   .then(s => console.log(`Updated the name of the sticker to ${s.name}`))
       *   .catch(console.error);
       */
      edit(options) {
        return this.guild.stickers.edit(this, options);
      }
      /**
       * Deletes the sticker.
       * @returns {Promise<Sticker>}
       * @param {string} [reason] Reason for deleting this sticker
       * @example
       * // Delete a message
       * sticker.delete()
       *   .then(s => console.log(`Deleted sticker ${s.name}`))
       *   .catch(console.error);
       */
      async delete(reason) {
        await this.guild.stickers.delete(this, reason);
        return this;
      }
      /**
       * Whether this sticker is the same as another one.
       * @param {Sticker|APISticker} other The sticker to compare it to
       * @returns {boolean}
       */
      equals(other) {
        if (other instanceof Sticker2) {
          return other.id === this.id && other.description === this.description && other.type === this.type && other.format === this.format && other.name === this.name && other.packId === this.packId && other.tags === this.tags && other.available === this.available && other.guildId === this.guildId && other.sortValue === this.sortValue;
        } else {
          return other.id === this.id && other.description === this.description && other.name === this.name && other.tags === this.tags;
        }
      }
    };
    exports2.Sticker = Sticker2;
  }
});

// node_modules/discord.js/src/structures/BaseGuildEmoji.js
var require_BaseGuildEmoji = __commonJS({
  "node_modules/discord.js/src/structures/BaseGuildEmoji.js"(exports2, module2) {
    "use strict";
    var { Emoji } = require_Emoji();
    var BaseGuildEmoji = class extends Emoji {
      constructor(client, data, guild) {
        super(client, data);
        this.guild = guild;
        this.requiresColons = null;
        this.managed = null;
        this.available = null;
        this._patch(data);
      }
      _patch(data) {
        if ("name" in data)
          this.name = data.name;
        if ("require_colons" in data) {
          this.requiresColons = data.require_colons;
        }
        if ("managed" in data) {
          this.managed = data.managed;
        }
        if ("available" in data) {
          this.available = data.available;
        }
      }
    };
    module2.exports = BaseGuildEmoji;
  }
});

// node_modules/discord.js/src/managers/GuildEmojiRoleManager.js
var require_GuildEmojiRoleManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildEmojiRoleManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var DataManager = require_DataManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { Role } = require_Role();
    var GuildEmojiRoleManager = class extends DataManager {
      constructor(emoji) {
        super(emoji.client, Role);
        this.emoji = emoji;
        this.guild = emoji.guild;
      }
      /**
       * The cache of roles belonging to this emoji
       * @type {Collection<Snowflake, Role>}
       * @readonly
       */
      get cache() {
        return this.guild.roles.cache.filter((role) => this.emoji._roles.includes(role.id));
      }
      /**
       * Adds a role (or multiple roles) to the list of roles that can use this emoji.
       * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add
       * @returns {Promise<GuildEmoji>}
       */
      add(roleOrRoles) {
        if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection2))
          roleOrRoles = [roleOrRoles];
        const resolvedRoles = [];
        for (const role of roleOrRoles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            return Promise.reject(new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "roles", role));
          }
          resolvedRoles.push(resolvedRole);
        }
        const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
        return this.set(newRoles);
      }
      /**
       * Removes a role (or multiple roles) from the list of roles that can use this emoji.
       * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove
       * @returns {Promise<GuildEmoji>}
       */
      remove(roleOrRoles) {
        if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection2))
          roleOrRoles = [roleOrRoles];
        const resolvedRoleIds = [];
        for (const role of roleOrRoles.values()) {
          const roleId = this.guild.roles.resolveId(role);
          if (!roleId) {
            return Promise.reject(new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "roles", role));
          }
          resolvedRoleIds.push(roleId);
        }
        const newRoles = [...this.cache.keys()].filter((id) => !resolvedRoleIds.includes(id));
        return this.set(newRoles);
      }
      /**
       * Sets the role(s) that can use this emoji.
       * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role ids to apply
       * @returns {Promise<GuildEmoji>}
       * @example
       * // Set the emoji's roles to a single role
       * guildEmoji.roles.set(['391156570408615936'])
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Remove all roles from an emoji
       * guildEmoji.roles.set([])
       *    .then(console.log)
       *    .catch(console.error);
       */
      set(roles) {
        return this.emoji.edit({ roles });
      }
      clone() {
        const clone = new this.constructor(this.emoji);
        clone._patch([...this.cache.keys()]);
        return clone;
      }
      /**
       * Patches the roles for this manager's cache
       * @param {Snowflake[]} roles The new roles
       * @private
       */
      _patch(roles) {
        this.emoji._roles = roles;
      }
      valueOf() {
        return this.cache;
      }
    };
    module2.exports = GuildEmojiRoleManager;
  }
});

// node_modules/discord.js/src/structures/GuildEmoji.js
var require_GuildEmoji = __commonJS({
  "node_modules/discord.js/src/structures/GuildEmoji.js"(exports2, module2) {
    "use strict";
    var { PermissionFlagsBits } = require_v106();
    var BaseGuildEmoji = require_BaseGuildEmoji();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var GuildEmojiRoleManager = require_GuildEmojiRoleManager();
    var GuildEmoji = class extends BaseGuildEmoji {
      constructor(client, data, guild) {
        super(client, data, guild);
        this.author = null;
        Object.defineProperty(this, "_roles", { value: [], writable: true });
        this._patch(data);
      }
      /**
       * The guild this emoji is part of
       * @type {Guild}
       * @name GuildEmoji#guild
       */
      _clone() {
        const clone = super._clone();
        clone._roles = this._roles.slice();
        return clone;
      }
      _patch(data) {
        super._patch(data);
        if (data.user)
          this.author = this.client.users._add(data.user);
        if (data.roles)
          this._roles = data.roles;
      }
      /**
       * Whether the emoji is deletable by the client user
       * @type {boolean}
       * @readonly
       */
      get deletable() {
        if (!this.guild.members.me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        return !this.managed && this.guild.members.me.permissions.has(PermissionFlagsBits.ManageEmojisAndStickers);
      }
      /**
       * A manager for roles this emoji is active for.
       * @type {GuildEmojiRoleManager}
       * @readonly
       */
      get roles() {
        return new GuildEmojiRoleManager(this);
      }
      /**
       * Fetches the author for this emoji
       * @returns {Promise<User>}
       */
      fetchAuthor() {
        return this.guild.emojis.fetchAuthor(this);
      }
      /**
       * Data for editing an emoji.
       * @typedef {Object} GuildEmojiEditOptions
       * @property {string} [name] The name of the emoji
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] Roles to restrict emoji to
       * @property {string} [reason] Reason for editing this emoji
       */
      /**
       * Edits the emoji.
       * @param {GuildEmojiEditOptions} options The options to provide
       * @returns {Promise<GuildEmoji>}
       * @example
       * // Edit an emoji
       * emoji.edit({ name: 'newemoji' })
       *   .then(e => console.log(`Edited emoji ${e}`))
       *   .catch(console.error);
       */
      edit(options) {
        return this.guild.emojis.edit(this.id, options);
      }
      /**
       * Sets the name of the emoji.
       * @param {string} name The new name for the emoji
       * @param {string} [reason] Reason for changing the emoji's name
       * @returns {Promise<GuildEmoji>}
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Deletes the emoji.
       * @param {string} [reason] Reason for deleting the emoji
       * @returns {Promise<GuildEmoji>}
       */
      async delete(reason) {
        await this.guild.emojis.delete(this.id, reason);
        return this;
      }
      /**
       * Whether this emoji is the same as another one.
       * @param {GuildEmoji|APIEmoji} other The emoji to compare it to
       * @returns {boolean}
       */
      equals(other) {
        if (other instanceof GuildEmoji) {
          return other.id === this.id && other.name === this.name && other.managed === this.managed && other.available === this.available && other.requiresColons === this.requiresColons && other.roles.cache.size === this.roles.cache.size && other.roles.cache.every((role) => this.roles.cache.has(role.id));
        } else {
          return other.id === this.id && other.name === this.name && other.roles.length === this.roles.cache.size && other.roles.every((role) => this.roles.cache.has(role));
        }
      }
    };
    module2.exports = GuildEmoji;
  }
});

// node_modules/discord.js/src/structures/ReactionEmoji.js
var require_ReactionEmoji = __commonJS({
  "node_modules/discord.js/src/structures/ReactionEmoji.js"(exports2, module2) {
    "use strict";
    var { Emoji } = require_Emoji();
    var { flatten } = require_Util();
    var ReactionEmoji = class extends Emoji {
      constructor(reaction, emoji) {
        super(reaction.message.client, emoji);
        this.reaction = reaction;
      }
      toJSON() {
        return flatten(this, { identifier: true });
      }
      valueOf() {
        return this.id;
      }
    };
    module2.exports = ReactionEmoji;
  }
});

// node_modules/discord.js/src/util/UserFlagsBitField.js
var require_UserFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/UserFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { UserFlags } = require_v106();
    var BitField = require_BitField();
    var UserFlagsBitField = class extends BitField {
    };
    /**
     * Numeric user flags.
     * @type {UserFlags}
     * @memberof UserFlagsBitField
     */
    __publicField(UserFlagsBitField, "Flags", UserFlags);
    module2.exports = UserFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/User.js
var require_User = __commonJS({
  "node_modules/discord.js/src/structures/User.js"(exports2, module2) {
    "use strict";
    var { userMention } = require_dist8();
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var TextBasedChannel = require_TextBasedChannel();
    var UserFlagsBitField = require_UserFlagsBitField();
    var User = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.bot = null;
        this.system = null;
        this.flags = null;
        this._patch(data);
      }
      _patch(data) {
        if ("username" in data) {
          this.username = data.username;
        } else {
          this.username ??= null;
        }
        if ("bot" in data) {
          this.bot = Boolean(data.bot);
        } else if (!this.partial && typeof this.bot !== "boolean") {
          this.bot = false;
        }
        if ("discriminator" in data) {
          this.discriminator = data.discriminator;
        } else {
          this.discriminator ??= null;
        }
        if ("avatar" in data) {
          this.avatar = data.avatar;
        } else {
          this.avatar ??= null;
        }
        if ("banner" in data) {
          this.banner = data.banner;
        } else if (this.banner !== null) {
          this.banner ??= void 0;
        }
        if ("accent_color" in data) {
          this.accentColor = data.accent_color;
        } else if (this.accentColor !== null) {
          this.accentColor ??= void 0;
        }
        if ("system" in data) {
          this.system = Boolean(data.system);
        } else if (!this.partial && typeof this.system !== "boolean") {
          this.system = false;
        }
        if ("public_flags" in data) {
          this.flags = new UserFlagsBitField(data.public_flags);
        }
      }
      /**
       * Whether this User is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return typeof this.username !== "string";
      }
      /**
       * The timestamp the user was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the user was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * A link to the user's avatar.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      avatarURL(options = {}) {
        return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
      }
      /**
       * A link to the user's default avatar
       * @type {string}
       * @readonly
       */
      get defaultAvatarURL() {
        return this.client.rest.cdn.defaultAvatar(this.discriminator % 5);
      }
      /**
       * A link to the user's avatar if they have one.
       * Otherwise a link to their default avatar will be returned.
       * @param {ImageURLOptions} [options={}] Options for the Image URL
       * @returns {string}
       */
      displayAvatarURL(options) {
        return this.avatarURL(options) ?? this.defaultAvatarURL;
      }
      /**
       * The hexadecimal version of the user accent color, with a leading hash
       * <info>The user must be force fetched for this property to be present</info>
       * @type {?string}
       * @readonly
       */
      get hexAccentColor() {
        if (typeof this.accentColor !== "number")
          return this.accentColor;
        return `#${this.accentColor.toString(16).padStart(6, "0")}`;
      }
      /**
       * A link to the user's banner. See {@link User#banner} for more info
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      bannerURL(options = {}) {
        return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
      }
      /**
       * The Discord "tag" (e.g. `hydrabolt#0001`) for this user
       * @type {?string}
       * @readonly
       */
      get tag() {
        return typeof this.username === "string" ? `${this.username}#${this.discriminator}` : null;
      }
      /**
       * The DM between the client's user and this user
       * @type {?DMChannel}
       * @readonly
       */
      get dmChannel() {
        return this.client.users.dmChannel(this.id);
      }
      /**
       * Creates a DM channel between the client and the user.
       * @param {boolean} [force=false] Whether to skip the cache check and request the API
       * @returns {Promise<DMChannel>}
       */
      createDM(force = false) {
        return this.client.users.createDM(this.id, { force });
      }
      /**
       * Deletes a DM channel (if one exists) between the client and the user. Resolves with the channel if successful.
       * @returns {Promise<DMChannel>}
       */
      deleteDM() {
        return this.client.users.deleteDM(this.id);
      }
      /**
       * Checks if the user is equal to another.
       * It compares id, username, discriminator, avatar, banner, accent color, and bot flags.
       * It is recommended to compare equality by using `user.id === user2.id` unless you want to compare all properties.
       * @param {User} user User to compare with
       * @returns {boolean}
       */
      equals(user) {
        return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.avatar === user.avatar && this.flags?.bitfield === user.flags?.bitfield && this.banner === user.banner && this.accentColor === user.accentColor;
      }
      /**
       * Compares the user with an API user object
       * @param {APIUser} user The API user object to compare
       * @returns {boolean}
       * @private
       */
      _equals(user) {
        return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.avatar === user.avatar && this.flags?.bitfield === user.public_flags && ("banner" in user ? this.banner === user.banner : true) && ("accent_color" in user ? this.accentColor === user.accent_color : true);
      }
      /**
       * Fetches this user's flags.
       * @param {boolean} [force=false] Whether to skip the cache check and request the API
       * @returns {Promise<UserFlagsBitField>}
       */
      fetchFlags(force = false) {
        return this.client.users.fetchFlags(this.id, { force });
      }
      /**
       * Fetches this user.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<User>}
       */
      fetch(force = true) {
        return this.client.users.fetch(this.id, { force });
      }
      /**
       * When concatenated with a string, this automatically returns the user's mention instead of the User object.
       * @returns {string}
       * @example
       * // Logs: Hello from <@123456789012345678>!
       * console.log(`Hello from ${user}!`);
       */
      toString() {
        return userMention(this.id);
      }
      toJSON(...props) {
        const json2 = super.toJSON(
          {
            createdTimestamp: true,
            defaultAvatarURL: true,
            hexAccentColor: true,
            tag: true
          },
          ...props
        );
        json2.avatarURL = this.avatarURL();
        json2.displayAvatarURL = this.displayAvatarURL();
        json2.bannerURL = this.banner ? this.bannerURL() : this.banner;
        return json2;
      }
    };
    TextBasedChannel.applyToClass(User);
    module2.exports = User;
  }
});

// node_modules/discord.js/src/managers/ReactionUserManager.js
var require_ReactionUserManager = __commonJS({
  "node_modules/discord.js/src/managers/ReactionUserManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var User = require_User();
    var ReactionUserManager = class extends CachedManager {
      constructor(reaction, iterable) {
        super(reaction.client, User, iterable);
        this.reaction = reaction;
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, User>}
       * @name ReactionUserManager#cache
       */
      /**
       * Options used to fetch users who gave a reaction.
       * @typedef {Object} FetchReactionUsersOptions
       * @property {number} [limit=100] The maximum amount of users to fetch, defaults to `100`
       * @property {Snowflake} [after] Limit fetching users to those with an id greater than the supplied id
       */
      /**
       * Fetches all the users that gave this reaction. Resolves with a collection of users, mapped by their ids.
       * @param {FetchReactionUsersOptions} [options] Options for fetching the users
       * @returns {Promise<Collection<Snowflake, User>>}
       */
      async fetch({ limit = 100, after } = {}) {
        const message = this.reaction.message;
        const query = makeURLSearchParams2({ limit, after });
        const data = await this.client.rest.get(
          Routes2.channelMessageReaction(message.channelId, message.id, this.reaction.emoji.identifier),
          { query }
        );
        const users = new Collection2();
        for (const rawUser of data) {
          const user = this.client.users._add(rawUser);
          this.cache.set(user.id, user);
          users.set(user.id, user);
        }
        return users;
      }
      /**
       * Removes a user from this reaction.
       * @param {UserResolvable} [user=this.client.user] The user to remove the reaction of
       * @returns {Promise<MessageReaction>}
       */
      async remove(user = this.client.user) {
        const userId = this.client.users.resolveId(user);
        if (!userId)
          throw new DiscordjsError2(ErrorCodes2.ReactionResolveUser);
        const message = this.reaction.message;
        const route = userId === this.client.user.id ? Routes2.channelMessageOwnReaction(message.channelId, message.id, this.reaction.emoji.identifier) : Routes2.channelMessageUserReaction(message.channelId, message.id, this.reaction.emoji.identifier, userId);
        await this.client.rest.delete(route);
        return this.reaction;
      }
    };
    module2.exports = ReactionUserManager;
  }
});

// node_modules/discord.js/src/structures/MessageReaction.js
var require_MessageReaction = __commonJS({
  "node_modules/discord.js/src/structures/MessageReaction.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var GuildEmoji = require_GuildEmoji();
    var ReactionEmoji = require_ReactionEmoji();
    var ReactionUserManager = require_ReactionUserManager();
    var { flatten } = require_Util();
    var MessageReaction = class {
      constructor(client, data, message) {
        Object.defineProperty(this, "client", { value: client });
        this.message = message;
        this.me = data.me;
        this.users = new ReactionUserManager(this, this.me ? [client.user] : []);
        this._emoji = new ReactionEmoji(this, data.emoji);
        this._patch(data);
      }
      _patch(data) {
        if ("count" in data) {
          this.count ??= data.count;
        }
      }
      /**
       * Makes the client user react with this reaction
       * @returns {Promise<MessageReaction>}
       */
      react() {
        return this.message.react(this.emoji);
      }
      /**
       * Removes all users from this reaction.
       * @returns {Promise<MessageReaction>}
       */
      async remove() {
        await this.client.rest.delete(
          Routes2.channelMessageReaction(this.message.channelId, this.message.id, this._emoji.identifier)
        );
        return this;
      }
      /**
       * The emoji of this reaction. Either a {@link GuildEmoji} object for known custom emojis, or a {@link ReactionEmoji}
       * object which has fewer properties. Whatever the prototype of the emoji, it will still have
       * `name`, `id`, `identifier` and `toString()`
       * @type {GuildEmoji|ReactionEmoji}
       * @readonly
       */
      get emoji() {
        if (this._emoji instanceof GuildEmoji)
          return this._emoji;
        if (this._emoji.id) {
          const emojis = this.message.client.emojis.cache;
          if (emojis.has(this._emoji.id)) {
            const emoji = emojis.get(this._emoji.id);
            this._emoji = emoji;
            return emoji;
          }
        }
        return this._emoji;
      }
      /**
       * Whether or not this reaction is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return this.count === null;
      }
      /**
       * Fetch this reaction.
       * @returns {Promise<MessageReaction>}
       */
      async fetch() {
        const message = await this.message.fetch();
        const existing = message.reactions.cache.get(this.emoji.id ?? this.emoji.name);
        this._patch(existing ?? { count: 0 });
        return this;
      }
      toJSON() {
        return flatten(this, { emoji: "emojiId", message: "messageId" });
      }
      valueOf() {
        return this._emoji.id ?? this._emoji.name;
      }
      _add(user) {
        if (this.partial)
          return;
        this.users.cache.set(user.id, user);
        if (!this.me || user.id !== this.message.client.user.id || this.count === 0)
          this.count++;
        this.me ||= user.id === this.message.client.user.id;
      }
      _remove(user) {
        if (this.partial)
          return;
        this.users.cache.delete(user.id);
        if (!this.me || user.id !== this.message.client.user.id)
          this.count--;
        if (user.id === this.message.client.user.id)
          this.me = false;
        if (this.count <= 0 && this.users.cache.size === 0) {
          this.message.reactions.cache.delete(this.emoji.id ?? this.emoji.name);
        }
      }
    };
    module2.exports = MessageReaction;
  }
});

// node_modules/discord.js/src/managers/ReactionManager.js
var require_ReactionManager = __commonJS({
  "node_modules/discord.js/src/managers/ReactionManager.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var MessageReaction = require_MessageReaction();
    var ReactionManager = class extends CachedManager {
      constructor(message, iterable) {
        super(message.client, MessageReaction, iterable);
        this.message = message;
      }
      _add(data, cache) {
        return super._add(data, cache, { id: data.emoji.id ?? data.emoji.name, extras: [this.message] });
      }
      /**
       * The reaction cache of this manager
       * @type {Collection<string|Snowflake, MessageReaction>}
       * @name ReactionManager#cache
       */
      /**
       * Data that can be resolved to a MessageReaction object. This can be:
       * * A MessageReaction
       * * A Snowflake
       * * The Unicode representation of an emoji
       * @typedef {MessageReaction|Snowflake} MessageReactionResolvable
       */
      /**
       * Resolves a {@link MessageReactionResolvable} to a {@link MessageReaction} object.
       * @method resolve
       * @memberof ReactionManager
       * @instance
       * @param {MessageReactionResolvable} reaction The MessageReaction to resolve
       * @returns {?MessageReaction}
       */
      /**
       * Resolves a {@link MessageReactionResolvable} to a {@link MessageReaction} id.
       * @method resolveId
       * @memberof ReactionManager
       * @instance
       * @param {MessageReactionResolvable} reaction The MessageReaction to resolve
       * @returns {?Snowflake}
       */
      /**
       * Removes all reactions from a message.
       * @returns {Promise<Message>}
       */
      async removeAll() {
        await this.client.rest.delete(Routes2.channelMessageAllReactions(this.message.channelId, this.message.id));
        return this.message;
      }
    };
    module2.exports = ReactionManager;
  }
});

// node_modules/discord.js/src/structures/Message.js
var require_Message = __commonJS({
  "node_modules/discord.js/src/structures/Message.js"(exports2) {
    "use strict";
    var { messageLink } = require_dist8();
    var { Collection: Collection2 } = require_dist();
    var { DiscordSnowflake } = require_dist3();
    var {
      InteractionType,
      ChannelType,
      MessageType,
      MessageFlags,
      PermissionFlagsBits
    } = require_v106();
    var Attachment = require_Attachment();
    var Base = require_Base();
    var ClientApplication = require_ClientApplication();
    var Embed = require_Embed();
    var InteractionCollector = require_InteractionCollector();
    var Mentions = require_MessageMentions();
    var MessagePayload = require_MessagePayload();
    var ReactionCollector = require_ReactionCollector();
    var { Sticker: Sticker2 } = require_Sticker();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ReactionManager = require_ReactionManager();
    var { createComponent } = require_Components();
    var { NonSystemMessageTypes, MaxBulkDeletableMessageAge, DeletableMessageTypes } = require_Constants();
    var MessageFlagsBitField = require_MessageFlagsBitField();
    var PermissionsBitField2 = require_PermissionsBitField();
    var { cleanContent, resolvePartialEmoji } = require_Util();
    var Message = class extends Base {
      constructor(client, data) {
        super(client);
        this.channelId = data.channel_id;
        this.guildId = data.guild_id ?? this.channel?.guild?.id ?? null;
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        this.createdTimestamp = DiscordSnowflake.timestampFrom(this.id);
        if ("type" in data) {
          this.type = data.type;
          this.system = !NonSystemMessageTypes.includes(this.type);
        } else {
          this.system ??= null;
          this.type ??= null;
        }
        if ("content" in data) {
          this.content = data.content;
        } else {
          this.content ??= null;
        }
        if ("author" in data) {
          this.author = this.client.users._add(data.author, !data.webhook_id);
        } else {
          this.author ??= null;
        }
        if ("pinned" in data) {
          this.pinned = Boolean(data.pinned);
        } else {
          this.pinned ??= null;
        }
        if ("tts" in data) {
          this.tts = data.tts;
        } else {
          this.tts ??= null;
        }
        if ("nonce" in data) {
          this.nonce = data.nonce;
        } else {
          this.nonce ??= null;
        }
        if ("embeds" in data) {
          this.embeds = data.embeds.map((e) => new Embed(e));
        } else {
          this.embeds = this.embeds?.slice() ?? [];
        }
        if ("components" in data) {
          this.components = data.components.map((c) => createComponent(c));
        } else {
          this.components = this.components?.slice() ?? [];
        }
        if ("attachments" in data) {
          this.attachments = new Collection2();
          if (data.attachments) {
            for (const attachment of data.attachments) {
              this.attachments.set(attachment.id, new Attachment(attachment));
            }
          }
        } else {
          this.attachments = new Collection2(this.attachments);
        }
        if ("sticker_items" in data || "stickers" in data) {
          this.stickers = new Collection2(
            (data.sticker_items ?? data.stickers)?.map((s) => [s.id, new Sticker2(this.client, s)])
          );
        } else {
          this.stickers = new Collection2(this.stickers);
        }
        if ("position" in data) {
          this.position = data.position;
        } else {
          this.position ??= null;
        }
        if ("role_subscription_data" in data) {
          this.roleSubscriptionData = {
            roleSubscriptionListingId: data.role_subscription_data.role_subscription_listing_id,
            tierName: data.role_subscription_data.tier_name,
            totalMonthsSubscribed: data.role_subscription_data.total_months_subscribed,
            isRenewal: data.role_subscription_data.is_renewal
          };
        } else {
          this.roleSubscriptionData ??= null;
        }
        if (data.edited_timestamp) {
          this.editedTimestamp = Date.parse(data.edited_timestamp);
        } else {
          this.editedTimestamp ??= null;
        }
        if ("reactions" in data) {
          this.reactions = new ReactionManager(this);
          if (data.reactions?.length > 0) {
            for (const reaction of data.reactions) {
              this.reactions._add(reaction);
            }
          }
        } else {
          this.reactions ??= new ReactionManager(this);
        }
        if (!this.mentions) {
          this.mentions = new Mentions(
            this,
            data.mentions,
            data.mention_roles,
            data.mention_everyone,
            data.mention_channels,
            data.referenced_message?.author
          );
        } else {
          this.mentions = new Mentions(
            this,
            data.mentions ?? this.mentions.users,
            data.mention_roles ?? this.mentions.roles,
            data.mention_everyone ?? this.mentions.everyone,
            data.mention_channels ?? this.mentions.crosspostedChannels,
            data.referenced_message?.author ?? this.mentions.repliedUser
          );
        }
        if ("webhook_id" in data) {
          this.webhookId = data.webhook_id;
        } else {
          this.webhookId ??= null;
        }
        if ("application" in data) {
          this.groupActivityApplication = new ClientApplication(this.client, data.application);
        } else {
          this.groupActivityApplication ??= null;
        }
        if ("application_id" in data) {
          this.applicationId = data.application_id;
        } else {
          this.applicationId ??= null;
        }
        if ("activity" in data) {
          this.activity = {
            partyId: data.activity.party_id,
            type: data.activity.type
          };
        } else {
          this.activity ??= null;
        }
        if ("thread" in data) {
          this.client.channels._add(data.thread, this.guild);
        }
        if (this.member && data.member) {
          this.member._patch(data.member);
        } else if (data.member && this.guild && this.author) {
          this.guild.members._add(Object.assign(data.member, { user: this.author }));
        }
        if ("flags" in data) {
          this.flags = new MessageFlagsBitField(data.flags).freeze();
        } else {
          this.flags = new MessageFlagsBitField(this.flags).freeze();
        }
        if ("message_reference" in data) {
          this.reference = {
            channelId: data.message_reference.channel_id,
            guildId: data.message_reference.guild_id,
            messageId: data.message_reference.message_id
          };
        } else {
          this.reference ??= null;
        }
        if (data.referenced_message) {
          this.channel?.messages._add({ guild_id: data.message_reference?.guild_id, ...data.referenced_message });
        }
        if (data.interaction) {
          this.interaction = {
            id: data.interaction.id,
            type: data.interaction.type,
            commandName: data.interaction.name,
            user: this.client.users._add(data.interaction.user)
          };
        } else {
          this.interaction ??= null;
        }
      }
      /**
       * The channel that the message was sent in
       * @type {TextBasedChannels}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * Whether or not this message is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return typeof this.content !== "string" || !this.author;
      }
      /**
       * Represents the author of the message as a guild member.
       * Only available if the message comes from a guild where the author is still a member
       * @type {?GuildMember}
       * @readonly
       */
      get member() {
        return this.guild?.members.resolve(this.author) ?? null;
      }
      /**
       * The time the message was sent at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The time the message was last edited at (if applicable)
       * @type {?Date}
       * @readonly
       */
      get editedAt() {
        return this.editedTimestamp && new Date(this.editedTimestamp);
      }
      /**
       * The guild the message was sent in (if in a guild channel)
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId) ?? this.channel?.guild ?? null;
      }
      /**
       * Whether this message has a thread associated with it
       * @type {boolean}
       * @readonly
       */
      get hasThread() {
        return this.flags.has(MessageFlags.HasThread);
      }
      /**
       * The thread started by this message
       * <info>This property is not suitable for checking whether a message has a thread,
       * use {@link Message#hasThread} instead.</info>
       * @type {?ThreadChannel}
       * @readonly
       */
      get thread() {
        return this.channel?.threads?.resolve(this.id) ?? null;
      }
      /**
       * The URL to jump to this message
       * @type {string}
       * @readonly
       */
      get url() {
        return this.inGuild() ? messageLink(this.channelId, this.id, this.guildId) : messageLink(this.channelId, this.id);
      }
      /**
       * The message contents with all mentions replaced by the equivalent text.
       * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.
       * @type {?string}
       * @readonly
       */
      get cleanContent() {
        return this.content != null ? cleanContent(this.content, this.channel) : null;
      }
      /**
       * Creates a reaction collector.
       * @param {ReactionCollectorOptions} [options={}] Options to send to the collector
       * @returns {ReactionCollector}
       * @example
       * // Create a reaction collector
       * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someId';
       * const collector = message.createReactionCollector({ filter, time: 15_000 });
       * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));
       * collector.on('end', collected => console.log(`Collected ${collected.size} items`));
       */
      createReactionCollector(options = {}) {
        return new ReactionCollector(this, options);
      }
      /**
       * An object containing the same properties as CollectorOptions, but a few more:
       * @typedef {ReactionCollectorOptions} AwaitReactionsOptions
       * @property {string[]} [errors] Stop/end reasons that cause the promise to reject
       */
      /**
       * Similar to createReactionCollector but in promise form.
       * Resolves with a collection of reactions that pass the specified filter.
       * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector
       * @returns {Promise<Collection<string | Snowflake, MessageReaction>>}
       * @example
       * // Create a reaction collector
       * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someId'
       * message.awaitReactions({ filter, time: 15_000 })
       *   .then(collected => console.log(`Collected ${collected.size} reactions`))
       *   .catch(console.error);
       */
      awaitReactions(options = {}) {
        return new Promise((resolve, reject) => {
          const collector = this.createReactionCollector(options);
          collector.once("end", (reactions, reason) => {
            if (options.errors?.includes(reason))
              reject(reactions);
            else
              resolve(reactions);
          });
        });
      }
      /**
       * @typedef {CollectorOptions} MessageComponentCollectorOptions
       * @property {ComponentType} [componentType] The type of component to listen for
       * @property {number} [max] The maximum total amount of interactions to collect
       * @property {number} [maxComponents] The maximum number of components to collect
       * @property {number} [maxUsers] The maximum number of users to interact
       */
      /**
       * Creates a message component interaction collector.
       * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector
       * @returns {InteractionCollector}
       * @example
       * // Create a message component interaction collector
       * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';
       * const collector = message.createMessageComponentCollector({ filter, time: 15_000 });
       * collector.on('collect', i => console.log(`Collected ${i.customId}`));
       * collector.on('end', collected => console.log(`Collected ${collected.size} items`));
       */
      createMessageComponentCollector(options = {}) {
        return new InteractionCollector(this.client, {
          ...options,
          interactionType: InteractionType.MessageComponent,
          message: this
        });
      }
      /**
       * An object containing the same properties as CollectorOptions, but a few more:
       * @typedef {Object} AwaitMessageComponentOptions
       * @property {CollectorFilter} [filter] The filter applied to this collector
       * @property {number} [time] Time to wait for an interaction before rejecting
       * @property {ComponentType} [componentType] The type of component interaction to collect
       * @property {number} [idle] Time to wait without another message component interaction before ending the collector
       * @property {boolean} [dispose] Whether to remove the message component interaction after collecting
       * @property {InteractionResponse} [interactionResponse] The interaction response to collect interactions from
       */
      /**
       * Collects a single component interaction that passes the filter.
       * The Promise will reject if the time expires.
       * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector
       * @returns {Promise<MessageComponentInteraction>}
       * @example
       * // Collect a message component interaction
       * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';
       * message.awaitMessageComponent({ filter, time: 15_000 })
       *   .then(interaction => console.log(`${interaction.customId} was clicked!`))
       *   .catch(console.error);
       */
      awaitMessageComponent(options = {}) {
        const _options = { ...options, max: 1 };
        return new Promise((resolve, reject) => {
          const collector = this.createMessageComponentCollector(_options);
          collector.once("end", (interactions, reason) => {
            const interaction = interactions.first();
            if (interaction)
              resolve(interaction);
            else
              reject(new DiscordjsError2(ErrorCodes2.InteractionCollectorError, reason));
          });
        });
      }
      /**
       * Whether the message is editable by the client user
       * @type {boolean}
       * @readonly
       */
      get editable() {
        const precheck = Boolean(this.author.id === this.client.user.id && (!this.guild || this.channel?.viewable));
        if (this.channel?.isThread()) {
          if (this.channel.archived)
            return false;
          if (this.channel.locked) {
            const permissions = this.permissionsFor(this.client.user);
            if (!permissions?.has(PermissionFlagsBits.ManageThreads, true))
              return false;
          }
        }
        return precheck;
      }
      /**
       * Whether the message is deletable by the client user
       * @type {boolean}
       * @readonly
       */
      get deletable() {
        if (!DeletableMessageTypes.includes(this.type))
          return false;
        if (!this.guild) {
          return this.author.id === this.client.user.id;
        }
        if (!this.channel?.viewable) {
          return false;
        }
        const permissions = this.channel?.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        if (permissions.has(PermissionFlagsBits.Administrator, false))
          return true;
        return this.type !== MessageType.AutoModerationAction && this.author.id === this.client.user.id || permissions.has(PermissionFlagsBits.ManageMessages, false) && !this.guild.members.me.isCommunicationDisabled();
      }
      /**
       * Whether the message is bulk deletable by the client user
       * @type {boolean}
       * @readonly
       * @example
       * // Filter for bulk deletable messages
       * channel.bulkDelete(messages.filter(message => message.bulkDeletable));
       */
      get bulkDeletable() {
        return (this.inGuild() && Date.now() - this.createdTimestamp < MaxBulkDeletableMessageAge && this.deletable && this.channel?.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageMessages, false)) ?? false;
      }
      /**
       * Whether the message is pinnable by the client user
       * @type {boolean}
       * @readonly
       */
      get pinnable() {
        const { channel } = this;
        return Boolean(
          !this.system && (!this.guild || channel?.viewable && channel?.permissionsFor(this.client.user)?.has(PermissionFlagsBits.ManageMessages, false))
        );
      }
      /**
       * Fetches the Message this crosspost/reply/pin-add references, if available to the client
       * @returns {Promise<Message>}
       */
      async fetchReference() {
        if (!this.reference)
          throw new DiscordjsError2(ErrorCodes2.MessageReferenceMissing);
        const { channelId, messageId } = this.reference;
        const channel = this.client.channels.resolve(channelId);
        if (!channel)
          throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        const message = await channel.messages.fetch(messageId);
        return message;
      }
      /**
       * Whether the message is crosspostable by the client user
       * @type {boolean}
       * @readonly
       */
      get crosspostable() {
        const bitfield = PermissionFlagsBits.SendMessages | (this.author.id === this.client.user.id ? PermissionsBitField2.DefaultBit : PermissionFlagsBits.ManageMessages);
        const { channel } = this;
        return Boolean(
          channel?.type === ChannelType.GuildAnnouncement && !this.flags.has(MessageFlags.Crossposted) && this.type === MessageType.Default && channel.viewable && channel.permissionsFor(this.client.user)?.has(bitfield, false)
        );
      }
      /**
       * Edits the content of the message.
       * @param {string|MessagePayload|MessageEditOptions} options The options to provide
       * @returns {Promise<Message>}
       * @example
       * // Update the content of a message
       * message.edit('This is my new content!')
       *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))
       *   .catch(console.error);
       */
      edit(options) {
        if (!this.channel)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ChannelNotCached));
        return this.channel.messages.edit(this, options);
      }
      /**
       * Publishes a message in an announcement channel to all channels following it.
       * @returns {Promise<Message>}
       * @example
       * // Crosspost a message
       * if (message.channel.type === ChannelType.GuildAnnouncement) {
       *   message.crosspost()
       *     .then(() => console.log('Crossposted message'))
       *     .catch(console.error);
       * }
       */
      crosspost() {
        if (!this.channel)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ChannelNotCached));
        return this.channel.messages.crosspost(this.id);
      }
      /**
       * Pins this message to the channel's pinned messages.
       * @param {string} [reason] Reason for pinning
       * @returns {Promise<Message>}
       * @example
       * // Pin a message
       * message.pin()
       *   .then(console.log)
       *   .catch(console.error)
       */
      async pin(reason) {
        if (!this.channel)
          throw new DiscordjsError2(ErrorCodes2.ChannelNotCached);
        await this.channel.messages.pin(this.id, reason);
        return this;
      }
      /**
       * Unpins this message from the channel's pinned messages.
       * @param {string} [reason] Reason for unpinning
       * @returns {Promise<Message>}
       * @example
       * // Unpin a message
       * message.unpin()
       *   .then(console.log)
       *   .catch(console.error)
       */
      async unpin(reason) {
        if (!this.channel)
          throw new DiscordjsError2(ErrorCodes2.ChannelNotCached);
        await this.channel.messages.unpin(this.id, reason);
        return this;
      }
      /**
       * Adds a reaction to the message.
       * @param {EmojiIdentifierResolvable} emoji The emoji to react with
       * @returns {Promise<MessageReaction>}
       * @example
       * // React to a message with a unicode emoji
       * message.react('🤔')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // React to a message with a custom emoji
       * message.react(message.guild.emojis.cache.get('123456789012345678'))
       *   .then(console.log)
       *   .catch(console.error);
       */
      async react(emoji) {
        if (!this.channel)
          throw new DiscordjsError2(ErrorCodes2.ChannelNotCached);
        await this.channel.messages.react(this.id, emoji);
        return this.client.actions.MessageReactionAdd.handle(
          {
            [this.client.actions.injectedUser]: this.client.user,
            [this.client.actions.injectedChannel]: this.channel,
            [this.client.actions.injectedMessage]: this,
            emoji: resolvePartialEmoji(emoji)
          },
          true
        ).reaction;
      }
      /**
       * Deletes the message.
       * @returns {Promise<Message>}
       * @example
       * // Delete a message
       * message.delete()
       *   .then(msg => console.log(`Deleted message from ${msg.author.username}`))
       *   .catch(console.error);
       */
      async delete() {
        if (!this.channel)
          throw new DiscordjsError2(ErrorCodes2.ChannelNotCached);
        await this.channel.messages.delete(this.id);
        return this;
      }
      /**
       * Options provided when sending a message as an inline reply.
       * @typedef {BaseMessageCreateOptions} MessageReplyOptions
       * @property {boolean} [failIfNotExists=this.client.options.failIfNotExists] Whether to error if the referenced
       * message does not exist (creates a standard message in this case when false)
       * @property {StickerResolvable[]} [stickers=[]] Stickers to send in the message
       */
      /**
       * Send an inline reply to this message.
       * @param {string|MessagePayload|MessageReplyOptions} options The options to provide
       * @returns {Promise<Message>}
       * @example
       * // Reply to a message
       * message.reply('This is a reply!')
       *   .then(() => console.log(`Replied to message "${message.content}"`))
       *   .catch(console.error);
       */
      reply(options) {
        if (!this.channel)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ChannelNotCached));
        let data;
        if (options instanceof MessagePayload) {
          data = options;
        } else {
          data = MessagePayload.create(this, options, {
            reply: {
              messageReference: this,
              failIfNotExists: options?.failIfNotExists ?? this.client.options.failIfNotExists
            }
          });
        }
        return this.channel.send(data);
      }
      /**
       * Options for starting a thread on a message.
       * @typedef {Object} StartThreadOptions
       * @property {string} name The name of the new thread
       * @property {ThreadAutoArchiveDuration} [autoArchiveDuration=this.channel.defaultAutoArchiveDuration] The amount of
       * time after which the thread should automatically archive in case of no recent activity
       * @property {string} [reason] Reason for creating the thread
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds
       */
      /**
       * Create a new public thread from this message
       * @see GuildTextThreadManager#create
       * @param {StartThreadOptions} [options] Options for starting a thread on this message
       * @returns {Promise<ThreadChannel>}
       */
      startThread(options = {}) {
        if (!this.channel)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ChannelNotCached));
        if (![ChannelType.GuildText, ChannelType.GuildAnnouncement].includes(this.channel.type)) {
          return Promise.reject(new DiscordjsError2(ErrorCodes2.MessageThreadParent));
        }
        if (this.hasThread)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.MessageExistingThread));
        return this.channel.threads.create({ ...options, startMessage: this });
      }
      /**
       * Fetch this message.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<Message>}
       */
      fetch(force = true) {
        if (!this.channel)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ChannelNotCached));
        return this.channel.messages.fetch({ message: this.id, force });
      }
      /**
       * Fetches the webhook used to create this message.
       * @returns {Promise<?Webhook>}
       */
      fetchWebhook() {
        if (!this.webhookId)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.WebhookMessage));
        if (this.webhookId === this.applicationId)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.WebhookApplication));
        return this.client.fetchWebhook(this.webhookId);
      }
      /**
       * Suppresses or unsuppresses embeds on a message.
       * @param {boolean} [suppress=true] If the embeds should be suppressed or not
       * @returns {Promise<Message>}
       */
      suppressEmbeds(suppress = true) {
        const flags = new MessageFlagsBitField(this.flags.bitfield);
        if (suppress) {
          flags.add(MessageFlags.SuppressEmbeds);
        } else {
          flags.remove(MessageFlags.SuppressEmbeds);
        }
        return this.edit({ flags });
      }
      /**
       * Removes the attachments from this message.
       * @returns {Promise<Message>}
       */
      removeAttachments() {
        return this.edit({ attachments: [] });
      }
      /**
       * Resolves a component by a custom id.
       * @param {string} customId The custom id to resolve against
       * @returns {?MessageActionRowComponent}
       */
      resolveComponent(customId) {
        return this.components.flatMap((row) => row.components).find((component) => component.customId === customId) ?? null;
      }
      /**
       * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages
       * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This
       * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.
       * @param {Message} message The message to compare it to
       * @param {APIMessage} rawData Raw data passed through the WebSocket about this message
       * @returns {boolean}
       */
      equals(message, rawData) {
        if (!message)
          return false;
        const embedUpdate = !message.author && !message.attachments;
        if (embedUpdate)
          return this.id === message.id && this.embeds.length === message.embeds.length;
        let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.length === message.attachments.length;
        if (equal && rawData) {
          equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === Date.parse(rawData.timestamp) && this.editedTimestamp === Date.parse(rawData.edited_timestamp);
        }
        return equal;
      }
      /**
       * Whether this message is from a guild.
       * @returns {boolean}
       */
      inGuild() {
        return Boolean(this.guildId);
      }
      /**
       * When concatenated with a string, this automatically concatenates the message's content instead of the object.
       * @returns {string}
       * @example
       * // Logs: Message: This is a message!
       * console.log(`Message: ${message}`);
       */
      toString() {
        return this.content;
      }
      toJSON() {
        return super.toJSON({
          channel: "channelId",
          author: "authorId",
          groupActivityApplication: "groupActivityApplicationId",
          guild: "guildId",
          cleanContent: true,
          member: false,
          reactions: false
        });
      }
    };
    exports2.Message = Message;
  }
});

// node_modules/discord.js/src/structures/Webhook.js
var require_Webhook = __commonJS({
  "node_modules/discord.js/src/structures/Webhook.js"(exports2, module2) {
    "use strict";
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { lazy } = require_dist2();
    var { DiscordSnowflake } = require_dist3();
    var { Routes: Routes2, WebhookType } = require_v106();
    var MessagePayload = require_MessagePayload();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var DataResolver2 = require_DataResolver();
    var getMessage = lazy(() => require_Message().Message);
    var Webhook2 = class {
      constructor(client, data) {
        Object.defineProperty(this, "client", { value: client });
        if (data)
          this._patch(data);
      }
      _patch(data) {
        if ("name" in data) {
          this.name = data.name;
        }
        Object.defineProperty(this, "token", {
          value: data.token ?? null,
          writable: true,
          configurable: true
        });
        if ("avatar" in data) {
          this.avatar = data.avatar;
        }
        this.id = data.id;
        if ("type" in data) {
          this.type = data.type;
        }
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        }
        if ("user" in data) {
          this.owner = this.client.users?._add(data.user) ?? data.user;
        } else {
          this.owner ??= null;
        }
        if ("application_id" in data) {
          this.applicationId = data.application_id;
        } else {
          this.applicationId ??= null;
        }
        if ("source_guild" in data) {
          this.sourceGuild = this.client.guilds?.resolve(data.source_guild.id) ?? data.source_guild;
        } else {
          this.sourceGuild ??= null;
        }
        if ("source_channel" in data) {
          this.sourceChannel = this.client.channels?.resolve(data.source_channel?.id) ?? data.source_channel;
        } else {
          this.sourceChannel ??= null;
        }
      }
      /**
       * Options that can be passed into send.
       * @typedef {BaseMessageOptions} WebhookMessageCreateOptions
       * @property {boolean} [tts=false] Whether the message should be spoken aloud
       * @property {MessageFlags} [flags] Which flags to set for the message.
       * <info>Only the {@link MessageFlags.SuppressEmbeds} flag can be set.</info>
       * @property {string} [username=this.name] Username override for the message
       * @property {string} [avatarURL] Avatar URL override for the message
       * @property {Snowflake} [threadId] The id of the thread in the channel to send to.
       * <info>For interaction webhooks, this property is ignored</info>
       * @property {string} [threadName] Name of the thread to create (only available if webhook is in a forum channel)
       */
      /**
       * Options that can be passed into editMessage.
       * @typedef {BaseMessageOptions} WebhookMessageEditOptions
       * @property {Attachment[]} [attachments] Attachments to send with the message
       * @property {Snowflake} [threadId] The id of the thread this message belongs to
       * <info>For interaction webhooks, this property is ignored</info>
       */
      /**
       * The channel the webhook belongs to
       * @type {?(TextChannel|VoiceChannel|StageChannel|NewsChannel|ForumChannel)}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * Sends a message with this webhook.
       * @param {string|MessagePayload|WebhookMessageCreateOptions} options The options to provide
       * @returns {Promise<Message>}
       * @example
       * // Send a basic message
       * webhook.send('hello!')
       *   .then(message => console.log(`Sent message: ${message.content}`))
       *   .catch(console.error);
       * @example
       * // Send a basic message in a thread
       * webhook.send({ content: 'hello!', threadId: '836856309672348295' })
       *   .then(message => console.log(`Sent message: ${message.content}`))
       *   .catch(console.error);
       * @example
       * // Send a remote file
       * webhook.send({
       *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']
       * })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Send a local file
       * webhook.send({
       *   files: [{
       *     attachment: 'entire/path/to/file.jpg',
       *     name: 'file.jpg'
       *   }]
       * })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Send an embed with a local image inside
       * webhook.send({
       *   content: 'This is an embed',
       *   embeds: [{
       *     thumbnail: {
       *          url: 'attachment://file.jpg'
       *       }
       *    }],
       *    files: [{
       *       attachment: 'entire/path/to/file.jpg',
       *       name: 'file.jpg'
       *    }]
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async send(options) {
        if (!this.token)
          throw new DiscordjsError2(ErrorCodes2.WebhookTokenUnavailable);
        let messagePayload;
        if (options instanceof MessagePayload) {
          messagePayload = options.resolveBody();
        } else {
          messagePayload = MessagePayload.create(this, options).resolveBody();
        }
        const query = makeURLSearchParams2({
          wait: true,
          thread_id: messagePayload.options.threadId
        });
        const { body, files } = await messagePayload.resolveFiles();
        const d = await this.client.rest.post(Routes2.webhook(this.id, this.token), {
          body,
          files,
          query,
          auth: false
        });
        if (!this.client.channels)
          return d;
        return this.client.channels.cache.get(d.channel_id)?.messages._add(d, false) ?? new (getMessage())(this.client, d);
      }
      /**
       * Sends a raw slack message with this webhook.
       * @param {Object} body The raw body to send
       * @returns {Promise<boolean>}
       * @example
       * // Send a slack message
       * webhook.sendSlackMessage({
       *   'username': 'Wumpus',
       *   'attachments': [{
       *     'pretext': 'this looks pretty cool',
       *     'color': '#F0F',
       *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',
       *     'footer': 'Powered by sneks',
       *     'ts': Date.now() / 1_000
       *   }]
       * }).catch(console.error);
       * @see {@link https://api.slack.com/messaging/webhooks}
       */
      async sendSlackMessage(body) {
        if (!this.token)
          throw new DiscordjsError2(ErrorCodes2.WebhookTokenUnavailable);
        const data = await this.client.rest.post(Routes2.webhookPlatform(this.id, this.token, "slack"), {
          query: makeURLSearchParams2({ wait: true }),
          auth: false,
          body
        });
        return data.toString() === "ok";
      }
      /**
       * Options used to edit a {@link Webhook}.
       * @typedef {Object} WebhookEditOptions
       * @property {string} [name=this.name] The new name for the webhook
       * @property {?(BufferResolvable)} [avatar] The new avatar for the webhook
       * @property {GuildTextChannelResolvable} [channel] The new channel for the webhook
       * @property {string} [reason] Reason for editing the webhook
       */
      /**
       * Edits this webhook.
       * @param {WebhookEditOptions} options Options for editing the webhook
       * @returns {Promise<Webhook>}
       */
      async edit({ name = this.name, avatar, channel, reason }) {
        if (avatar && !(typeof avatar === "string" && avatar.startsWith("data:"))) {
          avatar = await DataResolver2.resolveImage(avatar);
        }
        channel &&= channel.id ?? channel;
        const data = await this.client.rest.patch(Routes2.webhook(this.id, channel ? void 0 : this.token), {
          body: { name, avatar, channel_id: channel },
          reason,
          auth: !this.token || Boolean(channel)
        });
        this.name = data.name;
        this.avatar = data.avatar;
        this.channelId = data.channel_id;
        return this;
      }
      /**
       * Options that can be passed into fetchMessage.
       * @typedef {options} WebhookFetchMessageOptions
       * @property {boolean} [cache=true] Whether to cache the message.
       * @property {Snowflake} [threadId] The id of the thread this message belongs to.
       * <info>For interaction webhooks, this property is ignored</info>
       */
      /**
       * Gets a message that was sent by this webhook.
       * @param {Snowflake|'@original'} message The id of the message to fetch
       * @param {WebhookFetchMessageOptions} [options={}] The options to provide to fetch the message.
       * @returns {Promise<Message>} Returns the message sent by this webhook
       */
      async fetchMessage(message, { threadId } = {}) {
        if (!this.token)
          throw new DiscordjsError2(ErrorCodes2.WebhookTokenUnavailable);
        const data = await this.client.rest.get(Routes2.webhookMessage(this.id, this.token, message), {
          query: threadId ? makeURLSearchParams2({ thread_id: threadId }) : void 0,
          auth: false
        });
        if (!this.client.channels)
          return data;
        return this.client.channels.cache.get(data.channel_id)?.messages._add(data, false) ?? new (getMessage())(this.client, data);
      }
      /**
       * Edits a message that was sent by this webhook.
       * @param {MessageResolvable|'@original'} message The message to edit
       * @param {string|MessagePayload|WebhookMessageEditOptions} options The options to provide
       * @returns {Promise<Message>} Returns the message edited by this webhook
       */
      async editMessage(message, options) {
        if (!this.token)
          throw new DiscordjsError2(ErrorCodes2.WebhookTokenUnavailable);
        let messagePayload;
        if (options instanceof MessagePayload)
          messagePayload = options;
        else
          messagePayload = MessagePayload.create(this, options);
        const { body, files } = await messagePayload.resolveBody().resolveFiles();
        const d = await this.client.rest.patch(
          Routes2.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id),
          {
            body,
            files,
            query: messagePayload.options.threadId ? makeURLSearchParams2({ thread_id: messagePayload.options.threadId }) : void 0,
            auth: false
          }
        );
        const channelManager = this.client.channels;
        if (!channelManager)
          return d;
        const messageManager = channelManager.cache.get(d.channel_id)?.messages;
        if (!messageManager)
          return new (getMessage())(this.client, d);
        const existing = messageManager.cache.get(d.id);
        if (!existing)
          return messageManager._add(d);
        const clone = existing._clone();
        clone._patch(d);
        return clone;
      }
      /**
       * Deletes the webhook.
       * @param {string} [reason] Reason for deleting this webhook
       * @returns {Promise<void>}
       */
      async delete(reason) {
        await this.client.rest.delete(Routes2.webhook(this.id, this.token), {
          reason,
          auth: !this.token
        });
      }
      /**
       * Delete a message that was sent by this webhook.
       * @param {MessageResolvable|'@original'} message The message to delete
       * @param {Snowflake} [threadId] The id of the thread this message belongs to
       * @returns {Promise<void>}
       */
      async deleteMessage(message, threadId) {
        if (!this.token)
          throw new DiscordjsError2(ErrorCodes2.WebhookTokenUnavailable);
        await this.client.rest.delete(
          Routes2.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id),
          {
            query: threadId ? makeURLSearchParams2({ thread_id: threadId }) : void 0,
            auth: false
          }
        );
      }
      /**
       * The timestamp the webhook was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the webhook was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The URL of this webhook
       * @type {string}
       * @readonly
       */
      get url() {
        return this.client.options.rest.api + Routes2.webhook(this.id, this.token);
      }
      /**
       * A link to the webhook's avatar.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      avatarURL(options = {}) {
        return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
      }
      /**
       * Whether this webhook is created by a user.
       * @returns {boolean}
       */
      isUserCreated() {
        return Boolean(this.type === WebhookType.Incoming && this.owner && !this.owner.bot);
      }
      /**
       * Whether this webhook is created by an application.
       * @returns {boolean}
       */
      isApplicationCreated() {
        return this.type === WebhookType.Application;
      }
      /**
       * Whether or not this webhook is a channel follower webhook.
       * @returns {boolean}
       */
      isChannelFollower() {
        return this.type === WebhookType.ChannelFollower;
      }
      /**
       * Whether or not this webhook is an incoming webhook.
       * @returns {boolean}
       */
      isIncoming() {
        return this.type === WebhookType.Incoming;
      }
      static applyToClass(structure, ignore = []) {
        for (const prop of [
          "send",
          "sendSlackMessage",
          "fetchMessage",
          "edit",
          "editMessage",
          "delete",
          "deleteMessage",
          "createdTimestamp",
          "createdAt",
          "url"
        ]) {
          if (ignore.includes(prop))
            continue;
          Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook2.prototype, prop));
        }
      }
    };
    module2.exports = Webhook2;
  }
});

// node_modules/discord.js/src/client/WebhookClient.js
var require_WebhookClient = __commonJS({
  "node_modules/discord.js/src/client/WebhookClient.js"(exports2, module2) {
    "use strict";
    var BaseClient2 = require_BaseClient();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Webhook2 = require_Webhook();
    var { parseWebhookURL } = require_Util();
    var WebhookClient = class extends BaseClient2 {
      /**
       * Represents the credentials used for a webhook in the form of its id and token.
       * @typedef {Object} WebhookClientDataIdWithToken
       * @property {Snowflake} id The webhook's id
       * @property {string} token The webhook's token
       */
      /**
       * Represents the credentials used for a webhook in the form of a URL.
       * @typedef {Object} WebhookClientDataURL
       * @property {string} url The full URL for the webhook
       */
      /**
       * Represents the credentials used for a webhook.
       * @typedef {WebhookClientDataIdWithToken|WebhookClientDataURL} WebhookClientData
       */
      /**
       * Options for a webhook client.
       * @typedef {Object} WebhookClientOptions
       * @property {MessageMentionOptions} [allowedMentions] Default value for {@link BaseMessageOptions#allowedMentions}
       * @property {RESTOptions} [rest] Options for the REST manager
       */
      /**
       * @param {WebhookClientData} data The data of the webhook
       * @param {WebhookClientOptions} [options] Options for the webhook client
       */
      constructor(data, options) {
        super(options);
        Object.defineProperty(this, "client", { value: this });
        let { id, token } = data;
        if ("url" in data) {
          const parsed = parseWebhookURL(data.url);
          if (!parsed) {
            throw new DiscordjsError2(ErrorCodes2.WebhookURLInvalid);
          }
          ({ id, token } = parsed);
        }
        this.id = id;
        Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
      }
      /**
       * The options the webhook client was instantiated with.
       * @type {WebhookClientOptions}
       * @name WebhookClient#options
       */
      // These are here only for documentation purposes - they are implemented by Webhook
      /* eslint-disable no-empty-function, valid-jsdoc */
      /**
       * Sends a message with this webhook.
       * @param {string|MessagePayload|WebhookMessageCreateOptions} options The content for the reply
       * @returns {Promise<APIMessage>}
       */
      send() {
      }
      /**
       * Gets a message that was sent by this webhook.
       * @param {Snowflake} message The id of the message to fetch
       * @param {WebhookFetchMessageOptions} [options={}] The options to provide to fetch the message.
       * @returns {Promise<APIMessage>} Returns the message sent by this webhook
       */
      fetchMessage() {
      }
      /**
       * Edits a message that was sent by this webhook.
       * @param {MessageResolvable} message The message to edit
       * @param {string|MessagePayload|WebhookMessageEditOptions} options The options to provide
       * @returns {Promise<APIMessage>} Returns the message edited by this webhook
       */
      editMessage() {
      }
      sendSlackMessage() {
      }
      edit() {
      }
      delete() {
      }
      deleteMessage() {
      }
      get createdTimestamp() {
      }
      get createdAt() {
      }
      get url() {
      }
    };
    Webhook2.applyToClass(WebhookClient);
    module2.exports = WebhookClient;
  }
});

// node_modules/discord.js/src/structures/VoiceState.js
var require_VoiceState = __commonJS({
  "node_modules/discord.js/src/structures/VoiceState.js"(exports2, module2) {
    "use strict";
    var { ChannelType, Routes: Routes2 } = require_v106();
    var Base = require_Base();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var VoiceState = class extends Base {
      constructor(guild, data) {
        super(guild.client);
        this.guild = guild;
        this.id = data.user_id;
        this._patch(data);
      }
      _patch(data) {
        if ("deaf" in data) {
          this.serverDeaf = data.deaf;
        } else {
          this.serverDeaf ??= null;
        }
        if ("mute" in data) {
          this.serverMute = data.mute;
        } else {
          this.serverMute ??= null;
        }
        if ("self_deaf" in data) {
          this.selfDeaf = data.self_deaf;
        } else {
          this.selfDeaf ??= null;
        }
        if ("self_mute" in data) {
          this.selfMute = data.self_mute;
        } else {
          this.selfMute ??= null;
        }
        if ("self_video" in data) {
          this.selfVideo = data.self_video;
        } else {
          this.selfVideo ??= null;
        }
        if ("session_id" in data) {
          this.sessionId = data.session_id;
        } else {
          this.sessionId ??= null;
        }
        if ("self_video" in data) {
          this.streaming = data.self_stream ?? false;
        } else {
          this.streaming ??= null;
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        } else {
          this.channelId ??= null;
        }
        if ("suppress" in data) {
          this.suppress = data.suppress;
        } else {
          this.suppress ??= null;
        }
        if ("request_to_speak_timestamp" in data) {
          this.requestToSpeakTimestamp = data.request_to_speak_timestamp && Date.parse(data.request_to_speak_timestamp);
        } else {
          this.requestToSpeakTimestamp ??= null;
        }
        return this;
      }
      /**
       * The member that this voice state belongs to
       * @type {?GuildMember}
       * @readonly
       */
      get member() {
        return this.guild.members.cache.get(this.id) ?? null;
      }
      /**
       * The channel that the member is connected to
       * @type {?(VoiceChannel|StageChannel)}
       * @readonly
       */
      get channel() {
        return this.guild.channels.cache.get(this.channelId) ?? null;
      }
      /**
       * Whether this member is either self-deafened or server-deafened
       * @type {?boolean}
       * @readonly
       */
      get deaf() {
        return this.serverDeaf || this.selfDeaf;
      }
      /**
       * Whether this member is either self-muted or server-muted
       * @type {?boolean}
       * @readonly
       */
      get mute() {
        return this.serverMute || this.selfMute;
      }
      /**
       * Mutes/unmutes the member of this voice state.
       * @param {boolean} [mute=true] Whether or not the member should be muted
       * @param {string} [reason] Reason for muting or unmuting
       * @returns {Promise<GuildMember>}
       */
      setMute(mute = true, reason) {
        return this.guild.members.edit(this.id, { mute, reason });
      }
      /**
       * Deafens/undeafens the member of this voice state.
       * @param {boolean} [deaf=true] Whether or not the member should be deafened
       * @param {string} [reason] Reason for deafening or undeafening
       * @returns {Promise<GuildMember>}
       */
      setDeaf(deaf = true, reason) {
        return this.guild.members.edit(this.id, { deaf, reason });
      }
      /**
       * Disconnects the member from the channel.
       * @param {string} [reason] Reason for disconnecting the member from the channel
       * @returns {Promise<GuildMember>}
       */
      disconnect(reason) {
        return this.setChannel(null, reason);
      }
      /**
       * Moves the member to a different channel, or disconnects them from the one they're in.
       * @param {GuildVoiceChannelResolvable|null} channel Channel to move the member to, or `null` if you want to
       * disconnect them from voice.
       * @param {string} [reason] Reason for moving member to another channel or disconnecting
       * @returns {Promise<GuildMember>}
       */
      setChannel(channel, reason) {
        return this.guild.members.edit(this.id, { channel, reason });
      }
      /**
       * Data to edit the logged in user's own voice state with, when in a stage channel
       * @typedef {Object} VoiceStateEditOptions
       * @property {boolean} [requestToSpeak] Whether or not the client is requesting to become a speaker.
       * <info>Only available to the logged in user's own voice state.</info>
       * @property {boolean} [suppressed] Whether or not the user should be suppressed.
       */
      /**
       * Edits this voice state. Currently only available when in a stage channel
       * @param {VoiceStateEditOptions} options The options to provide
       * @returns {Promise<VoiceState>}
       */
      async edit(options) {
        if (this.channel?.type !== ChannelType.GuildStageVoice)
          throw new DiscordjsError2(ErrorCodes2.VoiceNotStageChannel);
        const target = this.client.user.id === this.id ? "@me" : this.id;
        if (target !== "@me" && options.requestToSpeak !== void 0) {
          throw new DiscordjsError2(ErrorCodes2.VoiceStateNotOwn);
        }
        if (!["boolean", "undefined"].includes(typeof options.requestToSpeak)) {
          throw new DiscordjsTypeError2(ErrorCodes2.VoiceStateInvalidType, "requestToSpeak");
        }
        if (!["boolean", "undefined"].includes(typeof options.suppressed)) {
          throw new DiscordjsTypeError2(ErrorCodes2.VoiceStateInvalidType, "suppressed");
        }
        await this.client.rest.patch(Routes2.guildVoiceState(this.guild.id, target), {
          body: {
            channel_id: this.channelId,
            request_to_speak_timestamp: options.requestToSpeak ? (/* @__PURE__ */ new Date()).toISOString() : options.requestToSpeak === false ? null : void 0,
            suppress: options.suppressed
          }
        });
        return this;
      }
      /**
       * Toggles the request to speak in the channel.
       * Only applicable for stage channels and for the client's own voice state.
       * @param {boolean} [requestToSpeak=true] Whether or not the client is requesting to become a speaker.
       * @example
       * // Making the client request to speak in a stage channel (raise its hand)
       * guild.members.me.voice.setRequestToSpeak(true);
       * @example
       * // Making the client cancel a request to speak
       * guild.members.me.voice.setRequestToSpeak(false);
       * @returns {Promise<VoiceState>}
       */
      setRequestToSpeak(requestToSpeak = true) {
        return this.edit({ requestToSpeak });
      }
      /**
       * Suppress/unsuppress the user. Only applicable for stage channels.
       * @param {boolean} [suppressed=true] Whether or not the user should be suppressed.
       * @example
       * // Making the client a speaker
       * guild.members.me.voice.setSuppressed(false);
       * @example
       * // Making the client an audience member
       * guild.members.me.voice.setSuppressed(true);
       * @example
       * // Inviting another user to speak
       * voiceState.setSuppressed(false);
       * @example
       * // Moving another user to the audience, or cancelling their invite to speak
       * voiceState.setSuppressed(true);
       * @returns {Promise<VoiceState>}
       */
      setSuppressed(suppressed = true) {
        return this.edit({ suppressed });
      }
      toJSON() {
        return super.toJSON({
          id: true,
          serverDeaf: true,
          serverMute: true,
          selfDeaf: true,
          selfMute: true,
          sessionId: true,
          channelId: "channel"
        });
      }
    };
    module2.exports = VoiceState;
  }
});

// node_modules/discord.js/src/managers/GuildMemberRoleManager.js
var require_GuildMemberRoleManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildMemberRoleManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { Routes: Routes2 } = require_v106();
    var DataManager = require_DataManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { Role } = require_Role();
    var GuildMemberRoleManager = class extends DataManager {
      constructor(member) {
        super(member.client, Role);
        this.member = member;
        this.guild = member.guild;
      }
      /**
       * The roles of this member
       * @type {Collection<Snowflake, Role>}
       * @readonly
       */
      get cache() {
        const everyone = this.guild.roles.everyone;
        return this.guild.roles.cache.filter((role) => this.member._roles.includes(role.id)).set(everyone.id, everyone);
      }
      /**
       * The role of the member used to hoist them in a separate category in the users list
       * @type {?Role}
       * @readonly
       */
      get hoist() {
        const hoistedRoles = this.cache.filter((role) => role.hoist);
        if (!hoistedRoles.size)
          return null;
        return hoistedRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
      }
      /**
       * The role of the member used to set their role icon
       * @type {?Role}
       * @readonly
       */
      get icon() {
        const iconRoles = this.cache.filter((role) => role.icon || role.unicodeEmoji);
        if (!iconRoles.size)
          return null;
        return iconRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
      }
      /**
       * The role of the member used to set their color
       * @type {?Role}
       * @readonly
       */
      get color() {
        const coloredRoles = this.cache.filter((role) => role.color);
        if (!coloredRoles.size)
          return null;
        return coloredRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
      }
      /**
       * The role of the member with the highest position
       * @type {Role}
       * @readonly
       */
      get highest() {
        return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
      }
      /**
       * The premium subscriber role of the guild, if present on the member
       * @type {?Role}
       * @readonly
       */
      get premiumSubscriberRole() {
        return this.cache.find((role) => role.tags?.premiumSubscriberRole) ?? null;
      }
      /**
       * The managed role this member created when joining the guild, if any
       * <info>Only ever available on bots</info>
       * @type {?Role}
       * @readonly
       */
      get botRole() {
        if (!this.member.user.bot)
          return null;
        return this.cache.find((role) => role.tags?.botId === this.member.user.id) ?? null;
      }
      /**
       * Adds a role (or multiple roles) to the member.
       * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add
       * @param {string} [reason] Reason for adding the role(s)
       * @returns {Promise<GuildMember>}
       */
      async add(roleOrRoles, reason) {
        if (roleOrRoles instanceof Collection2 || Array.isArray(roleOrRoles)) {
          const resolvedRoles = [];
          for (const role of roleOrRoles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "roles", role);
            }
            resolvedRoles.push(resolvedRole);
          }
          const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
          return this.set(newRoles, reason);
        } else {
          roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
          if (roleOrRoles === null) {
            throw new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "roles",
              "Role, Snowflake or Array or Collection of Roles or Snowflakes"
            );
          }
          await this.client.rest.put(Routes2.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
          const clone = this.member._clone();
          clone._roles = [...this.cache.keys(), roleOrRoles];
          return clone;
        }
      }
      /**
       * Removes a role (or multiple roles) from the member.
       * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove
       * @param {string} [reason] Reason for removing the role(s)
       * @returns {Promise<GuildMember>}
       */
      async remove(roleOrRoles, reason) {
        if (roleOrRoles instanceof Collection2 || Array.isArray(roleOrRoles)) {
          const resolvedRoles = [];
          for (const role of roleOrRoles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "roles", role);
            }
            resolvedRoles.push(resolvedRole);
          }
          const newRoles = this.cache.filter((role) => !resolvedRoles.includes(role.id));
          return this.set(newRoles, reason);
        } else {
          roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
          if (roleOrRoles === null) {
            throw new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "roles",
              "Role, Snowflake or Array or Collection of Roles or Snowflakes"
            );
          }
          await this.client.rest.delete(Routes2.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
          const clone = this.member._clone();
          const newRoles = this.cache.filter((role) => role.id !== roleOrRoles);
          clone._roles = [...newRoles.keys()];
          return clone;
        }
      }
      /**
       * Sets the roles applied to the member.
       * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role ids to apply
       * @param {string} [reason] Reason for applying the roles
       * @returns {Promise<GuildMember>}
       * @example
       * // Set the member's roles to a single role
       * guildMember.roles.set(['391156570408615936'])
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Remove all the roles from a member
       * guildMember.roles.set([])
       *   .then(member => console.log(`Member roles is now of ${member.roles.cache.size} size`))
       *   .catch(console.error);
       */
      set(roles, reason) {
        return this.member.edit({ roles, reason });
      }
      clone() {
        const clone = new this.constructor(this.member);
        clone.member._roles = [...this.cache.keys()];
        return clone;
      }
    };
    module2.exports = GuildMemberRoleManager;
  }
});

// node_modules/discord.js/src/util/GuildMemberFlagsBitField.js
var require_GuildMemberFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/GuildMemberFlagsBitField.js"(exports2) {
    "use strict";
    var { GuildMemberFlags } = require_v106();
    var BitField = require_BitField();
    var GuildMemberFlagsBitField = class extends BitField {
    };
    /**
     * Numeric guild guild member flags.
     * @type {GuildMemberFlags}
     * @memberof GuildMemberFlagsBitField
     */
    __publicField(GuildMemberFlagsBitField, "Flags", GuildMemberFlags);
    exports2.GuildMemberFlagsBitField = GuildMemberFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/GuildMember.js
var require_GuildMember = __commonJS({
  "node_modules/discord.js/src/structures/GuildMember.js"(exports2) {
    "use strict";
    var { PermissionFlagsBits } = require_v106();
    var Base = require_Base();
    var VoiceState = require_VoiceState();
    var TextBasedChannel = require_TextBasedChannel();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var GuildMemberRoleManager = require_GuildMemberRoleManager();
    var { GuildMemberFlagsBitField } = require_GuildMemberFlagsBitField();
    var PermissionsBitField2 = require_PermissionsBitField();
    var GuildMember = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this.joinedTimestamp = null;
        this.premiumSinceTimestamp = null;
        this.nickname = null;
        this.pending = null;
        this.communicationDisabledUntilTimestamp = null;
        this._roles = [];
        if (data)
          this._patch(data);
      }
      _patch(data) {
        if ("user" in data) {
          this.user = this.client.users._add(data.user, true);
        }
        if ("nick" in data)
          this.nickname = data.nick;
        if ("avatar" in data) {
          this.avatar = data.avatar;
        } else if (typeof this.avatar !== "string") {
          this.avatar = null;
        }
        if ("joined_at" in data)
          this.joinedTimestamp = Date.parse(data.joined_at);
        if ("premium_since" in data) {
          this.premiumSinceTimestamp = data.premium_since ? Date.parse(data.premium_since) : null;
        }
        if ("roles" in data)
          this._roles = data.roles;
        if ("pending" in data) {
          this.pending = data.pending;
        } else if (!this.partial) {
          this.pending ??= false;
        }
        if ("communication_disabled_until" in data) {
          this.communicationDisabledUntilTimestamp = data.communication_disabled_until && Date.parse(data.communication_disabled_until);
        }
        if ("flags" in data) {
          this.flags = new GuildMemberFlagsBitField(data.flags).freeze();
        } else {
          this.flags ??= new GuildMemberFlagsBitField().freeze();
        }
      }
      _clone() {
        const clone = super._clone();
        clone._roles = this._roles.slice();
        return clone;
      }
      /**
       * Whether this GuildMember is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return this.joinedTimestamp === null;
      }
      /**
       * A manager for the roles belonging to this member
       * @type {GuildMemberRoleManager}
       * @readonly
       */
      get roles() {
        return new GuildMemberRoleManager(this);
      }
      /**
       * The voice state of this member
       * @type {VoiceState}
       * @readonly
       */
      get voice() {
        return this.guild.voiceStates.cache.get(this.id) ?? new VoiceState(this.guild, { user_id: this.id });
      }
      /**
       * A link to the member's guild avatar.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      avatarURL(options = {}) {
        return this.avatar && this.client.rest.cdn.guildMemberAvatar(this.guild.id, this.id, this.avatar, options);
      }
      /**
       * A link to the member's guild avatar if they have one.
       * Otherwise, a link to their {@link User#displayAvatarURL} will be returned.
       * @param {ImageURLOptions} [options={}] Options for the Image URL
       * @returns {string}
       */
      displayAvatarURL(options) {
        return this.avatarURL(options) ?? this.user.displayAvatarURL(options);
      }
      /**
       * The time this member joined the guild
       * @type {?Date}
       * @readonly
       */
      get joinedAt() {
        return this.joinedTimestamp && new Date(this.joinedTimestamp);
      }
      /**
       * The time this member's timeout will be removed
       * @type {?Date}
       * @readonly
       */
      get communicationDisabledUntil() {
        return this.communicationDisabledUntilTimestamp && new Date(this.communicationDisabledUntilTimestamp);
      }
      /**
       * The last time this member started boosting the guild
       * @type {?Date}
       * @readonly
       */
      get premiumSince() {
        return this.premiumSinceTimestamp && new Date(this.premiumSinceTimestamp);
      }
      /**
       * The presence of this guild member
       * @type {?Presence}
       * @readonly
       */
      get presence() {
        return this.guild.presences.resolve(this.id);
      }
      /**
       * The displayed color of this member in base 10
       * @type {number}
       * @readonly
       */
      get displayColor() {
        return this.roles.color?.color ?? 0;
      }
      /**
       * The displayed color of this member in hexadecimal
       * @type {string}
       * @readonly
       */
      get displayHexColor() {
        return this.roles.color?.hexColor ?? "#000000";
      }
      /**
       * The member's id
       * @type {Snowflake}
       * @readonly
       */
      get id() {
        return this.user.id;
      }
      /**
       * The DM between the client's user and this member
       * @type {?DMChannel}
       * @readonly
       */
      get dmChannel() {
        return this.client.users.dmChannel(this.id);
      }
      /**
       * The nickname of this member, or their username if they don't have one
       * @type {?string}
       * @readonly
       */
      get displayName() {
        return this.nickname ?? this.user.username;
      }
      /**
       * The overall set of permissions for this member, taking only roles and owner status into account
       * @type {Readonly<PermissionsBitField>}
       * @readonly
       */
      get permissions() {
        if (this.user.id === this.guild.ownerId)
          return new PermissionsBitField2(PermissionsBitField2.All).freeze();
        return new PermissionsBitField2(this.roles.cache.map((role) => role.permissions)).freeze();
      }
      /**
       * Whether the client user is above this user in the hierarchy, according to role position and guild ownership.
       * This is a prerequisite for many moderative actions.
       * @type {boolean}
       * @readonly
       */
      get manageable() {
        if (this.user.id === this.guild.ownerId)
          return false;
        if (this.user.id === this.client.user.id)
          return false;
        if (this.client.user.id === this.guild.ownerId)
          return true;
        if (!this.guild.members.me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        return this.guild.members.me.roles.highest.comparePositionTo(this.roles.highest) > 0;
      }
      /**
       * Whether this member is kickable by the client user
       * @type {boolean}
       * @readonly
       */
      get kickable() {
        if (!this.guild.members.me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.KickMembers);
      }
      /**
       * Whether this member is bannable by the client user
       * @type {boolean}
       * @readonly
       */
      get bannable() {
        if (!this.guild.members.me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.BanMembers);
      }
      /**
       * Whether this member is moderatable by the client user
       * @type {boolean}
       * @readonly
       */
      get moderatable() {
        return !this.permissions.has(PermissionFlagsBits.Administrator) && this.manageable && (this.guild.members.me?.permissions.has(PermissionFlagsBits.ModerateMembers) ?? false);
      }
      /**
       * Whether this member is currently timed out
       * @returns {boolean}
       */
      isCommunicationDisabled() {
        return this.communicationDisabledUntilTimestamp > Date.now();
      }
      /**
       * Returns `channel.permissionsFor(guildMember)`. Returns permissions for a member in a guild channel,
       * taking into account roles and permission overwrites.
       * @param {GuildChannelResolvable} channel The guild channel to use as context
       * @returns {Readonly<PermissionsBitField>}
       */
      permissionsIn(channel) {
        channel = this.guild.channels.resolve(channel);
        if (!channel)
          throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        return channel.permissionsFor(this);
      }
      /**
       * Edits this member.
       * @param {GuildMemberEditOptions} options The options to provide
       * @returns {Promise<GuildMember>}
       */
      edit(options) {
        return this.guild.members.edit(this, options);
      }
      /**
       * Sets the flags for this member.
       * @param {GuildMemberFlagsResolvable} flags The flags to set
       * @param {string} [reason] Reason for setting the flags
       * @returns {Promise<GuildMember>}
       */
      setFlags(flags, reason) {
        return this.edit({ flags, reason });
      }
      /**
       * Sets the nickname for this member.
       * @param {?string} nick The nickname for the guild member, or `null` if you want to reset their nickname
       * @param {string} [reason] Reason for setting the nickname
       * @returns {Promise<GuildMember>}
       * @example
       * // Set a nickname for a guild member
       * guildMember.setNickname('cool nickname', 'Needed a new nickname')
       *   .then(member => console.log(`Set nickname of ${member.user.username}`))
       *   .catch(console.error);
       * @example
       * // Remove a nickname for a guild member
       * guildMember.setNickname(null, 'No nicknames allowed!')
       *   .then(member => console.log(`Removed nickname for ${member.user.username}`))
       *   .catch(console.error);
       */
      setNickname(nick, reason) {
        return this.edit({ nick, reason });
      }
      /**
       * Creates a DM channel between the client and this member.
       * @param {boolean} [force=false] Whether to skip the cache check and request the API
       * @returns {Promise<DMChannel>}
       */
      createDM(force = false) {
        return this.user.createDM(force);
      }
      /**
       * Deletes any DMs with this member.
       * @returns {Promise<DMChannel>}
       */
      deleteDM() {
        return this.user.deleteDM();
      }
      /**
       * Kicks this member from the guild.
       * @param {string} [reason] Reason for kicking user
       * @returns {Promise<GuildMember>}
       */
      kick(reason) {
        return this.guild.members.kick(this, reason);
      }
      /**
       * Bans this guild member.
       * @param {BanOptions} [options] Options for the ban
       * @returns {Promise<GuildMember>}
       * @example
       * // Ban a guild member, deleting a week's worth of messages
       * guildMember.ban({ deleteMessageSeconds: 60 * 60 * 24 * 7, reason: 'They deserved it' })
       *   .then(console.log)
       *   .catch(console.error);
       */
      ban(options) {
        return this.guild.bans.create(this, options);
      }
      /**
       * Times this guild member out.
       * @param {DateResolvable|null} communicationDisabledUntil The date or timestamp
       * for the member's communication to be disabled until. Provide `null` to remove the timeout.
       * @param {string} [reason] The reason for this timeout.
       * @returns {Promise<GuildMember>}
       * @example
       * // Time a guild member out for 5 minutes
       * guildMember.disableCommunicationUntil(Date.now() + (5 * 60 * 1000), 'They deserved it')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Remove the timeout of a guild member
       * guildMember.disableCommunicationUntil(null)
       *   .then(member => console.log(`Removed timeout for ${member.displayName}`))
       *   .catch(console.error);
       */
      disableCommunicationUntil(communicationDisabledUntil, reason) {
        return this.edit({ communicationDisabledUntil, reason });
      }
      /**
       * Times this guild member out.
       * @param {number|null} timeout The time in milliseconds
       * for the member's communication to be disabled until. Provide `null` to remove the timeout.
       * @param {string} [reason] The reason for this timeout.
       * @returns {Promise<GuildMember>}
       * @example
       * // Time a guild member out for 5 minutes
       * guildMember.timeout(5 * 60 * 1000, 'They deserved it')
       *   .then(console.log)
       *   .catch(console.error);
       */
      timeout(timeout, reason) {
        return this.disableCommunicationUntil(timeout && Date.now() + timeout, reason);
      }
      /**
       * Fetches this GuildMember.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<GuildMember>}
       */
      fetch(force = true) {
        return this.guild.members.fetch({ user: this.id, cache: true, force });
      }
      /**
       * Whether this guild member equals another guild member. It compares all properties, so for most
       * comparison it is advisable to just compare `member.id === member2.id` as it is significantly faster
       * and is often what most users need.
       * @param {GuildMember} member The member to compare with
       * @returns {boolean}
       */
      equals(member) {
        return member instanceof this.constructor && this.id === member.id && this.partial === member.partial && this.guild.id === member.guild.id && this.joinedTimestamp === member.joinedTimestamp && this.nickname === member.nickname && this.avatar === member.avatar && this.pending === member.pending && this.communicationDisabledUntilTimestamp === member.communicationDisabledUntilTimestamp && this.flags.bitfield === member.flags.bitfield && (this._roles === member._roles || this._roles.length === member._roles.length && this._roles.every((role, i) => role === member._roles[i]));
      }
      /**
       * When concatenated with a string, this automatically returns the user's mention instead of the GuildMember object.
       * @returns {string}
       * @example
       * // Logs: Hello from <@123456789012345678>!
       * console.log(`Hello from ${member}!`);
       */
      toString() {
        return this.user.toString();
      }
      toJSON() {
        const json2 = super.toJSON({
          guild: "guildId",
          user: "userId",
          displayName: true,
          roles: true
        });
        json2.avatarURL = this.avatarURL();
        json2.displayAvatarURL = this.displayAvatarURL();
        return json2;
      }
    };
    TextBasedChannel.applyToClass(GuildMember);
    exports2.GuildMember = GuildMember;
  }
});

// node_modules/discord.js/src/managers/MessageManager.js
var require_MessageManager = __commonJS({
  "node_modules/discord.js/src/managers/MessageManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { Message } = require_Message();
    var MessagePayload = require_MessagePayload();
    var { resolvePartialEmoji } = require_Util();
    var MessageManager = class extends CachedManager {
      constructor(channel, iterable) {
        super(channel.client, Message, iterable);
        this.channel = channel;
      }
      /**
       * The cache of Messages
       * @type {Collection<Snowflake, Message>}
       * @name MessageManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache);
      }
      /**
       * Data that can be resolved to a Message object. This can be:
       * * A Message
       * * A Snowflake
       * @typedef {Message|Snowflake} MessageResolvable
       */
      /**
       * Options used to fetch a message.
       * @typedef {BaseFetchOptions} FetchMessageOptions
       * @property {MessageResolvable} message The message to fetch
       */
      /**
       * Options used to fetch multiple messages.
       * <info>The `before`, `after`, and `around` parameters are mutually exclusive.</info>
       * @typedef {Object} FetchMessagesOptions
       * @property {number} [limit] The maximum number of messages to return
       * @property {Snowflake} [before] Consider only messages before this id
       * @property {Snowflake} [after] Consider only messages after this id
       * @property {Snowflake} [around] Consider only messages around this id
       * @property {boolean} [cache] Whether to cache the fetched messages
       */
      /**
       * Fetches message(s) from a channel.
       * <info>The returned Collection does not contain reaction users of the messages if they were not cached.
       * Those need to be fetched separately in such a case.</info>
       * @param {MessageResolvable|FetchMessageOptions|FetchMessagesOptions} [options] Options for fetching message(s)
       * @returns {Promise<Message|Collection<Snowflake, Message>>}
       * @example
       * // Fetch a message
       * channel.messages.fetch('99539446449315840')
       *   .then(message => console.log(message.content))
       *   .catch(console.error);
       * @example
       * // Fetch a maximum of 10 messages without caching
       * channel.messages.fetch({ limit: 10, cache: false })
       *   .then(messages => console.log(`Received ${messages.size} messages`))
       *   .catch(console.error);
       * @example
       * // Fetch a maximum of 10 messages without caching around a message id
       * channel.messages.fetch({ limit: 10, cache: false, around: '99539446449315840' })
       *   .then(messages => console.log(`Received ${messages.size} messages`))
       *   .catch(console.error);
       * @example
       * // Fetch messages and filter by a user id
       * channel.messages.fetch()
       *   .then(messages => console.log(`${messages.filter(m => m.author.id === '84484653687267328').size} messages`))
       *   .catch(console.error);
       */
      fetch(options) {
        if (!options)
          return this._fetchMany();
        const { message, cache, force } = options;
        const resolvedMessage = this.resolveId(message ?? options);
        if (resolvedMessage)
          return this._fetchSingle({ message: resolvedMessage, cache, force });
        return this._fetchMany(options);
      }
      async _fetchSingle({ message, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(message);
          if (existing && !existing.partial)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.channelMessage(this.channel.id, message));
        return this._add(data, cache);
      }
      async _fetchMany(options = {}) {
        const data = await this.client.rest.get(Routes2.channelMessages(this.channel.id), {
          query: makeURLSearchParams2(options)
        });
        return data.reduce((_data, message) => _data.set(message.id, this._add(message, options.cache)), new Collection2());
      }
      /**
       * Fetches the pinned messages of this channel and returns a collection of them.
       * <info>The returned Collection does not contain any reaction data of the messages.
       * Those need to be fetched separately.</info>
       * @param {boolean} [cache=true] Whether to cache the message(s)
       * @returns {Promise<Collection<Snowflake, Message>>}
       * @example
       * // Get pinned messages
       * channel.messages.fetchPinned()
       *   .then(messages => console.log(`Received ${messages.size} messages`))
       *   .catch(console.error);
       */
      async fetchPinned(cache = true) {
        const data = await this.client.rest.get(Routes2.channelPins(this.channel.id));
        const messages = new Collection2();
        for (const message of data)
          messages.set(message.id, this._add(message, cache));
        return messages;
      }
      /**
       * Resolves a {@link MessageResolvable} to a {@link Message} object.
       * @method resolve
       * @memberof MessageManager
       * @instance
       * @param {MessageResolvable} message The message resolvable to resolve
       * @returns {?Message}
       */
      /**
       * Resolves a {@link MessageResolvable} to a {@link Message} id.
       * @method resolveId
       * @memberof MessageManager
       * @instance
       * @param {MessageResolvable} message The message resolvable to resolve
       * @returns {?Snowflake}
       */
      /**
       * Options that can be passed to edit a message.
       * @typedef {BaseMessageOptions} MessageEditOptions
       * @property {Array<JSONEncodable<AttachmentPayload>>} [attachments] An array of attachments to keep,
       * all attachments will be kept if omitted
       * @property {MessageFlags} [flags] Which flags to set for the message
       * <info>Only the {@link MessageFlags.SuppressEmbeds} flag can be modified.</info>
       */
      /**
       * Edits a message, even if it's not cached.
       * @param {MessageResolvable} message The message to edit
       * @param {string|MessageEditOptions|MessagePayload} options The options to edit the message
       * @returns {Promise<Message>}
       */
      async edit(message, options) {
        const messageId = this.resolveId(message);
        if (!messageId)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        const { body, files } = await (options instanceof MessagePayload ? options : MessagePayload.create(message instanceof Message ? message : this, options)).resolveBody().resolveFiles();
        const d = await this.client.rest.patch(Routes2.channelMessage(this.channel.id, messageId), { body, files });
        const existing = this.cache.get(messageId);
        if (existing) {
          const clone = existing._clone();
          clone._patch(d);
          return clone;
        }
        return this._add(d);
      }
      /**
       * Publishes a message in an announcement channel to all channels following it, even if it's not cached.
       * @param {MessageResolvable} message The message to publish
       * @returns {Promise<Message>}
       */
      async crosspost(message) {
        message = this.resolveId(message);
        if (!message)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        const data = await this.client.rest.post(Routes2.channelMessageCrosspost(this.channel.id, message));
        return this.cache.get(data.id) ?? this._add(data);
      }
      /**
       * Pins a message to the channel's pinned messages, even if it's not cached.
       * @param {MessageResolvable} message The message to pin
       * @param {string} [reason] Reason for pinning
       * @returns {Promise<void>}
       */
      async pin(message, reason) {
        message = this.resolveId(message);
        if (!message)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        await this.client.rest.put(Routes2.channelPin(this.channel.id, message), { reason });
      }
      /**
       * Unpins a message from the channel's pinned messages, even if it's not cached.
       * @param {MessageResolvable} message The message to unpin
       * @param {string} [reason] Reason for unpinning
       * @returns {Promise<void>}
       */
      async unpin(message, reason) {
        message = this.resolveId(message);
        if (!message)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        await this.client.rest.delete(Routes2.channelPin(this.channel.id, message), { reason });
      }
      /**
       * Adds a reaction to a message, even if it's not cached.
       * @param {MessageResolvable} message The message to react to
       * @param {EmojiIdentifierResolvable} emoji The emoji to react with
       * @returns {Promise<void>}
       */
      async react(message, emoji) {
        message = this.resolveId(message);
        if (!message)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        emoji = resolvePartialEmoji(emoji);
        if (!emoji)
          throw new DiscordjsTypeError2(ErrorCodes2.EmojiType, "emoji", "EmojiIdentifierResolvable");
        const emojiId = emoji.id ? `${emoji.animated ? "a:" : ""}${emoji.name}:${emoji.id}` : encodeURIComponent(emoji.name);
        await this.client.rest.put(Routes2.channelMessageOwnReaction(this.channel.id, message, emojiId));
      }
      /**
       * Deletes a message, even if it's not cached.
       * @param {MessageResolvable} message The message to delete
       * @returns {Promise<void>}
       */
      async delete(message) {
        message = this.resolveId(message);
        if (!message)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        await this.client.rest.delete(Routes2.channelMessage(this.channel.id, message));
      }
    };
    module2.exports = MessageManager;
  }
});

// node_modules/discord.js/src/structures/InteractionWebhook.js
var require_InteractionWebhook = __commonJS({
  "node_modules/discord.js/src/structures/InteractionWebhook.js"(exports2, module2) {
    "use strict";
    var Webhook2 = require_Webhook();
    var InteractionWebhook = class {
      /**
       * @param {Client} client The instantiating client
       * @param {Snowflake} id The application's id
       * @param {string} token The interaction's token
       */
      constructor(client, id, token) {
        Object.defineProperty(this, "client", { value: client });
        this.id = id;
        Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
      }
      // These are here only for documentation purposes - they are implemented by Webhook
      /* eslint-disable no-empty-function */
      /**
       * Sends a message with this webhook.
       * @param {string|MessagePayload|InteractionReplyOptions} options The content for the reply
       * @returns {Promise<Message>}
       */
      send() {
      }
      /**
       * Gets a message that was sent by this webhook.
       * @param {Snowflake|'@original'} message The id of the message to fetch
       * @returns {Promise<Message>} Returns the message sent by this webhook
       */
      fetchMessage() {
      }
      /**
       * Edits a message that was sent by this webhook.
       * @param {MessageResolvable|'@original'} message The message to edit
       * @param {string|MessagePayload|WebhookMessageEditOptions} options The options to provide
       * @returns {Promise<Message>} Returns the message edited by this webhook
       */
      editMessage() {
      }
      deleteMessage() {
      }
      get url() {
      }
    };
    Webhook2.applyToClass(InteractionWebhook, ["sendSlackMessage", "edit", "delete", "createdTimestamp", "createdAt"]);
    module2.exports = InteractionWebhook;
  }
});

// node_modules/discord.js/src/structures/MessagePayload.js
var require_MessagePayload = __commonJS({
  "node_modules/discord.js/src/structures/MessagePayload.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer5 } = require("node:buffer");
    var { isJSONEncodable } = require_dist8();
    var { lazy } = require_dist2();
    var { MessageFlags } = require_v106();
    var ActionRowBuilder = require_ActionRowBuilder();
    var { DiscordjsRangeError: DiscordjsRangeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var DataResolver2 = require_DataResolver();
    var MessageFlagsBitField = require_MessageFlagsBitField();
    var { basename, verifyString } = require_Util();
    var getBaseInteraction = lazy(() => require_BaseInteraction());
    var MessagePayload = class {
      /**
       * @param {MessageTarget} target The target for this message to be sent to
       * @param {MessagePayloadOption} options The payload of this message
       */
      constructor(target, options) {
        this.target = target;
        this.options = options;
        this.body = null;
        this.files = null;
      }
      /**
       * Whether or not the target is a {@link Webhook} or a {@link WebhookClient}
       * @type {boolean}
       * @readonly
       */
      get isWebhook() {
        const Webhook2 = require_Webhook();
        const WebhookClient = require_WebhookClient();
        return this.target instanceof Webhook2 || this.target instanceof WebhookClient;
      }
      /**
       * Whether or not the target is a {@link User}
       * @type {boolean}
       * @readonly
       */
      get isUser() {
        const User = require_User();
        const { GuildMember } = require_GuildMember();
        return this.target instanceof User || this.target instanceof GuildMember;
      }
      /**
       * Whether or not the target is a {@link Message}
       * @type {boolean}
       * @readonly
       */
      get isMessage() {
        const { Message } = require_Message();
        return this.target instanceof Message;
      }
      /**
       * Whether or not the target is a {@link MessageManager}
       * @type {boolean}
       * @readonly
       */
      get isMessageManager() {
        const MessageManager = require_MessageManager();
        return this.target instanceof MessageManager;
      }
      /**
       * Whether or not the target is an {@link BaseInteraction} or an {@link InteractionWebhook}
       * @type {boolean}
       * @readonly
       */
      get isInteraction() {
        const BaseInteraction = getBaseInteraction();
        const InteractionWebhook = require_InteractionWebhook();
        return this.target instanceof BaseInteraction || this.target instanceof InteractionWebhook;
      }
      /**
       * Makes the content of this message.
       * @returns {?string}
       */
      makeContent() {
        let content;
        if (this.options.content === null) {
          content = "";
        } else if (this.options.content !== void 0) {
          content = verifyString(this.options.content, DiscordjsRangeError2, ErrorCodes2.MessageContentType, true);
        }
        return content;
      }
      /**
       * Resolves the body.
       * @returns {MessagePayload}
       */
      resolveBody() {
        if (this.body)
          return this;
        const isInteraction = this.isInteraction;
        const isWebhook = this.isWebhook;
        const content = this.makeContent();
        const tts = Boolean(this.options.tts);
        let nonce;
        if (this.options.nonce !== void 0) {
          nonce = this.options.nonce;
          if (typeof nonce === "number" ? !Number.isInteger(nonce) : typeof nonce !== "string") {
            throw new DiscordjsRangeError2(ErrorCodes2.MessageNonceType);
          }
        }
        const components = this.options.components?.map((c) => (isJSONEncodable(c) ? c : new ActionRowBuilder(c)).toJSON());
        let username;
        let avatarURL;
        let threadName;
        if (isWebhook) {
          username = this.options.username ?? this.target.name;
          if (this.options.avatarURL)
            avatarURL = this.options.avatarURL;
          if (this.options.threadName)
            threadName = this.options.threadName;
        }
        let flags;
        if (this.options.flags !== void 0 || this.isMessage && this.options.reply === void 0 || this.isMessageManager) {
          flags = // eslint-disable-next-line eqeqeq
          this.options.flags != null ? new MessageFlagsBitField(this.options.flags).bitfield : this.target.flags?.bitfield;
        }
        if (isInteraction && this.options.ephemeral) {
          flags |= MessageFlags.Ephemeral;
        }
        let allowedMentions = this.options.allowedMentions === void 0 ? this.target.client.options.allowedMentions : this.options.allowedMentions;
        if (allowedMentions?.repliedUser !== void 0) {
          allowedMentions = { ...allowedMentions, replied_user: allowedMentions.repliedUser };
          delete allowedMentions.repliedUser;
        }
        let message_reference;
        if (typeof this.options.reply === "object") {
          const reference = this.options.reply.messageReference;
          const message_id = this.isMessage ? reference.id ?? reference : this.target.messages.resolveId(reference);
          if (message_id) {
            message_reference = {
              message_id,
              fail_if_not_exists: this.options.reply.failIfNotExists ?? this.target.client.options.failIfNotExists
            };
          }
        }
        const attachments = this.options.files?.map((file, index) => ({
          id: index.toString(),
          description: file.description
        }));
        if (Array.isArray(this.options.attachments)) {
          this.options.attachments.push(...attachments ?? []);
        } else {
          this.options.attachments = attachments;
        }
        this.body = {
          content,
          tts,
          nonce,
          embeds: this.options.embeds?.map(
            (embed) => isJSONEncodable(embed) ? embed.toJSON() : this.target.client.options.jsonTransformer(embed)
          ),
          components,
          username,
          avatar_url: avatarURL,
          allowed_mentions: content === void 0 && message_reference === void 0 ? void 0 : allowedMentions,
          flags,
          message_reference,
          attachments: this.options.attachments,
          sticker_ids: this.options.stickers?.map((sticker) => sticker.id ?? sticker),
          thread_name: threadName
        };
        return this;
      }
      /**
       * Resolves files.
       * @returns {Promise<MessagePayload>}
       */
      async resolveFiles() {
        if (this.files)
          return this;
        this.files = await Promise.all(this.options.files?.map((file) => this.constructor.resolveFile(file)) ?? []);
        return this;
      }
      /**
       * Resolves a single file into an object sendable to the API.
       * @param {BufferResolvable|Stream|JSONEncodable<AttachmentPayload>} fileLike Something that could
       * be resolved to a file
       * @returns {Promise<RawFile>}
       */
      static async resolveFile(fileLike) {
        let attachment;
        let name;
        const findName = (thing) => {
          if (typeof thing === "string") {
            return basename(thing);
          }
          if (thing.path) {
            return basename(thing.path);
          }
          return "file.jpg";
        };
        const ownAttachment = typeof fileLike === "string" || fileLike instanceof Buffer5 || typeof fileLike.pipe === "function";
        if (ownAttachment) {
          attachment = fileLike;
          name = findName(attachment);
        } else {
          attachment = fileLike.attachment;
          name = fileLike.name ?? findName(attachment);
        }
        const { data, contentType } = await DataResolver2.resolveFile(attachment);
        return { data, name, contentType };
      }
      /**
       * Creates a {@link MessagePayload} from user-level arguments.
       * @param {MessageTarget} target Target to send to
       * @param {string|MessagePayloadOption} options Options or content to use
       * @param {MessagePayloadOption} [extra={}] Extra options to add onto specified options
       * @returns {MessagePayload}
       */
      static create(target, options, extra = {}) {
        return new this(
          target,
          typeof options !== "object" || options === null ? { content: options, ...extra } : { ...options, ...extra }
        );
      }
    };
    module2.exports = MessagePayload;
  }
});

// node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js
var require_TextBasedChannel = __commonJS({
  "node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { DiscordSnowflake } = require_dist3();
    var { InteractionType, Routes: Routes2 } = require_v106();
    var { DiscordjsTypeError: DiscordjsTypeError2, DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { MaxBulkDeletableMessageAge } = require_Constants();
    var InteractionCollector = require_InteractionCollector();
    var MessageCollector = require_MessageCollector();
    var MessagePayload = require_MessagePayload();
    var TextBasedChannel = class {
      constructor() {
        this.messages = new MessageManager(this);
        this.lastMessageId = null;
        this.lastPinTimestamp = null;
      }
      /**
       * The Message object of the last message in the channel, if one was sent
       * @type {?Message}
       * @readonly
       */
      get lastMessage() {
        return this.messages.resolve(this.lastMessageId);
      }
      /**
       * The date when the last pinned message was pinned, if there was one
       * @type {?Date}
       * @readonly
       */
      get lastPinAt() {
        return this.lastPinTimestamp && new Date(this.lastPinTimestamp);
      }
      /**
       * The base message options for messages.
       * @typedef {Object} BaseMessageOptions
       * @property {string|null} [content=''] The content for the message. This can only be `null` when editing a message.
       * @property {Embed[]|APIEmbed[]} [embeds] The embeds for the message
       * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content
       * (see [here](https://discord.com/developers/docs/resources/channel#allowed-mentions-object) for more details)
       * @property {Array<JSONEncodable<AttachmentPayload>>|BufferResolvable[]|Attachment[]|AttachmentBuilder[]} [files]
       * The files to send with the message.
       * @property {ActionRow[]|ActionRowBuilder[]} [components]
       * Action rows containing interactive components for the message (buttons, select menus)
       */
      /**
       * Options for sending a message with a reply.
       * @typedef {Object} ReplyOptions
       * @property {MessageResolvable} messageReference The message to reply to (must be in the same channel and not system)
       * @property {boolean} [failIfNotExists=this.client.options.failIfNotExists] Whether to error if the referenced
       * message does not exist (creates a standard message in this case when false)
       */
      /**
       * The options for sending a message.
       * @typedef {BaseMessageOptions} MessageCreateOptions
       * @property {boolean} [tts=false] Whether the message should be spoken aloud
       * @property {string} [nonce=''] The nonce for the message
       * @property {ReplyOptions} [reply] The options for replying to a message
       * @property {StickerResolvable[]} [stickers=[]] The stickers to send in the message
       * @property {MessageFlags} [flags] Which flags to set for the message.
       * <info>Only `MessageFlags.SuppressEmbeds` and `MessageFlags.SuppressNotifications` can be set.</info>
       */
      /**
       * Options provided to control parsing of mentions by Discord
       * @typedef {Object} MessageMentionOptions
       * @property {MessageMentionTypes[]} [parse] Types of mentions to be parsed
       * @property {Snowflake[]} [users] Snowflakes of Users to be parsed as mentions
       * @property {Snowflake[]} [roles] Snowflakes of Roles to be parsed as mentions
       * @property {boolean} [repliedUser=true] Whether the author of the Message being replied to should be pinged
       */
      /**
       * Types of mentions to enable in MessageMentionOptions.
       * - `roles`
       * - `users`
       * - `everyone`
       * @typedef {string} MessageMentionTypes
       */
      /**
       * @typedef {Object} FileOptions
       * @property {BufferResolvable} attachment File to attach
       * @property {string} [name='file.jpg'] Filename of the attachment
       * @property {string} description The description of the file
       */
      /**
       * Sends a message to this channel.
       * @param {string|MessagePayload|MessageCreateOptions} options The options to provide
       * @returns {Promise<Message>}
       * @example
       * // Send a basic message
       * channel.send('hello!')
       *   .then(message => console.log(`Sent message: ${message.content}`))
       *   .catch(console.error);
       * @example
       * // Send a remote file
       * channel.send({
       *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']
       * })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Send a local file
       * channel.send({
       *   files: [{
       *     attachment: 'entire/path/to/file.jpg',
       *     name: 'file.jpg',
       *     description: 'A description of the file'
       *   }]
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async send(options) {
        const User = require_User();
        const { GuildMember } = require_GuildMember();
        if (this instanceof User || this instanceof GuildMember) {
          const dm = await this.createDM();
          return dm.send(options);
        }
        let messagePayload;
        if (options instanceof MessagePayload) {
          messagePayload = options.resolveBody();
        } else {
          messagePayload = MessagePayload.create(this, options).resolveBody();
        }
        const { body, files } = await messagePayload.resolveFiles();
        const d = await this.client.rest.post(Routes2.channelMessages(this.id), { body, files });
        return this.messages.cache.get(d.id) ?? this.messages._add(d);
      }
      /**
       * Sends a typing indicator in the channel.
       * @returns {Promise<void>} Resolves upon the typing status being sent
       * @example
       * // Start typing in a channel
       * channel.sendTyping();
       */
      async sendTyping() {
        await this.client.rest.post(Routes2.channelTyping(this.id));
      }
      /**
       * Creates a Message Collector.
       * @param {MessageCollectorOptions} [options={}] The options to pass to the collector
       * @returns {MessageCollector}
       * @example
       * // Create a message collector
       * const filter = m => m.content.includes('discord');
       * const collector = channel.createMessageCollector({ filter, time: 15_000 });
       * collector.on('collect', m => console.log(`Collected ${m.content}`));
       * collector.on('end', collected => console.log(`Collected ${collected.size} items`));
       */
      createMessageCollector(options = {}) {
        return new MessageCollector(this, options);
      }
      /**
       * An object containing the same properties as CollectorOptions, but a few more:
       * @typedef {MessageCollectorOptions} AwaitMessagesOptions
       * @property {string[]} [errors] Stop/end reasons that cause the promise to reject
       */
      /**
       * Similar to createMessageCollector but in promise form.
       * Resolves with a collection of messages that pass the specified filter.
       * @param {AwaitMessagesOptions} [options={}] Optional options to pass to the internal collector
       * @returns {Promise<Collection<Snowflake, Message>>}
       * @example
       * // Await !vote messages
       * const filter = m => m.content.startsWith('!vote');
       * // Errors: ['time'] treats ending because of the time limit as an error
       * channel.awaitMessages({ filter, max: 4, time: 60_000, errors: ['time'] })
       *   .then(collected => console.log(collected.size))
       *   .catch(collected => console.log(`After a minute, only ${collected.size} out of 4 voted.`));
       */
      awaitMessages(options = {}) {
        return new Promise((resolve, reject) => {
          const collector = this.createMessageCollector(options);
          collector.once("end", (collection, reason) => {
            if (options.errors?.includes(reason)) {
              reject(collection);
            } else {
              resolve(collection);
            }
          });
        });
      }
      /**
       * Creates a component interaction collector.
       * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector
       * @returns {InteractionCollector}
       * @example
       * // Create a button interaction collector
       * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';
       * const collector = channel.createMessageComponentCollector({ filter, time: 15_000 });
       * collector.on('collect', i => console.log(`Collected ${i.customId}`));
       * collector.on('end', collected => console.log(`Collected ${collected.size} items`));
       */
      createMessageComponentCollector(options = {}) {
        return new InteractionCollector(this.client, {
          ...options,
          interactionType: InteractionType.MessageComponent,
          channel: this
        });
      }
      /**
       * Collects a single component interaction that passes the filter.
       * The Promise will reject if the time expires.
       * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector
       * @returns {Promise<MessageComponentInteraction>}
       * @example
       * // Collect a message component interaction
       * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';
       * channel.awaitMessageComponent({ filter, time: 15_000 })
       *   .then(interaction => console.log(`${interaction.customId} was clicked!`))
       *   .catch(console.error);
       */
      awaitMessageComponent(options = {}) {
        const _options = { ...options, max: 1 };
        return new Promise((resolve, reject) => {
          const collector = this.createMessageComponentCollector(_options);
          collector.once("end", (interactions, reason) => {
            const interaction = interactions.first();
            if (interaction)
              resolve(interaction);
            else
              reject(new DiscordjsError2(ErrorCodes2.InteractionCollectorError, reason));
          });
        });
      }
      /**
       * Bulk deletes given messages that are newer than two weeks.
       * @param {Collection<Snowflake, Message>|MessageResolvable[]|number} messages
       * Messages or number of messages to delete
       * @param {boolean} [filterOld=false] Filter messages to remove those which are older than two weeks automatically
       * @returns {Promise<Collection<Snowflake, Message|undefined>>} Returns the deleted messages
       * @example
       * // Bulk delete messages
       * channel.bulkDelete(5)
       *   .then(messages => console.log(`Bulk deleted ${messages.size} messages`))
       *   .catch(console.error);
       */
      async bulkDelete(messages, filterOld = false) {
        if (Array.isArray(messages) || messages instanceof Collection2) {
          let messageIds = messages instanceof Collection2 ? [...messages.keys()] : messages.map((m) => m.id ?? m);
          if (filterOld) {
            messageIds = messageIds.filter(
              (id) => Date.now() - DiscordSnowflake.timestampFrom(id) < MaxBulkDeletableMessageAge
            );
          }
          if (messageIds.length === 0)
            return new Collection2();
          if (messageIds.length === 1) {
            const message = this.client.actions.MessageDelete.getMessage(
              {
                message_id: messageIds[0]
              },
              this
            );
            await this.client.rest.delete(Routes2.channelMessage(this.id, messageIds[0]));
            return message ? new Collection2([[message.id, message]]) : new Collection2();
          }
          await this.client.rest.post(Routes2.channelBulkDelete(this.id), { body: { messages: messageIds } });
          return messageIds.reduce(
            (col, id) => col.set(
              id,
              this.client.actions.MessageDeleteBulk.getMessage(
                {
                  message_id: id
                },
                this
              )
            ),
            new Collection2()
          );
        }
        if (!isNaN(messages)) {
          const msgs = await this.messages.fetch({ limit: messages });
          return this.bulkDelete(msgs, filterOld);
        }
        throw new DiscordjsTypeError2(ErrorCodes2.MessageBulkDeleteType);
      }
      /**
       * Fetches all webhooks for the channel.
       * @returns {Promise<Collection<Snowflake, Webhook>>}
       * @example
       * // Fetch webhooks
       * channel.fetchWebhooks()
       *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))
       *   .catch(console.error);
       */
      fetchWebhooks() {
        return this.guild.channels.fetchWebhooks(this.id);
      }
      /**
       * Options used to create a {@link Webhook}.
       * @typedef {Object} ChannelWebhookCreateOptions
       * @property {string} name The name of the webhook
       * @property {?(BufferResolvable|Base64Resolvable)} [avatar] Avatar for the webhook
       * @property {string} [reason] Reason for creating the webhook
       */
      /**
       * Creates a webhook for the channel.
       * @param {ChannelWebhookCreateOptions} [options] Options for creating the webhook
       * @returns {Promise<Webhook>} Returns the created Webhook
       * @example
       * // Create a webhook for the current channel
       * channel.createWebhook({
       *   name: 'Snek',
       *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',
       *   reason: 'Needed a cool new Webhook'
       * })
       *   .then(console.log)
       *   .catch(console.error)
       */
      createWebhook(options) {
        return this.guild.channels.createWebhook({ channel: this.id, ...options });
      }
      /**
       * Sets the rate limit per user (slowmode) for this channel.
       * @param {number} rateLimitPerUser The new rate limit in seconds
       * @param {string} [reason] Reason for changing the channel's rate limit
       * @returns {Promise<this>}
       */
      setRateLimitPerUser(rateLimitPerUser, reason) {
        return this.edit({ rateLimitPerUser, reason });
      }
      /**
       * Sets whether this channel is flagged as NSFW.
       * @param {boolean} [nsfw=true] Whether the channel should be considered NSFW
       * @param {string} [reason] Reason for changing the channel's NSFW flag
       * @returns {Promise<this>}
       */
      setNSFW(nsfw = true, reason) {
        return this.edit({ nsfw, reason });
      }
      static applyToClass(structure, full = false, ignore = []) {
        const props = ["send"];
        if (full) {
          props.push(
            "lastMessage",
            "lastPinAt",
            "bulkDelete",
            "sendTyping",
            "createMessageCollector",
            "awaitMessages",
            "createMessageComponentCollector",
            "awaitMessageComponent",
            "fetchWebhooks",
            "createWebhook",
            "setRateLimitPerUser",
            "setNSFW"
          );
        }
        for (const prop of props) {
          if (ignore.includes(prop))
            continue;
          Object.defineProperty(
            structure.prototype,
            prop,
            Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop)
          );
        }
      }
    };
    module2.exports = TextBasedChannel;
    var MessageManager = require_MessageManager();
  }
});

// node_modules/discord.js/src/structures/DMChannel.js
var require_DMChannel = __commonJS({
  "node_modules/discord.js/src/structures/DMChannel.js"(exports2, module2) {
    "use strict";
    var { userMention } = require_dist8();
    var { ChannelType } = require_v106();
    var { BaseChannel } = require_BaseChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var MessageManager = require_MessageManager();
    var Partials = require_Partials();
    var DMChannel = class extends BaseChannel {
      constructor(client, data) {
        super(client, data);
        this.type = ChannelType.DM;
        this.messages = new MessageManager(this);
      }
      _patch(data) {
        super._patch(data);
        if (data.recipients) {
          const recipient = data.recipients[0];
          this.recipientId = recipient.id;
          if ("username" in recipient || this.client.options.partials.includes(Partials.Users)) {
            this.client.users._add(recipient);
          }
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        }
        if ("last_pin_timestamp" in data) {
          this.lastPinTimestamp = Date.parse(data.last_pin_timestamp);
        } else {
          this.lastPinTimestamp ??= null;
        }
      }
      /**
       * Whether this DMChannel is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return this.lastMessageId === void 0;
      }
      /**
       * The recipient on the other end of the DM
       * @type {?User}
       * @readonly
       */
      get recipient() {
        return this.client.users.resolve(this.recipientId);
      }
      /**
       * Fetch this DMChannel.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<DMChannel>}
       */
      fetch(force = true) {
        return this.client.users.createDM(this.recipientId, { force });
      }
      /**
       * When concatenated with a string, this automatically returns the recipient's mention instead of the
       * DMChannel object.
       * @returns {string}
       * @example
       * // Logs: Hello from <@123456789012345678>!
       * console.log(`Hello from ${channel}!`);
       */
      toString() {
        return userMention(this.recipientId);
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      get lastMessage() {
      }
      get lastPinAt() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      createMessageComponentCollector() {
      }
      awaitMessageComponent() {
      }
      // Doesn't work on DM channels; bulkDelete() {}
      // Doesn't work on DM channels; fetchWebhooks() {}
      // Doesn't work on DM channels; createWebhook() {}
      // Doesn't work on DM channels; setRateLimitPerUser() {}
      // Doesn't work on DM channels; setNSFW() {}
    };
    TextBasedChannel.applyToClass(DMChannel, true, [
      "bulkDelete",
      "fetchWebhooks",
      "createWebhook",
      "setRateLimitPerUser",
      "setNSFW"
    ]);
    module2.exports = DMChannel;
  }
});

// node_modules/discord.js/src/util/ThreadMemberFlagsBitField.js
var require_ThreadMemberFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/ThreadMemberFlagsBitField.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var ThreadMemberFlagsBitField = class extends BitField {
    };
    /**
     * Numeric thread member flags. There are currently no bitflags relevant to bots for this.
     * @type {Object<string, number>}
     * @memberof ThreadMemberFlagsBitField
     */
    __publicField(ThreadMemberFlagsBitField, "Flags", {});
    module2.exports = ThreadMemberFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/ThreadMember.js
var require_ThreadMember = __commonJS({
  "node_modules/discord.js/src/structures/ThreadMember.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();
    var ThreadMember = class extends Base {
      constructor(thread, data, extra = {}) {
        super(thread.client);
        this.thread = thread;
        this.joinedTimestamp = null;
        this.flags = null;
        this.id = data.user_id;
        this._patch(data, extra);
      }
      _patch(data, extra = {}) {
        if ("join_timestamp" in data)
          this.joinedTimestamp = Date.parse(data.join_timestamp);
        if ("flags" in data)
          this.flags = new ThreadMemberFlagsBitField(data.flags).freeze();
        if ("member" in data) {
          this.member = this.thread.guild.members._add(data.member, extra.cache);
        } else {
          this.member ??= null;
        }
      }
      /**
       * Whether this thread member is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return this.flags === null;
      }
      /**
       * The guild member associated with this thread member
       * @type {?GuildMember}
       * @readonly
       */
      get guildMember() {
        return this.member ?? this.thread.guild.members.resolve(this.id);
      }
      /**
       * The last time this member joined the thread
       * @type {?Date}
       * @readonly
       */
      get joinedAt() {
        return this.joinedTimestamp && new Date(this.joinedTimestamp);
      }
      /**
       * The user associated with this thread member
       * @type {?User}
       * @readonly
       */
      get user() {
        return this.client.users.resolve(this.id);
      }
      /**
       * Whether the client user can manage this thread member
       * @type {boolean}
       * @readonly
       */
      get manageable() {
        return !this.thread.archived && this.thread.editable;
      }
      /**
       * Removes this member from the thread.
       * @param {string} [reason] Reason for removing the member
       * @returns {ThreadMember}
       */
      async remove(reason) {
        await this.thread.members.remove(this.id, reason);
        return this;
      }
    };
    module2.exports = ThreadMember;
  }
});

// node_modules/discord.js/src/managers/ThreadMemberManager.js
var require_ThreadMemberManager = __commonJS({
  "node_modules/discord.js/src/managers/ThreadMemberManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ThreadMember = require_ThreadMember();
    var ThreadMemberManager = class extends CachedManager {
      constructor(thread, iterable) {
        super(thread.client, ThreadMember, iterable);
        this.thread = thread;
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, ThreadMember>}
       * @name ThreadMemberManager#cache
       */
      _add(data, cache = true) {
        const existing = this.cache.get(data.user_id);
        if (cache)
          existing?._patch(data, { cache });
        if (existing)
          return existing;
        const member = new ThreadMember(this.thread, data, { cache });
        if (cache)
          this.cache.set(data.user_id, member);
        return member;
      }
      /**
       * Fetches the client user as a ThreadMember of the thread.
       * @param {BaseFetchOptions} [options] The options for fetching the member
       * @returns {Promise<ThreadMember>}
       */
      fetchMe(options) {
        return this.fetch({ ...options, member: this.client.user.id });
      }
      /**
       * The client user as a ThreadMember of this ThreadChannel
       * @type {?ThreadMember}
       * @readonly
       */
      get me() {
        return this.resolve(this.client.user.id);
      }
      /**
       * Data that resolves to give a ThreadMember object. This can be:
       * * A ThreadMember object
       * * A User resolvable
       * @typedef {ThreadMember|UserResolvable} ThreadMemberResolvable
       */
      /**
       * Resolves a {@link ThreadMemberResolvable} to a {@link ThreadMember} object.
       * @param {ThreadMemberResolvable} member The user that is part of the thread
       * @returns {?GuildMember}
       */
      resolve(member) {
        const memberResolvable = super.resolve(member);
        if (memberResolvable)
          return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        if (userResolvable)
          return super.resolve(userResolvable);
        return null;
      }
      /**
       * Resolves a {@link ThreadMemberResolvable} to a {@link ThreadMember} id string.
       * @param {ThreadMemberResolvable} member The user that is part of the guild
       * @returns {?Snowflake}
       */
      resolveId(member) {
        const memberResolvable = super.resolveId(member);
        if (memberResolvable)
          return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        return this.cache.has(userResolvable) ? userResolvable : null;
      }
      /**
       * Adds a member to the thread.
       * @param {UserResolvable|'@me'} member The member to add
       * @param {string} [reason] The reason for adding this member
       * @returns {Promise<Snowflake>}
       */
      async add(member, reason) {
        const id = member === "@me" ? member : this.client.users.resolveId(member);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "member", "UserResolvable");
        await this.client.rest.put(Routes2.threadMembers(this.thread.id, id), { reason });
        return id;
      }
      /**
       * Remove a user from the thread.
       * @param {Snowflake|'@me'} id The id of the member to remove
       * @param {string} [reason] The reason for removing this member from the thread
       * @returns {Promise<Snowflake>}
       */
      async remove(id, reason) {
        await this.client.rest.delete(Routes2.threadMembers(this.thread.id, id), { reason });
        return id;
      }
      /**
       * Options used to fetch a thread member.
       * @typedef {BaseFetchOptions} FetchThreadMemberOptions
       * @property {ThreadMemberResolvable} member The thread member to fetch
       * @property {boolean} [withMember] Whether to also return the guild member associated with this thread member
       */
      /**
       * Options used to fetch multiple thread members with guild member data.
       * <info>With `withMember` set to `true`, pagination is enabled.</info>
       * @typedef {Object} FetchThreadMembersWithGuildMemberDataOptions
       * @property {true} withMember Whether to also return the guild member data
       * @property {Snowflake} [after] Consider only thread members after this id
       * @property {number} [limit] The maximum number of thread members to return
       * @property {boolean} [cache] Whether to cache the fetched thread members and guild members
       */
      /**
       * Options used to fetch multiple thread members without guild member data.
       * @typedef {Object} FetchThreadMembersWithoutGuildMemberDataOptions
       * @property {false} [withMember] Whether to also return the guild member data
       * @property {boolean} [cache] Whether to cache the fetched thread members
       */
      /**
       * Options used to fetch multiple thread members.
       * @typedef {FetchThreadMembersWithGuildMemberDataOptions|
       * FetchThreadMembersWithoutGuildMemberDataOptions} FetchThreadMembersOptions
       */
      /**
       * Fetches thread member(s) from Discord.
       * <info>This method requires the {@link GatewayIntentBits.GuildMembers} privileged gateway intent.</info>
       * @param {ThreadMemberResolvable|FetchThreadMemberOptions|FetchThreadMembersOptions} [options]
       * Options for fetching thread member(s)
       * @returns {Promise<ThreadMember|Collection<Snowflake, ThreadMember>>}
       */
      fetch(options) {
        if (!options)
          return this._fetchMany();
        const { member, withMember, cache, force } = options;
        const resolvedMember = this.resolveId(member ?? options);
        if (resolvedMember)
          return this._fetchSingle({ member: resolvedMember, withMember, cache, force });
        return this._fetchMany(options);
      }
      async _fetchSingle({ member, withMember, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(member);
          if (existing)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.threadMembers(this.thread.id, member), {
          query: makeURLSearchParams2({ with_member: withMember })
        });
        return this._add(data, cache);
      }
      async _fetchMany({ withMember, after, limit, cache } = {}) {
        const data = await this.client.rest.get(Routes2.threadMembers(this.thread.id), {
          query: makeURLSearchParams2({ with_member: withMember, after, limit })
        });
        return data.reduce((col, member) => col.set(member.user_id, this._add(member, cache)), new Collection2());
      }
    };
    module2.exports = ThreadMemberManager;
  }
});

// node_modules/discord.js/src/structures/ThreadChannel.js
var require_ThreadChannel = __commonJS({
  "node_modules/discord.js/src/structures/ThreadChannel.js"(exports2, module2) {
    "use strict";
    var { ChannelType, PermissionFlagsBits, Routes: Routes2, ChannelFlags } = require_v106();
    var { BaseChannel } = require_BaseChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var { DiscordjsRangeError: DiscordjsRangeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var MessageManager = require_MessageManager();
    var ThreadMemberManager = require_ThreadMemberManager();
    var ChannelFlagsBitField = require_ChannelFlagsBitField();
    var ThreadChannel = class extends BaseChannel {
      constructor(guild, data, client, fromInteraction = false) {
        super(guild?.client ?? client, data, false);
        this.guild = guild;
        this.guildId = guild?.id ?? data.guild_id;
        this.messages = new MessageManager(this);
        this.members = new ThreadMemberManager(this);
        if (data)
          this._patch(data, fromInteraction);
      }
      _patch(data, partial = false) {
        super._patch(data);
        if ("message" in data)
          this.messages._add(data.message);
        if ("name" in data) {
          this.name = data.name;
        }
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("parent_id" in data) {
          this.parentId = data.parent_id;
        } else {
          this.parentId ??= null;
        }
        if ("thread_metadata" in data) {
          this.locked = data.thread_metadata.locked ?? false;
          this.invitable = this.type === ChannelType.PrivateThread ? data.thread_metadata.invitable ?? false : null;
          this.archived = data.thread_metadata.archived;
          this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;
          this.archiveTimestamp = Date.parse(data.thread_metadata.archive_timestamp);
          if ("create_timestamp" in data.thread_metadata) {
            this._createdTimestamp = Date.parse(data.thread_metadata.create_timestamp);
          }
        } else {
          this.locked ??= null;
          this.archived ??= null;
          this.autoArchiveDuration ??= null;
          this.archiveTimestamp ??= null;
          this.invitable ??= null;
        }
        this._createdTimestamp ??= this.type === ChannelType.PrivateThread ? super.createdTimestamp : null;
        if ("owner_id" in data) {
          this.ownerId = data.owner_id;
        } else {
          this.ownerId ??= null;
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        } else {
          this.lastMessageId ??= null;
        }
        if ("last_pin_timestamp" in data) {
          this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
        } else {
          this.lastPinTimestamp ??= null;
        }
        if ("rate_limit_per_user" in data || !partial) {
          this.rateLimitPerUser = data.rate_limit_per_user ?? 0;
        } else {
          this.rateLimitPerUser ??= null;
        }
        if ("message_count" in data) {
          this.messageCount = data.message_count;
        } else {
          this.messageCount ??= null;
        }
        if ("member_count" in data) {
          this.memberCount = data.member_count;
        } else {
          this.memberCount ??= null;
        }
        if ("total_message_sent" in data) {
          this.totalMessageSent = data.total_message_sent;
        } else {
          this.totalMessageSent ??= null;
        }
        if (data.member && this.client.user)
          this.members._add({ user_id: this.client.user.id, ...data.member });
        if (data.messages)
          for (const message of data.messages)
            this.messages._add(message);
        if ("applied_tags" in data) {
          this.appliedTags = data.applied_tags;
        } else {
          this.appliedTags ??= [];
        }
      }
      /**
       * The timestamp when this thread was created. This isn't available for threads
       * created before 2022-01-09
       * @type {?number}
       * @readonly
       */
      get createdTimestamp() {
        return this._createdTimestamp;
      }
      /**
       * A collection of associated guild member objects of this thread's members
       * @type {Collection<Snowflake, GuildMember>}
       * @readonly
       */
      get guildMembers() {
        return this.members.cache.mapValues((member) => member.guildMember);
      }
      /**
       * The time at which this thread's archive status was last changed
       * <info>If the thread was never archived or unarchived, this is the time at which the thread was created</info>
       * @type {?Date}
       * @readonly
       */
      get archivedAt() {
        return this.archiveTimestamp && new Date(this.archiveTimestamp);
      }
      /**
       * The time the thread was created at
       * @type {?Date}
       * @readonly
       */
      get createdAt() {
        return this.createdTimestamp && new Date(this.createdTimestamp);
      }
      /**
       * The parent channel of this thread
       * @type {?(NewsChannel|TextChannel|ForumChannel)}
       * @readonly
       */
      get parent() {
        return this.guild.channels.resolve(this.parentId);
      }
      /**
       * Makes the client user join the thread.
       * @returns {Promise<ThreadChannel>}
       */
      async join() {
        await this.members.add("@me");
        return this;
      }
      /**
       * Makes the client user leave the thread.
       * @returns {Promise<ThreadChannel>}
       */
      async leave() {
        await this.members.remove("@me");
        return this;
      }
      /**
       * Gets the overall set of permissions for a member or role in this thread's parent channel, taking overwrites into
       * account.
       * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for
       * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission
       * will return all permissions
       * @returns {?Readonly<PermissionsBitField>}
       */
      permissionsFor(memberOrRole, checkAdmin) {
        return this.parent?.permissionsFor(memberOrRole, checkAdmin) ?? null;
      }
      /**
       * Fetches the owner of this thread. If the thread member object isn't needed,
       * use {@link ThreadChannel#ownerId} instead.
       * @param {BaseFetchOptions} [options] The options for fetching the member
       * @returns {Promise<?ThreadMember>}
       */
      async fetchOwner({ cache = true, force = false } = {}) {
        if (!force) {
          const existing = this.members.cache.get(this.ownerId);
          if (existing)
            return existing;
        }
        const members = await this.members.fetch({ cache });
        return members.get(this.ownerId) ?? null;
      }
      /**
       * Fetches the message that started this thread, if any.
       * <info>The `Promise` will reject if the original message in a forum post is deleted
       * or when the original message in the parent channel is deleted.
       * If you just need the id of that message, use {@link ThreadChannel#id} instead.</info>
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<Message<true>|null>}
       */
      // eslint-disable-next-line require-await
      async fetchStarterMessage(options) {
        const channel = this.parent?.type === ChannelType.GuildForum ? this : this.parent;
        return channel?.messages.fetch({ message: this.id, ...options }) ?? null;
      }
      /**
       * The options used to edit a thread channel
       * @typedef {Object} ThreadEditOptions
       * @property {string} [name] The new name for the thread
       * @property {boolean} [archived] Whether the thread is archived
       * @property {ThreadAutoArchiveDuration} [autoArchiveDuration] The amount of time after which the thread
       * should automatically archive in case of no recent activity
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds
       * @property {boolean} [locked] Whether the thread is locked
       * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to a thread
       * <info>Can only be edited on {@link ChannelType.PrivateThread}</info>
       * @property {Snowflake[]} [appliedTags] The tags to apply to the thread
       * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel
       * @property {string} [reason] Reason for editing the thread
       */
      /**
       * Edits this thread.
       * @param {ThreadEditOptions} options The options to provide
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Edit a thread
       * thread.edit({ name: 'new-thread' })
       *   .then(editedThread => console.log(editedThread))
       *   .catch(console.error);
       */
      async edit(options) {
        const newData = await this.client.rest.patch(Routes2.channel(this.id), {
          body: {
            name: (options.name ?? this.name).trim(),
            archived: options.archived,
            auto_archive_duration: options.autoArchiveDuration,
            rate_limit_per_user: options.rateLimitPerUser,
            locked: options.locked,
            invitable: this.type === ChannelType.PrivateThread ? options.invitable : void 0,
            applied_tags: options.appliedTags,
            flags: "flags" in options ? ChannelFlagsBitField.resolve(options.flags) : void 0
          },
          reason: options.reason
        });
        return this.client.actions.ChannelUpdate.handle(newData).updated;
      }
      /**
       * Sets whether the thread is archived.
       * @param {boolean} [archived=true] Whether the thread is archived
       * @param {string} [reason] Reason for archiving or unarchiving
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Archive the thread
       * thread.setArchived(true)
       *   .then(newThread => console.log(`Thread is now ${newThread.archived ? 'archived' : 'active'}`))
       *   .catch(console.error);
       */
      setArchived(archived = true, reason) {
        return this.edit({ archived, reason });
      }
      /**
       * Sets the duration after which the thread will automatically archive in case of no recent activity.
       * @param {ThreadAutoArchiveDuration} autoArchiveDuration The amount of time after which the thread
       * should automatically archive in case of no recent activity
       * @param {string} [reason] Reason for changing the auto archive duration
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Set the thread's auto archive time to 1 hour
       * thread.setAutoArchiveDuration(ThreadAutoArchiveDuration.OneHour)
       *   .then(newThread => {
       *     console.log(`Thread will now archive after ${newThread.autoArchiveDuration} minutes of inactivity`);
       *    });
       *   .catch(console.error);
       */
      setAutoArchiveDuration(autoArchiveDuration, reason) {
        return this.edit({ autoArchiveDuration, reason });
      }
      /**
       * Sets whether members without the {@link PermissionFlagsBits.ManageThreads} permission
       * can invite other members to this thread.
       * @param {boolean} [invitable=true] Whether non-moderators can invite non-moderators to this thread
       * @param {string} [reason] Reason for changing invite
       * @returns {Promise<ThreadChannel>}
       */
      setInvitable(invitable = true, reason) {
        if (this.type !== ChannelType.PrivateThread) {
          return Promise.reject(new DiscordjsRangeError2(ErrorCodes2.ThreadInvitableType, this.type));
        }
        return this.edit({ invitable, reason });
      }
      /**
       * Sets whether the thread can be **unarchived** by anyone with the
       * {@link PermissionFlagsBits.SendMessages} permission. When a thread is locked, only members with the
       * {@link PermissionFlagsBits.ManageThreads} permission can unarchive it.
       * @param {boolean} [locked=true] Whether the thread is locked
       * @param {string} [reason] Reason for locking or unlocking the thread
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Set the thread to locked
       * thread.setLocked(true)
       *   .then(newThread => console.log(`Thread is now ${newThread.locked ? 'locked' : 'unlocked'}`))
       *   .catch(console.error);
       */
      setLocked(locked = true, reason) {
        return this.edit({ locked, reason });
      }
      /**
       * Sets a new name for this thread.
       * @param {string} name The new name for the thread
       * @param {string} [reason] Reason for changing the thread's name
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Change the thread's name
       * thread.setName('not_general')
       *   .then(newThread => console.log(`Thread's new name is ${newThread.name}`))
       *   .catch(console.error);
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Sets the rate limit per user (slowmode) for this thread.
       * @param {number} rateLimitPerUser The new rate limit in seconds
       * @param {string} [reason] Reason for changing the thread's rate limit
       * @returns {Promise<ThreadChannel>}
       */
      setRateLimitPerUser(rateLimitPerUser, reason) {
        return this.edit({ rateLimitPerUser, reason });
      }
      /**
       * Set the applied tags for this channel (only applicable to forum threads)
       * @param {Snowflake[]} appliedTags The tags to set for this channel
       * @param {string} [reason] Reason for changing the thread's applied tags
       * @returns {Promise<ThreadChannel>}
       */
      setAppliedTags(appliedTags, reason) {
        return this.edit({ appliedTags, reason });
      }
      /**
       * Pins this thread from the forum channel (only applicable to forum threads).
       * @param {string} [reason] Reason for pinning
       * @returns {Promise<ThreadChannel>}
       */
      pin(reason) {
        return this.edit({ flags: this.flags.add(ChannelFlags.Pinned), reason });
      }
      /**
       * Unpins this thread from the forum channel (only applicable to forum threads).
       * @param {string} [reason] Reason for unpinning
       * @returns {Promise<ThreadChannel>}
       */
      unpin(reason) {
        return this.edit({ flags: this.flags.remove(ChannelFlags.Pinned), reason });
      }
      /**
       * Whether the client user is a member of the thread.
       * @type {boolean}
       * @readonly
       */
      get joined() {
        return this.members.cache.has(this.client.user?.id);
      }
      /**
       * Whether the thread is editable by the client user (name, archived, autoArchiveDuration)
       * @type {boolean}
       * @readonly
       */
      get editable() {
        return this.ownerId === this.client.user.id && (this.type !== ChannelType.PrivateThread || this.joined) || this.manageable;
      }
      /**
       * Whether the thread is joinable by the client user
       * @type {boolean}
       * @readonly
       */
      get joinable() {
        return !this.archived && !this.joined && this.permissionsFor(this.client.user)?.has(
          this.type === ChannelType.PrivateThread ? PermissionFlagsBits.ManageThreads : PermissionFlagsBits.ViewChannel,
          false
        );
      }
      /**
       * Whether the thread is manageable by the client user, for deleting or editing rateLimitPerUser or locked.
       * @type {boolean}
       * @readonly
       */
      get manageable() {
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        if (permissions.has(PermissionFlagsBits.Administrator, false))
          return true;
        return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.ManageThreads, false);
      }
      /**
       * Whether the thread is viewable by the client user
       * @type {boolean}
       * @readonly
       */
      get viewable() {
        if (this.client.user.id === this.guild.ownerId)
          return true;
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        return permissions.has(PermissionFlagsBits.ViewChannel, false);
      }
      /**
       * Whether the client user can send messages in this thread
       * @type {boolean}
       * @readonly
       */
      get sendable() {
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        if (permissions.has(PermissionFlagsBits.Administrator, false))
          return true;
        return !(this.archived && this.locked && !this.manageable) && (this.type !== ChannelType.PrivateThread || this.joined || this.manageable) && permissions.has(PermissionFlagsBits.SendMessagesInThreads, false) && this.guild.members.me.communicationDisabledUntilTimestamp < Date.now();
      }
      /**
       * Whether the thread is unarchivable by the client user
       * @type {boolean}
       * @readonly
       */
      get unarchivable() {
        return this.archived && this.sendable && (!this.locked || this.manageable);
      }
      /**
       * Deletes this thread.
       * @param {string} [reason] Reason for deleting this thread
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Delete the thread
       * thread.delete('cleaning out old threads')
       *   .then(deletedThread => console.log(deletedThread))
       *   .catch(console.error);
       */
      async delete(reason) {
        await this.guild.channels.delete(this.id, reason);
        return this;
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      get lastMessage() {
      }
      get lastPinAt() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      createMessageComponentCollector() {
      }
      awaitMessageComponent() {
      }
      bulkDelete() {
      }
      // Doesn't work on Thread channels; setRateLimitPerUser() {}
      // Doesn't work on Thread channels; setNSFW() {}
    };
    TextBasedChannel.applyToClass(ThreadChannel, true, ["fetchWebhooks", "setRateLimitPerUser", "setNSFW"]);
    module2.exports = ThreadChannel;
  }
});

// node_modules/discord.js/src/managers/ThreadManager.js
var require_ThreadManager = __commonJS({
  "node_modules/discord.js/src/managers/ThreadManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ThreadChannel = require_ThreadChannel();
    var ThreadManager = class extends CachedManager {
      constructor(channel, iterable) {
        super(channel.client, ThreadChannel, iterable);
        this.channel = channel;
      }
      /**
       * Data that can be resolved to a Thread Channel object. This can be:
       * * A ThreadChannel object
       * * A Snowflake
       * @typedef {ThreadChannel|Snowflake} ThreadChannelResolvable
       */
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, ThreadChannel>}
       * @name ThreadManager#cache
       */
      _add(thread) {
        const existing = this.cache.get(thread.id);
        if (existing)
          return existing;
        this.cache.set(thread.id, thread);
        return thread;
      }
      /**
       * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} object.
       * @method resolve
       * @memberof ThreadManager
       * @instance
       * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve
       * @returns {?ThreadChannel}
       */
      /**
       * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} id.
       * @method resolveId
       * @memberof ThreadManager
       * @instance
       * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve
       * @returns {?Snowflake}
       */
      /**
       * Options for creating a thread. <warn>Only one of `startMessage` or `type` can be defined.</warn>
       * @typedef {StartThreadOptions} ThreadCreateOptions
       * @property {MessageResolvable} [startMessage] The message to start a thread from. <warn>If this is defined then type
       * of thread gets automatically defined and cannot be changed. The provided `type` field will be ignored</warn>
       * @property {ChannelType.AnnouncementThread|ChannelType.PublicThread|ChannelType.PrivateThread} [type]
       * The type of thread to create.
       * Defaults to {@link ChannelType.PublicThread} if created in a {@link TextChannel}
       * <warn>When creating threads in a {@link NewsChannel} this is ignored and is always
       * {@link ChannelType.AnnouncementThread}</warn>
       * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to the thread
       * <info>Can only be set when type will be {@link ChannelType.PrivateThread}</info>
       */
      /**
       * Options for fetching multiple threads.
       * @typedef {Object} FetchThreadsOptions
       * @property {FetchArchivedThreadOptions} [archived] Options used to fetch archived threads
       */
      /**
       * Obtains a thread from Discord, or the channel cache if it's already available.
       * @param {ThreadChannelResolvable|FetchThreadsOptions} [options] The options to fetch threads. If it is a
       * ThreadChannelResolvable then the specified thread will be fetched. Fetches all active threads if `undefined`
       * @param {BaseFetchOptions} [cacheOptions] Additional options for this fetch. <warn>The `force` field gets ignored
       * if `options` is not a {@link ThreadChannelResolvable}</warn>
       * @returns {Promise<?(ThreadChannel|FetchedThreads|FetchedThreadsMore)>}
       * {@link FetchedThreads} if active & {@link FetchedThreadsMore} if archived.
       * @example
       * // Fetch a thread by its id
       * channel.threads.fetch('831955138126104859')
       *   .then(channel => console.log(channel.name))
       *   .catch(console.error);
       */
      fetch(options, { cache, force } = {}) {
        if (!options)
          return this.fetchActive(cache);
        const channel = this.client.channels.resolveId(options);
        if (channel)
          return this.client.channels.fetch(channel, { cache, force });
        if (options.archived) {
          return this.fetchArchived(options.archived, cache);
        }
        return this.fetchActive(cache);
      }
      /**
       * Data that can be resolved to a Date object. This can be:
       * * A Date object
       * * A number representing a timestamp
       * * An [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string
       * @typedef {Date|number|string} DateResolvable
       */
      /**
       * The options used to fetch archived threads.
       * @typedef {Object} FetchArchivedThreadOptions
       * @property {string} [type='public'] The type of threads to fetch (`public` or `private`)
       * @property {boolean} [fetchAll=false] Whether to fetch **all** archived threads when `type` is `private`
       * <info>This property requires the {@link PermissionFlagsBits.ManageThreads} permission if `true`.</info>
       * @property {DateResolvable|ThreadChannelResolvable} [before] Only return threads that were archived before this Date
       * or Snowflake
       * <warn>Must be a {@link ThreadChannelResolvable} when `type` is `private` and `fetchAll` is `false`.</warn>
       * @property {number} [limit] Maximum number of threads to return
       */
      /**
       * Data returned from fetching multiple threads.
       * @typedef {FetchedThreads} FetchedThreadsMore
       * @property {?boolean} hasMore Whether there are potentially additional threads that require a subsequent call
       */
      /**
       * Obtains a set of archived threads from Discord.
       * <info>This method requires the {@link PermissionFlagsBits.ReadMessageHistory} permission
       * in the parent channel.</info>
       * @param {FetchArchivedThreadOptions} [options] The options to fetch archived threads
       * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already
       * @returns {Promise<FetchedThreadsMore>}
       */
      async fetchArchived({ type = "public", fetchAll = false, before, limit } = {}, cache = true) {
        let path = Routes2.channelThreads(this.channel.id, type);
        if (type === "private" && !fetchAll) {
          path = Routes2.channelJoinedArchivedThreads(this.channel.id);
        }
        let timestamp2;
        let id;
        const query = makeURLSearchParams2({ limit });
        if (before !== void 0) {
          if (before instanceof ThreadChannel || /^\d{17,19}$/.test(String(before))) {
            id = this.resolveId(before);
            timestamp2 = this.resolve(before)?.archivedAt?.toISOString();
            const toUse = type === "private" && !fetchAll ? id : timestamp2;
            if (toUse) {
              query.set("before", toUse);
            }
          } else {
            try {
              timestamp2 = new Date(before).toISOString();
              if (type === "public" || fetchAll) {
                query.set("before", timestamp2);
              }
            } catch {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "before", "DateResolvable or ThreadChannelResolvable");
            }
          }
        }
        const raw = await this.client.rest.get(path, { query });
        return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });
      }
      /**
       * Obtains all active thread channels in the guild.
       * This internally calls {@link GuildChannelManager#fetchActiveThreads}.
       * @param {boolean} [cache=true] Whether to cache the fetched data
       * @returns {Promise<FetchedThreads>}
       */
      fetchActive(cache = true) {
        return this.channel.guild.channels.fetchActiveThreads(cache);
      }
      static _mapThreads(rawThreads, client, { parent, guild, cache }) {
        const threads = rawThreads.threads.reduce((coll, raw) => {
          const thread = client.channels._add(raw, guild ?? parent?.guild, { cache });
          if (parent && thread.parentId !== parent.id)
            return coll;
          return coll.set(thread.id, thread);
        }, new Collection2());
        const threadMembers = rawThreads.members.reduce(
          (coll, raw) => coll.set(raw.user_id, threads.get(raw.id).members._add(raw)),
          new Collection2()
        );
        const response = { threads, members: threadMembers };
        if ("has_more" in rawThreads)
          response.hasMore = rawThreads.has_more;
        return response;
      }
    };
    module2.exports = ThreadManager;
  }
});

// node_modules/discord.js/src/managers/GuildTextThreadManager.js
var require_GuildTextThreadManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildTextThreadManager.js"(exports2, module2) {
    "use strict";
    var { ChannelType, Routes: Routes2 } = require_v106();
    var ThreadManager = require_ThreadManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var GuildTextThreadManager = class extends ThreadManager {
      /**
       * The channel this Manager belongs to
       * @name GuildTextThreadManager#channel
       * @type {TextChannel|NewsChannel}
       */
      /**
       * Options for creating a thread. <warn>Only one of `startMessage` or `type` can be defined.</warn>
       * @typedef {StartThreadOptions} ThreadCreateOptions
       * @property {MessageResolvable} [startMessage] The message to start a thread from.
       * <warn>If this is defined, then the `type` of thread gets inferred automatically and cannot be changed.</warn>
       * @property {ThreadChannelTypes} [type] The type of thread to create.
       * Defaults to {@link ChannelType.PublicThread} if created in a {@link TextChannel}
       * <warn>When creating threads in a {@link NewsChannel}, this is ignored and is always
       * {@link ChannelType.AnnouncementThread}</warn>
       * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to the thread
       * <info>Can only be set when type will be {@link ChannelType.PrivateThread}</info>
       */
      /**
       * Creates a new thread in the channel.
       * @param {ThreadCreateOptions} [options] Options to create a new thread
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Create a new public thread
       * channel.threads
       *   .create({
       *     name: 'food-talk',
       *     autoArchiveDuration: ThreadAutoArchiveDuration.OneHour,
       *     reason: 'Needed a separate thread for food',
       *   })
       *   .then(threadChannel => console.log(threadChannel))
       *   .catch(console.error);
       * @example
       * // Create a new private thread
       * channel.threads
       *   .create({
       *      name: 'mod-talk',
       *      autoArchiveDuration: ThreadAutoArchiveDuration.OneHour,
       *      type: ChannelType.PrivateThread,
       *      reason: 'Needed a separate thread for moderation',
       *    })
       *   .then(threadChannel => console.log(threadChannel))
       *   .catch(console.error);
       */
      async create({
        name,
        autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
        startMessage,
        type,
        invitable,
        reason,
        rateLimitPerUser
      } = {}) {
        let resolvedType = this.channel.type === ChannelType.GuildAnnouncement ? ChannelType.AnnouncementThread : ChannelType.PublicThread;
        let startMessageId;
        if (startMessage) {
          startMessageId = this.channel.messages.resolveId(startMessage);
          if (!startMessageId)
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "startMessage", "MessageResolvable");
        } else if (this.channel.type !== ChannelType.GuildAnnouncement) {
          resolvedType = type ?? resolvedType;
        }
        const data = await this.client.rest.post(Routes2.threads(this.channel.id, startMessageId), {
          body: {
            name,
            auto_archive_duration: autoArchiveDuration,
            type: resolvedType,
            invitable: resolvedType === ChannelType.PrivateThread ? invitable : void 0,
            rate_limit_per_user: rateLimitPerUser
          },
          reason
        });
        return this.client.actions.ThreadCreate.handle(data).thread;
      }
    };
    module2.exports = GuildTextThreadManager;
  }
});

// node_modules/discord.js/src/structures/BaseGuildTextChannel.js
var require_BaseGuildTextChannel = __commonJS({
  "node_modules/discord.js/src/structures/BaseGuildTextChannel.js"(exports2, module2) {
    "use strict";
    var GuildChannel = require_GuildChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var GuildTextThreadManager = require_GuildTextThreadManager();
    var MessageManager = require_MessageManager();
    var BaseGuildTextChannel = class extends GuildChannel {
      constructor(guild, data, client) {
        super(guild, data, client, false);
        this.messages = new MessageManager(this);
        this.threads = new GuildTextThreadManager(this);
        this.nsfw = Boolean(data.nsfw);
        this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("nsfw" in data) {
          this.nsfw = Boolean(data.nsfw);
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        }
        if ("last_pin_timestamp" in data) {
          this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
        }
        if ("default_auto_archive_duration" in data) {
          this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
        }
        if ("messages" in data) {
          for (const message of data.messages)
            this.messages._add(message);
        }
      }
      /**
       * Sets the default auto archive duration for all newly created threads in this channel.
       * @param {ThreadAutoArchiveDuration} defaultAutoArchiveDuration The new default auto archive duration
       * @param {string} [reason] Reason for changing the channel's default auto archive duration
       * @returns {Promise<TextChannel>}
       */
      setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
        return this.edit({ defaultAutoArchiveDuration, reason });
      }
      /**
       * Sets the type of this channel.
       * <info>Only conversion between {@link TextChannel} and {@link NewsChannel} is supported.</info>
       * @param {ChannelType.GuildText|ChannelType.GuildAnnouncement} type The new channel type
       * @param {string} [reason] Reason for changing the channel's type
       * @returns {Promise<GuildChannel>}
       */
      setType(type, reason) {
        return this.edit({ type, reason });
      }
      /**
       * Sets a new topic for the guild channel.
       * @param {?string} topic The new topic for the guild channel
       * @param {string} [reason] Reason for changing the guild channel's topic
       * @returns {Promise<GuildChannel>}
       * @example
       * // Set a new channel topic
       * channel.setTopic('needs more rate limiting')
       *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))
       *   .catch(console.error);
       */
      setTopic(topic, reason) {
        return this.edit({ topic, reason });
      }
      /**
       * Data that can be resolved to an Application. This can be:
       * * An Application
       * * An Activity with associated Application
       * * A Snowflake
       * @typedef {Application|Snowflake} ApplicationResolvable
       */
      /**
       * Options used to create an invite to a guild channel.
       * @typedef {Object} InviteCreateOptions
       * @property {boolean} [temporary] Whether members that joined via the invite should be automatically
       * kicked after 24 hours if they have not yet received a role
       * @property {number} [maxAge] How long the invite should last (in seconds, 0 for forever)
       * @property {number} [maxUses] Maximum number of uses
       * @property {boolean} [unique] Create a unique invite, or use an existing one with similar settings
       * @property {UserResolvable} [targetUser] The user whose stream to display for this invite,
       * required if `targetType` is {@link InviteTargetType.Stream}, the user must be streaming in the channel
       * @property {ApplicationResolvable} [targetApplication] The embedded application to open for this invite,
       * required if `targetType` is {@link InviteTargetType.Stream}, the application must have the
       * {@link InviteTargetType.EmbeddedApplication} flag
       * @property {InviteTargetType} [targetType] The type of the target for this voice channel invite
       * @property {string} [reason] The reason for creating the invite
       */
      /**
       * Creates an invite to this guild channel.
       * @param {InviteCreateOptions} [options={}] The options for creating the invite
       * @returns {Promise<Invite>}
       * @example
       * // Create an invite to a channel
       * channel.createInvite()
       *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))
       *   .catch(console.error);
       */
      createInvite(options) {
        return this.guild.invites.create(this.id, options);
      }
      /**
       * Fetches a collection of invites to this guild channel.
       * Resolves with a collection mapping invites by their codes.
       * @param {boolean} [cache=true] Whether or not to cache the fetched invites
       * @returns {Promise<Collection<string, Invite>>}
       */
      fetchInvites(cache = true) {
        return this.guild.invites.fetch({ channelId: this.id, cache });
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      get lastMessage() {
      }
      get lastPinAt() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      createMessageComponentCollector() {
      }
      awaitMessageComponent() {
      }
      bulkDelete() {
      }
      fetchWebhooks() {
      }
      createWebhook() {
      }
      setRateLimitPerUser() {
      }
      setNSFW() {
      }
    };
    TextBasedChannel.applyToClass(BaseGuildTextChannel, true);
    module2.exports = BaseGuildTextChannel;
  }
});

// node_modules/discord.js/src/structures/NewsChannel.js
var require_NewsChannel = __commonJS({
  "node_modules/discord.js/src/structures/NewsChannel.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var BaseGuildTextChannel = require_BaseGuildTextChannel();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var NewsChannel = class extends BaseGuildTextChannel {
      /**
       * Adds the target to this channel's followers.
       * @param {TextChannelResolvable} channel The channel where the webhook should be created
       * @param {string} [reason] Reason for creating the webhook
       * @returns {Promise<NewsChannel>}
       * @example
       * if (channel.type === ChannelType.GuildAnnouncement) {
       *   channel.addFollower('222197033908436994', 'Important announcements')
       *     .then(() => console.log('Added follower'))
       *     .catch(console.error);
       * }
       */
      async addFollower(channel, reason) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId)
          throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        await this.client.rest.post(Routes2.channelFollowers(this.id), { body: { webhook_channel_id: channelId }, reason });
        return this;
      }
    };
    module2.exports = NewsChannel;
  }
});

// node_modules/discord.js/src/structures/BaseGuildVoiceChannel.js
var require_BaseGuildVoiceChannel = __commonJS({
  "node_modules/discord.js/src/structures/BaseGuildVoiceChannel.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { PermissionFlagsBits } = require_v106();
    var GuildChannel = require_GuildChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var MessageManager = require_MessageManager();
    var BaseGuildVoiceChannel = class extends GuildChannel {
      constructor(guild, data, client) {
        super(guild, data, client, false);
        this.messages = new MessageManager(this);
        this.nsfw = Boolean(data.nsfw);
        this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("rtc_region" in data) {
          this.rtcRegion = data.rtc_region;
        }
        if ("bitrate" in data) {
          this.bitrate = data.bitrate;
        }
        if ("user_limit" in data) {
          this.userLimit = data.user_limit;
        }
        if ("video_quality_mode" in data) {
          this.videoQualityMode = data.video_quality_mode;
        } else {
          this.videoQualityMode ??= null;
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        }
        if ("messages" in data) {
          for (const message of data.messages)
            this.messages._add(message);
        }
        if ("rate_limit_per_user" in data) {
          this.rateLimitPerUser = data.rate_limit_per_user;
        }
        if ("nsfw" in data) {
          this.nsfw = data.nsfw;
        }
      }
      /**
       * The members in this voice-based channel
       * @type {Collection<Snowflake, GuildMember>}
       * @readonly
       */
      get members() {
        const coll = new Collection2();
        for (const state of this.guild.voiceStates.cache.values()) {
          if (state.channelId === this.id && state.member) {
            coll.set(state.id, state.member);
          }
        }
        return coll;
      }
      /**
       * Checks if the voice-based channel is full
       * @type {boolean}
       * @readonly
       */
      get full() {
        return this.userLimit > 0 && this.members.size >= this.userLimit;
      }
      /**
       * Whether the channel is joinable by the client user
       * @type {boolean}
       * @readonly
       */
      get joinable() {
        if (!this.viewable)
          return false;
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        if (permissions.has(PermissionFlagsBits.Administrator, false))
          return true;
        return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.Connect, false);
      }
      /**
       * Creates an invite to this guild channel.
       * @param {InviteCreateOptions} [options={}] The options for creating the invite
       * @returns {Promise<Invite>}
       * @example
       * // Create an invite to a channel
       * channel.createInvite()
       *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))
       *   .catch(console.error);
       */
      createInvite(options) {
        return this.guild.invites.create(this.id, options);
      }
      /**
       * Fetches a collection of invites to this guild channel.
       * @param {boolean} [cache=true] Whether to cache the fetched invites
       * @returns {Promise<Collection<string, Invite>>}
       */
      fetchInvites(cache = true) {
        return this.guild.invites.fetch({ channelId: this.id, cache });
      }
      /**
       * Sets the bitrate of the channel.
       * @param {number} bitrate The new bitrate
       * @param {string} [reason] Reason for changing the channel's bitrate
       * @returns {Promise<BaseGuildVoiceChannel>}
       * @example
       * // Set the bitrate of a voice channel
       * channel.setBitrate(48_000)
       *   .then(channel => console.log(`Set bitrate to ${channel.bitrate}bps for ${channel.name}`))
       *   .catch(console.error);
       */
      setBitrate(bitrate, reason) {
        return this.edit({ bitrate, reason });
      }
      /**
       * Sets the RTC region of the channel.
       * @param {?string} rtcRegion The new region of the channel. Set to `null` to remove a specific region for the channel
       * @param {string} [reason] The reason for modifying this region.
       * @returns {Promise<BaseGuildVoiceChannel>}
       * @example
       * // Set the RTC region to sydney
       * channel.setRTCRegion('sydney');
       * @example
       * // Remove a fixed region for this channel - let Discord decide automatically
       * channel.setRTCRegion(null, 'We want to let Discord decide.');
       */
      setRTCRegion(rtcRegion, reason) {
        return this.edit({ rtcRegion, reason });
      }
      /**
       * Sets the user limit of the channel.
       * @param {number} userLimit The new user limit
       * @param {string} [reason] Reason for changing the user limit
       * @returns {Promise<BaseGuildVoiceChannel>}
       * @example
       * // Set the user limit of a voice channel
       * channel.setUserLimit(42)
       *   .then(channel => console.log(`Set user limit to ${channel.userLimit} for ${channel.name}`))
       *   .catch(console.error);
       */
      setUserLimit(userLimit, reason) {
        return this.edit({ userLimit, reason });
      }
      /**
       * Sets the camera video quality mode of the channel.
       * @param {VideoQualityMode} videoQualityMode The new camera video quality mode.
       * @param {string} [reason] Reason for changing the camera video quality mode.
       * @returns {Promise<BaseGuildVoiceChannel>}
       */
      setVideoQualityMode(videoQualityMode, reason) {
        return this.edit({ videoQualityMode, reason });
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      get lastMessage() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      createMessageComponentCollector() {
      }
      awaitMessageComponent() {
      }
      bulkDelete() {
      }
      fetchWebhooks() {
      }
      createWebhook() {
      }
      setRateLimitPerUser() {
      }
      setNSFW() {
      }
    };
    TextBasedChannel.applyToClass(BaseGuildVoiceChannel, true, ["lastPinAt"]);
    module2.exports = BaseGuildVoiceChannel;
  }
});

// node_modules/discord.js/src/structures/StageChannel.js
var require_StageChannel = __commonJS({
  "node_modules/discord.js/src/structures/StageChannel.js"(exports2, module2) {
    "use strict";
    var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    var StageChannel = class extends BaseGuildVoiceChannel {
      _patch(data) {
        super._patch(data);
        if ("topic" in data) {
          this.topic = data.topic;
        }
      }
      /**
       * The stage instance of this stage channel, if it exists
       * @type {?StageInstance}
       * @readonly
       */
      get stageInstance() {
        return this.guild.stageInstances.cache.find((stageInstance) => stageInstance.channelId === this.id) ?? null;
      }
      /**
       * Creates a stage instance associated with this stage channel.
       * @param {StageInstanceCreateOptions} options The options to create the stage instance
       * @returns {Promise<StageInstance>}
       */
      createStageInstance(options) {
        return this.guild.stageInstances.create(this.id, options);
      }
      /**
       * Sets a new topic for the guild channel.
       * @param {?string} topic The new topic for the guild channel
       * @param {string} [reason] Reason for changing the guild channel's topic
       * @returns {Promise<StageChannel>}
       * @example
       * // Set a new channel topic
       * stageChannel.setTopic('needs more rate limiting')
       *   .then(channel => console.log(`Channel's new topic is ${channel.topic}`))
       *   .catch(console.error);
       */
      setTopic(topic, reason) {
        return this.edit({ topic, reason });
      }
    };
    module2.exports = StageChannel;
  }
});

// node_modules/discord.js/src/structures/TextChannel.js
var require_TextChannel = __commonJS({
  "node_modules/discord.js/src/structures/TextChannel.js"(exports2, module2) {
    "use strict";
    var BaseGuildTextChannel = require_BaseGuildTextChannel();
    var TextChannel = class extends BaseGuildTextChannel {
      _patch(data) {
        super._patch(data);
        if ("rate_limit_per_user" in data) {
          this.rateLimitPerUser = data.rate_limit_per_user;
        }
      }
      /**
       * Sets the rate limit per user (slowmode) for this channel.
       * @param {number} rateLimitPerUser The new rate limit in seconds
       * @param {string} [reason] Reason for changing the channel's rate limit
       * @returns {Promise<TextChannel>}
       */
      setRateLimitPerUser(rateLimitPerUser, reason) {
        return this.edit({ rateLimitPerUser, reason });
      }
    };
    module2.exports = TextChannel;
  }
});

// node_modules/discord.js/src/structures/VoiceChannel.js
var require_VoiceChannel = __commonJS({
  "node_modules/discord.js/src/structures/VoiceChannel.js"(exports2, module2) {
    "use strict";
    var { PermissionFlagsBits } = require_v106();
    var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    var VoiceChannel = class extends BaseGuildVoiceChannel {
      /**
       * Whether the channel is joinable by the client user
       * @type {boolean}
       * @readonly
       */
      get joinable() {
        if (!super.joinable)
          return false;
        if (this.full && !this.permissionsFor(this.client.user).has(PermissionFlagsBits.MoveMembers, false))
          return false;
        return true;
      }
      /**
       * Checks if the client has permission to send audio to the voice channel
       * @type {boolean}
       * @readonly
       */
      get speakable() {
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        if (permissions.has(PermissionFlagsBits.Administrator, false))
          return true;
        return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.Speak, false);
      }
    };
    module2.exports = VoiceChannel;
  }
});

// node_modules/discord.js/src/structures/DirectoryChannel.js
var require_DirectoryChannel = __commonJS({
  "node_modules/discord.js/src/structures/DirectoryChannel.js"(exports2, module2) {
    "use strict";
    var { BaseChannel } = require_BaseChannel();
    var DirectoryChannel = class extends BaseChannel {
      constructor(guild, data, client) {
        super(client, data);
        this.guild = guild;
        this.guildId = guild.id;
      }
      _patch(data) {
        super._patch(data);
        this.name = data.name;
      }
    };
    module2.exports = DirectoryChannel;
  }
});

// node_modules/discord.js/src/structures/PartialGroupDMChannel.js
var require_PartialGroupDMChannel = __commonJS({
  "node_modules/discord.js/src/structures/PartialGroupDMChannel.js"(exports2, module2) {
    "use strict";
    var { BaseChannel } = require_BaseChannel();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var PartialGroupDMChannel = class extends BaseChannel {
      constructor(client, data) {
        super(client, data);
        this.flags = null;
        this.name = data.name;
        this.icon = data.icon;
        this.recipients = data.recipients;
      }
      /**
       * The URL to this channel's icon.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.channelIcon(this.id, this.icon, options);
      }
      delete() {
        return Promise.reject(new DiscordjsError2(ErrorCodes2.DeleteGroupDMChannel));
      }
      fetch() {
        return Promise.reject(new DiscordjsError2(ErrorCodes2.FetchGroupDMChannel));
      }
    };
    module2.exports = PartialGroupDMChannel;
  }
});

// node_modules/discord.js/src/managers/GuildForumThreadManager.js
var require_GuildForumThreadManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildForumThreadManager.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var ThreadManager = require_ThreadManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var MessagePayload = require_MessagePayload();
    var GuildForumThreadManager = class extends ThreadManager {
      /**
       * The channel this Manager belongs to
       * @name GuildForumThreadManager#channel
       * @type {ForumChannel}
       */
      /**
       * @typedef {BaseMessageOptions} GuildForumThreadMessageCreateOptions
       * @property {StickerResolvable} [stickers] The stickers to send with the message
       * @property {BitFieldResolvable} [flags] The flags to send with the message
       * <info>Only `MessageFlags.SuppressEmbeds` and `MessageFlags.SuppressNotifications` can be set.</info>
       */
      /**
       * Options for creating a thread.
       * @typedef {StartThreadOptions} GuildForumThreadCreateOptions
       * @property {GuildForumThreadMessageCreateOptions|MessagePayload} message The message associated with the thread post
       * @property {Snowflake[]} [appliedTags] The tags to apply to the thread
       */
      /**
       * Creates a new thread in the channel.
       * @param {GuildForumThreadCreateOptions} [options] Options to create a new thread
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Create a new forum post
       * forum.threads
       *   .create({
       *     name: 'Food Talk',
       *     autoArchiveDuration: ThreadAutoArchiveDuration.OneHour,
       *     message: {
       *      content: 'Discuss your favorite food!',
       *     },
       *     reason: 'Needed a separate thread for food',
       *   })
       *   .then(threadChannel => console.log(threadChannel))
       *   .catch(console.error);
       */
      async create({
        name,
        autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
        message,
        reason,
        rateLimitPerUser,
        appliedTags
      } = {}) {
        if (!message) {
          throw new DiscordjsTypeError2(ErrorCodes2.GuildForumMessageRequired);
        }
        const { body, files } = await (message instanceof MessagePayload ? message : MessagePayload.create(this, message)).resolveBody().resolveFiles();
        const data = await this.client.rest.post(Routes2.threads(this.channel.id), {
          body: {
            name,
            auto_archive_duration: autoArchiveDuration,
            rate_limit_per_user: rateLimitPerUser,
            applied_tags: appliedTags,
            message: body
          },
          files,
          reason
        });
        return this.client.actions.ThreadCreate.handle(data).thread;
      }
    };
    module2.exports = GuildForumThreadManager;
  }
});

// node_modules/discord.js/src/structures/ForumChannel.js
var require_ForumChannel = __commonJS({
  "node_modules/discord.js/src/structures/ForumChannel.js"(exports2, module2) {
    "use strict";
    var GuildChannel = require_GuildChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var GuildForumThreadManager = require_GuildForumThreadManager();
    var { transformAPIGuildForumTag, transformAPIGuildDefaultReaction } = require_Channels();
    var ForumChannel = class extends GuildChannel {
      constructor(guild, data, client) {
        super(guild, data, client, false);
        this.threads = new GuildForumThreadManager(this);
        this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("available_tags" in data) {
          this.availableTags = data.available_tags.map((tag) => transformAPIGuildForumTag(tag));
        } else {
          this.availableTags ??= [];
        }
        if ("default_reaction_emoji" in data) {
          this.defaultReactionEmoji = data.default_reaction_emoji ? transformAPIGuildDefaultReaction(data.default_reaction_emoji) : null;
        } else {
          this.defaultReactionEmoji ??= null;
        }
        if ("default_thread_rate_limit_per_user" in data) {
          this.defaultThreadRateLimitPerUser = data.default_thread_rate_limit_per_user;
        } else {
          this.defaultThreadRateLimitPerUser ??= null;
        }
        if ("rate_limit_per_user" in data) {
          this.rateLimitPerUser = data.rate_limit_per_user;
        } else {
          this.rateLimitPerUser ??= null;
        }
        if ("default_auto_archive_duration" in data) {
          this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
        } else {
          this.defaultAutoArchiveDuration ??= null;
        }
        if ("nsfw" in data) {
          this.nsfw = data.nsfw;
        } else {
          this.nsfw ??= false;
        }
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("default_sort_order" in data) {
          this.defaultSortOrder = data.default_sort_order;
        } else {
          this.defaultSortOrder ??= null;
        }
        this.defaultForumLayout = data.default_forum_layout;
      }
      /**
       * Sets the available tags for this forum channel
       * @param {GuildForumTagData[]} availableTags The tags to set as available in this channel
       * @param {string} [reason] Reason for changing the available tags
       * @returns {Promise<ForumChannel>}
       */
      setAvailableTags(availableTags, reason) {
        return this.edit({ availableTags, reason });
      }
      /**
       * Sets the default reaction emoji for this channel
       * @param {?DefaultReactionEmoji} defaultReactionEmoji The emoji to set as the default reaction emoji
       * @param {string} [reason] Reason for changing the default reaction emoji
       * @returns {Promise<ForumChannel>}
       */
      setDefaultReactionEmoji(defaultReactionEmoji, reason) {
        return this.edit({ defaultReactionEmoji, reason });
      }
      /**
       * Sets the default rate limit per user (slowmode) for new threads in this channel
       * @param {number} defaultThreadRateLimitPerUser The rate limit to set on newly created threads in this channel
       * @param {string} [reason] Reason for changing the default rate limit
       * @returns {Promise<ForumChannel>}
       */
      setDefaultThreadRateLimitPerUser(defaultThreadRateLimitPerUser, reason) {
        return this.edit({ defaultThreadRateLimitPerUser, reason });
      }
      /**
       * Creates an invite to this guild channel.
       * @param {InviteCreateOptions} [options={}] The options for creating the invite
       * @returns {Promise<Invite>}
       * @example
       * // Create an invite to a channel
       * channel.createInvite()
       *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))
       *   .catch(console.error);
       */
      createInvite(options) {
        return this.guild.invites.create(this.id, options);
      }
      /**
       * Fetches a collection of invites to this guild channel.
       * Resolves with a collection mapping invites by their codes.
       * @param {boolean} [cache=true] Whether to cache the fetched invites
       * @returns {Promise<Collection<string, Invite>>}
       */
      fetchInvites(cache) {
        return this.guild.invites.fetch({ channelId: this.id, cache });
      }
      /**
       * Sets the default auto archive duration for all newly created threads in this channel.
       * @param {ThreadAutoArchiveDuration} defaultAutoArchiveDuration The new default auto archive duration
       * @param {string} [reason] Reason for changing the channel's default auto archive duration
       * @returns {Promise<ForumChannel>}
       */
      setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
        return this.edit({ defaultAutoArchiveDuration, reason });
      }
      /**
       * Sets a new topic for the guild channel.
       * @param {?string} topic The new topic for the guild channel
       * @param {string} [reason] Reason for changing the guild channel's topic
       * @returns {Promise<ForumChannel>}
       * @example
       * // Set a new channel topic
       * channel.setTopic('needs more rate limiting')
       *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))
       *   .catch(console.error);
       */
      setTopic(topic, reason) {
        return this.edit({ topic, reason });
      }
      /**
       * Sets the default sort order mode used to order posts
       * @param {?SortOrderType} defaultSortOrder The default sort order mode to set on this channel
       * @param {string} [reason] Reason for changing the default sort order
       * @returns {Promise<ForumChannel>}
       */
      setDefaultSortOrder(defaultSortOrder, reason) {
        return this.edit({ defaultSortOrder, reason });
      }
      /**
       * Sets the default forum layout type used to display posts
       * @param {ForumLayoutType} defaultForumLayout The default forum layout type to set on this channel
       * @param {string} [reason] Reason for changing the default forum layout
       * @returns {Promise<ForumChannel>}
       */
      setDefaultForumLayout(defaultForumLayout, reason) {
        return this.edit({ defaultForumLayout, reason });
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      createWebhook() {
      }
      fetchWebhooks() {
      }
      setNSFW() {
      }
      setRateLimitPerUser() {
      }
    };
    TextBasedChannel.applyToClass(ForumChannel, true, [
      "send",
      "lastMessage",
      "lastPinAt",
      "bulkDelete",
      "sendTyping",
      "createMessageCollector",
      "awaitMessages",
      "createMessageComponentCollector",
      "awaitMessageComponent"
    ]);
    module2.exports = ForumChannel;
  }
});

// node_modules/discord.js/src/util/Channels.js
var require_Channels = __commonJS({
  "node_modules/discord.js/src/util/Channels.js"(exports2, module2) {
    "use strict";
    var { lazy } = require_dist2();
    var { ChannelType } = require_v106();
    var getCategoryChannel = lazy(() => require_CategoryChannel());
    var getDMChannel = lazy(() => require_DMChannel());
    var getNewsChannel = lazy(() => require_NewsChannel());
    var getStageChannel = lazy(() => require_StageChannel());
    var getTextChannel = lazy(() => require_TextChannel());
    var getThreadChannel = lazy(() => require_ThreadChannel());
    var getVoiceChannel = lazy(() => require_VoiceChannel());
    var getDirectoryChannel = lazy(() => require_DirectoryChannel());
    var getPartialGroupDMChannel = lazy(() => require_PartialGroupDMChannel());
    var getForumChannel = lazy(() => require_ForumChannel());
    function createChannel(client, data, guild, { allowUnknownGuild, fromInteraction } = {}) {
      let channel;
      if (!data.guild_id && !guild) {
        if (data.recipients && data.type !== ChannelType.GroupDM || data.type === ChannelType.DM) {
          channel = new (getDMChannel())(client, data);
        } else if (data.type === ChannelType.GroupDM) {
          channel = new (getPartialGroupDMChannel())(client, data);
        }
      } else {
        guild ??= client.guilds.cache.get(data.guild_id);
        if (guild || allowUnknownGuild) {
          switch (data.type) {
            case ChannelType.GuildText: {
              channel = new (getTextChannel())(guild, data, client);
              break;
            }
            case ChannelType.GuildVoice: {
              channel = new (getVoiceChannel())(guild, data, client);
              break;
            }
            case ChannelType.GuildCategory: {
              channel = new (getCategoryChannel())(guild, data, client);
              break;
            }
            case ChannelType.GuildAnnouncement: {
              channel = new (getNewsChannel())(guild, data, client);
              break;
            }
            case ChannelType.GuildStageVoice: {
              channel = new (getStageChannel())(guild, data, client);
              break;
            }
            case ChannelType.AnnouncementThread:
            case ChannelType.PublicThread:
            case ChannelType.PrivateThread: {
              channel = new (getThreadChannel())(guild, data, client, fromInteraction);
              if (!allowUnknownGuild)
                channel.parent?.threads.cache.set(channel.id, channel);
              break;
            }
            case ChannelType.GuildDirectory:
              channel = new (getDirectoryChannel())(guild, data, client);
              break;
            case ChannelType.GuildForum:
              channel = new (getForumChannel())(guild, data, client);
              break;
          }
          if (channel && !allowUnknownGuild)
            guild.channels?.cache.set(channel.id, channel);
        }
      }
      return channel;
    }
    function transformAPIGuildForumTag(tag) {
      return {
        id: tag.id,
        name: tag.name,
        moderated: tag.moderated,
        emoji: tag.emoji_id ?? tag.emoji_name ? {
          id: tag.emoji_id,
          name: tag.emoji_name
        } : null
      };
    }
    function transformGuildForumTag(tag) {
      return {
        id: tag.id,
        name: tag.name,
        moderated: tag.moderated,
        emoji_id: tag.emoji?.id ?? null,
        emoji_name: tag.emoji?.name ?? null
      };
    }
    function transformAPIGuildDefaultReaction(defaultReaction) {
      return {
        id: defaultReaction.emoji_id,
        name: defaultReaction.emoji_name
      };
    }
    function transformGuildDefaultReaction(defaultReaction) {
      return {
        emoji_id: defaultReaction.id,
        emoji_name: defaultReaction.name
      };
    }
    module2.exports = {
      createChannel,
      transformAPIGuildForumTag,
      transformGuildForumTag,
      transformAPIGuildDefaultReaction,
      transformGuildDefaultReaction
    };
  }
});

// node_modules/discord.js/src/client/actions/ChannelUpdate.js
var require_ChannelUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/ChannelUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { createChannel } = require_Channels();
    var ChannelUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        let channel = client.channels.cache.get(data.id);
        if (channel) {
          const old = channel._update(data);
          if (channel.type !== data.type) {
            const newChannel = createChannel(this.client, data, channel.guild);
            for (const [id, message] of channel.messages.cache)
              newChannel.messages.cache.set(id, message);
            channel = newChannel;
            this.client.channels.cache.set(channel.id, channel);
          }
          return {
            old,
            updated: channel
          };
        } else {
          client.channels._add(data);
        }
        return {};
      }
    };
    module2.exports = ChannelUpdateAction;
  }
});

// node_modules/discord.js/src/structures/AutoModerationRule.js
var require_AutoModerationRule = __commonJS({
  "node_modules/discord.js/src/structures/AutoModerationRule.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Base = require_Base();
    var { _transformAPIAutoModerationAction } = require_Transformers();
    var AutoModerationRule = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.id = data.id;
        this.guild = guild;
        this.creatorId = data.creator_id;
        this.triggerType = data.trigger_type;
        this._patch(data);
      }
      _patch(data) {
        if ("name" in data) {
          this.name = data.name;
        }
        if ("event_type" in data) {
          this.eventType = data.event_type;
        }
        if ("trigger_metadata" in data) {
          this.triggerMetadata = {
            keywordFilter: data.trigger_metadata.keyword_filter ?? [],
            regexPatterns: data.trigger_metadata.regex_patterns ?? [],
            presets: data.trigger_metadata.presets ?? [],
            allowList: data.trigger_metadata.allow_list ?? [],
            mentionTotalLimit: data.trigger_metadata.mention_total_limit ?? null
          };
        }
        if ("actions" in data) {
          this.actions = data.actions.map((action) => _transformAPIAutoModerationAction(action));
        }
        if ("enabled" in data) {
          this.enabled = data.enabled;
        }
        if ("exempt_roles" in data) {
          this.exemptRoles = new Collection2(
            data.exempt_roles.map((exemptRole) => [exemptRole, this.guild.roles.cache.get(exemptRole)])
          );
        }
        if ("exempt_channels" in data) {
          this.exemptChannels = new Collection2(
            data.exempt_channels.map((exemptChannel) => [exemptChannel, this.guild.channels.cache.get(exemptChannel)])
          );
        }
      }
      /**
       * Edits this auto moderation rule.
       * @param {AutoModerationRuleEditOptions} options Options for editing this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      edit(options) {
        return this.guild.autoModerationRules.edit(this.id, options);
      }
      /**
       * Deletes this auto moderation rule.
       * @param {string} [reason] The reason for deleting this auto moderation rule
       * @returns {Promise<void>}
       */
      delete(reason) {
        return this.guild.autoModerationRules.delete(this.id, reason);
      }
      /**
       * Sets the name for this auto moderation rule.
       * @param {string} name The name of this auto moderation rule
       * @param {string} [reason] The reason for changing the name of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Sets the event type for this auto moderation rule.
       * @param {AutoModerationRuleEventType} eventType The event type of this auto moderation rule
       * @param {string} [reason] The reason for changing the event type of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setEventType(eventType, reason) {
        return this.edit({ eventType, reason });
      }
      /**
       * Sets the keyword filter for this auto moderation rule.
       * @param {string[]} keywordFilter The keyword filter of this auto moderation rule
       * @param {string} [reason] The reason for changing the keyword filter of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setKeywordFilter(keywordFilter, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, keywordFilter }, reason });
      }
      /**
       * Sets the regular expression patterns for this auto moderation rule.
       * @param {string[]} regexPatterns The regular expression patterns of this auto moderation rule
       * <info>Only Rust-flavored regular expressions are supported.</info>
       * @param {string} [reason] The reason for changing the regular expression patterns of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setRegexPatterns(regexPatterns, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, regexPatterns }, reason });
      }
      /**
       * Sets the presets for this auto moderation rule.
       * @param {AutoModerationRuleKeywordPresetType[]} presets The presets of this auto moderation rule
       * @param {string} [reason] The reason for changing the presets of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setPresets(presets, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, presets }, reason });
      }
      /**
       * Sets the allow list for this auto moderation rule.
       * @param {string[]} allowList The allow list of this auto moderation rule
       * @param {string} [reason] The reason for changing the allow list of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setAllowList(allowList, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, allowList }, reason });
      }
      /**
       * Sets the mention total limit for this auto moderation rule.
       * @param {number} mentionTotalLimit The mention total limit of this auto moderation rule
       * @param {string} [reason] The reason for changing the mention total limit of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setMentionTotalLimit(mentionTotalLimit, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, mentionTotalLimit }, reason });
      }
      /**
       * Sets the actions for this auto moderation rule.
       * @param {AutoModerationActionOptions[]} actions The actions of this auto moderation rule
       * @param {string} [reason] The reason for changing the actions of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setActions(actions, reason) {
        return this.edit({ actions, reason });
      }
      /**
       * Sets whether this auto moderation rule should be enabled.
       * @param {boolean} [enabled=true] Whether to enable this auto moderation rule
       * @param {string} [reason] The reason for enabling or disabling this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setEnabled(enabled = true, reason) {
        return this.edit({ enabled, reason });
      }
      /**
       * Sets the exempt roles for this auto moderation rule.
       * @param {Collection<Snowflake, Role>|RoleResolvable[]} [exemptRoles] The exempt roles of this auto moderation rule
       * @param {string} [reason] The reason for changing the exempt roles of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setExemptRoles(exemptRoles, reason) {
        return this.edit({ exemptRoles, reason });
      }
      /**
       * Sets the exempt channels for this auto moderation rule.
       * @param {Collection<Snowflake, GuildChannel|ThreadChannel>|GuildChannelResolvable[]} [exemptChannels]
       * The exempt channels of this auto moderation rule
       * @param {string} [reason] The reason for changing the exempt channels of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setExemptChannels(exemptChannels, reason) {
        return this.edit({ exemptChannels, reason });
      }
    };
    module2.exports = AutoModerationRule;
  }
});

// node_modules/discord.js/src/structures/Integration.js
var require_Integration = __commonJS({
  "node_modules/discord.js/src/structures/Integration.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var Base = require_Base();
    var IntegrationApplication = require_IntegrationApplication();
    var Integration = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this.id = data.id;
        this.name = data.name;
        this.type = data.type;
        this.enabled = data.enabled ?? null;
        if ("syncing" in data) {
          this.syncing = data.syncing;
        } else {
          this.syncing ??= null;
        }
        this.role = this.guild.roles.resolve(data.role_id);
        if ("enable_emoticons" in data) {
          this.enableEmoticons = data.enable_emoticons;
        } else {
          this.enableEmoticons ??= null;
        }
        if (data.user) {
          this.user = this.client.users._add(data.user);
        } else {
          this.user ??= null;
        }
        this.account = data.account;
        if ("synced_at" in data) {
          this.syncedTimestamp = Date.parse(data.synced_at);
        } else {
          this.syncedTimestamp ??= null;
        }
        if ("subscriber_count" in data) {
          this.subscriberCount = data.subscriber_count;
        } else {
          this.subscriberCount ??= null;
        }
        if ("revoked" in data) {
          this.revoked = data.revoked;
        } else {
          this.revoked ??= null;
        }
        this._patch(data);
      }
      /**
       * The date at which this integration was last synced at
       * @type {?Date}
       * @readonly
       */
      get syncedAt() {
        return this.syncedTimestamp && new Date(this.syncedTimestamp);
      }
      /**
       * All roles that are managed by this integration
       * @type {Collection<Snowflake, Role>}
       * @readonly
       */
      get roles() {
        const roles = this.guild.roles.cache;
        return roles.filter((role) => role.tags?.integrationId === this.id);
      }
      _patch(data) {
        if ("expire_behavior" in data) {
          this.expireBehavior = data.expire_behavior;
        } else {
          this.expireBehavior ??= null;
        }
        if ("expire_grace_period" in data) {
          this.expireGracePeriod = data.expire_grace_period;
        } else {
          this.expireGracePeriod ??= null;
        }
        if ("application" in data) {
          if (this.application) {
            this.application._patch(data.application);
          } else {
            this.application = new IntegrationApplication(this.client, data.application);
          }
        } else {
          this.application ??= null;
        }
        if ("scopes" in data) {
          this.scopes = data.scopes;
        } else {
          this.scopes ??= [];
        }
      }
      /**
       * Deletes this integration.
       * @returns {Promise<Integration>}
       * @param {string} [reason] Reason for deleting this integration
       */
      async delete(reason) {
        await this.client.rest.delete(Routes2.guildIntegration(this.guild.id, this.id), { reason });
        return this;
      }
      toJSON() {
        return super.toJSON({
          role: "roleId",
          guild: "guildId",
          user: "userId"
        });
      }
    };
    module2.exports = Integration;
  }
});

// node_modules/discord.js/src/structures/StageInstance.js
var require_StageInstance = __commonJS({
  "node_modules/discord.js/src/structures/StageInstance.js"(exports2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var StageInstance = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this._patch(data);
      }
      _patch(data) {
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        }
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("privacy_level" in data) {
          this.privacyLevel = data.privacy_level;
        }
        if ("discoverable_disabled" in data) {
          this.discoverableDisabled = data.discoverable_disabled;
        } else {
          this.discoverableDisabled ??= null;
        }
        if ("guild_scheduled_event_id" in data) {
          this.guildScheduledEventId = data.guild_scheduled_event_id;
        } else {
          this.guildScheduledEventId ??= null;
        }
      }
      /**
       * The stage channel associated with this stage instance
       * @type {?StageChannel}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * The guild this stage instance belongs to
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      /**
       * The associated guild scheduled event of this stage instance
       * @type {?GuildScheduledEvent}
       * @readonly
       */
      get guildScheduledEvent() {
        return this.guild?.scheduledEvents.resolve(this.guildScheduledEventId) ?? null;
      }
      /**
       * Edits this stage instance.
       * @param {StageInstanceEditOptions} options The options to edit the stage instance
       * @returns {Promise<StageInstance>}
       * @example
       * // Edit a stage instance
       * stageInstance.edit({ topic: 'new topic' })
       *  .then(stageInstance => console.log(stageInstance))
       *  .catch(console.error)
       */
      edit(options) {
        return this.guild.stageInstances.edit(this.channelId, options);
      }
      /**
       * Deletes this stage instance.
       * @returns {Promise<StageInstance>}
       * @example
       * // Delete a stage instance
       * stageInstance.delete()
       *  .then(stageInstance => console.log(stageInstance))
       *  .catch(console.error);
       */
      async delete() {
        await this.guild.stageInstances.delete(this.channelId);
        const clone = this._clone();
        return clone;
      }
      /**
       * Sets the topic of this stage instance.
       * @param {string} topic The topic for the stage instance
       * @returns {Promise<StageInstance>}
       * @example
       * // Set topic of a stage instance
       * stageInstance.setTopic('new topic')
       *  .then(stageInstance => console.log(`Set the topic to: ${stageInstance.topic}`))
       *  .catch(console.error);
       */
      setTopic(topic) {
        return this.guild.stageInstances.edit(this.channelId, { topic });
      }
      /**
       * The timestamp this stage instances was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time this stage instance was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
    };
    exports2.StageInstance = StageInstance;
  }
});

// node_modules/discord.js/src/structures/GuildAuditLogsEntry.js
var require_GuildAuditLogsEntry = __commonJS({
  "node_modules/discord.js/src/structures/GuildAuditLogsEntry.js"(exports2, module2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { AuditLogOptionsType, AuditLogEvent } = require_v106();
    var AutoModerationRule = require_AutoModerationRule();
    var { GuildScheduledEvent } = require_GuildScheduledEvent();
    var Integration = require_Integration();
    var Invite2 = require_Invite();
    var { StageInstance } = require_StageInstance();
    var { Sticker: Sticker2 } = require_Sticker();
    var Webhook2 = require_Webhook();
    var Partials = require_Partials();
    var { flatten } = require_Util();
    var Targets = {
      All: "All",
      Guild: "Guild",
      GuildScheduledEvent: "GuildScheduledEvent",
      Channel: "Channel",
      User: "User",
      Role: "Role",
      Invite: "Invite",
      Webhook: "Webhook",
      Emoji: "Emoji",
      Message: "Message",
      Integration: "Integration",
      StageInstance: "StageInstance",
      Sticker: "Sticker",
      Thread: "Thread",
      ApplicationCommand: "ApplicationCommand",
      AutoModeration: "AutoModeration",
      Unknown: "Unknown"
    };
    var _GuildAuditLogsEntry = class {
      constructor(guild, data, logs) {
        this.targetType = _GuildAuditLogsEntry.targetType(data.action_type);
        const targetType = this.targetType;
        this.actionType = _GuildAuditLogsEntry.actionType(data.action_type);
        this.action = data.action_type;
        this.reason = data.reason ?? null;
        this.executorId = data.user_id;
        this.executor = data.user_id ? guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.user_id }) : guild.client.users.cache.get(data.user_id) ?? null : null;
        this.changes = data.changes?.map((c) => ({ key: c.key, old: c.old_value, new: c.new_value })) ?? [];
        this.id = data.id;
        this.extra = null;
        switch (data.action_type) {
          case AuditLogEvent.MemberPrune:
            this.extra = {
              removed: Number(data.options.members_removed),
              days: Number(data.options.delete_member_days)
            };
            break;
          case AuditLogEvent.MemberMove:
          case AuditLogEvent.MessageDelete:
          case AuditLogEvent.MessageBulkDelete:
            this.extra = {
              channel: guild.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
              count: Number(data.options.count)
            };
            break;
          case AuditLogEvent.MessagePin:
          case AuditLogEvent.MessageUnpin:
            this.extra = {
              channel: guild.client.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
              messageId: data.options.message_id
            };
            break;
          case AuditLogEvent.MemberDisconnect:
            this.extra = {
              count: Number(data.options.count)
            };
            break;
          case AuditLogEvent.ChannelOverwriteCreate:
          case AuditLogEvent.ChannelOverwriteUpdate:
          case AuditLogEvent.ChannelOverwriteDelete:
            switch (data.options.type) {
              case AuditLogOptionsType.Role:
                this.extra = guild.roles.cache.get(data.options.id) ?? {
                  id: data.options.id,
                  name: data.options.role_name,
                  type: AuditLogOptionsType.Role
                };
                break;
              case AuditLogOptionsType.Member:
                this.extra = guild.members.cache.get(data.options.id) ?? {
                  id: data.options.id,
                  type: AuditLogOptionsType.Member
                };
                break;
              default:
                break;
            }
            break;
          case AuditLogEvent.StageInstanceCreate:
          case AuditLogEvent.StageInstanceDelete:
          case AuditLogEvent.StageInstanceUpdate:
            this.extra = {
              channel: guild.client.channels.cache.get(data.options?.channel_id) ?? { id: data.options?.channel_id }
            };
            break;
          case AuditLogEvent.ApplicationCommandPermissionUpdate:
            this.extra = {
              applicationId: data.options.application_id
            };
            break;
          case AuditLogEvent.AutoModerationBlockMessage:
          case AuditLogEvent.AutoModerationFlagToChannel:
          case AuditLogEvent.AutoModerationUserCommunicationDisabled:
            this.extra = {
              autoModerationRuleName: data.options.auto_moderation_rule_name,
              autoModerationRuleTriggerType: data.options.auto_moderation_rule_trigger_type
            };
            break;
          default:
            break;
        }
        this.targetId = data.target_id;
        this.target = null;
        if (targetType === Targets.Unknown) {
          this.target = this.changes.reduce((o, c) => {
            o[c.key] = c.new ?? c.old;
            return o;
          }, {});
          this.target.id = data.target_id;
        } else if (targetType === Targets.User && data.target_id) {
          this.target = guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.target_id }) : guild.client.users.cache.get(data.target_id) ?? null;
        } else if (targetType === Targets.Guild) {
          this.target = guild.client.guilds.cache.get(data.target_id);
        } else if (targetType === Targets.Webhook) {
          this.target = logs?.webhooks.get(data.target_id) ?? new Webhook2(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              {
                id: data.target_id,
                guild_id: guild.id
              }
            )
          );
        } else if (targetType === Targets.Invite) {
          let change = this.changes.find((c) => c.key === "code");
          change = change.new ?? change.old;
          this.target = guild.invites.cache.get(change) ?? new Invite2(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              { guild }
            )
          );
        } else if (targetType === Targets.Message) {
          this.target = data.action_type === AuditLogEvent.MessageBulkDelete ? guild.channels.cache.get(data.target_id) ?? { id: data.target_id } : guild.client.users.cache.get(data.target_id) ?? null;
        } else if (targetType === Targets.Integration) {
          this.target = logs?.integrations.get(data.target_id) ?? new Integration(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              { id: data.target_id }
            ),
            guild
          );
        } else if (targetType === Targets.Channel || targetType === Targets.Thread) {
          this.target = guild.channels.cache.get(data.target_id) ?? this.changes.reduce(
            (o, c) => {
              o[c.key] = c.new ?? c.old;
              return o;
            },
            { id: data.target_id }
          );
        } else if (targetType === Targets.StageInstance) {
          this.target = guild.stageInstances.cache.get(data.target_id) ?? new StageInstance(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              {
                id: data.target_id,
                channel_id: data.options?.channel_id,
                guild_id: guild.id
              }
            )
          );
        } else if (targetType === Targets.Sticker) {
          this.target = guild.stickers.cache.get(data.target_id) ?? new Sticker2(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              { id: data.target_id }
            )
          );
        } else if (targetType === Targets.GuildScheduledEvent) {
          this.target = guild.scheduledEvents.cache.get(data.target_id) ?? new GuildScheduledEvent(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              { id: data.target_id, guild_id: guild.id }
            )
          );
        } else if (targetType === Targets.ApplicationCommand) {
          this.target = logs?.applicationCommands.get(data.target_id) ?? { id: data.target_id };
        } else if (targetType === Targets.AutoModeration) {
          this.target = guild.autoModerationRules.cache.get(data.target_id) ?? new AutoModerationRule(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              { id: data.target_id, guild_id: guild.id }
            ),
            guild
          );
        } else if (data.target_id) {
          this.target = guild[`${targetType.toLowerCase()}s`]?.cache.get(data.target_id) ?? { id: data.target_id };
        }
      }
      /**
       * Finds the target type of a guild audit log entry.
       * @param {AuditLogEvent} target The action target
       * @returns {AuditLogTargetType}
       */
      static targetType(target) {
        if (target < 10)
          return Targets.Guild;
        if (target < 20)
          return Targets.Channel;
        if (target < 30)
          return Targets.User;
        if (target < 40)
          return Targets.Role;
        if (target < 50)
          return Targets.Invite;
        if (target < 60)
          return Targets.Webhook;
        if (target < 70)
          return Targets.Emoji;
        if (target < 80)
          return Targets.Message;
        if (target < 83)
          return Targets.Integration;
        if (target < 86)
          return Targets.StageInstance;
        if (target < 100)
          return Targets.Sticker;
        if (target < 110)
          return Targets.GuildScheduledEvent;
        if (target < 120)
          return Targets.Thread;
        if (target < 130)
          return Targets.ApplicationCommand;
        if (target >= 140 && target < 150)
          return Targets.AutoModeration;
        return Targets.Unknown;
      }
      /**
       * Finds the action type from the guild audit log entry action.
       * @param {AuditLogEvent} action The action target
       * @returns {AuditLogActionType}
       */
      static actionType(action) {
        if ([
          AuditLogEvent.ChannelCreate,
          AuditLogEvent.ChannelOverwriteCreate,
          AuditLogEvent.MemberBanRemove,
          AuditLogEvent.BotAdd,
          AuditLogEvent.RoleCreate,
          AuditLogEvent.InviteCreate,
          AuditLogEvent.WebhookCreate,
          AuditLogEvent.EmojiCreate,
          AuditLogEvent.MessagePin,
          AuditLogEvent.IntegrationCreate,
          AuditLogEvent.StageInstanceCreate,
          AuditLogEvent.StickerCreate,
          AuditLogEvent.GuildScheduledEventCreate,
          AuditLogEvent.ThreadCreate,
          AuditLogEvent.AutoModerationRuleCreate,
          AuditLogEvent.AutoModerationBlockMessage
        ].includes(action)) {
          return "Create";
        }
        if ([
          AuditLogEvent.ChannelDelete,
          AuditLogEvent.ChannelOverwriteDelete,
          AuditLogEvent.MemberKick,
          AuditLogEvent.MemberPrune,
          AuditLogEvent.MemberBanAdd,
          AuditLogEvent.MemberDisconnect,
          AuditLogEvent.RoleDelete,
          AuditLogEvent.InviteDelete,
          AuditLogEvent.WebhookDelete,
          AuditLogEvent.EmojiDelete,
          AuditLogEvent.MessageDelete,
          AuditLogEvent.MessageBulkDelete,
          AuditLogEvent.MessageUnpin,
          AuditLogEvent.IntegrationDelete,
          AuditLogEvent.StageInstanceDelete,
          AuditLogEvent.StickerDelete,
          AuditLogEvent.GuildScheduledEventDelete,
          AuditLogEvent.ThreadDelete,
          AuditLogEvent.AutoModerationRuleDelete
        ].includes(action)) {
          return "Delete";
        }
        if ([
          AuditLogEvent.GuildUpdate,
          AuditLogEvent.ChannelUpdate,
          AuditLogEvent.ChannelOverwriteUpdate,
          AuditLogEvent.MemberUpdate,
          AuditLogEvent.MemberRoleUpdate,
          AuditLogEvent.MemberMove,
          AuditLogEvent.RoleUpdate,
          AuditLogEvent.InviteUpdate,
          AuditLogEvent.WebhookUpdate,
          AuditLogEvent.EmojiUpdate,
          AuditLogEvent.IntegrationUpdate,
          AuditLogEvent.StageInstanceUpdate,
          AuditLogEvent.StickerUpdate,
          AuditLogEvent.GuildScheduledEventUpdate,
          AuditLogEvent.ThreadUpdate,
          AuditLogEvent.ApplicationCommandPermissionUpdate,
          AuditLogEvent.AutoModerationRuleUpdate
        ].includes(action)) {
          return "Update";
        }
        return "All";
      }
      /**
       * The timestamp this entry was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time this entry was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      toJSON() {
        return flatten(this, { createdTimestamp: true });
      }
    };
    var GuildAuditLogsEntry = _GuildAuditLogsEntry;
    /**
     * Key mirror of all available audit log targets.
     * @type {Object<string, string>}
     * @memberof GuildAuditLogsEntry
     */
    __publicField(GuildAuditLogsEntry, "Targets", Targets);
    module2.exports = GuildAuditLogsEntry;
  }
});

// node_modules/discord.js/src/client/actions/GuildAuditLogEntryCreate.js
var require_GuildAuditLogEntryCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildAuditLogEntryCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
    var Events3 = require_Events();
    var GuildAuditLogEntryCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        let auditLogEntry;
        if (guild) {
          auditLogEntry = new GuildAuditLogsEntry(guild, data);
          client.emit(Events3.GuildAuditLogEntryCreate, auditLogEntry, guild);
        }
        return { auditLogEntry };
      }
    };
    module2.exports = GuildAuditLogEntryCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildBanAdd.js
var require_GuildBanAdd = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildBanAdd.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildBanAdd = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild)
          client.emit(Events3.GuildBanAdd, guild.bans._add(data));
      }
    };
    module2.exports = GuildBanAdd;
  }
});

// node_modules/discord.js/src/structures/GuildBan.js
var require_GuildBan = __commonJS({
  "node_modules/discord.js/src/structures/GuildBan.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var GuildBan = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this._patch(data);
      }
      _patch(data) {
        if ("user" in data) {
          this.user = this.client.users._add(data.user, true);
        }
        if ("reason" in data) {
          this.reason = data.reason;
        }
      }
      /**
       * Whether this GuildBan is partial. If the reason is not provided the value is null
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return !("reason" in this);
      }
      /**
       * Fetches this GuildBan.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<GuildBan>}
       */
      fetch(force = true) {
        return this.guild.bans.fetch({ user: this.user, cache: true, force });
      }
    };
    module2.exports = GuildBan;
  }
});

// node_modules/discord.js/src/client/actions/GuildBanRemove.js
var require_GuildBanRemove = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildBanRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildBan = require_GuildBan();
    var Events3 = require_Events();
    var GuildBanRemove = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const ban = guild.bans.cache.get(data.user.id) ?? new GuildBan(client, data, guild);
          guild.bans.cache.delete(ban.user.id);
          client.emit(Events3.GuildBanRemove, ban);
        }
      }
    };
    module2.exports = GuildBanRemove;
  }
});

// node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js
var require_GuildChannelsPositionUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildChannelsPositionUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          for (const partialChannel of data.channels) {
            const channel = guild.channels.cache.get(partialChannel.id);
            if (channel)
              channel.rawPosition = partialChannel.position;
          }
        }
        return { guild };
      }
    };
    module2.exports = GuildChannelsPositionUpdate;
  }
});

// node_modules/discord.js/src/client/actions/GuildDelete.js
var require_GuildDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        let guild = client.guilds.cache.get(data.id);
        if (guild) {
          if (data.unavailable) {
            guild.available = false;
            client.emit(Events3.GuildUnavailable, guild);
            return;
          }
          for (const channel of guild.channels.cache.values())
            this.client.channels._remove(channel.id);
          client.voice.adapters.get(data.id)?.destroy();
          client.guilds.cache.delete(guild.id);
          client.emit(Events3.GuildDelete, guild);
        }
      }
    };
    module2.exports = GuildDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildEmojiCreate.js
var require_GuildEmojiCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildEmojiCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildEmojiCreateAction = class extends Action {
      handle(guild, createdEmoji) {
        const already = guild.emojis.cache.has(createdEmoji.id);
        const emoji = guild.emojis._add(createdEmoji);
        if (!already)
          this.client.emit(Events3.GuildEmojiCreate, emoji);
        return { emoji };
      }
    };
    module2.exports = GuildEmojiCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildEmojiDelete.js
var require_GuildEmojiDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildEmojiDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildEmojiDeleteAction = class extends Action {
      handle(emoji) {
        emoji.guild.emojis.cache.delete(emoji.id);
        this.client.emit(Events3.GuildEmojiDelete, emoji);
        return { emoji };
      }
    };
    module2.exports = GuildEmojiDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js
var require_GuildEmojiUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildEmojiUpdateAction = class extends Action {
      handle(current, data) {
        const old = current._update(data);
        this.client.emit(Events3.GuildEmojiUpdate, old, current);
        return { emoji: current };
      }
    };
    module2.exports = GuildEmojiUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js
var require_GuildEmojisUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildEmojisUpdateAction = class extends Action {
      handle(data) {
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (!guild?.emojis)
          return;
        const deletions = new Map(guild.emojis.cache);
        for (const emoji of data.emojis) {
          const cachedEmoji = guild.emojis.cache.get(emoji.id);
          if (cachedEmoji) {
            deletions.delete(emoji.id);
            if (!cachedEmoji.equals(emoji)) {
              this.client.actions.GuildEmojiUpdate.handle(cachedEmoji, emoji);
            }
          } else {
            this.client.actions.GuildEmojiCreate.handle(guild, emoji);
          }
        }
        for (const emoji of deletions.values()) {
          this.client.actions.GuildEmojiDelete.handle(emoji);
        }
      }
    };
    module2.exports = GuildEmojisUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildIntegrationsUpdate.js
var require_GuildIntegrationsUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildIntegrationsUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildIntegrationsUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild)
          client.emit(Events3.GuildIntegrationsUpdate, guild);
      }
    };
    module2.exports = GuildIntegrationsUpdate;
  }
});

// node_modules/discord.js/src/util/Status.js
var require_Status = __commonJS({
  "node_modules/discord.js/src/util/Status.js"(exports2, module2) {
    "use strict";
    var { createEnum } = require_Enums();
    module2.exports = createEnum([
      "Ready",
      "Connecting",
      "Reconnecting",
      "Idle",
      "Nearly",
      "Disconnected",
      "WaitingForGuilds",
      "Identifying",
      "Resuming"
    ]);
  }
});

// node_modules/discord.js/src/client/actions/GuildMemberRemove.js
var require_GuildMemberRemove = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildMemberRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var Status2 = require_Status();
    var GuildMemberRemoveAction = class extends Action {
      handle(data, shard) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        let member = null;
        if (guild) {
          member = this.getMember({ user: data.user }, guild);
          guild.memberCount--;
          if (member) {
            guild.members.cache.delete(member.id);
            if (shard.status === Status2.Ready)
              client.emit(Events3.GuildMemberRemove, member);
          }
          guild.presences.cache.delete(data.user.id);
          guild.voiceStates.cache.delete(data.user.id);
        }
        return { guild, member };
      }
    };
    module2.exports = GuildMemberRemoveAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildMemberUpdate.js
var require_GuildMemberUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildMemberUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var Status2 = require_Status();
    var GuildMemberUpdateAction = class extends Action {
      handle(data, shard) {
        const { client } = this;
        if (data.user.username) {
          const user = client.users.cache.get(data.user.id);
          if (!user) {
            client.users._add(data.user);
          } else if (!user._equals(data.user)) {
            client.actions.UserUpdate.handle(data.user);
          }
        }
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const member = this.getMember({ user: data.user }, guild);
          if (member) {
            const old = member._update(data);
            if (shard.status === Status2.Ready && !member.equals(old))
              client.emit(Events3.GuildMemberUpdate, old, member);
          } else {
            const newMember = guild.members._add(data);
            this.client.emit(Events3.GuildMemberAvailable, newMember);
          }
        }
      }
    };
    module2.exports = GuildMemberUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildRoleCreate.js
var require_GuildRoleCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildRoleCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildRoleCreate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        let role;
        if (guild) {
          const already = guild.roles.cache.has(data.role.id);
          role = guild.roles._add(data.role);
          if (!already)
            client.emit(Events3.GuildRoleCreate, role);
        }
        return { role };
      }
    };
    module2.exports = GuildRoleCreate;
  }
});

// node_modules/discord.js/src/client/actions/GuildRoleDelete.js
var require_GuildRoleDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildRoleDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildRoleDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        let role;
        if (guild) {
          role = guild.roles.cache.get(data.role_id);
          if (role) {
            guild.roles.cache.delete(data.role_id);
            client.emit(Events3.GuildRoleDelete, role);
          }
        }
        return { role };
      }
    };
    module2.exports = GuildRoleDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildRoleUpdate.js
var require_GuildRoleUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildRoleUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildRoleUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          let old = null;
          const role = guild.roles.cache.get(data.role.id);
          if (role) {
            old = role._update(data.role);
            client.emit(Events3.GuildRoleUpdate, old, role);
          }
          return {
            old,
            updated: role
          };
        }
        return {
          old: null,
          updated: null
        };
      }
    };
    module2.exports = GuildRoleUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js
var require_GuildRolesPositionUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildRolesPositionUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          for (const partialRole of data.roles) {
            const role = guild.roles.cache.get(partialRole.id);
            if (role)
              role.rawPosition = partialRole.position;
          }
        }
        return { guild };
      }
    };
    module2.exports = GuildRolesPositionUpdate;
  }
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventCreate.js
var require_GuildScheduledEventCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildScheduledEventCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildScheduledEventCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = guild.scheduledEvents._add(data);
          client.emit(Events3.GuildScheduledEventCreate, guildScheduledEvent);
          return { guildScheduledEvent };
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventDelete.js
var require_GuildScheduledEventDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildScheduledEventDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildScheduledEventDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = this.getScheduledEvent(data, guild);
          if (guildScheduledEvent) {
            guild.scheduledEvents.cache.delete(guildScheduledEvent.id);
            client.emit(Events3.GuildScheduledEventDelete, guildScheduledEvent);
            return { guildScheduledEvent };
          }
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUpdate.js
var require_GuildScheduledEventUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildScheduledEventUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildScheduledEventUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const oldGuildScheduledEvent = guild.scheduledEvents.cache.get(data.id)?._clone() ?? null;
          const newGuildScheduledEvent = guild.scheduledEvents._add(data);
          client.emit(Events3.GuildScheduledEventUpdate, oldGuildScheduledEvent, newGuildScheduledEvent);
          return { oldGuildScheduledEvent, newGuildScheduledEvent };
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUserAdd.js
var require_GuildScheduledEventUserAdd = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildScheduledEventUserAdd.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildScheduledEventUserAddAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = this.getScheduledEvent(data, guild);
          const user = this.getUser(data);
          if (guildScheduledEvent && user) {
            client.emit(Events3.GuildScheduledEventUserAdd, guildScheduledEvent, user);
            return { guildScheduledEvent, user };
          }
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventUserAddAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUserRemove.js
var require_GuildScheduledEventUserRemove = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildScheduledEventUserRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildScheduledEventUserRemoveAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = this.getScheduledEvent(data, guild);
          const user = this.getUser(data);
          if (guildScheduledEvent && user) {
            client.emit(Events3.GuildScheduledEventUserRemove, guildScheduledEvent, user);
            return { guildScheduledEvent, user };
          }
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventUserRemoveAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildStickerCreate.js
var require_GuildStickerCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildStickerCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildStickerCreateAction = class extends Action {
      handle(guild, createdSticker) {
        const already = guild.stickers.cache.has(createdSticker.id);
        const sticker = guild.stickers._add(createdSticker);
        if (!already)
          this.client.emit(Events3.GuildStickerCreate, sticker);
        return { sticker };
      }
    };
    module2.exports = GuildStickerCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildStickerDelete.js
var require_GuildStickerDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildStickerDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildStickerDeleteAction = class extends Action {
      handle(sticker) {
        sticker.guild.stickers.cache.delete(sticker.id);
        this.client.emit(Events3.GuildStickerDelete, sticker);
        return { sticker };
      }
    };
    module2.exports = GuildStickerDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildStickerUpdate.js
var require_GuildStickerUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildStickerUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildStickerUpdateAction = class extends Action {
      handle(current, data) {
        const old = current._update(data);
        this.client.emit(Events3.GuildStickerUpdate, old, current);
        return { sticker: current };
      }
    };
    module2.exports = GuildStickerUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildStickersUpdate.js
var require_GuildStickersUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildStickersUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildStickersUpdateAction = class extends Action {
      handle(data) {
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (!guild?.stickers)
          return;
        const deletions = new Map(guild.stickers.cache);
        for (const sticker of data.stickers) {
          const cachedSticker = guild.stickers.cache.get(sticker.id);
          if (cachedSticker) {
            deletions.delete(sticker.id);
            if (!cachedSticker.equals(sticker)) {
              this.client.actions.GuildStickerUpdate.handle(cachedSticker, sticker);
            }
          } else {
            this.client.actions.GuildStickerCreate.handle(guild, sticker);
          }
        }
        for (const sticker of deletions.values()) {
          this.client.actions.GuildStickerDelete.handle(sticker);
        }
      }
    };
    module2.exports = GuildStickersUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildUpdate.js
var require_GuildUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.id);
        if (guild) {
          const old = guild._update(data);
          client.emit(Events3.GuildUpdate, old, guild);
          return {
            old,
            updated: guild
          };
        }
        return {
          old: null,
          updated: null
        };
      }
    };
    module2.exports = GuildUpdateAction;
  }
});

// node_modules/discord.js/src/structures/CommandInteractionOptionResolver.js
var require_CommandInteractionOptionResolver = __commonJS({
  "node_modules/discord.js/src/structures/CommandInteractionOptionResolver.js"(exports2, module2) {
    "use strict";
    var { ApplicationCommandOptionType } = require_v106();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var CommandInteractionOptionResolver = class {
      constructor(client, options, resolved) {
        Object.defineProperty(this, "client", { value: client });
        this._group = null;
        this._subcommand = null;
        this._hoistedOptions = options;
        if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.SubcommandGroup) {
          this._group = this._hoistedOptions[0].name;
          this._hoistedOptions = this._hoistedOptions[0].options ?? [];
        }
        if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.Subcommand) {
          this._subcommand = this._hoistedOptions[0].name;
          this._hoistedOptions = this._hoistedOptions[0].options ?? [];
        }
        Object.defineProperty(this, "data", { value: Object.freeze([...options]) });
        Object.defineProperty(this, "resolved", { value: resolved ? Object.freeze(resolved) : null });
      }
      /**
       * Gets an option by its name.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?CommandInteractionOption} The option, if found.
       */
      get(name, required = false) {
        const option = this._hoistedOptions.find((opt) => opt.name === name);
        if (!option) {
          if (required) {
            throw new DiscordjsTypeError2(ErrorCodes2.CommandInteractionOptionNotFound, name);
          }
          return null;
        }
        return option;
      }
      /**
       * Gets an option by name and property and checks its type.
       * @param {string} name The name of the option.
       * @param {ApplicationCommandOptionType[]} allowedTypes The allowed types of the option.
       * @param {string[]} properties The properties to check for for `required`.
       * @param {boolean} required Whether to throw an error if the option is not found.
       * @returns {?CommandInteractionOption} The option, if found.
       * @private
       */
      _getTypedOption(name, allowedTypes, properties, required) {
        const option = this.get(name, required);
        if (!option) {
          return null;
        } else if (!allowedTypes.includes(option.type)) {
          throw new DiscordjsTypeError2(ErrorCodes2.CommandInteractionOptionType, name, option.type, allowedTypes.join(", "));
        } else if (required && properties.every((prop) => option[prop] === null || option[prop] === void 0)) {
          throw new DiscordjsTypeError2(ErrorCodes2.CommandInteractionOptionEmpty, name, option.type);
        }
        return option;
      }
      /**
       * Gets the selected subcommand.
       * @param {boolean} [required=true] Whether to throw an error if there is no subcommand.
       * @returns {?string} The name of the selected subcommand, or null if not set and not required.
       */
      getSubcommand(required = true) {
        if (required && !this._subcommand) {
          throw new DiscordjsTypeError2(ErrorCodes2.CommandInteractionOptionNoSubcommand);
        }
        return this._subcommand;
      }
      /**
       * Gets the selected subcommand group.
       * @param {boolean} [required=false] Whether to throw an error if there is no subcommand group.
       * @returns {?string} The name of the selected subcommand group, or null if not set and not required.
       */
      getSubcommandGroup(required = false) {
        if (required && !this._group) {
          throw new DiscordjsTypeError2(ErrorCodes2.CommandInteractionOptionNoSubcommandGroup);
        }
        return this._group;
      }
      /**
       * Gets a boolean option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?boolean} The value of the option, or null if not set and not required.
       */
      getBoolean(name, required = false) {
        const option = this._getTypedOption(name, [ApplicationCommandOptionType.Boolean], ["value"], required);
        return option?.value ?? null;
      }
      /**
       * Gets a channel option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @param {ChannelType[]} [channelTypes=[]] The allowed types of channels. If empty, all channel types are allowed.
       * @returns {?(GuildChannel|ThreadChannel|APIChannel)}
       * The value of the option, or null if not set and not required.
       */
      getChannel(name, required = false, channelTypes = []) {
        const option = this._getTypedOption(name, [ApplicationCommandOptionType.Channel], ["channel"], required);
        const channel = option?.channel ?? null;
        if (channel && channelTypes.length > 0 && !channelTypes.includes(channel.type)) {
          throw new DiscordjsTypeError2(
            ErrorCodes2.CommandInteractionOptionInvalidChannelType,
            name,
            channel.type,
            channelTypes.join(", ")
          );
        }
        return channel;
      }
      /**
       * Gets a string option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?string} The value of the option, or null if not set and not required.
       */
      getString(name, required = false) {
        const option = this._getTypedOption(name, [ApplicationCommandOptionType.String], ["value"], required);
        return option?.value ?? null;
      }
      /**
       * Gets an integer option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?number} The value of the option, or null if not set and not required.
       */
      getInteger(name, required = false) {
        const option = this._getTypedOption(name, [ApplicationCommandOptionType.Integer], ["value"], required);
        return option?.value ?? null;
      }
      /**
       * Gets a number option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?number} The value of the option, or null if not set and not required.
       */
      getNumber(name, required = false) {
        const option = this._getTypedOption(name, [ApplicationCommandOptionType.Number], ["value"], required);
        return option?.value ?? null;
      }
      /**
       * Gets a user option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?User} The value of the option, or null if not set and not required.
       */
      getUser(name, required = false) {
        const option = this._getTypedOption(
          name,
          [ApplicationCommandOptionType.User, ApplicationCommandOptionType.Mentionable],
          ["user"],
          required
        );
        return option?.user ?? null;
      }
      /**
       * Gets a member option.
       * @param {string} name The name of the option.
       * @returns {?(GuildMember|APIGuildMember)}
       * The value of the option, or null if the user is not present in the guild or the option is not set.
       */
      getMember(name) {
        const option = this._getTypedOption(
          name,
          [ApplicationCommandOptionType.User, ApplicationCommandOptionType.Mentionable],
          ["member"],
          false
        );
        return option?.member ?? null;
      }
      /**
       * Gets a role option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?(Role|APIRole)} The value of the option, or null if not set and not required.
       */
      getRole(name, required = false) {
        const option = this._getTypedOption(
          name,
          [ApplicationCommandOptionType.Role, ApplicationCommandOptionType.Mentionable],
          ["role"],
          required
        );
        return option?.role ?? null;
      }
      /**
       * Gets an attachment option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?Attachment} The value of the option, or null if not set and not required.
       */
      getAttachment(name, required = false) {
        const option = this._getTypedOption(name, [ApplicationCommandOptionType.Attachment], ["attachment"], required);
        return option?.attachment ?? null;
      }
      /**
       * Gets a mentionable option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?(User|GuildMember|APIGuildMember|Role|APIRole)}
       * The value of the option, or null if not set and not required.
       */
      getMentionable(name, required = false) {
        const option = this._getTypedOption(
          name,
          [ApplicationCommandOptionType.Mentionable],
          ["user", "member", "role"],
          required
        );
        return option?.member ?? option?.user ?? option?.role ?? null;
      }
      /**
       * Gets a message option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?Message}
       * The value of the option, or null if not set and not required.
       */
      getMessage(name, required = false) {
        const option = this._getTypedOption(name, ["_MESSAGE"], ["message"], required);
        return option?.message ?? null;
      }
      /**
       * The full autocomplete option object.
       * @typedef {Object} AutocompleteFocusedOption
       * @property {string} name The name of the option
       * @property {ApplicationCommandOptionType} type The type of the application command option
       * @property {string} value The value of the option
       * @property {boolean} focused Whether this option is currently in focus for autocomplete
       */
      /**
       * Gets the focused option.
       * @param {boolean} [getFull=false] Whether to get the full option object
       * @returns {string|AutocompleteFocusedOption}
       * The value of the option, or the whole option if getFull is true
       */
      getFocused(getFull = false) {
        const focusedOption = this._hoistedOptions.find((option) => option.focused);
        if (!focusedOption)
          throw new DiscordjsTypeError2(ErrorCodes2.AutocompleteInteractionOptionNoFocusedOption);
        return getFull ? focusedOption : focusedOption.value;
      }
    };
    module2.exports = CommandInteractionOptionResolver;
  }
});

// node_modules/discord.js/src/structures/AutocompleteInteraction.js
var require_AutocompleteInteraction = __commonJS({
  "node_modules/discord.js/src/structures/AutocompleteInteraction.js"(exports2, module2) {
    "use strict";
    var { InteractionResponseType, Routes: Routes2 } = require_v106();
    var BaseInteraction = require_BaseInteraction();
    var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var AutocompleteInteraction = class extends BaseInteraction {
      constructor(client, data) {
        super(client, data);
        this.commandId = data.data.id;
        this.commandName = data.data.name;
        this.commandType = data.data.type;
        this.commandGuildId = data.data.guild_id ?? null;
        this.responded = false;
        this.options = new CommandInteractionOptionResolver(this.client, data.data.options ?? []);
      }
      /**
       * The invoked application command, if it was fetched before
       * @type {?ApplicationCommand}
       */
      get command() {
        const id = this.commandId;
        return this.guild?.commands.cache.get(id) ?? this.client.application.commands.cache.get(id) ?? null;
      }
      /**
       * Sends results for the autocomplete of this interaction.
       * @param {ApplicationCommandOptionChoiceData[]} options The options for the autocomplete
       * @returns {Promise<void>}
       * @example
       * // respond to autocomplete interaction
       * interaction.respond([
       *  {
       *    name: 'Option 1',
       *    value: 'option1',
       *  },
       * ])
       *  .then(() => console.log('Successfully responded to the autocomplete interaction'))
       *  .catch(console.error);
       */
      async respond(options) {
        if (this.responded)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        await this.client.rest.post(Routes2.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.ApplicationCommandAutocompleteResult,
            data: { choices: this.client.options.jsonTransformer(options) }
          },
          auth: false
        });
        this.responded = true;
      }
    };
    module2.exports = AutocompleteInteraction;
  }
});

// node_modules/discord.js/src/structures/InteractionResponse.js
var require_InteractionResponse = __commonJS({
  "node_modules/discord.js/src/structures/InteractionResponse.js"(exports2, module2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { InteractionType } = require_v106();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var InteractionResponse = class {
      constructor(interaction, id) {
        this.interaction = interaction;
        this.id = id ?? interaction.id;
        this.client = interaction.client;
      }
      /**
       * The timestamp the interaction response was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the interaction response was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * Collects a single component interaction that passes the filter.
       * The Promise will reject if the time expires.
       * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector
       * @returns {Promise<MessageComponentInteraction>}
       */
      awaitMessageComponent(options = {}) {
        const _options = { ...options, max: 1 };
        return new Promise((resolve, reject) => {
          const collector = this.createMessageComponentCollector(_options);
          collector.once("end", (interactions, reason) => {
            const interaction = interactions.first();
            if (interaction)
              resolve(interaction);
            else
              reject(new DiscordjsError2(ErrorCodes2.InteractionCollectorError, reason));
          });
        });
      }
      /**
       * Creates a message component interaction collector
       * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector
       * @returns {InteractionCollector}
       */
      createMessageComponentCollector(options = {}) {
        return new InteractionCollector(this.client, {
          ...options,
          interactionResponse: this,
          interactionType: InteractionType.MessageComponent
        });
      }
      /**
       * Fetches the response as a {@link Message} object.
       * @returns {Promise<Message>}
       */
      fetch() {
        return this.interaction.fetchReply();
      }
      /**
       * Deletes the response.
       * @returns {Promise<void>}
       */
      delete() {
        return this.interaction.deleteReply();
      }
      /**
       * Edits the response.
       * @param {string|MessagePayload|WebhookMessageEditOptions} options The new options for the response.
       * @returns {Promise<Message>}
       */
      edit(options) {
        return this.interaction.editReply(options);
      }
    };
    var InteractionCollector = require_InteractionCollector();
    module2.exports = InteractionResponse;
  }
});

// node_modules/discord.js/src/structures/interfaces/InteractionResponses.js
var require_InteractionResponses = __commonJS({
  "node_modules/discord.js/src/structures/interfaces/InteractionResponses.js"(exports2, module2) {
    "use strict";
    var { isJSONEncodable } = require_dist8();
    var { InteractionResponseType, MessageFlags, Routes: Routes2, InteractionType } = require_v106();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var InteractionCollector = require_InteractionCollector();
    var InteractionResponse = require_InteractionResponse();
    var MessagePayload = require_MessagePayload();
    var InteractionResponses = class {
      /**
       * Options for deferring the reply to an {@link BaseInteraction}.
       * @typedef {Object} InteractionDeferReplyOptions
       * @property {boolean} [ephemeral] Whether the reply should be ephemeral
       * @property {boolean} [fetchReply] Whether to fetch the reply
       */
      /**
       * Options for deferring and updating the reply to a {@link MessageComponentInteraction}.
       * @typedef {Object} InteractionDeferUpdateOptions
       * @property {boolean} [fetchReply] Whether to fetch the reply
       */
      /**
       * Options for a reply to a {@link BaseInteraction}.
       * @typedef {BaseMessageOptions} InteractionReplyOptions
       * @property {boolean} [tts=false] Whether the message should be spoken aloud
       * @property {boolean} [ephemeral] Whether the reply should be ephemeral
       * @property {boolean} [fetchReply] Whether to fetch the reply
       * @property {MessageFlags} [flags] Which flags to set for the message.
       * <info>Only `MessageFlags.SuppressEmbeds` and `MessageFlags.Ephemeral` can be set.</info>
       */
      /**
       * Options for updating the message received from a {@link MessageComponentInteraction}.
       * @typedef {MessageEditOptions} InteractionUpdateOptions
       * @property {boolean} [fetchReply] Whether to fetch the reply
       */
      /**
       * Defers the reply to this interaction.
       * @param {InteractionDeferReplyOptions} [options] Options for deferring the reply to this interaction
       * @returns {Promise<Message|InteractionResponse>}
       * @example
       * // Defer the reply to this interaction
       * interaction.deferReply()
       *   .then(console.log)
       *   .catch(console.error)
       * @example
       * // Defer to send an ephemeral reply later
       * interaction.deferReply({ ephemeral: true })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async deferReply(options = {}) {
        if (this.deferred || this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        this.ephemeral = options.ephemeral ?? false;
        await this.client.rest.post(Routes2.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.DeferredChannelMessageWithSource,
            data: {
              flags: options.ephemeral ? MessageFlags.Ephemeral : void 0
            }
          },
          auth: false
        });
        this.deferred = true;
        return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
      }
      /**
       * Creates a reply to this interaction.
       * <info>Use the `fetchReply` option to get the bot's reply message.</info>
       * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply
       * @returns {Promise<Message|InteractionResponse>}
       * @example
       * // Reply to the interaction and fetch the response
       * interaction.reply({ content: 'Pong!', fetchReply: true })
       *   .then((message) => console.log(`Reply sent with content ${message.content}`))
       *   .catch(console.error);
       * @example
       * // Create an ephemeral reply with an embed
       * const embed = new EmbedBuilder().setDescription('Pong!');
       *
       * interaction.reply({ embeds: [embed], ephemeral: true })
       *   .then(() => console.log('Reply sent.'))
       *   .catch(console.error);
       */
      async reply(options) {
        if (this.deferred || this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        this.ephemeral = options.ephemeral ?? false;
        let messagePayload;
        if (options instanceof MessagePayload)
          messagePayload = options;
        else
          messagePayload = MessagePayload.create(this, options);
        const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
        await this.client.rest.post(Routes2.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.ChannelMessageWithSource,
            data
          },
          files,
          auth: false
        });
        this.replied = true;
        return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
      }
      /**
       * Fetches a reply to this interaction.
       * @see Webhook#fetchMessage
       * @param {Snowflake|'@original'} [message='@original'] The response to fetch
       * @returns {Promise<Message>}
       * @example
       * // Fetch the initial reply to this interaction
       * interaction.fetchReply()
       *   .then(reply => console.log(`Replied with ${reply.content}`))
       *   .catch(console.error);
       */
      fetchReply(message = "@original") {
        return this.webhook.fetchMessage(message);
      }
      /**
       * Options that can be passed into {@link InteractionResponses#editReply}.
       * @typedef {WebhookMessageEditOptions} InteractionEditReplyOptions
       * @property {MessageResolvable|'@original'} [message='@original'] The response to edit
       */
      /**
       * Edits a reply to this interaction.
       * @see Webhook#editMessage
       * @param {string|MessagePayload|InteractionEditReplyOptions} options The new options for the message
       * @returns {Promise<Message>}
       * @example
       * // Edit the initial reply to this interaction
       * interaction.editReply('New content')
       *   .then(console.log)
       *   .catch(console.error);
       */
      async editReply(options) {
        if (!this.deferred && !this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionNotReplied);
        const msg = await this.webhook.editMessage(options.message ?? "@original", options);
        this.replied = true;
        return msg;
      }
      /**
       * Deletes a reply to this interaction.
       * @see Webhook#deleteMessage
       * @param {MessageResolvable|'@original'} [message='@original'] The response to delete
       * @returns {Promise<void>}
       * @example
       * // Delete the initial reply to this interaction
       * interaction.deleteReply()
       *   .then(console.log)
       *   .catch(console.error);
       */
      async deleteReply(message = "@original") {
        await this.webhook.deleteMessage(message);
      }
      /**
       * Send a follow-up message to this interaction.
       * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply
       * @returns {Promise<Message>}
       */
      followUp(options) {
        if (!this.deferred && !this.replied)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.InteractionNotReplied));
        return this.webhook.send(options);
      }
      /**
       * Defers an update to the message to which the component was attached.
       * @param {InteractionDeferUpdateOptions} [options] Options for deferring the update to this interaction
       * @returns {Promise<Message|InteractionResponse>}
       * @example
       * // Defer updating and reset the component's loading state
       * interaction.deferUpdate()
       *   .then(console.log)
       *   .catch(console.error);
       */
      async deferUpdate(options = {}) {
        if (this.deferred || this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        await this.client.rest.post(Routes2.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.DeferredMessageUpdate
          },
          auth: false
        });
        this.deferred = true;
        return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message?.interaction?.id);
      }
      /**
       * Updates the original message of the component on which the interaction was received on.
       * @param {string|MessagePayload|InteractionUpdateOptions} options The options for the updated message
       * @returns {Promise<Message|void>}
       * @example
       * // Remove the components from the message
       * interaction.update({
       *   content: "A component interaction was received",
       *   components: []
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async update(options) {
        if (this.deferred || this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        let messagePayload;
        if (options instanceof MessagePayload)
          messagePayload = options;
        else
          messagePayload = MessagePayload.create(this, options);
        const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
        await this.client.rest.post(Routes2.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.UpdateMessage,
            data
          },
          files,
          auth: false
        });
        this.replied = true;
        return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message.interaction?.id);
      }
      /**
       * Shows a modal component
       * @param {APIModal|ModalData|Modal} modal The modal to show
       * @returns {Promise<void>}
       */
      async showModal(modal) {
        if (this.deferred || this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        await this.client.rest.post(Routes2.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.Modal,
            data: isJSONEncodable(modal) ? modal.toJSON() : this.client.options.jsonTransformer(modal)
          },
          auth: false
        });
        this.replied = true;
      }
      /**
       * An object containing the same properties as {@link CollectorOptions}, but a few less:
       * @typedef {Object} AwaitModalSubmitOptions
       * @property {CollectorFilter} [filter] The filter applied to this collector
       * @property {number} time Time in milliseconds to wait for an interaction before rejecting
       */
      /**
       * Collects a single modal submit interaction that passes the filter.
       * The Promise will reject if the time expires.
       * @param {AwaitModalSubmitOptions} options Options to pass to the internal collector
       * @returns {Promise<ModalSubmitInteraction>}
       * @example
       * // Collect a modal submit interaction
       * const filter = (interaction) => interaction.customId === 'modal';
       * interaction.awaitModalSubmit({ filter, time: 15_000 })
       *   .then(interaction => console.log(`${interaction.customId} was submitted!`))
       *   .catch(console.error);
       */
      awaitModalSubmit(options) {
        if (typeof options.time !== "number")
          throw new DiscordjsError2(ErrorCodes2.InvalidType, "time", "number");
        const _options = { ...options, max: 1, interactionType: InteractionType.ModalSubmit };
        return new Promise((resolve, reject) => {
          const collector = new InteractionCollector(this.client, _options);
          collector.once("end", (interactions, reason) => {
            const interaction = interactions.first();
            if (interaction)
              resolve(interaction);
            else
              reject(new DiscordjsError2(ErrorCodes2.InteractionCollectorError, reason));
          });
        });
      }
      static applyToClass(structure, ignore = []) {
        const props = [
          "deferReply",
          "reply",
          "fetchReply",
          "editReply",
          "deleteReply",
          "followUp",
          "deferUpdate",
          "update",
          "showModal",
          "awaitModalSubmit"
        ];
        for (const prop of props) {
          if (ignore.includes(prop))
            continue;
          Object.defineProperty(
            structure.prototype,
            prop,
            Object.getOwnPropertyDescriptor(InteractionResponses.prototype, prop)
          );
        }
      }
    };
    module2.exports = InteractionResponses;
  }
});

// node_modules/discord.js/src/structures/MessageComponentInteraction.js
var require_MessageComponentInteraction = __commonJS({
  "node_modules/discord.js/src/structures/MessageComponentInteraction.js"(exports2, module2) {
    "use strict";
    var { lazy } = require_dist2();
    var BaseInteraction = require_BaseInteraction();
    var InteractionWebhook = require_InteractionWebhook();
    var InteractionResponses = require_InteractionResponses();
    var getMessage = lazy(() => require_Message().Message);
    var MessageComponentInteraction = class extends BaseInteraction {
      constructor(client, data) {
        super(client, data);
        this.message = this.channel?.messages._add(data.message) ?? new (getMessage())(client, data.message);
        this.customId = data.data.custom_id;
        this.componentType = data.data.component_type;
        this.deferred = false;
        this.ephemeral = null;
        this.replied = false;
        this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
      }
      /**
       * Components that can be placed in an action row for messages.
       * * ButtonComponent
       * * StringSelectMenuComponent
       * * UserSelectMenuComponent
       * * RoleSelectMenuComponent
       * * MentionableSelectMenuComponent
       * * ChannelSelectMenuComponent
       * @typedef {ButtonComponent|StringSelectMenuComponent|UserSelectMenuComponent|
       * RoleSelectMenuComponent|MentionableSelectMenuComponent|ChannelSelectMenuComponent} MessageActionRowComponent
       */
      /**
       * The component which was interacted with
       * @type {MessageActionRowComponent|APIMessageActionRowComponent}
       * @readonly
       */
      get component() {
        return this.message.components.flatMap((row) => row.components).find((component) => (component.customId ?? component.custom_id) === this.customId);
      }
      // These are here only for documentation purposes - they are implemented by InteractionResponses
      /* eslint-disable no-empty-function */
      deferReply() {
      }
      reply() {
      }
      fetchReply() {
      }
      editReply() {
      }
      deleteReply() {
      }
      followUp() {
      }
      deferUpdate() {
      }
      update() {
      }
      showModal() {
      }
      awaitModalSubmit() {
      }
    };
    InteractionResponses.applyToClass(MessageComponentInteraction);
    module2.exports = MessageComponentInteraction;
  }
});

// node_modules/discord.js/src/structures/ButtonInteraction.js
var require_ButtonInteraction = __commonJS({
  "node_modules/discord.js/src/structures/ButtonInteraction.js"(exports2, module2) {
    "use strict";
    var MessageComponentInteraction = require_MessageComponentInteraction();
    var ButtonInteraction = class extends MessageComponentInteraction {
    };
    module2.exports = ButtonInteraction;
  }
});

// node_modules/discord.js/src/structures/ChannelSelectMenuInteraction.js
var require_ChannelSelectMenuInteraction = __commonJS({
  "node_modules/discord.js/src/structures/ChannelSelectMenuInteraction.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var MessageComponentInteraction = require_MessageComponentInteraction();
    var ChannelSelectMenuInteraction = class extends MessageComponentInteraction {
      constructor(client, data) {
        super(client, data);
        const { resolved, values } = data.data;
        this.values = values ?? [];
        this.channels = new Collection2();
        for (const channel of Object.values(resolved?.channels ?? {})) {
          this.channels.set(channel.id, this.client.channels._add(channel, this.guild) ?? channel);
        }
      }
    };
    module2.exports = ChannelSelectMenuInteraction;
  }
});

// node_modules/discord.js/src/structures/CommandInteraction.js
var require_CommandInteraction = __commonJS({
  "node_modules/discord.js/src/structures/CommandInteraction.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Attachment = require_Attachment();
    var BaseInteraction = require_BaseInteraction();
    var InteractionWebhook = require_InteractionWebhook();
    var InteractionResponses = require_InteractionResponses();
    var CommandInteraction = class extends BaseInteraction {
      constructor(client, data) {
        super(client, data);
        this.commandId = data.data.id;
        this.commandName = data.data.name;
        this.commandType = data.data.type;
        this.commandGuildId = data.data.guild_id ?? null;
        this.deferred = false;
        this.replied = false;
        this.ephemeral = null;
        this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
      }
      /**
       * The invoked application command, if it was fetched before
       * @type {?ApplicationCommand}
       */
      get command() {
        const id = this.commandId;
        return this.guild?.commands.cache.get(id) ?? this.client.application.commands.cache.get(id) ?? null;
      }
      /**
       * Represents the resolved data of a received command interaction.
       * @typedef {Object} CommandInteractionResolvedData
       * @property {Collection<Snowflake, User>} [users] The resolved users
       * @property {Collection<Snowflake, GuildMember|APIGuildMember>} [members] The resolved guild members
       * @property {Collection<Snowflake, Role|APIRole>} [roles] The resolved roles
       * @property {Collection<Snowflake, BaseChannel|APIChannel>} [channels] The resolved channels
       * @property {Collection<Snowflake, Message|APIMessage>} [messages] The resolved messages
       * @property {Collection<Snowflake, Attachment>} [attachments] The resolved attachments
       */
      /**
       * Transforms the resolved received from the API.
       * @param {APIInteractionDataResolved} resolved The received resolved objects
       * @returns {CommandInteractionResolvedData}
       * @private
       */
      transformResolved({ members, users, channels, roles, messages, attachments }) {
        const result = {};
        if (members) {
          result.members = new Collection2();
          for (const [id, member] of Object.entries(members)) {
            const user = users[id];
            result.members.set(id, this.guild?.members._add({ user, ...member }) ?? member);
          }
        }
        if (users) {
          result.users = new Collection2();
          for (const user of Object.values(users)) {
            result.users.set(user.id, this.client.users._add(user));
          }
        }
        if (roles) {
          result.roles = new Collection2();
          for (const role of Object.values(roles)) {
            result.roles.set(role.id, this.guild?.roles._add(role) ?? role);
          }
        }
        if (channels) {
          result.channels = new Collection2();
          for (const channel of Object.values(channels)) {
            result.channels.set(channel.id, this.client.channels._add(channel, this.guild) ?? channel);
          }
        }
        if (messages) {
          result.messages = new Collection2();
          for (const message of Object.values(messages)) {
            result.messages.set(message.id, this.channel?.messages?._add(message) ?? message);
          }
        }
        if (attachments) {
          result.attachments = new Collection2();
          for (const attachment of Object.values(attachments)) {
            const patched = new Attachment(attachment);
            result.attachments.set(attachment.id, patched);
          }
        }
        return result;
      }
      /**
       * Represents an option of a received command interaction.
       * @typedef {Object} CommandInteractionOption
       * @property {string} name The name of the option
       * @property {ApplicationCommandOptionType} type The type of the option
       * @property {boolean} [autocomplete] Whether the autocomplete interaction is enabled for a
       * {@link ApplicationCommandOptionType.String}, {@link ApplicationCommandOptionType.Integer} or
       * {@link ApplicationCommandOptionType.Number} option
       * @property {string|number|boolean} [value] The value of the option
       * @property {CommandInteractionOption[]} [options] Additional options if this option is a
       * subcommand (group)
       * @property {User} [user] The resolved user
       * @property {GuildMember|APIGuildMember} [member] The resolved member
       * @property {GuildChannel|ThreadChannel|APIChannel} [channel] The resolved channel
       * @property {Role|APIRole} [role] The resolved role
       * @property {Attachment} [attachment] The resolved attachment
       */
      /**
       * Transforms an option received from the API.
       * @param {APIApplicationCommandOption} option The received option
       * @param {APIInteractionDataResolved} resolved The resolved interaction data
       * @returns {CommandInteractionOption}
       * @private
       */
      transformOption(option, resolved) {
        const result = {
          name: option.name,
          type: option.type
        };
        if ("value" in option)
          result.value = option.value;
        if ("options" in option)
          result.options = option.options.map((opt) => this.transformOption(opt, resolved));
        if (resolved) {
          const user = resolved.users?.[option.value];
          if (user)
            result.user = this.client.users._add(user);
          const member = resolved.members?.[option.value];
          if (member)
            result.member = this.guild?.members._add({ user, ...member }) ?? member;
          const channel = resolved.channels?.[option.value];
          if (channel)
            result.channel = this.client.channels._add(channel, this.guild) ?? channel;
          const role = resolved.roles?.[option.value];
          if (role)
            result.role = this.guild?.roles._add(role) ?? role;
          const attachment = resolved.attachments?.[option.value];
          if (attachment)
            result.attachment = new Attachment(attachment);
        }
        return result;
      }
      // These are here only for documentation purposes - they are implemented by InteractionResponses
      /* eslint-disable no-empty-function */
      deferReply() {
      }
      reply() {
      }
      fetchReply() {
      }
      editReply() {
      }
      deleteReply() {
      }
      followUp() {
      }
      showModal() {
      }
      awaitModalSubmit() {
      }
    };
    InteractionResponses.applyToClass(CommandInteraction, ["deferUpdate", "update"]);
    module2.exports = CommandInteraction;
  }
});

// node_modules/discord.js/src/structures/ChatInputCommandInteraction.js
var require_ChatInputCommandInteraction = __commonJS({
  "node_modules/discord.js/src/structures/ChatInputCommandInteraction.js"(exports2, module2) {
    "use strict";
    var CommandInteraction = require_CommandInteraction();
    var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
    var ChatInputCommandInteraction = class extends CommandInteraction {
      constructor(client, data) {
        super(client, data);
        this.options = new CommandInteractionOptionResolver(
          this.client,
          data.data.options?.map((option) => this.transformOption(option, data.data.resolved)) ?? [],
          this.transformResolved(data.data.resolved ?? {})
        );
      }
      /**
       * Returns a string representation of the command interaction.
       * This can then be copied by a user and executed again in a new command while keeping the option order.
       * @returns {string}
       */
      toString() {
        const properties = [
          this.commandName,
          this.options._group,
          this.options._subcommand,
          ...this.options._hoistedOptions.map((o) => `${o.name}:${o.value}`)
        ];
        return `/${properties.filter(Boolean).join(" ")}`;
      }
    };
    module2.exports = ChatInputCommandInteraction;
  }
});

// node_modules/discord.js/src/structures/MentionableSelectMenuInteraction.js
var require_MentionableSelectMenuInteraction = __commonJS({
  "node_modules/discord.js/src/structures/MentionableSelectMenuInteraction.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var MessageComponentInteraction = require_MessageComponentInteraction();
    var Events3 = require_Events();
    var MentionableSelectMenuInteraction = class extends MessageComponentInteraction {
      constructor(client, data) {
        super(client, data);
        const { resolved, values } = data.data;
        const { members, users, roles } = resolved ?? {};
        this.values = values ?? [];
        this.users = new Collection2();
        this.members = new Collection2();
        this.roles = new Collection2();
        if (members) {
          for (const [id, member] of Object.entries(members)) {
            const user = users[id];
            if (!user) {
              this.client.emit(
                Events3.Debug,
                `[MentionableSelectMenuInteraction] Received a member without a user, skipping ${id}`
              );
              continue;
            }
            this.members.set(id, this.guild?.members._add({ user, ...member }) ?? { user, ...member });
          }
        }
        if (users) {
          for (const user of Object.values(users)) {
            this.users.set(user.id, this.client.users._add(user));
          }
        }
        if (roles) {
          for (const role of Object.values(roles)) {
            this.roles.set(role.id, this.guild?.roles._add(role) ?? role);
          }
        }
      }
    };
    module2.exports = MentionableSelectMenuInteraction;
  }
});

// node_modules/discord.js/src/structures/ContextMenuCommandInteraction.js
var require_ContextMenuCommandInteraction = __commonJS({
  "node_modules/discord.js/src/structures/ContextMenuCommandInteraction.js"(exports2, module2) {
    "use strict";
    var { lazy } = require_dist2();
    var { ApplicationCommandOptionType } = require_v106();
    var CommandInteraction = require_CommandInteraction();
    var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
    var getMessage = lazy(() => require_Message().Message);
    var ContextMenuCommandInteraction = class extends CommandInteraction {
      constructor(client, data) {
        super(client, data);
        this.options = new CommandInteractionOptionResolver(
          this.client,
          this.resolveContextMenuOptions(data.data),
          this.transformResolved(data.data.resolved)
        );
        this.targetId = data.data.target_id;
      }
      /**
       * Resolves and transforms options received from the API for a context menu interaction.
       * @param {APIApplicationCommandInteractionData} data The interaction data
       * @returns {CommandInteractionOption[]}
       * @private
       */
      resolveContextMenuOptions({ target_id, resolved }) {
        const result = [];
        if (resolved.users?.[target_id]) {
          result.push(
            this.transformOption({ name: "user", type: ApplicationCommandOptionType.User, value: target_id }, resolved)
          );
        }
        if (resolved.messages?.[target_id]) {
          result.push({
            name: "message",
            type: "_MESSAGE",
            value: target_id,
            message: this.channel?.messages._add(resolved.messages[target_id]) ?? new (getMessage())(this.client, resolved.messages[target_id])
          });
        }
        return result;
      }
    };
    module2.exports = ContextMenuCommandInteraction;
  }
});

// node_modules/discord.js/src/structures/MessageContextMenuCommandInteraction.js
var require_MessageContextMenuCommandInteraction = __commonJS({
  "node_modules/discord.js/src/structures/MessageContextMenuCommandInteraction.js"(exports2, module2) {
    "use strict";
    var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();
    var MessageContextMenuCommandInteraction = class extends ContextMenuCommandInteraction {
      /**
       * The message this interaction was sent from
       * @type {Message|APIMessage}
       * @readonly
       */
      get targetMessage() {
        return this.options.getMessage("message");
      }
    };
    module2.exports = MessageContextMenuCommandInteraction;
  }
});

// node_modules/discord.js/src/structures/ModalSubmitFields.js
var require_ModalSubmitFields = __commonJS({
  "node_modules/discord.js/src/structures/ModalSubmitFields.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { ComponentType } = require_v106();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ModalSubmitFields = class {
      constructor(components) {
        this.components = components;
        this.fields = components.reduce((accumulator, next) => {
          next.components.forEach((c) => accumulator.set(c.customId, c));
          return accumulator;
        }, new Collection2());
      }
      /**
       * Gets a field given a custom id from a component
       * @param {string} customId The custom id of the component
       * @param {ComponentType} [type] The type of the component
       * @returns {ModalData}
       */
      getField(customId, type) {
        const field = this.fields.get(customId);
        if (!field)
          throw new DiscordjsTypeError2(ErrorCodes2.ModalSubmitInteractionFieldNotFound, customId);
        if (type !== void 0 && type !== field.type) {
          throw new DiscordjsTypeError2(ErrorCodes2.ModalSubmitInteractionFieldType, customId, field.type, type);
        }
        return field;
      }
      /**
       * Gets the value of a text input component given a custom id
       * @param {string} customId The custom id of the text input component
       * @returns {string}
       */
      getTextInputValue(customId) {
        return this.getField(customId, ComponentType.TextInput).value;
      }
    };
    module2.exports = ModalSubmitFields;
  }
});

// node_modules/discord.js/src/structures/ModalSubmitInteraction.js
var require_ModalSubmitInteraction = __commonJS({
  "node_modules/discord.js/src/structures/ModalSubmitInteraction.js"(exports2, module2) {
    "use strict";
    var { lazy } = require_dist2();
    var BaseInteraction = require_BaseInteraction();
    var InteractionWebhook = require_InteractionWebhook();
    var ModalSubmitFields = require_ModalSubmitFields();
    var InteractionResponses = require_InteractionResponses();
    var getMessage = lazy(() => require_Message().Message);
    var ModalSubmitInteraction = class extends BaseInteraction {
      constructor(client, data) {
        super(client, data);
        this.customId = data.data.custom_id;
        if ("message" in data) {
          this.message = this.channel?.messages._add(data.message) ?? new (getMessage())(this.client, data.message);
        } else {
          this.message = null;
        }
        this.components = data.data.components?.map((c) => ModalSubmitInteraction.transformComponent(c));
        this.fields = new ModalSubmitFields(this.components);
        this.deferred = false;
        this.replied = false;
        this.ephemeral = null;
        this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
      }
      /**
       * Transforms component data to discord.js-compatible data
       * @param {*} rawComponent The data to transform
       * @returns {ModalData[]}
       */
      static transformComponent(rawComponent) {
        return {
          value: rawComponent.value,
          type: rawComponent.type,
          customId: rawComponent.custom_id,
          components: rawComponent.components?.map((c) => this.transformComponent(c))
        };
      }
      /**
       * Whether this is from a {@link MessageComponentInteraction}.
       * @returns {boolean}
       */
      isFromMessage() {
        return Boolean(this.message);
      }
      // These are here only for documentation purposes - they are implemented by InteractionResponses
      /* eslint-disable no-empty-function */
      deferReply() {
      }
      reply() {
      }
      fetchReply() {
      }
      editReply() {
      }
      deleteReply() {
      }
      followUp() {
      }
      deferUpdate() {
      }
      update() {
      }
    };
    InteractionResponses.applyToClass(ModalSubmitInteraction, "showModal");
    module2.exports = ModalSubmitInteraction;
  }
});

// node_modules/discord.js/src/structures/RoleSelectMenuInteraction.js
var require_RoleSelectMenuInteraction = __commonJS({
  "node_modules/discord.js/src/structures/RoleSelectMenuInteraction.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var MessageComponentInteraction = require_MessageComponentInteraction();
    var RoleSelectMenuInteraction = class extends MessageComponentInteraction {
      constructor(client, data) {
        super(client, data);
        const { resolved, values } = data.data;
        this.values = values ?? [];
        this.roles = new Collection2();
        for (const role of Object.values(resolved?.roles ?? {})) {
          this.roles.set(role.id, this.guild?.roles._add(role) ?? role);
        }
      }
    };
    module2.exports = RoleSelectMenuInteraction;
  }
});

// node_modules/discord.js/src/structures/StringSelectMenuInteraction.js
var require_StringSelectMenuInteraction = __commonJS({
  "node_modules/discord.js/src/structures/StringSelectMenuInteraction.js"(exports2, module2) {
    "use strict";
    var MessageComponentInteraction = require_MessageComponentInteraction();
    var StringSelectMenuInteraction = class extends MessageComponentInteraction {
      constructor(client, data) {
        super(client, data);
        this.values = data.data.values ?? [];
      }
    };
    module2.exports = StringSelectMenuInteraction;
  }
});

// node_modules/discord.js/src/structures/UserContextMenuCommandInteraction.js
var require_UserContextMenuCommandInteraction = __commonJS({
  "node_modules/discord.js/src/structures/UserContextMenuCommandInteraction.js"(exports2, module2) {
    "use strict";
    var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();
    var UserContextMenuCommandInteraction = class extends ContextMenuCommandInteraction {
      /**
       * The target user from this interaction
       * @type {User}
       * @readonly
       */
      get targetUser() {
        return this.options.getUser("user");
      }
      /**
       * The target member from this interaction
       * @type {?(GuildMember|APIGuildMember)}
       * @readonly
       */
      get targetMember() {
        return this.options.getMember("user");
      }
    };
    module2.exports = UserContextMenuCommandInteraction;
  }
});

// node_modules/discord.js/src/structures/UserSelectMenuInteraction.js
var require_UserSelectMenuInteraction = __commonJS({
  "node_modules/discord.js/src/structures/UserSelectMenuInteraction.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var MessageComponentInteraction = require_MessageComponentInteraction();
    var Events3 = require_Events();
    var UserSelectMenuInteraction = class extends MessageComponentInteraction {
      constructor(client, data) {
        super(client, data);
        const { resolved, values } = data.data;
        this.values = values ?? [];
        this.users = new Collection2();
        this.members = new Collection2();
        for (const user of Object.values(resolved?.users ?? {})) {
          this.users.set(user.id, this.client.users._add(user));
        }
        for (const [id, member] of Object.entries(resolved?.members ?? {})) {
          const user = resolved.users[id];
          if (!user) {
            this.client.emit(Events3.Debug, `[UserSelectMenuInteraction] Received a member without a user, skipping ${id}`);
            continue;
          }
          this.members.set(id, this.guild?.members._add({ user, ...member }) ?? { user, ...member });
        }
      }
    };
    module2.exports = UserSelectMenuInteraction;
  }
});

// node_modules/discord.js/src/client/actions/InteractionCreate.js
var require_InteractionCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/InteractionCreate.js"(exports2, module2) {
    "use strict";
    var { InteractionType, ComponentType, ApplicationCommandType } = require_v106();
    var Action = require_Action();
    var AutocompleteInteraction = require_AutocompleteInteraction();
    var ButtonInteraction = require_ButtonInteraction();
    var ChannelSelectMenuInteraction = require_ChannelSelectMenuInteraction();
    var ChatInputCommandInteraction = require_ChatInputCommandInteraction();
    var MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
    var MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
    var ModalSubmitInteraction = require_ModalSubmitInteraction();
    var RoleSelectMenuInteraction = require_RoleSelectMenuInteraction();
    var StringSelectMenuInteraction = require_StringSelectMenuInteraction();
    var UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
    var UserSelectMenuInteraction = require_UserSelectMenuInteraction();
    var Events3 = require_Events();
    var InteractionCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel(data);
        let InteractionClass;
        switch (data.type) {
          case InteractionType.ApplicationCommand:
            switch (data.data.type) {
              case ApplicationCommandType.ChatInput:
                InteractionClass = ChatInputCommandInteraction;
                break;
              case ApplicationCommandType.User:
                InteractionClass = UserContextMenuCommandInteraction;
                break;
              case ApplicationCommandType.Message:
                if (channel && !channel.isTextBased())
                  return;
                InteractionClass = MessageContextMenuCommandInteraction;
                break;
              default:
                client.emit(
                  Events3.Debug,
                  `[INTERACTION] Received application command interaction with unknown type: ${data.data.type}`
                );
                return;
            }
            break;
          case InteractionType.MessageComponent:
            if (channel && !channel.isTextBased())
              return;
            switch (data.data.component_type) {
              case ComponentType.Button:
                InteractionClass = ButtonInteraction;
                break;
              case ComponentType.StringSelect:
                InteractionClass = StringSelectMenuInteraction;
                break;
              case ComponentType.UserSelect:
                InteractionClass = UserSelectMenuInteraction;
                break;
              case ComponentType.RoleSelect:
                InteractionClass = RoleSelectMenuInteraction;
                break;
              case ComponentType.MentionableSelect:
                InteractionClass = MentionableSelectMenuInteraction;
                break;
              case ComponentType.ChannelSelect:
                InteractionClass = ChannelSelectMenuInteraction;
                break;
              default:
                client.emit(
                  Events3.Debug,
                  `[INTERACTION] Received component interaction with unknown type: ${data.data.component_type}`
                );
                return;
            }
            break;
          case InteractionType.ApplicationCommandAutocomplete:
            InteractionClass = AutocompleteInteraction;
            break;
          case InteractionType.ModalSubmit:
            InteractionClass = ModalSubmitInteraction;
            break;
          default:
            client.emit(Events3.Debug, `[INTERACTION] Received interaction with unknown type: ${data.type}`);
            return;
        }
        const interaction = new InteractionClass(client, data);
        client.emit(Events3.InteractionCreate, interaction);
      }
    };
    module2.exports = InteractionCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/InviteCreate.js
var require_InviteCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/InviteCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var InviteCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        const guild = client.guilds.cache.get(data.guild_id);
        if (!channel)
          return false;
        const inviteData = Object.assign(data, { channel, guild });
        const invite = guild.invites._add(inviteData);
        client.emit(Events3.InviteCreate, invite);
        return { invite };
      }
    };
    module2.exports = InviteCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/InviteDelete.js
var require_InviteDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/InviteDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Invite2 = require_Invite();
    var Events3 = require_Events();
    var InviteDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        const guild = client.guilds.cache.get(data.guild_id);
        if (!channel)
          return false;
        const inviteData = Object.assign(data, { channel, guild });
        const invite = new Invite2(client, inviteData);
        guild.invites.cache.delete(invite.code);
        client.emit(Events3.InviteDelete, invite);
        return { invite };
      }
    };
    module2.exports = InviteDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/MessageCreate.js
var require_MessageCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var MessageCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel(data);
        if (channel) {
          if (!channel.isTextBased())
            return {};
          if (channel.isThread()) {
            channel.messageCount++;
            channel.totalMessageSent++;
          }
          const existing = channel.messages.cache.get(data.id);
          if (existing)
            return { message: existing };
          const message = channel.messages._add(data);
          channel.lastMessageId = data.id;
          client.emit(Events3.MessageCreate, message);
          return { message };
        }
        return {};
      }
    };
    module2.exports = MessageCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/MessageDelete.js
var require_MessageDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var MessageDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel(data);
        let message;
        if (channel) {
          if (!channel.isTextBased())
            return {};
          if (channel.isThread())
            channel.messageCount--;
          message = this.getMessage(data, channel);
          if (message) {
            channel.messages.cache.delete(message.id);
            client.emit(Events3.MessageDelete, message);
          }
        }
        return { message };
      }
    };
    module2.exports = MessageDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/MessageDeleteBulk.js
var require_MessageDeleteBulk = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageDeleteBulk.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Action = require_Action();
    var Events3 = require_Events();
    var MessageDeleteBulkAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        if (channel) {
          if (!channel.isTextBased())
            return {};
          if (channel.isThread())
            channel.messageCount -= data.ids.length;
          const ids = data.ids;
          const messages = new Collection2();
          for (const id of ids) {
            const message = this.getMessage(
              {
                id,
                guild_id: data.guild_id
              },
              channel,
              false
            );
            if (message) {
              messages.set(message.id, message);
              channel.messages.cache.delete(id);
            }
          }
          if (messages.size > 0)
            client.emit(Events3.MessageBulkDelete, messages, channel);
          return { messages };
        }
        return {};
      }
    };
    module2.exports = MessageDeleteBulkAction;
  }
});

// node_modules/discord.js/src/client/actions/MessageReactionAdd.js
var require_MessageReactionAdd = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageReactionAdd.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var Partials = require_Partials();
    var MessageReactionAdd = class extends Action {
      handle(data, fromStructure = false) {
        if (!data.emoji)
          return false;
        const user = this.getUserFromMember(data);
        if (!user)
          return false;
        const channel = this.getChannel(data);
        if (!channel?.isTextBased())
          return false;
        const message = this.getMessage(data, channel);
        if (!message)
          return false;
        const includePartial = this.client.options.partials.includes(Partials.Reaction);
        if (message.partial && !includePartial)
          return false;
        const reaction = message.reactions._add({
          emoji: data.emoji,
          count: message.partial ? null : 0,
          me: user.id === this.client.user.id
        });
        if (!reaction)
          return false;
        reaction._add(user);
        if (fromStructure)
          return { message, reaction, user };
        this.client.emit(Events3.MessageReactionAdd, reaction, user);
        return { message, reaction, user };
      }
    };
    module2.exports = MessageReactionAdd;
  }
});

// node_modules/discord.js/src/client/actions/MessageReactionRemove.js
var require_MessageReactionRemove = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageReactionRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var MessageReactionRemove = class extends Action {
      handle(data) {
        if (!data.emoji)
          return false;
        const user = this.getUser(data);
        if (!user)
          return false;
        const channel = this.getChannel(data);
        if (!channel?.isTextBased())
          return false;
        const message = this.getMessage(data, channel);
        if (!message)
          return false;
        const reaction = this.getReaction(data, message, user);
        if (!reaction)
          return false;
        reaction._remove(user);
        this.client.emit(Events3.MessageReactionRemove, reaction, user);
        return { message, reaction, user };
      }
    };
    module2.exports = MessageReactionRemove;
  }
});

// node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js
var require_MessageReactionRemoveAll = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var MessageReactionRemoveAll = class extends Action {
      handle(data) {
        const channel = this.getChannel(data);
        if (!channel?.isTextBased())
          return false;
        const message = this.getMessage(data, channel);
        if (!message)
          return false;
        const removed = message.reactions.cache.clone();
        message.reactions.cache.clear();
        this.client.emit(Events3.MessageReactionRemoveAll, message, removed);
        return { message };
      }
    };
    module2.exports = MessageReactionRemoveAll;
  }
});

// node_modules/discord.js/src/client/actions/MessageReactionRemoveEmoji.js
var require_MessageReactionRemoveEmoji = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageReactionRemoveEmoji.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var MessageReactionRemoveEmoji = class extends Action {
      handle(data) {
        const channel = this.getChannel(data);
        if (!channel?.isTextBased())
          return false;
        const message = this.getMessage(data, channel);
        if (!message)
          return false;
        const reaction = this.getReaction(data, message);
        if (!reaction)
          return false;
        if (!message.partial)
          message.reactions.cache.delete(reaction.emoji.id ?? reaction.emoji.name);
        this.client.emit(Events3.MessageReactionRemoveEmoji, reaction);
        return { reaction };
      }
    };
    module2.exports = MessageReactionRemoveEmoji;
  }
});

// node_modules/discord.js/src/client/actions/MessageUpdate.js
var require_MessageUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var MessageUpdateAction = class extends Action {
      handle(data) {
        const channel = this.getChannel(data);
        if (channel) {
          if (!channel.isTextBased())
            return {};
          const { id, channel_id, guild_id, author, timestamp: timestamp2, type } = data;
          const message = this.getMessage({ id, channel_id, guild_id, author, timestamp: timestamp2, type }, channel);
          if (message) {
            const old = message._update(data);
            return {
              old,
              updated: message
            };
          }
        }
        return {};
      }
    };
    module2.exports = MessageUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/PresenceUpdate.js
var require_PresenceUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/PresenceUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var PresenceUpdateAction = class extends Action {
      handle(data) {
        let user = this.client.users.cache.get(data.user.id);
        if (!user && data.user.username)
          user = this.client.users._add(data.user);
        if (!user)
          return;
        if (data.user.username) {
          if (!user._equals(data.user))
            this.client.actions.UserUpdate.handle(data.user);
        }
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (!guild)
          return;
        const oldPresence = guild.presences.cache.get(user.id)?._clone() ?? null;
        let member = guild.members.cache.get(user.id);
        if (!member && data.status !== "offline") {
          member = guild.members._add({
            user,
            deaf: false,
            mute: false
          });
          this.client.emit(Events3.GuildMemberAvailable, member);
        }
        const newPresence = guild.presences._add(Object.assign(data, { guild }));
        if (this.client.listenerCount(Events3.PresenceUpdate) && !newPresence.equals(oldPresence)) {
          this.client.emit(Events3.PresenceUpdate, oldPresence, newPresence);
        }
      }
    };
    module2.exports = PresenceUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/StageInstanceCreate.js
var require_StageInstanceCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/StageInstanceCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var StageInstanceCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel(data);
        if (channel) {
          const stageInstance = channel.guild.stageInstances._add(data);
          client.emit(Events3.StageInstanceCreate, stageInstance);
          return { stageInstance };
        }
        return {};
      }
    };
    module2.exports = StageInstanceCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/StageInstanceDelete.js
var require_StageInstanceDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/StageInstanceDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var StageInstanceDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel(data);
        if (channel) {
          const stageInstance = channel.guild.stageInstances._add(data);
          if (stageInstance) {
            channel.guild.stageInstances.cache.delete(stageInstance.id);
            client.emit(Events3.StageInstanceDelete, stageInstance);
            return { stageInstance };
          }
        }
        return {};
      }
    };
    module2.exports = StageInstanceDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/StageInstanceUpdate.js
var require_StageInstanceUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/StageInstanceUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var StageInstanceUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel(data);
        if (channel) {
          const oldStageInstance = channel.guild.stageInstances.cache.get(data.id)?._clone() ?? null;
          const newStageInstance = channel.guild.stageInstances._add(data);
          client.emit(Events3.StageInstanceUpdate, oldStageInstance, newStageInstance);
          return { oldStageInstance, newStageInstance };
        }
        return {};
      }
    };
    module2.exports = StageInstanceUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/ThreadCreate.js
var require_ThreadCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/ThreadCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var ThreadCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const existing = client.channels.cache.has(data.id);
        const thread = client.channels._add(data);
        if (!existing && thread) {
          client.emit(Events3.ThreadCreate, thread, data.newly_created ?? false);
        }
        return { thread };
      }
    };
    module2.exports = ThreadCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/ThreadDelete.js
var require_ThreadDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/ThreadDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var ThreadDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const thread = client.channels.cache.get(data.id);
        if (thread) {
          client.channels._remove(thread.id);
          client.emit(Events3.ThreadDelete, thread);
        }
        return { thread };
      }
    };
    module2.exports = ThreadDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/ThreadListSync.js
var require_ThreadListSync = __commonJS({
  "node_modules/discord.js/src/client/actions/ThreadListSync.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Action = require_Action();
    var Events3 = require_Events();
    var ThreadListSyncAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (!guild)
          return {};
        if (data.channel_ids) {
          for (const id of data.channel_ids) {
            const channel = client.channels.resolve(id);
            if (channel)
              this.removeStale(channel);
          }
        } else {
          for (const channel of guild.channels.cache.values()) {
            this.removeStale(channel);
          }
        }
        const syncedThreads = data.threads.reduce((coll, rawThread) => {
          const thread = client.channels._add(rawThread);
          return coll.set(thread.id, thread);
        }, new Collection2());
        for (const rawMember of Object.values(data.members)) {
          const thread = client.channels.cache.get(rawMember.id);
          if (thread) {
            thread.members._add(rawMember);
          }
        }
        client.emit(Events3.ThreadListSync, syncedThreads, guild);
        return {
          syncedThreads
        };
      }
      removeStale(channel) {
        channel.threads?.cache.forEach((thread) => {
          if (!thread.archived) {
            this.client.channels._remove(thread.id);
          }
        });
      }
    };
    module2.exports = ThreadListSyncAction;
  }
});

// node_modules/discord.js/src/client/actions/ThreadMemberUpdate.js
var require_ThreadMemberUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/ThreadMemberUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var ThreadMemberUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const thread = client.channels.cache.get(data.id);
        if (thread) {
          const member = thread.members.cache.get(data.user_id);
          if (!member) {
            const newMember = thread.members._add(data);
            return { newMember };
          }
          const old = member._update(data);
          client.emit(Events3.ThreadMemberUpdate, old, member);
        }
        return {};
      }
    };
    module2.exports = ThreadMemberUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/ThreadMembersUpdate.js
var require_ThreadMembersUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/ThreadMembersUpdate.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Action = require_Action();
    var Events3 = require_Events();
    var ThreadMembersUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const thread = client.channels.cache.get(data.id);
        if (thread) {
          thread.memberCount = data.member_count;
          const addedMembers = new Collection2();
          const removedMembers = new Collection2();
          data.added_members?.reduce(
            (_addedMembers, addedMember) => _addedMembers.set(addedMember.user_id, thread.members._add(addedMember)),
            addedMembers
          );
          data.removed_member_ids?.reduce((removedMembersIds, removedMembersId) => {
            const threadMember = this.getThreadMember(removedMembersId, thread.members);
            if (threadMember)
              removedMembersIds.set(threadMember.id, threadMember);
            thread.members.cache.delete(removedMembersId);
            return removedMembersIds;
          }, removedMembers);
          if (addedMembers.size === 0 && removedMembers.size === 0) {
            return {};
          }
          client.emit(Events3.ThreadMembersUpdate, addedMembers, removedMembers, thread);
        }
        return {};
      }
    };
    module2.exports = ThreadMembersUpdateAction;
  }
});

// node_modules/discord.js/src/structures/Typing.js
var require_Typing = __commonJS({
  "node_modules/discord.js/src/structures/Typing.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var Typing = class extends Base {
      constructor(channel, user, data) {
        super(channel.client);
        this.channel = channel;
        this.user = user;
        this._patch(data);
      }
      _patch(data) {
        if ("timestamp" in data) {
          this.startedTimestamp = data.timestamp * 1e3;
        }
      }
      /**
       * Indicates whether the status is received from a guild.
       * @returns {boolean}
       */
      inGuild() {
        return this.guild !== null;
      }
      /**
       * The time the user started typing at
       * @type {Date}
       * @readonly
       */
      get startedAt() {
        return new Date(this.startedTimestamp);
      }
      /**
       * The guild the status is from
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.channel.guild ?? null;
      }
      /**
       * The member who is typing
       * @type {?GuildMember}
       * @readonly
       */
      get member() {
        return this.guild?.members.resolve(this.user) ?? null;
      }
    };
    module2.exports = Typing;
  }
});

// node_modules/discord.js/src/client/actions/TypingStart.js
var require_TypingStart = __commonJS({
  "node_modules/discord.js/src/client/actions/TypingStart.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Typing = require_Typing();
    var Events3 = require_Events();
    var TypingStart = class extends Action {
      handle(data) {
        const channel = this.getChannel(data);
        if (!channel)
          return;
        if (!channel.isTextBased()) {
          this.client.emit(Events3.Warn, `Discord sent a typing packet to a ${channel.type} channel ${channel.id}`);
          return;
        }
        const user = this.getUserFromMember(data);
        if (user) {
          this.client.emit(Events3.TypingStart, new Typing(channel, user, data));
        }
      }
    };
    module2.exports = TypingStart;
  }
});

// node_modules/discord.js/src/client/actions/UserUpdate.js
var require_UserUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/UserUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var UserUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const newUser = data.id === client.user.id ? client.user : client.users.cache.get(data.id);
        const oldUser = newUser._update(data);
        if (!oldUser.equals(newUser)) {
          client.emit(Events3.UserUpdate, oldUser, newUser);
          return {
            old: oldUser,
            updated: newUser
          };
        }
        return {
          old: null,
          updated: null
        };
      }
    };
    module2.exports = UserUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/VoiceStateUpdate.js
var require_VoiceStateUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/VoiceStateUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var VoiceState = require_VoiceState();
    var Events3 = require_Events();
    var VoiceStateUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const oldState = guild.voiceStates.cache.get(data.user_id)?._clone() ?? new VoiceState(guild, { user_id: data.user_id });
          const newState = guild.voiceStates._add(data);
          let member = guild.members.cache.get(data.user_id);
          if (member && data.member) {
            member._patch(data.member);
          } else if (data.member?.user && data.member.joined_at) {
            member = guild.members._add(data.member);
          }
          if (member?.user.id === client.user.id) {
            client.emit("debug", `[VOICE] received voice state update: ${JSON.stringify(data)}`);
            client.voice.onVoiceStateUpdate(data);
          }
          client.emit(Events3.VoiceStateUpdate, oldState, newState);
        }
      }
    };
    module2.exports = VoiceStateUpdate;
  }
});

// node_modules/discord.js/src/client/actions/WebhooksUpdate.js
var require_WebhooksUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/WebhooksUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var WebhooksUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        if (channel)
          client.emit(Events3.WebhooksUpdate, channel);
      }
    };
    module2.exports = WebhooksUpdate;
  }
});

// node_modules/discord.js/src/client/actions/ActionsManager.js
var require_ActionsManager = __commonJS({
  "node_modules/discord.js/src/client/actions/ActionsManager.js"(exports2, module2) {
    "use strict";
    var ActionsManager2 = class {
      // These symbols represent fully built data that we inject at times when calling actions manually.
      // Action#getUser, for example, will return the injected data (which is assumed to be a built structure)
      // instead of trying to make it from provided data
      injectedUser = Symbol("djs.actions.injectedUser");
      injectedChannel = Symbol("djs.actions.injectedChannel");
      injectedMessage = Symbol("djs.actions.injectedMessage");
      constructor(client) {
        this.client = client;
        this.register(require_ApplicationCommandPermissionsUpdate());
        this.register(require_AutoModerationActionExecution2());
        this.register(require_AutoModerationRuleCreate());
        this.register(require_AutoModerationRuleDelete());
        this.register(require_AutoModerationRuleUpdate());
        this.register(require_ChannelCreate());
        this.register(require_ChannelDelete());
        this.register(require_ChannelUpdate());
        this.register(require_GuildAuditLogEntryCreate());
        this.register(require_GuildBanAdd());
        this.register(require_GuildBanRemove());
        this.register(require_GuildChannelsPositionUpdate());
        this.register(require_GuildDelete());
        this.register(require_GuildEmojiCreate());
        this.register(require_GuildEmojiDelete());
        this.register(require_GuildEmojiUpdate());
        this.register(require_GuildEmojisUpdate());
        this.register(require_GuildIntegrationsUpdate());
        this.register(require_GuildMemberRemove());
        this.register(require_GuildMemberUpdate());
        this.register(require_GuildRoleCreate());
        this.register(require_GuildRoleDelete());
        this.register(require_GuildRoleUpdate());
        this.register(require_GuildRolesPositionUpdate());
        this.register(require_GuildScheduledEventCreate());
        this.register(require_GuildScheduledEventDelete());
        this.register(require_GuildScheduledEventUpdate());
        this.register(require_GuildScheduledEventUserAdd());
        this.register(require_GuildScheduledEventUserRemove());
        this.register(require_GuildStickerCreate());
        this.register(require_GuildStickerDelete());
        this.register(require_GuildStickerUpdate());
        this.register(require_GuildStickersUpdate());
        this.register(require_GuildUpdate());
        this.register(require_InteractionCreate());
        this.register(require_InviteCreate());
        this.register(require_InviteDelete());
        this.register(require_MessageCreate());
        this.register(require_MessageDelete());
        this.register(require_MessageDeleteBulk());
        this.register(require_MessageReactionAdd());
        this.register(require_MessageReactionRemove());
        this.register(require_MessageReactionRemoveAll());
        this.register(require_MessageReactionRemoveEmoji());
        this.register(require_MessageUpdate());
        this.register(require_PresenceUpdate());
        this.register(require_StageInstanceCreate());
        this.register(require_StageInstanceDelete());
        this.register(require_StageInstanceUpdate());
        this.register(require_ThreadCreate());
        this.register(require_ThreadDelete());
        this.register(require_ThreadListSync());
        this.register(require_ThreadMemberUpdate());
        this.register(require_ThreadMembersUpdate());
        this.register(require_TypingStart());
        this.register(require_UserUpdate());
        this.register(require_VoiceStateUpdate());
        this.register(require_WebhooksUpdate());
      }
      register(Action) {
        this[Action.name.replace(/Action$/, "")] = new Action(this.client);
      }
    };
    module2.exports = ActionsManager2;
  }
});

// node_modules/discord.js/src/client/voice/ClientVoiceManager.js
var require_ClientVoiceManager = __commonJS({
  "node_modules/discord.js/src/client/voice/ClientVoiceManager.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    var ClientVoiceManager2 = class {
      constructor(client) {
        Object.defineProperty(this, "client", { value: client });
        this.adapters = /* @__PURE__ */ new Map();
        client.on(Events3.ShardDisconnect, (_, shardId) => {
          for (const [guildId, adapter] of this.adapters.entries()) {
            if (client.guilds.cache.get(guildId)?.shardId === shardId) {
              adapter.destroy();
            }
          }
        });
      }
      onVoiceServer(payload) {
        this.adapters.get(payload.guild_id)?.onVoiceServerUpdate(payload);
      }
      onVoiceStateUpdate(payload) {
        if (payload.guild_id && payload.session_id && payload.user_id === this.client.user?.id) {
          this.adapters.get(payload.guild_id)?.onVoiceStateUpdate(payload);
        }
      }
    };
    module2.exports = ClientVoiceManager2;
  }
});

// node_modules/ws/lib/constants.js
var require_constants5 = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants5();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib2 = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants5();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib2.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib2.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib2.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = {
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver2 = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants5();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver2 = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data, true);
          } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver2;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants5();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender2 = class {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions2, generateMask) {
        this._extensions = extensions2 || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge2 = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            randomFillSync(mask, 0, 4);
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge2 = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge2 ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking)
          return [target, data];
        if (merge2) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(Sender2.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender2.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender2.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            Sender2.frame(data, {
              [kByteLength]: byteLength,
              fin: options.fin,
              generateMask: this._generateMask,
              mask: options.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender2.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const params = this._queue[i];
              const callback = params[params.length - 1];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender2.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender2;
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants5();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event2 = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event2.prototype, "target", { enumerable: true });
    Object.defineProperty(Event2.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event2 {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event2 {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event2 {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget2 = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event2("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event: Event2,
      EventTarget: EventTarget2,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format2(extensions2) {
      return Object.keys(extensions2).map((extension) => {
        let configurations = extensions2[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format: format2, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket2 = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var https2 = require("https");
    var http2 = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Readable: Readable2 } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver2();
    var Sender2 = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants5();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format: format2, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class extends EventEmitter2 {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket2.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver2({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender2(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket2.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket2.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket2.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === WebSocket2.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket2.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = WebSocket2.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https2.request : http2.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format2({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted])
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING)
          return;
        req = websocket._req = null;
        if (res.headers.upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions2;
          try {
            extensions2 = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions2);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions2[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream4, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream4.setHeader) {
        stream4[kAborted] = true;
        stream4.abort();
        if (stream4.socket && !stream4.socket.destroyed) {
          stream4.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream4.destroy(err);
        stream4.once("error", websocket.emit.bind(websocket, "error"));
        stream4.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream4) {
      stream4.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream4) {
      stream4.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream2(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close2() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close2() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open2() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open2() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream2;
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var http2 = require("http");
    var https2 = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket2();
    var { GUID, kWebSocket } = require_constants5();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer2 = class extends EventEmitter2 {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http2.createServer((req, res) => {
            const body = http2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (req.headers.upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!key || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 8 && version !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions2 = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions2[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions2,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions2, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions2, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions2[PerMessageDeflate.extensionName]) {
          const params = extensions2[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions2;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer2;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http2.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket2 = require_websocket2();
    WebSocket2.createWebSocketStream = require_stream();
    WebSocket2.Server = require_websocket_server();
    WebSocket2.Receiver = require_receiver2();
    WebSocket2.Sender = require_sender();
    WebSocket2.WebSocket = WebSocket2;
    WebSocket2.WebSocketServer = WebSocket2.Server;
    module2.exports = WebSocket2;
  }
});

// node_modules/discord.js/src/WebSocket.js
var require_WebSocket = __commonJS({
  "node_modules/discord.js/src/WebSocket.js"(exports2) {
    "use strict";
    var erlpack;
    var { Buffer: Buffer5 } = require("node:buffer");
    try {
      erlpack = require("erlpack");
      if (!erlpack.pack)
        erlpack = null;
    } catch {
    }
    exports2.WebSocket = require_ws();
    var ab = new TextDecoder();
    exports2.encoding = erlpack ? "etf" : "json";
    exports2.pack = erlpack ? erlpack.pack : JSON.stringify;
    exports2.unpack = (data, type) => {
      if (exports2.encoding === "json" || type === "json") {
        if (typeof data !== "string") {
          data = ab.decode(data);
        }
        return JSON.parse(data);
      }
      if (!Buffer5.isBuffer(data))
        data = Buffer5.from(new Uint8Array(data));
      return erlpack.unpack(data);
    };
    exports2.create = (gateway, query = {}, ...args) => {
      const [g, q] = gateway.split("?");
      query.encoding = exports2.encoding;
      query = new URLSearchParams(query);
      if (q)
        new URLSearchParams(q).forEach((v, k) => query.set(k, v));
      const ws = new exports2.WebSocket(`${g}?${query}`, ...args);
      return ws;
    };
    for (const state of ["CONNECTING", "OPEN", "CLOSING", "CLOSED"])
      exports2[state] = exports2.WebSocket[state];
  }
});

// node_modules/discord.js/src/util/WebSocketShardEvents.js
var require_WebSocketShardEvents = __commonJS({
  "node_modules/discord.js/src/util/WebSocketShardEvents.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      Close: "close",
      Destroyed: "destroyed",
      InvalidSession: "invalidSession",
      Ready: "ready",
      Resumed: "resumed",
      AllReady: "allReady"
    };
  }
});

// node_modules/discord.js/src/client/websocket/WebSocketShard.js
var require_WebSocketShard = __commonJS({
  "node_modules/discord.js/src/client/websocket/WebSocketShard.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("node:events");
    var { setTimeout: setTimeout2, setInterval: setInterval2, clearTimeout: clearTimeout2, clearInterval: clearInterval2 } = require("node:timers");
    var { GatewayDispatchEvents, GatewayIntentBits: GatewayIntentBits2, GatewayOpcodes } = require_v106();
    var WebSocket2 = require_WebSocket();
    var Events3 = require_Events();
    var Status2 = require_Status();
    var WebSocketShardEvents = require_WebSocketShardEvents();
    var STATUS_KEYS = Object.keys(Status2);
    var CONNECTION_STATE = Object.keys(WebSocket2.WebSocket);
    var zlib2;
    try {
      zlib2 = require("zlib-sync");
    } catch {
    }
    var WebSocketShard = class extends EventEmitter2 {
      constructor(manager, id) {
        super();
        this.manager = manager;
        this.id = id;
        this.status = Status2.Idle;
        this.sequence = -1;
        this.closeSequence = 0;
        this.sessionId = null;
        this.resumeURL = null;
        this.ping = -1;
        this.lastPingTimestamp = -1;
        this.lastHeartbeatAcked = true;
        this.closeEmitted = false;
        Object.defineProperty(this, "ratelimit", {
          value: {
            queue: [],
            total: 120,
            remaining: 120,
            time: 6e4,
            timer: null
          }
        });
        Object.defineProperty(this, "connection", { value: null, writable: true });
        Object.defineProperty(this, "inflate", { value: null, writable: true });
        Object.defineProperty(this, "helloTimeout", { value: null, writable: true });
        Object.defineProperty(this, "wsCloseTimeout", { value: null, writable: true });
        Object.defineProperty(this, "eventsAttached", { value: false, writable: true });
        Object.defineProperty(this, "expectedGuilds", { value: null, writable: true });
        Object.defineProperty(this, "readyTimeout", { value: null, writable: true });
        Object.defineProperty(this, "connectedAt", { value: 0, writable: true });
      }
      /**
       * Emits a debug event.
       * @param {string} message The debug message
       * @private
       */
      debug(message) {
        this.manager.debug(message, this);
      }
      /**
       * Connects the shard to the gateway.
       * @private
       * @returns {Promise<void>} A promise that will resolve if the shard turns ready successfully,
       * or reject if we couldn't connect
       */
      connect() {
        const { client } = this.manager;
        if (this.connection?.readyState === WebSocket2.OPEN && this.status === Status2.Ready) {
          return Promise.resolve();
        }
        const gateway = this.resumeURL ?? this.manager.gateway;
        return new Promise((resolve, reject) => {
          const cleanup = () => {
            this.removeListener(WebSocketShardEvents.Close, onClose);
            this.removeListener(WebSocketShardEvents.Ready, onReady);
            this.removeListener(WebSocketShardEvents.Resumed, onResumed);
            this.removeListener(WebSocketShardEvents.InvalidSession, onInvalidOrDestroyed);
            this.removeListener(WebSocketShardEvents.Destroyed, onInvalidOrDestroyed);
          };
          const onReady = () => {
            cleanup();
            resolve();
          };
          const onResumed = () => {
            cleanup();
            resolve();
          };
          const onClose = (event) => {
            cleanup();
            reject(event);
          };
          const onInvalidOrDestroyed = () => {
            cleanup();
            reject();
          };
          this.once(WebSocketShardEvents.Ready, onReady);
          this.once(WebSocketShardEvents.Resumed, onResumed);
          this.once(WebSocketShardEvents.Close, onClose);
          this.once(WebSocketShardEvents.InvalidSession, onInvalidOrDestroyed);
          this.once(WebSocketShardEvents.Destroyed, onInvalidOrDestroyed);
          if (this.connection?.readyState === WebSocket2.OPEN) {
            this.debug("An open connection was found, attempting an immediate identify.");
            this.identify();
            return;
          }
          if (this.connection) {
            this.debug(`A connection object was found. Cleaning up before continuing.
    State: ${CONNECTION_STATE[this.connection.readyState]}`);
            this.destroy({ emit: false });
          }
          const wsQuery = { v: client.options.ws.version };
          if (zlib2) {
            this.inflate = new zlib2.Inflate({
              chunkSize: 65535,
              flush: zlib2.Z_SYNC_FLUSH,
              to: WebSocket2.encoding === "json" ? "string" : ""
            });
            wsQuery.compress = "zlib-stream";
          }
          this.debug(
            `[CONNECT]
    Gateway    : ${gateway}
    Version    : ${client.options.ws.version}
    Encoding   : ${WebSocket2.encoding}
    Compression: ${zlib2 ? "zlib-stream" : "none"}`
          );
          this.status = this.status === Status2.Disconnected ? Status2.Reconnecting : Status2.Connecting;
          this.setHelloTimeout();
          this.connectedAt = Date.now();
          const ws = this.connection = WebSocket2.create(gateway, wsQuery, { handshakeTimeout: 3e4 });
          ws.onopen = this.onOpen.bind(this);
          ws.onmessage = this.onMessage.bind(this);
          ws.onerror = this.onError.bind(this);
          ws.onclose = this.onClose.bind(this);
        });
      }
      /**
       * Called whenever a connection is opened to the gateway.
       * @private
       */
      onOpen() {
        this.debug(`[CONNECTED] Took ${Date.now() - this.connectedAt}ms`);
        this.status = Status2.Nearly;
      }
      /**
       * Called whenever a message is received.
       * @param {MessageEvent} event Event received
       * @private
       */
      onMessage({ data }) {
        let raw;
        if (data instanceof ArrayBuffer)
          data = new Uint8Array(data);
        if (zlib2) {
          const l = data.length;
          const flush = l >= 4 && data[l - 4] === 0 && data[l - 3] === 0 && data[l - 2] === 255 && data[l - 1] === 255;
          this.inflate.push(data, flush && zlib2.Z_SYNC_FLUSH);
          if (!flush)
            return;
          raw = this.inflate.result;
        } else {
          raw = data;
        }
        let packet;
        try {
          packet = WebSocket2.unpack(raw);
        } catch (err) {
          this.manager.client.emit(Events3.ShardError, err, this.id);
          return;
        }
        this.manager.client.emit(Events3.Raw, packet, this.id);
        if (packet.op === GatewayOpcodes.Dispatch)
          this.manager.emit(packet.t, packet.d, this.id);
        this.onPacket(packet);
      }
      /**
       * Called whenever an error occurs with the WebSocket.
       * @param {ErrorEvent} event The error that occurred
       * @private
       */
      onError(event) {
        const error = event?.error ?? event;
        if (!error)
          return;
        this.manager.client.emit(Events3.ShardError, error, this.id);
      }
      /**
       * @external CloseEvent
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}
       */
      /**
       * @external ErrorEvent
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent}
       */
      /**
       * @external MessageEvent
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}
       */
      /**
       * Called whenever a connection to the gateway is closed.
       * @param {CloseEvent} event Close event that was received
       * @private
       */
      onClose(event) {
        this.closeEmitted = true;
        if (this.sequence !== -1)
          this.closeSequence = this.sequence;
        this.sequence = -1;
        this.setHeartbeatTimer(-1);
        this.setHelloTimeout(-1);
        this.setWsCloseTimeout(-1);
        if (this.connection) {
          this._cleanupConnection();
          this.destroy({ reset: !this.sessionId, emit: false, log: false });
        }
        this.status = Status2.Disconnected;
        this.emitClose(event);
      }
      /**
       * This method is responsible to emit close event for this shard.
       * This method helps the shard reconnect.
       * @param {CloseEvent} [event] Close event that was received
       */
      emitClose(event = {
        code: 1011,
        reason: "INTERNAL_ERROR",
        wasClean: false
      }) {
        this.debug(`[CLOSE]
    Event Code: ${event.code}
    Clean     : ${event.wasClean}
    Reason    : ${event.reason ?? "No reason received"}`);
        this.emit(WebSocketShardEvents.Close, event);
      }
      /**
       * Called whenever a packet is received.
       * @param {Object} packet The received packet
       * @private
       */
      onPacket(packet) {
        if (!packet) {
          this.debug(`Received broken packet: '${packet}'.`);
          return;
        }
        switch (packet.t) {
          case GatewayDispatchEvents.Ready:
            this.emit(WebSocketShardEvents.Ready);
            this.sessionId = packet.d.session_id;
            this.resumeURL = packet.d.resume_gateway_url;
            this.expectedGuilds = new Set(packet.d.guilds.map((d) => d.id));
            this.status = Status2.WaitingForGuilds;
            this.debug(`[READY] Session ${this.sessionId} | Resume url ${this.resumeURL}.`);
            this.lastHeartbeatAcked = true;
            this.sendHeartbeat("ReadyHeartbeat");
            break;
          case GatewayDispatchEvents.Resumed: {
            this.emit(WebSocketShardEvents.Resumed);
            this.status = Status2.Ready;
            const replayed = packet.s - this.closeSequence;
            this.debug(`[RESUMED] Session ${this.sessionId} | Replayed ${replayed} events.`);
            this.lastHeartbeatAcked = true;
            this.sendHeartbeat("ResumeHeartbeat");
            break;
          }
        }
        if (packet.s > this.sequence)
          this.sequence = packet.s;
        switch (packet.op) {
          case GatewayOpcodes.Hello:
            this.setHelloTimeout(-1);
            this.setHeartbeatTimer(packet.d.heartbeat_interval);
            this.identify();
            break;
          case GatewayOpcodes.Reconnect:
            this.debug("[RECONNECT] Discord asked us to reconnect");
            this.destroy({ closeCode: 4e3 });
            break;
          case GatewayOpcodes.InvalidSession:
            this.debug(`[INVALID SESSION] Resumable: ${packet.d}.`);
            if (packet.d) {
              this.identifyResume();
              return;
            }
            this.sequence = -1;
            this.sessionId = null;
            this.status = Status2.Reconnecting;
            this.emit(WebSocketShardEvents.InvalidSession);
            break;
          case GatewayOpcodes.HeartbeatAck:
            this.ackHeartbeat();
            break;
          case GatewayOpcodes.Heartbeat:
            this.sendHeartbeat("HeartbeatRequest", true);
            break;
          default:
            this.manager.handlePacket(packet, this);
            if (this.status === Status2.WaitingForGuilds && packet.t === GatewayDispatchEvents.GuildCreate) {
              this.expectedGuilds.delete(packet.d.id);
              this.checkReady();
            }
        }
      }
      /**
       * Checks if the shard can be marked as ready
       * @private
       */
      checkReady() {
        if (this.readyTimeout) {
          clearTimeout2(this.readyTimeout);
          this.readyTimeout = null;
        }
        if (!this.expectedGuilds.size) {
          this.debug("Shard received all its guilds. Marking as fully ready.");
          this.status = Status2.Ready;
          this.emit(WebSocketShardEvents.AllReady);
          return;
        }
        const hasGuildsIntent = this.manager.client.options.intents.has(GatewayIntentBits2.Guilds);
        const { waitGuildTimeout } = this.manager.client.options;
        this.readyTimeout = setTimeout2(
          () => {
            this.debug(
              `Shard ${hasGuildsIntent ? "did" : "will"} not receive any more guild packets${hasGuildsIntent ? ` in ${waitGuildTimeout} ms` : ""}.
Unavailable guild count: ${this.expectedGuilds.size}`
            );
            this.readyTimeout = null;
            this.status = Status2.Ready;
            this.emit(WebSocketShardEvents.AllReady, this.expectedGuilds);
          },
          hasGuildsIntent ? waitGuildTimeout : 0
        ).unref();
      }
      /**
       * Sets the HELLO packet timeout.
       * @param {number} [time] If set to -1, it will clear the hello timeout
       * @private
       */
      setHelloTimeout(time) {
        if (time === -1) {
          if (this.helloTimeout) {
            this.debug("Clearing the HELLO timeout.");
            clearTimeout2(this.helloTimeout);
            this.helloTimeout = null;
          }
          return;
        }
        this.debug("Setting a HELLO timeout for 20s.");
        this.helloTimeout = setTimeout2(() => {
          this.debug("Did not receive HELLO in time. Destroying and connecting again.");
          this.destroy({ reset: true, closeCode: 4009 });
        }, 2e4).unref();
      }
      /**
       * Sets the WebSocket Close timeout.
       * This method is responsible for detecting any zombie connections if the WebSocket fails to close properly.
       * @param {number} [time] If set to -1, it will clear the timeout
       * @private
       */
      setWsCloseTimeout(time) {
        if (this.wsCloseTimeout) {
          this.debug("[WebSocket] Clearing the close timeout.");
          clearTimeout2(this.wsCloseTimeout);
        }
        if (time === -1) {
          this.wsCloseTimeout = null;
          return;
        }
        this.wsCloseTimeout = setTimeout2(() => {
          this.setWsCloseTimeout(-1);
          this.debug(`[WebSocket] Close Emitted: ${this.closeEmitted}`);
          if (this.closeEmitted) {
            this.debug(
              `[WebSocket] was closed. | WS State: ${CONNECTION_STATE[this.connection?.readyState ?? WebSocket2.CLOSED]}`
            );
            this.closeEmitted = false;
            return;
          }
          this.debug(
            `[WebSocket] did not close properly, assuming a zombie connection.
Emitting close and reconnecting again.`
          );
          if (this.connection)
            this._cleanupConnection();
          this.emitClose({
            code: 4009,
            reason: "Session time out.",
            wasClean: false
          });
        }, time);
      }
      /**
       * Sets the heartbeat timer for this shard.
       * @param {number} time If -1, clears the interval, any other number sets an interval
       * @private
       */
      setHeartbeatTimer(time) {
        if (time === -1) {
          if (this.heartbeatInterval) {
            this.debug("Clearing the heartbeat interval.");
            clearInterval2(this.heartbeatInterval);
            this.heartbeatInterval = null;
          }
          return;
        }
        this.debug(`Setting a heartbeat interval for ${time}ms.`);
        if (this.heartbeatInterval)
          clearInterval2(this.heartbeatInterval);
        this.heartbeatInterval = setInterval2(() => this.sendHeartbeat(), time).unref();
      }
      /**
       * Sends a heartbeat to the WebSocket.
       * If this shard didn't receive a heartbeat last time, it will destroy it and reconnect
       * @param {string} [tag='HeartbeatTimer'] What caused this heartbeat to be sent
       * @param {boolean} [ignoreHeartbeatAck] If we should send the heartbeat forcefully.
       * @private
       */
      sendHeartbeat(tag = "HeartbeatTimer", ignoreHeartbeatAck = [Status2.WaitingForGuilds, Status2.Identifying, Status2.Resuming].includes(this.status)) {
        if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {
          this.debug(`[${tag}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);
        } else if (!this.lastHeartbeatAcked) {
          this.debug(
            `[${tag}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.
    Status          : ${STATUS_KEYS[this.status]}
    Sequence        : ${this.sequence}
    Connection State: ${this.connection ? CONNECTION_STATE[this.connection.readyState] : "No Connection??"}`
          );
          this.destroy({ reset: true, closeCode: 4009 });
          return;
        }
        this.debug(`[${tag}] Sending a heartbeat.`);
        this.lastHeartbeatAcked = false;
        this.lastPingTimestamp = Date.now();
        this.send({ op: GatewayOpcodes.Heartbeat, d: this.sequence }, true);
      }
      /**
       * Acknowledges a heartbeat.
       * @private
       */
      ackHeartbeat() {
        this.lastHeartbeatAcked = true;
        const latency = Date.now() - this.lastPingTimestamp;
        this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`);
        this.ping = latency;
      }
      /**
       * Identifies the client on the connection.
       * @private
       * @returns {void}
       */
      identify() {
        return this.sessionId ? this.identifyResume() : this.identifyNew();
      }
      /**
       * Identifies as a new connection on the gateway.
       * @private
       */
      identifyNew() {
        const { client } = this.manager;
        if (!client.token) {
          this.debug("[IDENTIFY] No token available to identify a new session.");
          return;
        }
        this.status = Status2.Identifying;
        const d = {
          ...client.options.ws,
          intents: client.options.intents.bitfield,
          token: client.token,
          shard: [this.id, Number(client.options.shardCount)]
        };
        this.debug(`[IDENTIFY] Shard ${this.id}/${client.options.shardCount} with intents: ${d.intents}`);
        this.send({ op: GatewayOpcodes.Identify, d }, true);
      }
      /**
       * Resumes a session on the gateway.
       * @private
       */
      identifyResume() {
        if (!this.sessionId) {
          this.debug("[RESUME] No session id was present; identifying as a new session.");
          this.identifyNew();
          return;
        }
        this.status = Status2.Resuming;
        this.debug(`[RESUME] Session ${this.sessionId}, sequence ${this.closeSequence}`);
        const d = {
          token: this.manager.client.token,
          session_id: this.sessionId,
          seq: this.closeSequence
        };
        this.send({ op: GatewayOpcodes.Resume, d }, true);
      }
      /**
       * Adds a packet to the queue to be sent to the gateway.
       * <warn>If you use this method, make sure you understand that you need to provide
       * a full [Payload](https://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-commands).
       * Do not use this method if you don't know what you're doing.</warn>
       * @param {Object} data The full packet to send
       * @param {boolean} [important=false] If this packet should be added first in queue
       */
      send(data, important = false) {
        this.ratelimit.queue[important ? "unshift" : "push"](data);
        this.processQueue();
      }
      /**
       * Sends data, bypassing the queue.
       * @param {Object} data Packet to send
       * @returns {void}
       * @private
       */
      _send(data) {
        if (this.connection?.readyState !== WebSocket2.OPEN) {
          this.debug(
            `Tried to send packet '${JSON.stringify(data).replaceAll(
              this.manager.client.token,
              this.manager.client._censoredToken
            )}' but no WebSocket is available!`
          );
          this.destroy({ closeCode: 4e3 });
          return;
        }
        this.connection.send(WebSocket2.pack(data), (err) => {
          if (err)
            this.manager.client.emit(Events3.ShardError, err, this.id);
        });
      }
      /**
       * Processes the current WebSocket queue.
       * @returns {void}
       * @private
       */
      processQueue() {
        if (this.ratelimit.remaining === 0)
          return;
        if (this.ratelimit.queue.length === 0)
          return;
        if (this.ratelimit.remaining === this.ratelimit.total) {
          this.ratelimit.timer = setTimeout2(() => {
            this.ratelimit.remaining = this.ratelimit.total;
            this.processQueue();
          }, this.ratelimit.time).unref();
        }
        while (this.ratelimit.remaining > 0) {
          const item = this.ratelimit.queue.shift();
          if (!item)
            return;
          this._send(item);
          this.ratelimit.remaining--;
        }
      }
      /**
       * Destroys this shard and closes its WebSocket connection.
       * @param {Object} [options={ closeCode: 1000, reset: false, emit: true, log: true }] Options for destroying the shard
       * @private
       */
      destroy({ closeCode = 1e3, reset = false, emit = true, log = true } = {}) {
        if (log) {
          this.debug(`[DESTROY]
    Close Code    : ${closeCode}
    Reset         : ${reset}
    Emit DESTROYED: ${emit}`);
        }
        this.setHeartbeatTimer(-1);
        this.setHelloTimeout(-1);
        this.debug(
          `[WebSocket] Destroy: Attempting to close the WebSocket. | WS State: ${CONNECTION_STATE[this.connection?.readyState ?? WebSocket2.CLOSED]}`
        );
        if (this.connection) {
          if (this.connection.readyState === WebSocket2.OPEN) {
            this.connection.close(closeCode);
            this.debug(`[WebSocket] Close: Tried closing. | WS State: ${CONNECTION_STATE[this.connection.readyState]}`);
          } else {
            this.debug(`WS State: ${CONNECTION_STATE[this.connection.readyState]}`);
            this._cleanupConnection();
            try {
              this.connection.close(closeCode);
            } catch (err) {
              this.debug(
                `[WebSocket] Close: Something went wrong while closing the WebSocket: ${err.message || err}. Forcefully terminating the connection | WS State: ${CONNECTION_STATE[this.connection.readyState]}`
              );
              this.connection.terminate();
            }
            if (emit)
              this._emitDestroyed();
          }
        } else if (emit) {
          this._emitDestroyed();
        }
        this.debug(
          `[WebSocket] Adding a WebSocket close timeout to ensure a correct WS reconnect.
        Timeout: ${this.manager.client.options.closeTimeout}ms`
        );
        this.setWsCloseTimeout(this.manager.client.options.closeTimeout);
        this.connection = null;
        this.status = Status2.Disconnected;
        if (this.sequence !== -1)
          this.closeSequence = this.sequence;
        if (reset) {
          this.sequence = -1;
          this.sessionId = null;
          this.resumeURL = null;
        }
        this.ratelimit.remaining = this.ratelimit.total;
        this.ratelimit.queue.length = 0;
        if (this.ratelimit.timer) {
          clearTimeout2(this.ratelimit.timer);
          this.ratelimit.timer = null;
        }
      }
      /**
       * Cleans up the WebSocket connection listeners.
       * @private
       */
      _cleanupConnection() {
        this.connection.onopen = this.connection.onclose = this.connection.onmessage = null;
        this.connection.onerror = () => null;
      }
      /**
       * Emits the DESTROYED event on the shard
       * @private
       */
      _emitDestroyed() {
        this.emit(WebSocketShardEvents.Destroyed);
      }
    };
    module2.exports = WebSocketShard;
  }
});

// node_modules/discord.js/src/client/websocket/handlers/APPLICATION_COMMAND_PERMISSIONS_UPDATE.js
var require_APPLICATION_COMMAND_PERMISSIONS_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/APPLICATION_COMMAND_PERMISSIONS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ApplicationCommandPermissionsUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_ACTION_EXECUTION.js
var require_AUTO_MODERATION_ACTION_EXECUTION = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_ACTION_EXECUTION.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.AutoModerationActionExecution.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_CREATE.js
var require_AUTO_MODERATION_RULE_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.AutoModerationRuleCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_DELETE.js
var require_AUTO_MODERATION_RULE_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.AutoModerationRuleDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_UPDATE.js
var require_AUTO_MODERATION_RULE_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.AutoModerationRuleUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_CREATE.js
var require_CHANNEL_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/CHANNEL_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ChannelCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_DELETE.js
var require_CHANNEL_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/CHANNEL_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ChannelDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js
var require_CHANNEL_PINS_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    module2.exports = (client, { d: data }) => {
      const channel = client.channels.cache.get(data.channel_id);
      const time = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      if (channel) {
        channel.lastPinTimestamp = time;
        client.emit(Events3.ChannelPinsUpdate, channel, time);
      }
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_UPDATE.js
var require_CHANNEL_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/CHANNEL_UPDATE.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    module2.exports = (client, packet) => {
      const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
      if (old && updated) {
        client.emit(Events3.ChannelUpdate, old, updated);
      }
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_AUDIT_LOG_ENTRY_CREATE.js
var require_GUILD_AUDIT_LOG_ENTRY_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_AUDIT_LOG_ENTRY_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildAuditLogEntryCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_ADD.js
var require_GUILD_BAN_ADD = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_ADD.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildBanAdd.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_REMOVE.js
var require_GUILD_BAN_REMOVE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildBanRemove.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_CREATE.js
var require_GUILD_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_CREATE.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    var Status2 = require_Status();
    module2.exports = (client, { d: data }, shard) => {
      let guild = client.guilds.cache.get(data.id);
      if (guild) {
        if (!guild.available && !data.unavailable) {
          guild._patch(data);
        }
      } else {
        data.shardId = shard.id;
        guild = client.guilds._add(data);
        if (client.ws.status === Status2.Ready) {
          client.emit(Events3.GuildCreate, guild);
        }
      }
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_DELETE.js
var require_GUILD_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js
var require_GUILD_EMOJIS_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildEmojisUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js
var require_GUILD_INTEGRATIONS_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildIntegrationsUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js
var require_GUILD_MEMBERS_CHUNK = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Events3 = require_Events();
    module2.exports = (client, { d: data }) => {
      const guild = client.guilds.cache.get(data.guild_id);
      if (!guild)
        return;
      const members = new Collection2();
      for (const member of data.members)
        members.set(member.user.id, guild.members._add(member));
      if (data.presences) {
        for (const presence of data.presences)
          guild.presences._add(Object.assign(presence, { guild }));
      }
      client.emit(Events3.GuildMembersChunk, members, guild, {
        index: data.chunk_index,
        count: data.chunk_count,
        notFound: data.not_found,
        nonce: data.nonce
      });
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_ADD.js
var require_GUILD_MEMBER_ADD = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_ADD.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    var Status2 = require_Status();
    module2.exports = (client, { d: data }, shard) => {
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        guild.memberCount++;
        const member = guild.members._add(data);
        if (shard.status === Status2.Ready) {
          client.emit(Events3.GuildMemberAdd, member);
        }
      }
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js
var require_GUILD_MEMBER_REMOVE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet, shard) => {
      client.actions.GuildMemberRemove.handle(packet.d, shard);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js
var require_GUILD_MEMBER_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet, shard) => {
      client.actions.GuildMemberUpdate.handle(packet.d, shard);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_CREATE.js
var require_GUILD_ROLE_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildRoleCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_DELETE.js
var require_GUILD_ROLE_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildRoleDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js
var require_GUILD_ROLE_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildRoleUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_CREATE.js
var require_GUILD_SCHEDULED_EVENT_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_DELETE.js
var require_GUILD_SCHEDULED_EVENT_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_UPDATE.js
var require_GUILD_SCHEDULED_EVENT_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_ADD.js
var require_GUILD_SCHEDULED_EVENT_USER_ADD = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_ADD.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventUserAdd.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_REMOVE.js
var require_GUILD_SCHEDULED_EVENT_USER_REMOVE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventUserRemove.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_STICKERS_UPDATE.js
var require_GUILD_STICKERS_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_STICKERS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildStickersUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_UPDATE.js
var require_GUILD_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/INTERACTION_CREATE.js
var require_INTERACTION_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/INTERACTION_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.InteractionCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/INVITE_CREATE.js
var require_INVITE_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/INVITE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.InviteCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/INVITE_DELETE.js
var require_INVITE_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/INVITE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.InviteDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_CREATE.js
var require_MESSAGE_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE.js
var require_MESSAGE_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js
var require_MESSAGE_DELETE_BULK = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageDeleteBulk.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js
var require_MESSAGE_REACTION_ADD = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionAdd.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js
var require_MESSAGE_REACTION_REMOVE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionRemove.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js
var require_MESSAGE_REACTION_REMOVE_ALL = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionRemoveAll.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js
var require_MESSAGE_REACTION_REMOVE_EMOJI = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionRemoveEmoji.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_UPDATE.js
var require_MESSAGE_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_UPDATE.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    module2.exports = (client, packet) => {
      const { old, updated } = client.actions.MessageUpdate.handle(packet.d);
      if (old && updated) {
        client.emit(Events3.MessageUpdate, old, updated);
      }
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/PRESENCE_UPDATE.js
var require_PRESENCE_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/PRESENCE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.PresenceUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/structures/ClientUser.js
var require_ClientUser = __commonJS({
  "node_modules/discord.js/src/structures/ClientUser.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var User = require_User();
    var DataResolver2 = require_DataResolver();
    var ClientUser = class extends User {
      _patch(data) {
        super._patch(data);
        if ("verified" in data) {
          this.verified = data.verified;
        }
        if ("mfa_enabled" in data) {
          this.mfaEnabled = typeof data.mfa_enabled === "boolean" ? data.mfa_enabled : null;
        } else {
          this.mfaEnabled ??= null;
        }
        if ("token" in data)
          this.client.token = data.token;
      }
      /**
       * Represents the client user's presence
       * @type {ClientPresence}
       * @readonly
       */
      get presence() {
        return this.client.presence;
      }
      /**
       * Data used to edit the logged in client
       * @typedef {Object} ClientUserEditOptions
       * @property {string} [username] The new username
       * @property {?(BufferResolvable|Base64Resolvable)} [avatar] The new avatar
       */
      /**
       * Edits the logged in client.
       * @param {ClientUserEditOptions} options The options to provide
       * @returns {Promise<ClientUser>}
       */
      async edit({ username, avatar }) {
        const data = await this.client.rest.patch(Routes2.user(), {
          body: { username, avatar: avatar && await DataResolver2.resolveImage(avatar) }
        });
        this.client.token = data.token;
        this.client.rest.setToken(data.token);
        const { updated } = this.client.actions.UserUpdate.handle(data);
        return updated ?? this;
      }
      /**
       * Sets the username of the logged in client.
       * <info>Changing usernames in Discord is heavily rate limited, with only 2 requests
       * every hour. Use this sparingly!</info>
       * @param {string} username The new username
       * @returns {Promise<ClientUser>}
       * @example
       * // Set username
       * client.user.setUsername('discordjs')
       *   .then(user => console.log(`My new username is ${user.username}`))
       *   .catch(console.error);
       */
      setUsername(username) {
        return this.edit({ username });
      }
      /**
       * Sets the avatar of the logged in client.
       * @param {?(BufferResolvable|Base64Resolvable)} avatar The new avatar
       * @returns {Promise<ClientUser>}
       * @example
       * // Set avatar
       * client.user.setAvatar('./avatar.png')
       *   .then(user => console.log(`New avatar set!`))
       *   .catch(console.error);
       */
      setAvatar(avatar) {
        return this.edit({ avatar });
      }
      /**
       * Options for setting activities
       * @typedef {Object} ActivitiesOptions
       * @property {string} [name] Name of the activity
       * @property {ActivityType} [type] Type of the activity
       * @property {string} [url] Twitch / YouTube stream URL
       */
      /**
       * Data resembling a raw Discord presence.
       * @typedef {Object} PresenceData
       * @property {PresenceStatusData} [status] Status of the user
       * @property {boolean} [afk] Whether the user is AFK
       * @property {ActivitiesOptions[]} [activities] Activity the user is playing
       * @property {number|number[]} [shardId] Shard id(s) to have the activity set on
       */
      /**
       * Sets the full presence of the client user.
       * @param {PresenceData} data Data for the presence
       * @returns {ClientPresence}
       * @example
       * // Set the client user's presence
       * client.user.setPresence({ activities: [{ name: 'with discord.js' }], status: 'idle' });
       */
      setPresence(data) {
        return this.client.presence.set(data);
      }
      /**
       * A user's status. Must be one of:
       * * `online`
       * * `idle`
       * * `invisible`
       * * `dnd` (do not disturb)
       * @typedef {string} PresenceStatusData
       */
      /**
       * Sets the status of the client user.
       * @param {PresenceStatusData} status Status to change to
       * @param {number|number[]} [shardId] Shard id(s) to have the activity set on
       * @returns {ClientPresence}
       * @example
       * // Set the client user's status
       * client.user.setStatus('idle');
       */
      setStatus(status, shardId) {
        return this.setPresence({ status, shardId });
      }
      /**
       * Options for setting an activity.
       * @typedef {Object} ActivityOptions
       * @property {string} [name] Name of the activity
       * @property {string} [url] Twitch / YouTube stream URL
       * @property {ActivityType} [type] Type of the activity
       * @property {number|number[]} [shardId] Shard Id(s) to have the activity set on
       */
      /**
       * Sets the activity the client user is playing.
       * @param {string|ActivityOptions} [name] Activity being played, or options for setting the activity
       * @param {ActivityOptions} [options] Options for setting the activity
       * @returns {ClientPresence}
       * @example
       * // Set the client user's activity
       * client.user.setActivity('discord.js', { type: ActivityType.Watching });
       */
      setActivity(name, options = {}) {
        if (!name)
          return this.setPresence({ activities: [], shardId: options.shardId });
        const activity = Object.assign({}, options, typeof name === "object" ? name : { name });
        return this.setPresence({ activities: [activity], shardId: activity.shardId });
      }
      /**
       * Sets/removes the AFK flag for the client user.
       * @param {boolean} [afk=true] Whether or not the user is AFK
       * @param {number|number[]} [shardId] Shard Id(s) to have the AFK flag set on
       * @returns {ClientPresence}
       */
      setAFK(afk = true, shardId) {
        return this.setPresence({ afk, shardId });
      }
    };
    module2.exports = ClientUser;
  }
});

// node_modules/discord.js/src/client/websocket/handlers/READY.js
var require_READY = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/READY.js"(exports2, module2) {
    "use strict";
    var ClientApplication = require_ClientApplication();
    var ClientUser;
    module2.exports = (client, { d: data }, shard) => {
      if (client.user) {
        client.user._patch(data.user);
      } else {
        ClientUser ??= require_ClientUser();
        client.user = new ClientUser(client, data.user);
        client.users.cache.set(client.user.id, client.user);
      }
      for (const guild of data.guilds) {
        guild.shardId = shard.id;
        client.guilds._add(guild);
      }
      if (client.application) {
        client.application._patch(data.application);
      } else {
        client.application = new ClientApplication(client, data.application);
      }
      shard.checkReady();
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/RESUMED.js
var require_RESUMED = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/RESUMED.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    module2.exports = (client, packet, shard) => {
      const replayed = shard.sequence - shard.closeSequence;
      client.emit(Events3.ShardResume, shard.id, replayed);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js
var require_STAGE_INSTANCE_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.StageInstanceCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js
var require_STAGE_INSTANCE_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.StageInstanceDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js
var require_STAGE_INSTANCE_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.StageInstanceUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_CREATE.js
var require_THREAD_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/THREAD_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_DELETE.js
var require_THREAD_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/THREAD_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_LIST_SYNC.js
var require_THREAD_LIST_SYNC = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/THREAD_LIST_SYNC.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadListSync.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js
var require_THREAD_MEMBERS_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadMembersUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js
var require_THREAD_MEMBER_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadMemberUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_UPDATE.js
var require_THREAD_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/THREAD_UPDATE.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    module2.exports = (client, packet) => {
      const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
      if (old && updated) {
        client.emit(Events3.ThreadUpdate, old, updated);
      }
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/TYPING_START.js
var require_TYPING_START = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/TYPING_START.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.TypingStart.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/USER_UPDATE.js
var require_USER_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/USER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.UserUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js
var require_VOICE_SERVER_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.emit("debug", `[VOICE] received voice server: ${JSON.stringify(packet)}`);
      client.voice.onVoiceServer(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/VOICE_STATE_UPDATE.js
var require_VOICE_STATE_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/VOICE_STATE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.VoiceStateUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/WEBHOOKS_UPDATE.js
var require_WEBHOOKS_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/WEBHOOKS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.WebhooksUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/index.js
var require_handlers = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/index.js"(exports2, module2) {
    "use strict";
    var handlers = Object.fromEntries([
      ["APPLICATION_COMMAND_PERMISSIONS_UPDATE", require_APPLICATION_COMMAND_PERMISSIONS_UPDATE()],
      ["AUTO_MODERATION_ACTION_EXECUTION", require_AUTO_MODERATION_ACTION_EXECUTION()],
      ["AUTO_MODERATION_RULE_CREATE", require_AUTO_MODERATION_RULE_CREATE()],
      ["AUTO_MODERATION_RULE_DELETE", require_AUTO_MODERATION_RULE_DELETE()],
      ["AUTO_MODERATION_RULE_UPDATE", require_AUTO_MODERATION_RULE_UPDATE()],
      ["CHANNEL_CREATE", require_CHANNEL_CREATE()],
      ["CHANNEL_DELETE", require_CHANNEL_DELETE()],
      ["CHANNEL_PINS_UPDATE", require_CHANNEL_PINS_UPDATE()],
      ["CHANNEL_UPDATE", require_CHANNEL_UPDATE()],
      ["GUILD_AUDIT_LOG_ENTRY_CREATE", require_GUILD_AUDIT_LOG_ENTRY_CREATE()],
      ["GUILD_BAN_ADD", require_GUILD_BAN_ADD()],
      ["GUILD_BAN_REMOVE", require_GUILD_BAN_REMOVE()],
      ["GUILD_CREATE", require_GUILD_CREATE()],
      ["GUILD_DELETE", require_GUILD_DELETE()],
      ["GUILD_EMOJIS_UPDATE", require_GUILD_EMOJIS_UPDATE()],
      ["GUILD_INTEGRATIONS_UPDATE", require_GUILD_INTEGRATIONS_UPDATE()],
      ["GUILD_MEMBERS_CHUNK", require_GUILD_MEMBERS_CHUNK()],
      ["GUILD_MEMBER_ADD", require_GUILD_MEMBER_ADD()],
      ["GUILD_MEMBER_REMOVE", require_GUILD_MEMBER_REMOVE()],
      ["GUILD_MEMBER_UPDATE", require_GUILD_MEMBER_UPDATE()],
      ["GUILD_ROLE_CREATE", require_GUILD_ROLE_CREATE()],
      ["GUILD_ROLE_DELETE", require_GUILD_ROLE_DELETE()],
      ["GUILD_ROLE_UPDATE", require_GUILD_ROLE_UPDATE()],
      ["GUILD_SCHEDULED_EVENT_CREATE", require_GUILD_SCHEDULED_EVENT_CREATE()],
      ["GUILD_SCHEDULED_EVENT_DELETE", require_GUILD_SCHEDULED_EVENT_DELETE()],
      ["GUILD_SCHEDULED_EVENT_UPDATE", require_GUILD_SCHEDULED_EVENT_UPDATE()],
      ["GUILD_SCHEDULED_EVENT_USER_ADD", require_GUILD_SCHEDULED_EVENT_USER_ADD()],
      ["GUILD_SCHEDULED_EVENT_USER_REMOVE", require_GUILD_SCHEDULED_EVENT_USER_REMOVE()],
      ["GUILD_STICKERS_UPDATE", require_GUILD_STICKERS_UPDATE()],
      ["GUILD_UPDATE", require_GUILD_UPDATE()],
      ["INTERACTION_CREATE", require_INTERACTION_CREATE()],
      ["INVITE_CREATE", require_INVITE_CREATE()],
      ["INVITE_DELETE", require_INVITE_DELETE()],
      ["MESSAGE_CREATE", require_MESSAGE_CREATE()],
      ["MESSAGE_DELETE", require_MESSAGE_DELETE()],
      ["MESSAGE_DELETE_BULK", require_MESSAGE_DELETE_BULK()],
      ["MESSAGE_REACTION_ADD", require_MESSAGE_REACTION_ADD()],
      ["MESSAGE_REACTION_REMOVE", require_MESSAGE_REACTION_REMOVE()],
      ["MESSAGE_REACTION_REMOVE_ALL", require_MESSAGE_REACTION_REMOVE_ALL()],
      ["MESSAGE_REACTION_REMOVE_EMOJI", require_MESSAGE_REACTION_REMOVE_EMOJI()],
      ["MESSAGE_UPDATE", require_MESSAGE_UPDATE()],
      ["PRESENCE_UPDATE", require_PRESENCE_UPDATE()],
      ["READY", require_READY()],
      ["RESUMED", require_RESUMED()],
      ["STAGE_INSTANCE_CREATE", require_STAGE_INSTANCE_CREATE()],
      ["STAGE_INSTANCE_DELETE", require_STAGE_INSTANCE_DELETE()],
      ["STAGE_INSTANCE_UPDATE", require_STAGE_INSTANCE_UPDATE()],
      ["THREAD_CREATE", require_THREAD_CREATE()],
      ["THREAD_DELETE", require_THREAD_DELETE()],
      ["THREAD_LIST_SYNC", require_THREAD_LIST_SYNC()],
      ["THREAD_MEMBERS_UPDATE", require_THREAD_MEMBERS_UPDATE()],
      ["THREAD_MEMBER_UPDATE", require_THREAD_MEMBER_UPDATE()],
      ["THREAD_UPDATE", require_THREAD_UPDATE()],
      ["TYPING_START", require_TYPING_START()],
      ["USER_UPDATE", require_USER_UPDATE()],
      ["VOICE_SERVER_UPDATE", require_VOICE_SERVER_UPDATE()],
      ["VOICE_STATE_UPDATE", require_VOICE_STATE_UPDATE()],
      ["WEBHOOKS_UPDATE", require_WEBHOOKS_UPDATE()]
    ]);
    module2.exports = handlers;
  }
});

// node_modules/discord.js/src/client/websocket/WebSocketManager.js
var require_WebSocketManager = __commonJS({
  "node_modules/discord.js/src/client/websocket/WebSocketManager.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("node:events");
    var { setImmediate: setImmediate2 } = require("node:timers");
    var { setTimeout: sleep } = require("node:timers/promises");
    var { Collection: Collection2 } = require_dist();
    var { GatewayCloseCodes, GatewayDispatchEvents, Routes: Routes2 } = require_v106();
    var WebSocketShard = require_WebSocketShard();
    var PacketHandlers = require_handlers();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Events3 = require_Events();
    var Status2 = require_Status();
    var WebSocketShardEvents = require_WebSocketShardEvents();
    var BeforeReadyWhitelist = [
      GatewayDispatchEvents.Ready,
      GatewayDispatchEvents.Resumed,
      GatewayDispatchEvents.GuildCreate,
      GatewayDispatchEvents.GuildDelete,
      GatewayDispatchEvents.GuildMembersChunk,
      GatewayDispatchEvents.GuildMemberAdd,
      GatewayDispatchEvents.GuildMemberRemove
    ];
    var unrecoverableErrorCodeMap = {
      [GatewayCloseCodes.AuthenticationFailed]: ErrorCodes2.TokenInvalid,
      [GatewayCloseCodes.InvalidShard]: ErrorCodes2.ShardingInvalid,
      [GatewayCloseCodes.ShardingRequired]: ErrorCodes2.ShardingRequired,
      [GatewayCloseCodes.InvalidIntents]: ErrorCodes2.InvalidIntents,
      [GatewayCloseCodes.DisallowedIntents]: ErrorCodes2.DisallowedIntents
    };
    var UNRESUMABLE_CLOSE_CODES = [1e3, GatewayCloseCodes.AlreadyAuthenticated, GatewayCloseCodes.InvalidSeq];
    var WebSocketManager2 = class extends EventEmitter2 {
      constructor(client) {
        super();
        Object.defineProperty(this, "client", { value: client });
        this.gateway = null;
        this.totalShards = this.client.options.shards.length;
        this.shards = new Collection2();
        Object.defineProperty(this, "shardQueue", { value: /* @__PURE__ */ new Set(), writable: true });
        Object.defineProperty(this, "packetQueue", { value: [] });
        this.status = Status2.Idle;
        this.destroyed = false;
        this.reconnecting = false;
      }
      /**
       * The average ping of all WebSocketShards
       * @type {number}
       * @readonly
       */
      get ping() {
        const sum = this.shards.reduce((a, b) => a + b.ping, 0);
        return sum / this.shards.size;
      }
      /**
       * Emits a debug message.
       * @param {string} message The debug message
       * @param {?WebSocketShard} [shard] The shard that emitted this message, if any
       * @private
       */
      debug(message, shard) {
        this.client.emit(Events3.Debug, `[WS => ${shard ? `Shard ${shard.id}` : "Manager"}] ${message}`);
      }
      /**
       * Connects this manager to the gateway.
       * @private
       */
      async connect() {
        const invalidToken = new DiscordjsError2(ErrorCodes2.TokenInvalid);
        const {
          url: gatewayURL,
          shards: recommendedShards,
          session_start_limit: sessionStartLimit
        } = await this.client.rest.get(Routes2.gatewayBot()).catch((error) => {
          throw error.status === 401 ? invalidToken : error;
        });
        const { total, remaining } = sessionStartLimit;
        this.debug(`Fetched Gateway Information
    URL: ${gatewayURL}
    Recommended Shards: ${recommendedShards}`);
        this.debug(`Session Limit Information
    Total: ${total}
    Remaining: ${remaining}`);
        this.gateway = `${gatewayURL}/`;
        let { shards } = this.client.options;
        if (shards === "auto") {
          this.debug(`Using the recommended shard count provided by Discord: ${recommendedShards}`);
          this.totalShards = this.client.options.shardCount = recommendedShards;
          shards = this.client.options.shards = Array.from({ length: recommendedShards }, (_, i) => i);
        }
        this.totalShards = shards.length;
        this.debug(`Spawning shards: ${shards.join(", ")}`);
        this.shardQueue = new Set(shards.map((id) => new WebSocketShard(this, id)));
        return this.createShards();
      }
      /**
       * Handles the creation of a shard.
       * @returns {Promise<boolean>}
       * @private
       */
      async createShards() {
        if (!this.shardQueue.size)
          return false;
        const [shard] = this.shardQueue;
        this.shardQueue.delete(shard);
        if (!shard.eventsAttached) {
          shard.on(WebSocketShardEvents.AllReady, (unavailableGuilds) => {
            this.client.emit(Events3.ShardReady, shard.id, unavailableGuilds);
            if (!this.shardQueue.size)
              this.reconnecting = false;
            this.checkShardsReady();
          });
          shard.on(WebSocketShardEvents.Close, (event) => {
            if (event.code === 1e3 ? this.destroyed : event.code in unrecoverableErrorCodeMap) {
              this.client.emit(Events3.ShardDisconnect, event, shard.id);
              this.debug(GatewayCloseCodes[event.code], shard);
              return;
            }
            if (UNRESUMABLE_CLOSE_CODES.includes(event.code)) {
              shard.sessionId = null;
            }
            this.client.emit(Events3.ShardReconnecting, shard.id);
            this.shardQueue.add(shard);
            if (shard.sessionId)
              this.debug(`Session id is present, attempting an immediate reconnect...`, shard);
            this.reconnect();
          });
          shard.on(WebSocketShardEvents.InvalidSession, () => {
            this.client.emit(Events3.ShardReconnecting, shard.id);
          });
          shard.on(WebSocketShardEvents.Destroyed, () => {
            this.debug("Shard was destroyed but no WebSocket connection was present! Reconnecting...", shard);
            this.client.emit(Events3.ShardReconnecting, shard.id);
            this.shardQueue.add(shard);
            this.reconnect();
          });
          shard.eventsAttached = true;
        }
        this.shards.set(shard.id, shard);
        try {
          await shard.connect();
        } catch (error) {
          if (error?.code && error.code in unrecoverableErrorCodeMap) {
            throw new DiscordjsError2(unrecoverableErrorCodeMap[error.code]);
          } else if (!error || error.code) {
            this.debug("Failed to connect to the gateway, requeueing...", shard);
            this.shardQueue.add(shard);
          } else {
            throw error;
          }
        }
        if (this.shardQueue.size) {
          this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`);
          await sleep(5e3);
          return this.createShards();
        }
        return true;
      }
      /**
       * Handles reconnects for this manager.
       * @private
       * @returns {Promise<boolean>}
       */
      async reconnect() {
        if (this.reconnecting || this.status !== Status2.Ready)
          return false;
        this.reconnecting = true;
        try {
          await this.createShards();
        } catch (error) {
          this.debug(`Couldn't reconnect or fetch information about the gateway. ${error}`);
          if (error.httpStatus !== 401) {
            this.debug(`Possible network error occurred. Retrying in 5s...`);
            await sleep(5e3);
            this.reconnecting = false;
            return this.reconnect();
          }
          if (this.client.listenerCount(Events3.Invalidated)) {
            this.client.emit(Events3.Invalidated);
            this.destroy();
          } else {
            this.client.destroy();
          }
        } finally {
          this.reconnecting = false;
        }
        return true;
      }
      /**
       * Broadcasts a packet to every shard this manager handles.
       * @param {Object} packet The packet to send
       * @private
       */
      broadcast(packet) {
        for (const shard of this.shards.values())
          shard.send(packet);
      }
      /**
       * Destroys this manager and all its shards.
       * @private
       */
      destroy() {
        if (this.destroyed)
          return;
        this.debug(`Manager was destroyed. Called by:
${new Error().stack}`);
        this.destroyed = true;
        this.shardQueue.clear();
        for (const shard of this.shards.values())
          shard.destroy({ closeCode: 1e3, reset: true, emit: false, log: false });
      }
      /**
       * Processes a packet and queues it if this WebSocketManager is not ready.
       * @param {Object} [packet] The packet to be handled
       * @param {WebSocketShard} [shard] The shard that will handle this packet
       * @returns {boolean}
       * @private
       */
      handlePacket(packet, shard) {
        if (packet && this.status !== Status2.Ready) {
          if (!BeforeReadyWhitelist.includes(packet.t)) {
            this.packetQueue.push({ packet, shard });
            return false;
          }
        }
        if (this.packetQueue.length) {
          const item = this.packetQueue.shift();
          setImmediate2(() => {
            this.handlePacket(item.packet, item.shard);
          }).unref();
        }
        if (packet && PacketHandlers[packet.t]) {
          PacketHandlers[packet.t](this.client, packet, shard);
        }
        return true;
      }
      /**
       * Checks whether the client is ready to be marked as ready.
       * @private
       */
      checkShardsReady() {
        if (this.status === Status2.Ready)
          return;
        if (this.shards.size !== this.totalShards || this.shards.some((s) => s.status !== Status2.Ready)) {
          return;
        }
        this.triggerClientReady();
      }
      /**
       * Causes the client to be marked as ready and emits the ready event.
       * @private
       */
      triggerClientReady() {
        this.status = Status2.Ready;
        this.client.readyTimestamp = Date.now();
        this.client.emit(Events3.ClientReady, this.client);
        this.handlePacket();
      }
    };
    module2.exports = WebSocketManager2;
  }
});

// node_modules/discord.js/src/managers/BaseGuildEmojiManager.js
var require_BaseGuildEmojiManager = __commonJS({
  "node_modules/discord.js/src/managers/BaseGuildEmojiManager.js"(exports2, module2) {
    "use strict";
    var CachedManager = require_CachedManager();
    var GuildEmoji = require_GuildEmoji();
    var ReactionEmoji = require_ReactionEmoji();
    var { parseEmoji } = require_Util();
    var BaseGuildEmojiManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, GuildEmoji, iterable);
      }
      /**
       * The cache of GuildEmojis
       * @type {Collection<Snowflake, GuildEmoji>}
       * @name BaseGuildEmojiManager#cache
       */
      /**
       * Data that can be resolved into a GuildEmoji object. This can be:
       * * A Snowflake
       * * A GuildEmoji object
       * * A ReactionEmoji object
       * @typedef {Snowflake|GuildEmoji|ReactionEmoji} EmojiResolvable
       */
      /**
       * Resolves an EmojiResolvable to an Emoji object.
       * @param {EmojiResolvable} emoji The Emoji resolvable to identify
       * @returns {?GuildEmoji}
       */
      resolve(emoji) {
        if (emoji instanceof ReactionEmoji)
          return super.resolve(emoji.id);
        return super.resolve(emoji);
      }
      /**
       * Resolves an EmojiResolvable to an Emoji id string.
       * @param {EmojiResolvable} emoji The Emoji resolvable to identify
       * @returns {?Snowflake}
       */
      resolveId(emoji) {
        if (emoji instanceof ReactionEmoji)
          return emoji.id;
        return super.resolveId(emoji);
      }
      /**
       * Data that can be resolved to give an emoji identifier. This can be:
       * * An EmojiResolvable
       * * The `<a:name:id>`, `<:name:id>`, `a:name:id` or `name:id` emoji identifier string of an emoji
       * * The Unicode representation of an emoji
       * @typedef {string|EmojiResolvable} EmojiIdentifierResolvable
       */
      /**
       * Resolves an EmojiResolvable to an emoji identifier.
       * @param {EmojiIdentifierResolvable} emoji The emoji resolvable to resolve
       * @returns {?string}
       */
      resolveIdentifier(emoji) {
        const emojiResolvable = this.resolve(emoji);
        if (emojiResolvable)
          return emojiResolvable.identifier;
        if (emoji instanceof ReactionEmoji)
          return emoji.identifier;
        if (typeof emoji === "string") {
          const res = parseEmoji(emoji);
          if (res?.name.length) {
            emoji = `${res.animated ? "a:" : ""}${res.name}${res.id ? `:${res.id}` : ""}`;
          }
          if (!emoji.includes("%"))
            return encodeURIComponent(emoji);
          return emoji;
        }
        return null;
      }
    };
    module2.exports = BaseGuildEmojiManager2;
  }
});

// node_modules/discord.js/src/managers/ChannelManager.js
var require_ChannelManager = __commonJS({
  "node_modules/discord.js/src/managers/ChannelManager.js"(exports2, module2) {
    "use strict";
    var process2 = require("node:process");
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { BaseChannel } = require_BaseChannel();
    var { createChannel } = require_Channels();
    var { ThreadChannelTypes } = require_Constants();
    var Events3 = require_Events();
    var cacheWarningEmitted = false;
    var ChannelManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, BaseChannel, iterable);
        const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === void 0 || this._cache.maxSize === Infinity;
        if (!cacheWarningEmitted && !defaultCaching) {
          cacheWarningEmitted = true;
          process2.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
      }
      /**
       * The cache of Channels
       * @type {Collection<Snowflake, BaseChannel>}
       * @name ChannelManager#cache
       */
      _add(data, guild, { cache = true, allowUnknownGuild = false, fromInteraction = false } = {}) {
        const existing = this.cache.get(data.id);
        if (existing) {
          if (cache)
            existing._patch(data, fromInteraction);
          guild?.channels?._add(existing);
          if (ThreadChannelTypes.includes(existing.type)) {
            existing.parent?.threads?._add(existing);
          }
          return existing;
        }
        const channel = createChannel(this.client, data, guild, { allowUnknownGuild, fromInteraction });
        if (!channel) {
          this.client.emit(Events3.Debug, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);
          return null;
        }
        if (cache && !allowUnknownGuild)
          this.cache.set(channel.id, channel);
        return channel;
      }
      _remove(id) {
        const channel = this.cache.get(id);
        channel?.guild?.channels.cache.delete(id);
        for (const [code, invite] of channel?.guild?.invites.cache ?? []) {
          if (invite.channelId === id)
            channel.guild.invites.cache.delete(code);
        }
        channel?.parent?.threads?.cache.delete(id);
        this.cache.delete(id);
      }
      /**
       * Data that can be resolved to give a Channel object. This can be:
       * * A Channel object
       * * A Snowflake
       * @typedef {BaseChannel|Snowflake} ChannelResolvable
       */
      /**
       * Resolves a ChannelResolvable to a Channel object.
       * @method resolve
       * @memberof ChannelManager
       * @instance
       * @param {ChannelResolvable} channel The channel resolvable to resolve
       * @returns {?BaseChannel}
       */
      /**
       * Resolves a ChannelResolvable to a channel id string.
       * @method resolveId
       * @memberof ChannelManager
       * @instance
       * @param {ChannelResolvable} channel The channel resolvable to resolve
       * @returns {?Snowflake}
       */
      /**
       * Options for fetching a channel from Discord
       * @typedef {BaseFetchOptions} FetchChannelOptions
       * @property {boolean} [allowUnknownGuild=false] Allows the channel to be returned even if the guild is not in cache,
       * it will not be cached. <warn>Many of the properties and methods on the returned channel will throw errors</warn>
       */
      /**
       * Obtains a channel from Discord, or the channel cache if it's already available.
       * @param {Snowflake} id The channel's id
       * @param {FetchChannelOptions} [options] Additional options for this fetch
       * @returns {Promise<?BaseChannel>}
       * @example
       * // Fetch a channel by its id
       * client.channels.fetch('222109930545610754')
       *   .then(channel => console.log(channel.name))
       *   .catch(console.error);
       */
      async fetch(id, { allowUnknownGuild = false, cache = true, force = false } = {}) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing && !existing.partial)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.channel(id));
        return this._add(data, null, { cache, allowUnknownGuild });
      }
    };
    module2.exports = ChannelManager2;
  }
});

// node_modules/discord.js/src/structures/GuildAuditLogs.js
var require_GuildAuditLogs = __commonJS({
  "node_modules/discord.js/src/structures/GuildAuditLogs.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var ApplicationCommand = require_ApplicationCommand();
    var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
    var Integration = require_Integration();
    var Webhook2 = require_Webhook();
    var { flatten } = require_Util();
    var GuildAuditLogs = class {
      constructor(guild, data) {
        if (data.users)
          for (const user of data.users)
            guild.client.users._add(user);
        if (data.threads)
          for (const thread of data.threads)
            guild.client.channels._add(thread, guild);
        this.webhooks = new Collection2();
        if (data.webhooks) {
          for (const hook of data.webhooks) {
            this.webhooks.set(hook.id, new Webhook2(guild.client, hook));
          }
        }
        this.integrations = new Collection2();
        if (data.integrations) {
          for (const integration of data.integrations) {
            this.integrations.set(integration.id, new Integration(guild.client, integration, guild));
          }
        }
        this.guildScheduledEvents = data.guild_scheduled_events.reduce(
          (guildScheduledEvents, guildScheduledEvent) => guildScheduledEvents.set(guildScheduledEvent.id, guild.scheduledEvents._add(guildScheduledEvent)),
          new Collection2()
        );
        this.applicationCommands = new Collection2();
        if (data.application_commands) {
          for (const command of data.application_commands) {
            this.applicationCommands.set(command.id, new ApplicationCommand(guild.client, command, guild));
          }
        }
        this.autoModerationRules = data.auto_moderation_rules.reduce(
          (autoModerationRules, autoModerationRule) => autoModerationRules.set(autoModerationRule.id, guild.autoModerationRules._add(autoModerationRule)),
          new Collection2()
        );
        this.entries = new Collection2();
        for (const item of data.audit_log_entries) {
          const entry = new GuildAuditLogsEntry(guild, item, this);
          this.entries.set(entry.id, entry);
        }
      }
      toJSON() {
        return flatten(this);
      }
    };
    module2.exports = GuildAuditLogs;
  }
});

// node_modules/discord.js/src/structures/GuildPreviewEmoji.js
var require_GuildPreviewEmoji = __commonJS({
  "node_modules/discord.js/src/structures/GuildPreviewEmoji.js"(exports2, module2) {
    "use strict";
    var BaseGuildEmoji = require_BaseGuildEmoji();
    var GuildPreviewEmoji = class extends BaseGuildEmoji {
      /**
       * The public guild this emoji is part of
       * @type {GuildPreview}
       * @name GuildPreviewEmoji#guild
       */
      constructor(client, data, guild) {
        super(client, data, guild);
        this.roles = data.roles;
      }
    };
    module2.exports = GuildPreviewEmoji;
  }
});

// node_modules/discord.js/src/structures/GuildPreview.js
var require_GuildPreview = __commonJS({
  "node_modules/discord.js/src/structures/GuildPreview.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { DiscordSnowflake } = require_dist3();
    var { Routes: Routes2 } = require_v106();
    var Base = require_Base();
    var GuildPreviewEmoji = require_GuildPreviewEmoji();
    var { Sticker: Sticker2 } = require_Sticker();
    var GuildPreview2 = class extends Base {
      constructor(client, data) {
        super(client);
        if (!data)
          return;
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("icon" in data) {
          this.icon = data.icon;
        }
        if ("splash" in data) {
          this.splash = data.splash;
        }
        if ("discovery_splash" in data) {
          this.discoverySplash = data.discovery_splash;
        }
        if ("features" in data) {
          this.features = data.features;
        }
        if ("approximate_member_count" in data) {
          this.approximateMemberCount = data.approximate_member_count;
        }
        if ("approximate_presence_count" in data) {
          this.approximatePresenceCount = data.approximate_presence_count;
        }
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ??= null;
        }
        if (!this.emojis) {
          this.emojis = new Collection2();
        } else {
          this.emojis.clear();
        }
        for (const emoji of data.emojis) {
          this.emojis.set(emoji.id, new GuildPreviewEmoji(this.client, emoji, this));
        }
        this.stickers = data.stickers.reduce(
          (stickers, sticker) => stickers.set(sticker.id, new Sticker2(this.client, sticker)),
          new Collection2()
        );
      }
      /**
       * The timestamp this guild was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time this guild was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The URL to this guild's splash.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      splashURL(options = {}) {
        return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
      }
      /**
       * The URL to this guild's discovery splash.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      discoverySplashURL(options = {}) {
        return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
      }
      /**
       * The URL to this guild's icon.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
      }
      /**
       * Fetches this guild.
       * @returns {Promise<GuildPreview>}
       */
      async fetch() {
        const data = await this.client.rest.get(Routes2.guildPreview(this.id));
        this._patch(data);
        return this;
      }
      /**
       * When concatenated with a string, this automatically returns the guild's name instead of the Guild object.
       * @returns {string}
       * @example
       * // Logs: Hello from My Guild!
       * console.log(`Hello from ${previewGuild}!`);
       */
      toString() {
        return this.name;
      }
      toJSON() {
        const json2 = super.toJSON();
        json2.iconURL = this.iconURL();
        json2.splashURL = this.splashURL();
        return json2;
      }
    };
    module2.exports = GuildPreview2;
  }
});

// node_modules/discord.js/src/managers/AutoModerationRuleManager.js
var require_AutoModerationRuleManager = __commonJS({
  "node_modules/discord.js/src/managers/AutoModerationRuleManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var AutoModerationRule = require_AutoModerationRule();
    var AutoModerationRuleManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, AutoModerationRule, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, AutoModerationRule>}
       * @name AutoModerationRuleManager#cache
       */
      /**
       * Resolves an {@link AutoModerationRuleResolvable} to an {@link AutoModerationRule} object.
       * @method resolve
       * @memberof AutoModerationRuleManager
       * @instance
       * @param {AutoModerationRuleResolvable} autoModerationRule The AutoModerationRule resolvable to resolve
       * @returns {?AutoModerationRule}
       */
      /**
       * Resolves an {@link AutoModerationRuleResolvable} to a {@link AutoModerationRule} id.
       * @method resolveId
       * @memberof AutoModerationRuleManager
       * @instance
       * @param {AutoModerationRuleResolvable} autoModerationRule The AutoModerationRule resolvable to resolve
       * @returns {?Snowflake}
       */
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.guild] });
      }
      /**
       * Options used to set the trigger metadata of an auto moderation rule.
       * @typedef {Object} AutoModerationTriggerMetadataOptions
       * @property {string[]} [keywordFilter] The substrings that will be searched for in the content
       * @property {string[]} [regexPatterns] The regular expression patterns which will be matched against the content
       * <info>Only Rust-flavored regular expressions are supported.</info>
       * @property {AutoModerationRuleKeywordPresetType[]} [presets]
       * The internally pre-defined wordsets which will be searched for in the content
       * @property {string[]} [allowList] The substrings that will be exempt from triggering
       * {@link AutoModerationRuleTriggerType.Keyword} and {@link AutoModerationRuleTriggerType.KeywordPreset}
       * @property {?number} [mentionTotalLimit] The total number of role & user mentions allowed per message
       */
      /**
       * Options used to set the actions of an auto moderation rule.
       * @typedef {Object} AutoModerationActionOptions
       * @property {AutoModerationActionType} type The type of this auto moderation rule action
       * @property {AutoModerationActionMetadataOptions} [metadata] Additional metadata needed during execution
       * <info>This property is required if using a `type` of
       * {@link AutoModerationActionType.SendAlertMessage} or {@link AutoModerationActionType.Timeout}.</info>
       */
      /**
       * Options used to set the metadata of an auto moderation rule action.
       * @typedef {Object} AutoModerationActionMetadataOptions
       * @property {GuildTextChannelResolvable|ThreadChannel} [channel] The channel to which content will be logged
       * @property {number} [durationSeconds] The timeout duration in seconds
       * @property {string} [customMessage] The custom message that is shown whenever a message is blocked
       */
      /**
       * Options used to create an auto moderation rule.
       * @typedef {Object} AutoModerationRuleCreateOptions
       * @property {string} name The name of the auto moderation rule
       * @property {AutoModerationRuleEventType} eventType The event type of the auto moderation rule
       * @property {AutoModerationRuleTriggerType} triggerType The trigger type of the auto moderation rule
       * @property {AutoModerationTriggerMetadataOptions} [triggerMetadata] The trigger metadata of the auto moderation rule
       * <info>This property is required if using a `triggerType` of
       * {@link AutoModerationRuleTriggerType.Keyword}, {@link AutoModerationRuleTriggerType.KeywordPreset},
       * or {@link AutoModerationRuleTriggerType.MentionSpam}.</info>
       * @property {AutoModerationActionOptions[]} actions
       * The actions that will execute when the auto moderation rule is triggered
       * @property {boolean} [enabled] Whether the auto moderation rule should be enabled
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [exemptRoles]
       * The roles that should not be affected by the auto moderation rule
       * @property {Collection<Snowflake, GuildChannel|ThreadChannel>|GuildChannelResolvable[]} [exemptChannels]
       * The channels that should not be affected by the auto moderation rule
       * @property {string} [reason] The reason for creating the auto moderation rule
       */
      /**
       * Creates a new auto moderation rule.
       * @param {AutoModerationRuleCreateOptions} options Options for creating the auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      async create({
        name,
        eventType,
        triggerType,
        triggerMetadata,
        actions,
        enabled,
        exemptRoles,
        exemptChannels,
        reason
      }) {
        const data = await this.client.rest.post(Routes2.guildAutoModerationRules(this.guild.id), {
          body: {
            name,
            event_type: eventType,
            trigger_type: triggerType,
            trigger_metadata: triggerMetadata && {
              keyword_filter: triggerMetadata.keywordFilter,
              regex_patterns: triggerMetadata.regexPatterns,
              presets: triggerMetadata.presets,
              allow_list: triggerMetadata.allowList,
              mention_total_limit: triggerMetadata.mentionTotalLimit
            },
            actions: actions.map((action) => ({
              type: action.type,
              metadata: {
                duration_seconds: action.metadata?.durationSeconds,
                channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),
                custom_message: action.metadata?.customMessage
              }
            })),
            enabled,
            exempt_roles: exemptRoles?.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
            exempt_channels: exemptChannels?.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
          },
          reason
        });
        return this._add(data);
      }
      /**
       * Options used to edit an auto moderation rule.
       * @typedef {Object} AutoModerationRuleEditOptions
       * @property {string} [name] The name of the auto moderation rule
       * @property {AutoModerationRuleEventType} [eventType] The event type of the auto moderation rule
       * @property {AutoModerationTriggerMetadataOptions} [triggerMetadata] The trigger metadata of the auto moderation rule
       * @property {AutoModerationActionOptions[]} [actions]
       * The actions that will execute when the auto moderation rule is triggered
       * @property {boolean} [enabled] Whether the auto moderation rule should be enabled
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [exemptRoles]
       * The roles that should not be affected by the auto moderation rule
       * @property {Collection<Snowflake, GuildChannel|ThreadChannel>|GuildChannelResolvable[]} [exemptChannels]
       * The channels that should not be affected by the auto moderation rule
       * @property {string} [reason] The reason for creating the auto moderation rule
       */
      /**
       * Edits an auto moderation rule.
       * @param {AutoModerationRuleResolvable} autoModerationRule The auto moderation rule to edit
       * @param {AutoModerationRuleEditOptions} options Options for editing the auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      async edit(autoModerationRule, { name, eventType, triggerMetadata, actions, enabled, exemptRoles, exemptChannels, reason }) {
        const autoModerationRuleId = this.resolveId(autoModerationRule);
        const data = await this.client.rest.patch(Routes2.guildAutoModerationRule(this.guild.id, autoModerationRuleId), {
          body: {
            name,
            event_type: eventType,
            trigger_metadata: triggerMetadata && {
              keyword_filter: triggerMetadata.keywordFilter,
              regex_patterns: triggerMetadata.regexPatterns,
              presets: triggerMetadata.presets,
              allow_list: triggerMetadata.allowList,
              mention_total_limit: triggerMetadata.mentionTotalLimit
            },
            actions: actions?.map((action) => ({
              type: action.type,
              metadata: {
                duration_seconds: action.metadata?.durationSeconds,
                channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),
                custom_message: action.metadata?.customMessage
              }
            })),
            enabled,
            exempt_roles: exemptRoles?.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
            exempt_channels: exemptChannels?.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
          },
          reason
        });
        return this._add(data);
      }
      /**
       * Data that can be resolved to give an AutoModerationRule object. This can be:
       * * An AutoModerationRule
       * * A Snowflake
       * @typedef {AutoModerationRule|Snowflake} AutoModerationRuleResolvable
       */
      /**
       * Options used to fetch a single auto moderation rule from a guild.
       * @typedef {BaseFetchOptions} FetchAutoModerationRuleOptions
       * @property {AutoModerationRuleResolvable} autoModerationRule The auto moderation rule to fetch
       */
      /**
       * Options used to fetch all auto moderation rules from a guild.
       * @typedef {Object} FetchAutoModerationRulesOptions
       * @property {boolean} [cache] Whether to cache the fetched auto moderation rules
       */
      /**
       * Fetches auto moderation rules from Discord.
       * @param {AutoModerationRuleResolvable|FetchAutoModerationRuleOptions|FetchAutoModerationRulesOptions} [options]
       * Options for fetching auto moderation rule(s)
       * @returns {Promise<AutoModerationRule|Collection<Snowflake, AutoModerationRule>>}
       * @example
       * // Fetch all auto moderation rules from a guild without caching
       * guild.autoModerationRules.fetch({ cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single auto moderation rule
       * guild.autoModerationRules.fetch('979083472868098119')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single auto moderation rule without checking cache and without caching
       * guild.autoModerationRules.fetch({ autoModerationRule: '979083472868098119', cache: false, force: true })
       *   .then(console.log)
       *   .catch(console.error)
       */
      fetch(options) {
        if (!options)
          return this._fetchMany();
        const { autoModerationRule, cache, force } = options;
        const resolvedAutoModerationRule = this.resolveId(autoModerationRule ?? options);
        if (resolvedAutoModerationRule) {
          return this._fetchSingle({ autoModerationRule: resolvedAutoModerationRule, cache, force });
        }
        return this._fetchMany(options);
      }
      async _fetchSingle({ autoModerationRule, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(autoModerationRule);
          if (existing)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.guildAutoModerationRule(this.guild.id, autoModerationRule));
        return this._add(data, cache);
      }
      async _fetchMany(options = {}) {
        const data = await this.client.rest.get(Routes2.guildAutoModerationRules(this.guild.id));
        return data.reduce(
          (col, autoModerationRule) => col.set(autoModerationRule.id, this._add(autoModerationRule, options.cache)),
          new Collection2()
        );
      }
      /**
       * Deletes an auto moderation rule.
       * @param {AutoModerationRuleResolvable} autoModerationRule The auto moderation rule to delete
       * @param {string} [reason] The reason for deleting the auto moderation rule
       * @returns {Promise<void>}
       */
      async delete(autoModerationRule, reason) {
        const autoModerationRuleId = this.resolveId(autoModerationRule);
        await this.client.rest.delete(Routes2.guildAutoModerationRule(this.guild.id, autoModerationRuleId), { reason });
      }
    };
    module2.exports = AutoModerationRuleManager;
  }
});

// node_modules/discord.js/src/managers/GuildApplicationCommandManager.js
var require_GuildApplicationCommandManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildApplicationCommandManager.js"(exports2, module2) {
    "use strict";
    var ApplicationCommandManager = require_ApplicationCommandManager();
    var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
    var GuildApplicationCommandManager = class extends ApplicationCommandManager {
      constructor(guild, iterable) {
        super(guild.client, iterable);
        this.guild = guild;
        this.permissions = new ApplicationCommandPermissionsManager(this);
      }
    };
    module2.exports = GuildApplicationCommandManager;
  }
});

// node_modules/discord.js/src/managers/GuildBanManager.js
var require_GuildBanManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildBanManager.js"(exports2, module2) {
    "use strict";
    var process2 = require("node:process");
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var GuildBan = require_GuildBan();
    var { GuildMember } = require_GuildMember();
    var deprecationEmittedForDeleteMessageDays = false;
    var GuildBanManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildBan, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, GuildBan>}
       * @name GuildBanManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
      }
      /**
       * Data that resolves to give a GuildBan object. This can be:
       * * A GuildBan object
       * * A User resolvable
       * @typedef {GuildBan|UserResolvable} GuildBanResolvable
       */
      /**
       * Resolves a GuildBanResolvable to a GuildBan object.
       * @param {GuildBanResolvable} ban The ban that is in the guild
       * @returns {?GuildBan}
       */
      resolve(ban) {
        return super.resolve(ban) ?? super.resolve(this.client.users.resolveId(ban));
      }
      /**
       * Options used to fetch a single ban from a guild.
       * @typedef {BaseFetchOptions} FetchBanOptions
       * @property {UserResolvable} user The ban to fetch
       */
      /**
       * Options used to fetch multiple bans from a guild.
       * @typedef {Object} FetchBansOptions
       * @property {number} [limit] The maximum number of bans to return
       * @property {Snowflake} [before] Consider only bans before this id
       * @property {Snowflake} [after] Consider only bans after this id
       * @property {boolean} [cache] Whether to cache the fetched bans
       */
      /**
       * Fetches ban(s) from Discord.
       * @param {UserResolvable|FetchBanOptions|FetchBansOptions} [options] Options for fetching guild ban(s)
       * @returns {Promise<GuildBan|Collection<Snowflake, GuildBan>>}
       * @example
       * // Fetch multiple bans from a guild
       * guild.bans.fetch()
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a maximum of 5 bans from a guild without caching
       * guild.bans.fetch({ limit: 5, cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single ban
       * guild.bans.fetch('351871113346809860')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single ban without checking cache
       * guild.bans.fetch({ user, force: true })
       *   .then(console.log)
       *   .catch(console.error)
       * @example
       * // Fetch a single ban without caching
       * guild.bans.fetch({ user, cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       */
      fetch(options) {
        if (!options)
          return this._fetchMany();
        const { user, cache, force, limit, before, after } = options;
        const resolvedUser = this.client.users.resolveId(user ?? options);
        if (resolvedUser)
          return this._fetchSingle({ user: resolvedUser, cache, force });
        if (!before && !after && !limit && cache === void 0) {
          return Promise.reject(new DiscordjsError2(ErrorCodes2.FetchBanResolveId));
        }
        return this._fetchMany(options);
      }
      async _fetchSingle({ user, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(user);
          if (existing && !existing.partial)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.guildBan(this.guild.id, user));
        return this._add(data, cache);
      }
      async _fetchMany(options = {}) {
        const data = await this.client.rest.get(Routes2.guildBans(this.guild.id), {
          query: makeURLSearchParams2(options)
        });
        return data.reduce((col, ban) => col.set(ban.user.id, this._add(ban, options.cache)), new Collection2());
      }
      /**
       * Options used to ban a user from a guild.
       * @typedef {Object} BanOptions
       * @property {number} [deleteMessageDays] Number of days of messages to delete, must be between 0 and 7, inclusive
       * <warn>This property is deprecated. Use `deleteMessageSeconds` instead.</warn>
       * @property {number} [deleteMessageSeconds] Number of seconds of messages to delete,
       * must be between 0 and 604800 (7 days), inclusive
       * @property {string} [reason] The reason for the ban
       */
      /**
       * Bans a user from the guild.
       * @param {UserResolvable} user The user to ban
       * @param {BanOptions} [options] Options for the ban
       * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.
       * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot
       * be resolved, the user id will be the result.
       * @example
       * // Ban a user by id (or with a user/guild member object)
       * guild.bans.create('84484653687267328')
       *   .then(banInfo => console.log(`Banned ${banInfo.user?.tag ?? banInfo.tag ?? banInfo}`))
       *   .catch(console.error);
       */
      async create(user, options = {}) {
        if (typeof options !== "object")
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        const id = this.client.users.resolveId(user);
        if (!id)
          throw new DiscordjsError2(ErrorCodes2.BanResolveId, true);
        if (options.deleteMessageDays !== void 0 && !deprecationEmittedForDeleteMessageDays) {
          process2.emitWarning(
            // eslint-disable-next-line max-len
            "The deleteMessageDays option for GuildBanManager#create() is deprecated. Use the deleteMessageSeconds option instead.",
            "DeprecationWarning"
          );
          deprecationEmittedForDeleteMessageDays = true;
        }
        await this.client.rest.put(Routes2.guildBan(this.guild.id, id), {
          body: {
            delete_message_seconds: options.deleteMessageSeconds ?? (options.deleteMessageDays ? options.deleteMessageDays * 24 * 60 * 60 : void 0)
          },
          reason: options.reason
        });
        if (user instanceof GuildMember)
          return user;
        const _user = this.client.users.resolve(id);
        if (_user) {
          return this.guild.members.resolve(_user) ?? _user;
        }
        return id;
      }
      /**
       * Unbans a user from the guild.
       * @param {UserResolvable} user The user to unban
       * @param {string} [reason] Reason for unbanning user
       * @returns {Promise<?User>}
       * @example
       * // Unban a user by id (or with a user/guild member object)
       * guild.bans.remove('84484653687267328')
       *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))
       *   .catch(console.error);
       */
      async remove(user, reason) {
        const id = this.client.users.resolveId(user);
        if (!id)
          throw new DiscordjsError2(ErrorCodes2.BanResolveId);
        await this.client.rest.delete(Routes2.guildBan(this.guild.id, id), { reason });
        return this.client.users.resolve(user);
      }
    };
    module2.exports = GuildBanManager;
  }
});

// node_modules/discord.js/src/managers/GuildChannelManager.js
var require_GuildChannelManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildChannelManager.js"(exports2, module2) {
    "use strict";
    var process2 = require("node:process");
    var { Collection: Collection2 } = require_dist();
    var { ChannelType, Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var GuildTextThreadManager = require_GuildTextThreadManager();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var GuildChannel = require_GuildChannel();
    var PermissionOverwrites = require_PermissionOverwrites();
    var ThreadChannel = require_ThreadChannel();
    var Webhook2 = require_Webhook();
    var ChannelFlagsBitField = require_ChannelFlagsBitField();
    var { transformGuildForumTag, transformGuildDefaultReaction } = require_Channels();
    var { ThreadChannelTypes } = require_Constants();
    var DataResolver2 = require_DataResolver();
    var { setPosition } = require_Util();
    var cacheWarningEmitted = false;
    var GuildChannelManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildChannel, iterable);
        const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === void 0 || this._cache.maxSize === Infinity;
        if (!cacheWarningEmitted && !defaultCaching) {
          cacheWarningEmitted = true;
          process2.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
        this.guild = guild;
      }
      /**
       * The number of channels in this managers cache excluding thread channels
       * that do not count towards a guild's maximum channels restriction.
       * @type {number}
       * @readonly
       */
      get channelCountWithoutThreads() {
        return this.cache.reduce((acc, channel) => {
          if (ThreadChannelTypes.includes(channel.type))
            return acc;
          return ++acc;
        }, 0);
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, GuildChannel|ThreadChannel>}
       * @name GuildChannelManager#cache
       */
      _add(channel) {
        const existing = this.cache.get(channel.id);
        if (existing)
          return existing;
        this.cache.set(channel.id, channel);
        return channel;
      }
      /**
       * Data that can be resolved to give a Guild Channel object. This can be:
       * * A GuildChannel object
       * * A ThreadChannel object
       * * A Snowflake
       * @typedef {GuildChannel|ThreadChannel|Snowflake} GuildChannelResolvable
       */
      /**
       * Resolves a GuildChannelResolvable to a Channel object.
       * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve
       * @returns {?(GuildChannel|ThreadChannel)}
       */
      resolve(channel) {
        if (channel instanceof ThreadChannel)
          return super.resolve(channel.id);
        return super.resolve(channel);
      }
      /**
       * Resolves a GuildChannelResolvable to a channel id.
       * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve
       * @returns {?Snowflake}
       */
      resolveId(channel) {
        if (channel instanceof ThreadChannel)
          return super.resolveId(channel.id);
        return super.resolveId(channel);
      }
      /**
       * Adds the target channel to a channel's followers.
       * @param {NewsChannel|Snowflake} channel The channel to follow
       * @param {TextChannelResolvable} targetChannel The channel where published announcements will be posted at
       * @param {string} [reason] Reason for creating the webhook
       * @returns {Promise<Snowflake>} Returns created target webhook id.
       */
      async addFollower(channel, targetChannel, reason) {
        const channelId = this.resolveId(channel);
        const targetChannelId = this.resolveId(targetChannel);
        if (!channelId || !targetChannelId)
          throw new Error(ErrorCodes2.GuildChannelResolve);
        const { webhook_id } = await this.client.rest.post(Routes2.channelFollowers(channelId), {
          body: { webhook_channel_id: targetChannelId },
          reason
        });
        return webhook_id;
      }
      /**
       * Options used to create a new channel in a guild.
       * @typedef {CategoryCreateChannelOptions} GuildChannelCreateOptions
       * @property {?CategoryChannelResolvable} [parent] Parent of the new channel
       */
      /**
       * Creates a new channel in the guild.
       * @param {GuildChannelCreateOptions} options Options for creating the new channel
       * @returns {Promise<GuildChannel>}
       * @example
       * // Create a new text channel
       * guild.channels.create({ name: 'new-general', reason: 'Needed a cool new channel' })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Create a new channel with permission overwrites
       * guild.channels.create({
       *   name: 'new-general',
       *   type: ChannelType.GuildVoice,
       *   permissionOverwrites: [
       *      {
       *        id: message.author.id,
       *        deny: [PermissionFlagsBits.ViewChannel],
       *     },
       *   ],
       * })
       */
      async create({
        name,
        type,
        topic,
        nsfw,
        bitrate,
        userLimit,
        parent,
        permissionOverwrites,
        position,
        rateLimitPerUser,
        rtcRegion,
        videoQualityMode,
        availableTags,
        defaultReactionEmoji,
        defaultAutoArchiveDuration,
        defaultSortOrder,
        defaultForumLayout,
        reason
      }) {
        parent &&= this.client.channels.resolveId(parent);
        permissionOverwrites &&= permissionOverwrites.map((o) => PermissionOverwrites.resolve(o, this.guild));
        const data = await this.client.rest.post(Routes2.guildChannels(this.guild.id), {
          body: {
            name,
            topic,
            type,
            nsfw,
            bitrate,
            user_limit: userLimit,
            parent_id: parent,
            position,
            permission_overwrites: permissionOverwrites,
            rate_limit_per_user: rateLimitPerUser,
            rtc_region: rtcRegion,
            video_quality_mode: videoQualityMode,
            available_tags: availableTags?.map((availableTag) => transformGuildForumTag(availableTag)),
            default_reaction_emoji: defaultReactionEmoji && transformGuildDefaultReaction(defaultReactionEmoji),
            default_auto_archive_duration: defaultAutoArchiveDuration,
            default_sort_order: defaultSortOrder,
            default_forum_layout: defaultForumLayout
          },
          reason
        });
        return this.client.actions.ChannelCreate.handle(data).channel;
      }
      /**
       * @typedef {ChannelWebhookCreateOptions} WebhookCreateOptions
       * @property {TextChannel|NewsChannel|VoiceChannel|StageChannel|ForumChannel|Snowflake} channel
       * The channel to create the webhook for
       */
      /**
       * Creates a webhook for the channel.
       * @param {WebhookCreateOptions} options Options for creating the webhook
       * @returns {Promise<Webhook>} Returns the created Webhook
       * @example
       * // Create a webhook for the current channel
       * guild.channels.createWebhook({
       *   channel: '222197033908436994',
       *   name: 'Snek',
       *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',
       *   reason: 'Needed a cool new Webhook'
       * })
       *   .then(console.log)
       *   .catch(console.error)
       */
      async createWebhook({ channel, name, avatar, reason }) {
        const id = this.resolveId(channel);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "channel", "GuildChannelResolvable");
        if (typeof avatar === "string" && !avatar.startsWith("data:")) {
          avatar = await DataResolver2.resolveImage(avatar);
        }
        const data = await this.client.rest.post(Routes2.channelWebhooks(id), {
          body: {
            name,
            avatar
          },
          reason
        });
        return new Webhook2(this.client, data);
      }
      /**
       * Options used to edit a guild channel.
       * @typedef {Object} GuildChannelEditOptions
       * @property {string} [name] The name of the channel
       * @property {ChannelType} [type] The type of the channel (only conversion between text and news is supported)
       * @property {number} [position] The position of the channel
       * @property {?string} [topic] The topic of the text channel
       * @property {boolean} [nsfw] Whether the channel is NSFW
       * @property {number} [bitrate] The bitrate of the voice channel
       * @property {number} [userLimit] The user limit of the voice channel
       * @property {?CategoryChannelResolvable} [parent] The parent of the channel
       * @property {boolean} [lockPermissions]
       * Lock the permissions of the channel to what the parent's permissions are
       * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]
       * Permission overwrites for the channel
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the channel in seconds
       * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]
       * The default auto archive duration for all new threads in this channel
       * @property {?string} [rtcRegion] The RTC region of the channel
       * @property {?VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel
       * @property {GuildForumTagData[]} [availableTags] The tags to set as available in a forum channel
       * @property {?DefaultReactionEmoji} [defaultReactionEmoji] The emoji to set as the default reaction emoji
       * @property {number} [defaultThreadRateLimitPerUser] The rate limit per user (slowmode) to set on forum posts
       * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel
       * @property {?SortOrderType} [defaultSortOrder] The default sort order mode to set on the channel
       * @property {ForumLayoutType} [defaultForumLayout] The default forum layout to set on the channel
       * @property {string} [reason] Reason for editing this channel
       */
      /**
       * Edits the channel.
       * @param {GuildChannelResolvable} channel The channel to edit
       * @param {GuildChannelEditOptions} options Options for editing the channel
       * @returns {Promise<GuildChannel>}
       * @example
       * // Edit a channel
       * guild.channels.edit('222197033908436994', { name: 'new-channel' })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async edit(channel, options) {
        channel = this.resolve(channel);
        if (!channel)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "channel", "GuildChannelResolvable");
        const parent = options.parent && this.client.channels.resolveId(options.parent);
        if (options.position !== void 0) {
          await this.setPosition(channel, options.position, { position: options.position, reason: options.reason });
        }
        let permission_overwrites = options.permissionOverwrites?.map((o) => PermissionOverwrites.resolve(o, this.guild));
        if (options.lockPermissions) {
          if (parent) {
            const newParent = this.guild.channels.resolve(parent);
            if (newParent?.type === ChannelType.GuildCategory) {
              permission_overwrites = newParent.permissionOverwrites.cache.map(
                (o) => PermissionOverwrites.resolve(o, this.guild)
              );
            }
          } else if (channel.parent) {
            permission_overwrites = channel.parent.permissionOverwrites.cache.map(
              (o) => PermissionOverwrites.resolve(o, this.guild)
            );
          }
        }
        const newData = await this.client.rest.patch(Routes2.channel(channel.id), {
          body: {
            name: (options.name ?? channel.name).trim(),
            type: options.type,
            topic: options.topic,
            nsfw: options.nsfw,
            bitrate: options.bitrate ?? channel.bitrate,
            user_limit: options.userLimit ?? channel.userLimit,
            rtc_region: "rtcRegion" in options ? options.rtcRegion : channel.rtcRegion,
            video_quality_mode: options.videoQualityMode,
            parent_id: parent,
            lock_permissions: options.lockPermissions,
            rate_limit_per_user: options.rateLimitPerUser,
            default_auto_archive_duration: options.defaultAutoArchiveDuration,
            permission_overwrites,
            available_tags: options.availableTags?.map((availableTag) => transformGuildForumTag(availableTag)),
            default_reaction_emoji: options.defaultReactionEmoji && transformGuildDefaultReaction(options.defaultReactionEmoji),
            default_thread_rate_limit_per_user: options.defaultThreadRateLimitPerUser,
            flags: "flags" in options ? ChannelFlagsBitField.resolve(options.flags) : void 0,
            default_sort_order: options.defaultSortOrder,
            default_forum_layout: options.defaultForumLayout
          },
          reason: options.reason
        });
        return this.client.actions.ChannelUpdate.handle(newData).updated;
      }
      /**
       * Sets a new position for the guild channel.
       * @param {GuildChannelResolvable} channel The channel to set the position for
       * @param {number} position The new position for the guild channel
       * @param {SetChannelPositionOptions} options Options for setting position
       * @returns {Promise<GuildChannel>}
       * @example
       * // Set a new channel position
       * guild.channels.setPosition('222078374472843266', 2)
       *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))
       *   .catch(console.error);
       */
      async setPosition(channel, position, { relative, reason } = {}) {
        channel = this.resolve(channel);
        if (!channel)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "channel", "GuildChannelResolvable");
        const updatedChannels = await setPosition(
          channel,
          position,
          relative,
          this.guild._sortedChannels(channel),
          this.client,
          Routes2.guildChannels(this.guild.id),
          reason
        );
        this.client.actions.GuildChannelsPositionUpdate.handle({
          guild_id: this.guild.id,
          channels: updatedChannels
        });
        return channel;
      }
      /**
       * Obtains one or more guild channels from Discord, or the channel cache if they're already available.
       * @param {Snowflake} [id] The channel's id
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<?GuildChannel|ThreadChannel|Collection<Snowflake, ?GuildChannel>>}
       * @example
       * // Fetch all channels from the guild (excluding threads)
       * message.guild.channels.fetch()
       *   .then(channels => console.log(`There are ${channels.size} channels.`))
       *   .catch(console.error);
       * @example
       * // Fetch a single channel
       * message.guild.channels.fetch('222197033908436994')
       *   .then(channel => console.log(`The channel name is: ${channel.name}`))
       *   .catch(console.error);
       */
      async fetch(id, { cache = true, force = false } = {}) {
        if (id && !force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        if (id) {
          const data2 = await this.client.rest.get(Routes2.channel(id));
          if (this.guild.id !== data2.guild_id)
            throw new DiscordjsError2(ErrorCodes2.GuildChannelUnowned);
          return this.client.channels._add(data2, this.guild, { cache });
        }
        const data = await this.client.rest.get(Routes2.guildChannels(this.guild.id));
        const channels = new Collection2();
        for (const channel of data)
          channels.set(channel.id, this.client.channels._add(channel, this.guild, { cache }));
        return channels;
      }
      /**
       * Fetches all webhooks for the channel.
       * @param {GuildChannelResolvable} channel The channel to fetch webhooks for
       * @returns {Promise<Collection<Snowflake, Webhook>>}
       * @example
       * // Fetch webhooks
       * guild.channels.fetchWebhooks('769862166131245066')
       *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))
       *   .catch(console.error);
       */
      async fetchWebhooks(channel) {
        const id = this.resolveId(channel);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "channel", "GuildChannelResolvable");
        const data = await this.client.rest.get(Routes2.channelWebhooks(id));
        return data.reduce((hooks, hook) => hooks.set(hook.id, new Webhook2(this.client, hook)), new Collection2());
      }
      /**
       * Data that can be resolved to give a Category Channel object. This can be:
       * * A CategoryChannel object
       * * A Snowflake
       * @typedef {CategoryChannel|Snowflake} CategoryChannelResolvable
       */
      /**
       * The data needed for updating a channel's position.
       * @typedef {Object} ChannelPosition
       * @property {GuildChannel|Snowflake} channel Channel to update
       * @property {number} [position] New position for the channel
       * @property {CategoryChannelResolvable} [parent] Parent channel for this channel
       * @property {boolean} [lockPermissions] If the overwrites should be locked to the parents overwrites
       */
      /**
       * Batch-updates the guild's channels' positions.
       * <info>Only one channel's parent can be changed at a time</info>
       * @param {ChannelPosition[]} channelPositions Channel positions to update
       * @returns {Promise<Guild>}
       * @example
       * guild.channels.setPositions([{ channel: channelId, position: newChannelIndex }])
       *   .then(guild => console.log(`Updated channel positions for ${guild}`))
       *   .catch(console.error);
       */
      async setPositions(channelPositions) {
        channelPositions = channelPositions.map((r) => ({
          id: this.client.channels.resolveId(r.channel),
          position: r.position,
          lock_permissions: r.lockPermissions,
          parent_id: r.parent !== void 0 ? this.resolveId(r.parent) : void 0
        }));
        await this.client.rest.patch(Routes2.guildChannels(this.guild.id), { body: channelPositions });
        return this.client.actions.GuildChannelsPositionUpdate.handle({
          guild_id: this.guild.id,
          channels: channelPositions
        }).guild;
      }
      /**
       * Data returned from fetching threads.
       * @typedef {Object} FetchedThreads
       * @property {Collection<Snowflake, ThreadChannel>} threads The threads that were fetched
       * @property {Collection<Snowflake, ThreadMember>} members The thread members in the received threads
       */
      /**
       * Obtains all active thread channels in the guild.
       * @param {boolean} [cache=true] Whether to cache the fetched data
       * @returns {Promise<FetchedThreads>}
       * @example
       * // Fetch all threads from the guild
       * message.guild.channels.fetchActiveThreads()
       *   .then(fetched => console.log(`There are ${fetched.threads.size} threads.`))
       *   .catch(console.error);
       */
      async fetchActiveThreads(cache = true) {
        const raw = await this.client.rest.get(Routes2.guildActiveThreads(this.guild.id));
        return GuildTextThreadManager._mapThreads(raw, this.client, { guild: this.guild, cache });
      }
      /**
       * Deletes the channel.
       * @param {GuildChannelResolvable} channel The channel to delete
       * @param {string} [reason] Reason for deleting this channel
       * @returns {Promise<void>}
       * @example
       * // Delete the channel
       * guild.channels.delete('858850993013260338', 'making room for new channels')
       *   .then(console.log)
       *   .catch(console.error);
       */
      async delete(channel, reason) {
        const id = this.resolveId(channel);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "channel", "GuildChannelResolvable");
        await this.client.rest.delete(Routes2.channel(id), { reason });
        this.client.actions.ChannelDelete.handle({ id });
      }
    };
    module2.exports = GuildChannelManager;
  }
});

// node_modules/discord.js/src/managers/GuildEmojiManager.js
var require_GuildEmojiManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildEmojiManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { Routes: Routes2, PermissionFlagsBits } = require_v106();
    var BaseGuildEmojiManager2 = require_BaseGuildEmojiManager();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var DataResolver2 = require_DataResolver();
    var GuildEmojiManager = class extends BaseGuildEmojiManager2 {
      constructor(guild, iterable) {
        super(guild.client, iterable);
        this.guild = guild;
      }
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.guild] });
      }
      /**
       * Options used for creating an emoji in a guild.
       * @typedef {Object} GuildEmojiCreateOptions
       * @property {BufferResolvable|Base64Resolvable} attachment The image for the emoji
       * @property {string} name The name for the emoji
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to limit the emoji to
       * @property {string} [reason] The reason for creating the emoji
       */
      /**
       * Creates a new custom emoji in the guild.
       * @param {GuildEmojiCreateOptions} options Options for creating the emoji
       * @returns {Promise<Emoji>} The created emoji
       * @example
       * // Create a new emoji from a URL
       * guild.emojis.create({ attachment: 'https://i.imgur.com/w3duR07.png', name: 'rip' })
       *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))
       *   .catch(console.error);
       * @example
       * // Create a new emoji from a file on your computer
       * guild.emojis.create({ attachment: './memes/banana.png', name: 'banana' })
       *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))
       *   .catch(console.error);
       */
      async create({ attachment, name, roles, reason }) {
        attachment = await DataResolver2.resolveImage(attachment);
        if (!attachment)
          throw new DiscordjsTypeError2(ErrorCodes2.ReqResourceType);
        const body = { image: attachment, name };
        if (roles) {
          if (!Array.isArray(roles) && !(roles instanceof Collection2)) {
            throw new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "options.roles",
              "Array or Collection of Roles or Snowflakes",
              true
            );
          }
          body.roles = [];
          for (const role of roles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "options.roles", role);
            }
            body.roles.push(resolvedRole);
          }
        }
        const emoji = await this.client.rest.post(Routes2.guildEmojis(this.guild.id), { body, reason });
        return this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji;
      }
      /**
       * Obtains one or more emojis from Discord, or the emoji cache if they're already available.
       * @param {Snowflake} [id] The emoji's id
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<GuildEmoji|Collection<Snowflake, GuildEmoji>>}
       * @example
       * // Fetch all emojis from the guild
       * message.guild.emojis.fetch()
       *   .then(emojis => console.log(`There are ${emojis.size} emojis.`))
       *   .catch(console.error);
       * @example
       * // Fetch a single emoji
       * message.guild.emojis.fetch('222078108977594368')
       *   .then(emoji => console.log(`The emoji name is: ${emoji.name}`))
       *   .catch(console.error);
       */
      async fetch(id, { cache = true, force = false } = {}) {
        if (id) {
          if (!force) {
            const existing = this.cache.get(id);
            if (existing)
              return existing;
          }
          const emoji = await this.client.rest.get(Routes2.guildEmoji(this.guild.id, id));
          return this._add(emoji, cache);
        }
        const data = await this.client.rest.get(Routes2.guildEmojis(this.guild.id));
        const emojis = new Collection2();
        for (const emoji of data)
          emojis.set(emoji.id, this._add(emoji, cache));
        return emojis;
      }
      /**
       * Deletes an emoji.
       * @param {EmojiResolvable} emoji The Emoji resolvable to delete
       * @param {string} [reason] Reason for deleting the emoji
       * @returns {Promise<void>}
       */
      async delete(emoji, reason) {
        const id = this.resolveId(emoji);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "emoji", "EmojiResolvable", true);
        await this.client.rest.delete(Routes2.guildEmoji(this.guild.id, id), { reason });
      }
      /**
       * Edits an emoji.
       * @param {EmojiResolvable} emoji The Emoji resolvable to edit
       * @param {GuildEmojiEditOptions} options The options to provide
       * @returns {Promise<GuildEmoji>}
       */
      async edit(emoji, options) {
        const id = this.resolveId(emoji);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "emoji", "EmojiResolvable", true);
        const roles = options.roles?.map((r) => this.guild.roles.resolveId(r));
        const newData = await this.client.rest.patch(Routes2.guildEmoji(this.guild.id, id), {
          body: {
            name: options.name,
            roles
          },
          reason: options.reason
        });
        const existing = this.cache.get(id);
        if (existing) {
          const clone = existing._clone();
          clone._patch(newData);
          return clone;
        }
        return this._add(newData);
      }
      /**
       * Fetches the author for this emoji
       * @param {EmojiResolvable} emoji The emoji to fetch the author of
       * @returns {Promise<User>}
       */
      async fetchAuthor(emoji) {
        emoji = this.resolve(emoji);
        if (!emoji)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "emoji", "EmojiResolvable", true);
        if (emoji.managed) {
          throw new DiscordjsError2(ErrorCodes2.EmojiManaged);
        }
        const { me } = this.guild.members;
        if (!me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        if (!me.permissions.has(PermissionFlagsBits.ManageEmojisAndStickers)) {
          throw new DiscordjsError2(ErrorCodes2.MissingManageEmojisAndStickersPermission, this.guild);
        }
        const data = await this.client.rest.get(Routes2.guildEmoji(this.guild.id, emoji.id));
        emoji._patch(data);
        return emoji.author;
      }
    };
    module2.exports = GuildEmojiManager;
  }
});

// node_modules/discord.js/src/managers/GuildInviteManager.js
var require_GuildInviteManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildInviteManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Invite2 = require_Invite();
    var DataResolver2 = require_DataResolver();
    var GuildInviteManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, Invite2, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this Manager
       * @type {Collection<string, Invite>}
       * @name GuildInviteManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { id: data.code, extras: [this.guild] });
      }
      /**
       * Data that resolves to give an Invite object. This can be:
       * * An invite code
       * * An invite URL
       * @typedef {string} InviteResolvable
       */
      /**
       * Data that can be resolved to a channel that an invite can be created on. This can be:
       * * TextChannel
       * * VoiceChannel
       * * NewsChannel
       * * StageChannel
       * * Snowflake
       * @typedef {TextChannel|VoiceChannel|NewsChannel|StageChannel|Snowflake}
       * GuildInvitableChannelResolvable
       */
      /**
       * Resolves an InviteResolvable to an Invite object.
       * @method resolve
       * @memberof GuildInviteManager
       * @instance
       * @param {InviteResolvable} invite The invite resolvable to resolve
       * @returns {?Invite}
       */
      /**
       * Resolves an InviteResolvable to an invite code string.
       * @method resolveId
       * @memberof GuildInviteManager
       * @instance
       * @param {InviteResolvable} invite The invite resolvable to resolve
       * @returns {?string}
       */
      /**
       * Options used to fetch a single invite from a guild.
       * @typedef {Object} FetchInviteOptions
       * @property {InviteResolvable} code The invite to fetch
       * @property {boolean} [cache=true] Whether or not to cache the fetched invite
       * @property {boolean} [force=false] Whether to skip the cache check and request the API
       */
      /**
       * Options used to fetch all invites from a guild.
       * @typedef {Object} FetchInvitesOptions
       * @property {GuildInvitableChannelResolvable} [channelId]
       * The channel to fetch all invites from
       * @property {boolean} [cache=true] Whether or not to cache the fetched invites
       */
      /**
       * Fetches invite(s) from Discord.
       * @param {InviteResolvable|FetchInviteOptions|FetchInvitesOptions} [options] Options for fetching guild invite(s)
       * @returns {Promise<Invite|Collection<string, Invite>>}
       * @example
       * // Fetch all invites from a guild
       * guild.invites.fetch()
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch all invites from a guild without caching
       * guild.invites.fetch({ cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch all invites from a channel
       * guild.invites.fetch({ channelId: '222197033908436994' })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single invite
       * guild.invites.fetch('bRCvFy9')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single invite without checking cache
       * guild.invites.fetch({ code: 'bRCvFy9', force: true })
       *   .then(console.log)
       *   .catch(console.error)
       * @example
       * // Fetch a single invite without caching
       * guild.invites.fetch({ code: 'bRCvFy9', cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       */
      fetch(options) {
        if (!options)
          return this._fetchMany();
        if (typeof options === "string") {
          const code = DataResolver2.resolveInviteCode(options);
          if (!code)
            return Promise.reject(new DiscordjsError2(ErrorCodes2.InviteResolveCode));
          return this._fetchSingle({ code, cache: true });
        }
        if (!options.code) {
          if (options.channelId) {
            const id = this.guild.channels.resolveId(options.channelId);
            if (!id)
              return Promise.reject(new DiscordjsError2(ErrorCodes2.GuildChannelResolve));
            return this._fetchChannelMany(id, options.cache);
          }
          if ("cache" in options)
            return this._fetchMany(options.cache);
          return Promise.reject(new DiscordjsError2(ErrorCodes2.InviteResolveCode));
        }
        return this._fetchSingle({
          ...options,
          code: DataResolver2.resolveInviteCode(options.code)
        });
      }
      async _fetchSingle({ code, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(code);
          if (existing)
            return existing;
        }
        const invites = await this._fetchMany(cache);
        const invite = invites.get(code);
        if (!invite)
          throw new DiscordjsError2(ErrorCodes2.InviteNotFound);
        return invite;
      }
      async _fetchMany(cache) {
        const data = await this.client.rest.get(Routes2.guildInvites(this.guild.id));
        return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection2());
      }
      async _fetchChannelMany(channelId, cache) {
        const data = await this.client.rest.get(Routes2.channelInvites(channelId));
        return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection2());
      }
      /**
       * Create an invite to the guild from the provided channel.
       * @param {GuildInvitableChannelResolvable} channel The options for creating the invite from a channel.
       * @param {InviteCreateOptions} [options={}] The options for creating the invite from a channel.
       * @returns {Promise<Invite>}
       * @example
       * // Create an invite to a selected channel
       * guild.invites.create('599942732013764608')
       *   .then(console.log)
       *   .catch(console.error);
       */
      async create(channel, { temporary, maxAge, maxUses, unique, targetUser, targetApplication, targetType, reason } = {}) {
        const id = this.guild.channels.resolveId(channel);
        if (!id)
          throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        const invite = await this.client.rest.post(Routes2.channelInvites(id), {
          body: {
            temporary,
            max_age: maxAge,
            max_uses: maxUses,
            unique,
            target_user_id: this.client.users.resolveId(targetUser),
            target_application_id: targetApplication?.id ?? targetApplication?.applicationId ?? targetApplication,
            target_type: targetType
          },
          reason
        });
        return new Invite2(this.client, invite);
      }
      /**
       * Deletes an invite.
       * @param {InviteResolvable} invite The invite to delete
       * @param {string} [reason] Reason for deleting the invite
       * @returns {Promise<void>}
       */
      async delete(invite, reason) {
        const code = DataResolver2.resolveInviteCode(invite);
        await this.client.rest.delete(Routes2.invite(code), { reason });
      }
    };
    module2.exports = GuildInviteManager;
  }
});

// node_modules/discord.js/src/managers/GuildMemberManager.js
var require_GuildMemberManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildMemberManager.js"(exports2, module2) {
    "use strict";
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require("node:timers");
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { DiscordSnowflake } = require_dist3();
    var { Routes: Routes2, GatewayOpcodes } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, DiscordjsRangeError: DiscordjsRangeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    var { GuildMember } = require_GuildMember();
    var { Role } = require_Role();
    var Events3 = require_Events();
    var { GuildMemberFlagsBitField } = require_GuildMemberFlagsBitField();
    var Partials = require_Partials();
    var GuildMemberManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildMember, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, GuildMember>}
       * @name GuildMemberManager#cache
       */
      _add(data, cache = true) {
        return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
      }
      /**
       * Data that resolves to give a GuildMember object. This can be:
       * * A GuildMember object
       * * A User resolvable
       * @typedef {GuildMember|UserResolvable} GuildMemberResolvable
       */
      /**
       * Resolves a {@link GuildMemberResolvable} to a {@link GuildMember} object.
       * @param {GuildMemberResolvable} member The user that is part of the guild
       * @returns {?GuildMember}
       */
      resolve(member) {
        const memberResolvable = super.resolve(member);
        if (memberResolvable)
          return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        if (userResolvable)
          return super.resolve(userResolvable);
        return null;
      }
      /**
       * Resolves a {@link GuildMemberResolvable} to a member id.
       * @param {GuildMemberResolvable} member The user that is part of the guild
       * @returns {?Snowflake}
       */
      resolveId(member) {
        const memberResolvable = super.resolveId(member);
        if (memberResolvable)
          return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        return this.cache.has(userResolvable) ? userResolvable : null;
      }
      /**
       * Options used to add a user to a guild using OAuth2.
       * @typedef {Object} AddGuildMemberOptions
       * @property {string} accessToken An OAuth2 access token for the user with the {@link OAuth2Scopes.GuildsJoin}
       * scope granted to the bot's application
       * @property {string} [nick] The nickname to give to the member
       * <info>This property requires the {@link PermissionFlagsBits.ManageNicknames} permission.</info>
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to add to the member
       * <info>This property requires the {@link PermissionFlagsBits.ManageRoles} permission.</info>
       * @property {boolean} [mute] Whether the member should be muted
       * <info>This property requires the {@link PermissionFlagsBits.MuteMembers} permission.</info>
       * @property {boolean} [deaf] Whether the member should be deafened
       * <info>This property requires the {@link PermissionFlagsBits.MuteMembers} permission.</info>
       * @property {boolean} [force] Whether to skip the cache check and request the API directly
       * @property {boolean} [fetchWhenExisting=true] Whether to fetch the user if not cached and already a member
       */
      /**
       * Adds a user to the guild using OAuth2.
       * <info>This method requires the {@link PermissionFlagsBits.CreateInstantInvite} permission.
       * @param {UserResolvable} user The user to add to the guild
       * @param {AddGuildMemberOptions} options Options for adding the user to the guild
       * @returns {Promise<GuildMember|null>}
       */
      async add(user, options) {
        const userId = this.client.users.resolveId(user);
        if (!userId)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "user", "UserResolvable");
        if (!options.force) {
          const cachedUser = this.cache.get(userId);
          if (cachedUser)
            return cachedUser;
        }
        const resolvedOptions = {
          access_token: options.accessToken,
          nick: options.nick,
          mute: options.mute,
          deaf: options.deaf
        };
        if (options.roles) {
          if (!Array.isArray(options.roles) && !(options.roles instanceof Collection2)) {
            throw new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "options.roles",
              "Array or Collection of Roles or Snowflakes",
              true
            );
          }
          const resolvedRoles = [];
          for (const role of options.roles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "options.roles", role);
            }
            resolvedRoles.push(resolvedRole);
          }
          resolvedOptions.roles = resolvedRoles;
        }
        const data = await this.client.rest.put(Routes2.guildMember(this.guild.id, userId), { body: resolvedOptions });
        return data instanceof Uint8Array ? options.fetchWhenExisting === false ? null : this.fetch(userId) : this._add(data);
      }
      /**
       * The client user as a GuildMember of this guild
       * @type {?GuildMember}
       * @readonly
       */
      get me() {
        return this.resolve(this.client.user.id) ?? (this.client.options.partials.includes(Partials.GuildMember) ? this._add({ user: { id: this.client.user.id } }, true) : null);
      }
      /**
       * Options used to fetch a single member from a guild.
       * @typedef {BaseFetchOptions} FetchMemberOptions
       * @property {UserResolvable} user The user to fetch
       */
      /**
       * Options used to fetch multiple members from a guild.
       * @typedef {Object} FetchMembersOptions
       * @property {UserResolvable|UserResolvable[]} [user] The user(s) to fetch
       * @property {?string} [query] Limit fetch to members with similar usernames
       * @property {number} [limit=0] Maximum number of members to request
       * @property {boolean} [withPresences=false] Whether to include the presences
       * @property {number} [time=120e3] Timeout for receipt of members
       * @property {?string} [nonce] Nonce for this request (32 characters max - default to base 16 now timestamp)
       */
      /**
       * Fetches member(s) from a guild.
       * @param {UserResolvable|FetchMemberOptions|FetchMembersOptions} [options] Options for fetching member(s).
       * Omitting the parameter or providing `undefined` will fetch all members.
       * @returns {Promise<GuildMember|Collection<Snowflake, GuildMember>>}
       * @example
       * // Fetch all members from a guild
       * guild.members.fetch()
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single member
       * guild.members.fetch('66564597481480192')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single member without checking cache
       * guild.members.fetch({ user, force: true })
       *   .then(console.log)
       *   .catch(console.error)
       * @example
       * // Fetch a single member without caching
       * guild.members.fetch({ user, cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch by an array of users including their presences
       * guild.members.fetch({ user: ['66564597481480192', '191615925336670208'], withPresences: true })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch by query
       * guild.members.fetch({ query: 'hydra', limit: 1 })
       *   .then(console.log)
       *   .catch(console.error);
       */
      fetch(options) {
        if (!options)
          return this._fetchMany();
        const { user: users, limit, withPresences, cache, force } = options;
        const resolvedUser = this.client.users.resolveId(users ?? options);
        if (resolvedUser && !limit && !withPresences)
          return this._fetchSingle({ user: resolvedUser, cache, force });
        const resolvedUsers = users?.map?.((user) => this.client.users.resolveId(user)) ?? resolvedUser ?? void 0;
        return this._fetchMany({ ...options, users: resolvedUsers });
      }
      async _fetchSingle({ user, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(user);
          if (existing && !existing.partial)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.guildMember(this.guild.id, user));
        return this._add(data, cache);
      }
      _fetchMany({
        limit = 0,
        withPresences: presences,
        users,
        query,
        time = 12e4,
        nonce = DiscordSnowflake.generate().toString()
      } = {}) {
        if (nonce.length > 32)
          return Promise.reject(new DiscordjsRangeError2(ErrorCodes2.MemberFetchNonceLength));
        return new Promise((resolve, reject) => {
          if (!query && !users)
            query = "";
          this.guild.shard.send({
            op: GatewayOpcodes.RequestGuildMembers,
            d: {
              guild_id: this.guild.id,
              presences,
              user_ids: users,
              query,
              nonce,
              limit
            }
          });
          const fetchedMembers = new Collection2();
          let i = 0;
          const handler = (members, _, chunk) => {
            if (chunk.nonce !== nonce)
              return;
            timeout.refresh();
            i++;
            for (const member of members.values()) {
              fetchedMembers.set(member.id, member);
            }
            if (members.size < 1e3 || limit && fetchedMembers.size >= limit || i === chunk.count) {
              clearTimeout2(timeout);
              this.client.removeListener(Events3.GuildMembersChunk, handler);
              this.client.decrementMaxListeners();
              resolve(users && !Array.isArray(users) && fetchedMembers.size ? fetchedMembers.first() : fetchedMembers);
            }
          };
          const timeout = setTimeout2(() => {
            this.client.removeListener(Events3.GuildMembersChunk, handler);
            this.client.decrementMaxListeners();
            reject(new DiscordjsError2(ErrorCodes2.GuildMembersTimeout));
          }, time).unref();
          this.client.incrementMaxListeners();
          this.client.on(Events3.GuildMembersChunk, handler);
        });
      }
      /**
       * Fetches the client user as a GuildMember of the guild.
       * @param {BaseFetchOptions} [options] The options for fetching the member
       * @returns {Promise<GuildMember>}
       */
      fetchMe(options) {
        return this.fetch({ ...options, user: this.client.user.id });
      }
      /**
       * Options used for searching guild members.
       * @typedef {Object} GuildSearchMembersOptions
       * @property {string} query Filter members whose username or nickname start with this query
       * @property {number} [limit] Maximum number of members to search
       * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)
       */
      /**
       * Searches for members in the guild based on a query.
       * @param {GuildSearchMembersOptions} options Options for searching members
       * @returns {Promise<Collection<Snowflake, GuildMember>>}
       */
      async search({ query, limit, cache = true } = {}) {
        const data = await this.client.rest.get(Routes2.guildMembersSearch(this.guild.id), {
          query: makeURLSearchParams2({ query, limit })
        });
        return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection2());
      }
      /**
       * Options used for listing guild members.
       * @typedef {Object} GuildListMembersOptions
       * @property {Snowflake} [after] Limit fetching members to those with an id greater than the supplied id
       * @property {number} [limit] Maximum number of members to list
       * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)
       */
      /**
       * Lists up to 1000 members of the guild.
       * @param {GuildListMembersOptions} [options] Options for listing members
       * @returns {Promise<Collection<Snowflake, GuildMember>>}
       */
      async list({ after, limit, cache = true } = {}) {
        const query = makeURLSearchParams2({ limit, after });
        const data = await this.client.rest.get(Routes2.guildMembers(this.guild.id), { query });
        return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection2());
      }
      /**
       * The data for editing a guild member.
       * @typedef {Object} GuildMemberEditOptions
       * @property {?string} [nick] The nickname to set for the member
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles or role ids to apply
       * @property {boolean} [mute] Whether or not the member should be muted
       * @property {boolean} [deaf] Whether or not the member should be deafened
       * @property {GuildVoiceChannelResolvable|null} [channel] Channel to move the member to
       * (if they are connected to voice), or `null` if you want to disconnect them from voice
       * @property {DateResolvable|null} [communicationDisabledUntil] The date or timestamp
       * for the member's communication to be disabled until. Provide `null` to enable communication again.
       * @property {GuildMemberFlagsResolvable} [flags] The flags to set for the member
       * @property {string} [reason] Reason for editing this user
       */
      /**
       * Edits a member of the guild.
       * <info>The user must be a member of the guild</info>
       * @param {UserResolvable} user The member to edit
       * @param {GuildMemberEditOptions} options The options to provide
       * @returns {Promise<GuildMember>}
       */
      async edit(user, { reason, ...options }) {
        const id = this.client.users.resolveId(user);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "user", "UserResolvable");
        if (options.channel) {
          options.channel = this.guild.channels.resolve(options.channel);
          if (!(options.channel instanceof BaseGuildVoiceChannel)) {
            throw new DiscordjsError2(ErrorCodes2.GuildVoiceChannelResolve);
          }
          options.channel_id = options.channel.id;
          options.channel = void 0;
        } else if (options.channel === null) {
          options.channel_id = null;
          options.channel = void 0;
        }
        options.roles &&= options.roles.map((role) => role instanceof Role ? role.id : role);
        if (options.communicationDisabledUntil !== void 0) {
          options.communication_disabled_until = // eslint-disable-next-line eqeqeq
          options.communicationDisabledUntil != null ? new Date(options.communicationDisabledUntil).toISOString() : options.communicationDisabledUntil;
        }
        if (options.flags !== void 0) {
          options.flags = GuildMemberFlagsBitField.resolve(options.flags);
        }
        let endpoint;
        if (id === this.client.user.id) {
          const keys = Object.keys(options);
          if (keys.length === 1 && keys[0] === "nick")
            endpoint = Routes2.guildMember(this.guild.id);
          else
            endpoint = Routes2.guildMember(this.guild.id, id);
        } else {
          endpoint = Routes2.guildMember(this.guild.id, id);
        }
        const d = await this.client.rest.patch(endpoint, { body: options, reason });
        const clone = this.cache.get(id)?._clone();
        clone?._patch(d);
        return clone ?? this._add(d, false);
      }
      /**
       * Options used for pruning guild members.
       * <info>It's recommended to set {@link GuildPruneMembersOptions#count options.count}
       * to `false` for large guilds.</info>
       * @typedef {Object} GuildPruneMembersOptions
       * @property {number} [days] Number of days of inactivity required to kick
       * @property {boolean} [dry=false] Get the number of users that will be kicked, without actually kicking them
       * @property {boolean} [count] Whether or not to return the number of users that have been kicked.
       * @property {RoleResolvable[]} [roles] Array of roles to bypass the "...and no roles" constraint when pruning
       * @property {string} [reason] Reason for this prune
       */
      /**
       * Prunes members from the guild based on how long they have been inactive.
       * @param {GuildPruneMembersOptions} [options] Options for pruning
       * @returns {Promise<number|null>} The number of members that were/will be kicked
       * @example
       * // See how many members will be pruned
       * guild.members.prune({ dry: true })
       *   .then(pruned => console.log(`This will prune ${pruned} people!`))
       *   .catch(console.error);
       * @example
       * // Actually prune the members
       * guild.members.prune({ days: 1, reason: 'too many people!' })
       *   .then(pruned => console.log(`I just pruned ${pruned} people!`))
       *   .catch(console.error);
       * @example
       * // Include members with a specified role
       * guild.members.prune({ days: 7, roles: ['657259391652855808'] })
       *    .then(pruned => console.log(`I just pruned ${pruned} people!`))
       *    .catch(console.error);
       */
      async prune({ days, dry = false, count: compute_prune_count, roles = [], reason } = {}) {
        if (typeof days !== "number")
          throw new DiscordjsTypeError2(ErrorCodes2.PruneDaysType);
        const query = { days };
        const resolvedRoles = [];
        for (const role of roles) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array", "options.roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        if (resolvedRoles.length) {
          query.include_roles = dry ? resolvedRoles.join(",") : resolvedRoles;
        }
        const endpoint = Routes2.guildPrune(this.guild.id);
        const { pruned } = await (dry ? this.client.rest.get(endpoint, { query: makeURLSearchParams2(query), reason }) : this.client.rest.post(endpoint, { body: { ...query, compute_prune_count }, reason }));
        return pruned;
      }
      /**
       * Kicks a user from the guild.
       * <info>The user must be a member of the guild</info>
       * @param {UserResolvable} user The member to kick
       * @param {string} [reason] Reason for kicking
       * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.
       * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot
       * be resolved, the user's id will be the result.
       * @example
       * // Kick a user by id (or with a user/guild member object)
       * guild.members.kick('84484653687267328')
       *   .then(kickInfo => console.log(`Kicked ${kickInfo.user?.tag ?? kickInfo.tag ?? kickInfo}`))
       *   .catch(console.error);
       */
      async kick(user, reason) {
        const id = this.client.users.resolveId(user);
        if (!id)
          return Promise.reject(new DiscordjsTypeError2(ErrorCodes2.InvalidType, "user", "UserResolvable"));
        await this.client.rest.delete(Routes2.guildMember(this.guild.id, id), { reason });
        return this.resolve(user) ?? this.client.users.resolve(user) ?? id;
      }
      /**
       * Bans a user from the guild.
       * @param {UserResolvable} user The user to ban
       * @param {BanOptions} [options] Options for the ban
       * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.
       * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot
       * be resolved, the user id will be the result.
       * Internally calls the GuildBanManager#create method.
       * @example
       * // Ban a user by id (or with a user/guild member object)
       * guild.members.ban('84484653687267328')
       *   .then(banInfo => console.log(`Banned ${banInfo.user?.tag ?? banInfo.tag ?? banInfo}`))
       *   .catch(console.error);
       */
      ban(user, options) {
        return this.guild.bans.create(user, options);
      }
      /**
       * Unbans a user from the guild. Internally calls the {@link GuildBanManager#remove} method.
       * @param {UserResolvable} user The user to unban
       * @param {string} [reason] Reason for unbanning user
       * @returns {Promise<?User>} The user that was unbanned
       * @example
       * // Unban a user by id (or with a user/guild member object)
       * guild.members.unban('84484653687267328')
       *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))
       *   .catch(console.error);
       */
      unban(user, reason) {
        return this.guild.bans.remove(user, reason);
      }
      /**
       * Options used for adding or removing a role from a member.
       * @typedef {Object} AddOrRemoveGuildMemberRoleOptions
       * @property {GuildMemberResolvable} user The user to add/remove the role from
       * @property {RoleResolvable} role The role to add/remove
       * @property {string} [reason] Reason for adding/removing the role
       */
      /**
       * Adds a role to a member.
       * @param {AddOrRemoveGuildMemberRoleOptions} options Options for adding the role
       * @returns {Promise<GuildMember|User|Snowflake>}
       */
      async addRole(options) {
        const { user, role, reason } = options;
        const userId = this.guild.members.resolveId(user);
        const roleId = this.guild.roles.resolveId(role);
        await this.client.rest.put(Routes2.guildMemberRole(this.guild.id, userId, roleId), { reason });
        return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
      }
      /**
       * Removes a role from a member.
       * @param {AddOrRemoveGuildMemberRoleOptions} options Options for removing the role
       * @returns {Promise<GuildMember|User|Snowflake>}
       */
      async removeRole(options) {
        const { user, role, reason } = options;
        const userId = this.guild.members.resolveId(user);
        const roleId = this.guild.roles.resolveId(role);
        await this.client.rest.delete(Routes2.guildMemberRole(this.guild.id, userId, roleId), { reason });
        return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
      }
    };
    module2.exports = GuildMemberManager;
  }
});

// node_modules/discord.js/src/managers/GuildScheduledEventManager.js
var require_GuildScheduledEventManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildScheduledEventManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { GuildScheduledEventEntityType, Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { GuildScheduledEvent } = require_GuildScheduledEvent();
    var DataResolver2 = require_DataResolver();
    var GuildScheduledEventManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildScheduledEvent, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, GuildScheduledEvent>}
       * @name GuildScheduledEventManager#cache
       */
      /**
       * Data that resolves to give a GuildScheduledEvent object. This can be:
       * * A Snowflake
       * * A GuildScheduledEvent object
       * @typedef {Snowflake|GuildScheduledEvent} GuildScheduledEventResolvable
       */
      /**
       * Options used to create a guild scheduled event.
       * @typedef {Object} GuildScheduledEventCreateOptions
       * @property {string} name The name of the guild scheduled event
       * @property {DateResolvable} scheduledStartTime The time to schedule the event at
       * @property {DateResolvable} [scheduledEndTime] The time to end the event at
       * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.External}</warn>
       * @property {GuildScheduledEventPrivacyLevel} privacyLevel The privacy level of the guild scheduled event
       * @property {GuildScheduledEventEntityType} entityType The scheduled entity type of the event
       * @property {string} [description] The description of the guild scheduled event
       * @property {GuildVoiceChannelResolvable} [channel] The channel of the guild scheduled event
       * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.StageInstance} or
       * {@link GuildScheduledEventEntityType.Voice}</warn>
       * @property {GuildScheduledEventEntityMetadataOptions} [entityMetadata] The entity metadata of the
       * guild scheduled event
       * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.External}</warn>
       * @property {?(BufferResolvable|Base64Resolvable)} [image] The cover image of the guild scheduled event
       * @property {string} [reason] The reason for creating the guild scheduled event
       */
      /**
       * Options used to set entity metadata of a guild scheduled event.
       * @typedef {Object} GuildScheduledEventEntityMetadataOptions
       * @property {string} [location] The location of the guild scheduled event
       * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.External}</warn>
       */
      /**
       * Creates a new guild scheduled event.
       * @param {GuildScheduledEventCreateOptions} options Options for creating the guild scheduled event
       * @returns {Promise<GuildScheduledEvent>}
       */
      async create(options) {
        if (typeof options !== "object")
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        let {
          privacyLevel,
          entityType,
          channel,
          name,
          scheduledStartTime,
          description,
          scheduledEndTime,
          entityMetadata,
          reason,
          image
        } = options;
        let entity_metadata, channel_id;
        if (entityType === GuildScheduledEventEntityType.External) {
          channel_id = channel === void 0 ? channel : null;
          entity_metadata = { location: entityMetadata?.location };
        } else {
          channel_id = this.guild.channels.resolveId(channel);
          if (!channel_id)
            throw new DiscordjsError2(ErrorCodes2.GuildVoiceChannelResolve);
          entity_metadata = entityMetadata === void 0 ? entityMetadata : null;
        }
        const data = await this.client.rest.post(Routes2.guildScheduledEvents(this.guild.id), {
          body: {
            channel_id,
            name,
            privacy_level: privacyLevel,
            scheduled_start_time: new Date(scheduledStartTime).toISOString(),
            scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
            description,
            entity_type: entityType,
            entity_metadata,
            image: image && await DataResolver2.resolveImage(image)
          },
          reason
        });
        return this._add(data);
      }
      /**
       * Options used to fetch a single guild scheduled event from a guild.
       * @typedef {BaseFetchOptions} FetchGuildScheduledEventOptions
       * @property {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to fetch
       * @property {boolean} [withUserCount=true] Whether to fetch the number of users subscribed to the scheduled event
       */
      /**
       * Options used to fetch multiple guild scheduled events from a guild.
       * @typedef {Object} FetchGuildScheduledEventsOptions
       * @property {boolean} [cache] Whether or not to cache the fetched guild scheduled events
       * @property {boolean} [withUserCount=true] Whether to fetch the number of users subscribed to each scheduled event
       * should be returned
       */
      /**
       * Obtains one or more guild scheduled events from Discord, or the guild cache if it's already available.
       * @param {GuildScheduledEventResolvable|FetchGuildScheduledEventOptions|FetchGuildScheduledEventsOptions} [options]
       * The id of the guild scheduled event or options
       * @returns {Promise<GuildScheduledEvent|Collection<Snowflake, GuildScheduledEvent>>}
       */
      async fetch(options = {}) {
        const id = this.resolveId(options.guildScheduledEvent ?? options);
        if (id) {
          if (!options.force) {
            const existing = this.cache.get(id);
            if (existing)
              return existing;
          }
          const data2 = await this.client.rest.get(Routes2.guildScheduledEvent(this.guild.id, id), {
            query: makeURLSearchParams2({ with_user_count: options.withUserCount ?? true })
          });
          return this._add(data2, options.cache);
        }
        const data = await this.client.rest.get(Routes2.guildScheduledEvents(this.guild.id), {
          query: makeURLSearchParams2({ with_user_count: options.withUserCount ?? true })
        });
        return data.reduce(
          (coll, rawGuildScheduledEventData) => coll.set(
            rawGuildScheduledEventData.id,
            this.guild.scheduledEvents._add(rawGuildScheduledEventData, options.cache)
          ),
          new Collection2()
        );
      }
      /**
       * Options used to edit a guild scheduled event.
       * @typedef {Object} GuildScheduledEventEditOptions
       * @property {string} [name] The name of the guild scheduled event
       * @property {DateResolvable} [scheduledStartTime] The time to schedule the event at
       * @property {DateResolvable} [scheduledEndTime] The time to end the event at
       * @property {GuildScheduledEventPrivacyLevel} [privacyLevel] The privacy level of the guild scheduled event
       * @property {GuildScheduledEventEntityType} [entityType] The scheduled entity type of the event
       * @property {string} [description] The description of the guild scheduled event
       * @property {?GuildVoiceChannelResolvable} [channel] The channel of the guild scheduled event
       * @property {GuildScheduledEventStatus} [status] The status of the guild scheduled event
       * @property {GuildScheduledEventEntityMetadataOptions} [entityMetadata] The entity metadata of the
       * guild scheduled event
       * <warn>This can be modified only if `entityType` of the `GuildScheduledEvent` to be edited is
       * {@link GuildScheduledEventEntityType.External}</warn>
       * @property {?(BufferResolvable|Base64Resolvable)} [image] The cover image of the guild scheduled event
       * @property {string} [reason] The reason for editing the guild scheduled event
       */
      /**
       * Edits a guild scheduled event.
       * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to edit
       * @param {GuildScheduledEventEditOptions} options Options to edit the guild scheduled event
       * @returns {Promise<GuildScheduledEvent>}
       */
      async edit(guildScheduledEvent, options) {
        const guildScheduledEventId = this.resolveId(guildScheduledEvent);
        if (!guildScheduledEventId)
          throw new DiscordjsError2(ErrorCodes2.GuildScheduledEventResolve);
        if (typeof options !== "object")
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        let {
          privacyLevel,
          entityType,
          channel,
          status,
          name,
          scheduledStartTime,
          description,
          scheduledEndTime,
          entityMetadata,
          reason,
          image
        } = options;
        let entity_metadata;
        if (entityMetadata) {
          entity_metadata = {
            location: entityMetadata.location
          };
        }
        const data = await this.client.rest.patch(Routes2.guildScheduledEvent(this.guild.id, guildScheduledEventId), {
          body: {
            channel_id: channel === void 0 ? channel : this.guild.channels.resolveId(channel),
            name,
            privacy_level: privacyLevel,
            scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : void 0,
            scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
            description,
            entity_type: entityType,
            status,
            image: image && await DataResolver2.resolveImage(image),
            entity_metadata
          },
          reason
        });
        return this._add(data);
      }
      /**
       * Deletes a guild scheduled event.
       * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to delete
       * @returns {Promise<void>}
       */
      async delete(guildScheduledEvent) {
        const guildScheduledEventId = this.resolveId(guildScheduledEvent);
        if (!guildScheduledEventId)
          throw new DiscordjsError2(ErrorCodes2.GuildScheduledEventResolve);
        await this.client.rest.delete(Routes2.guildScheduledEvent(this.guild.id, guildScheduledEventId));
      }
      /**
       * Options used to fetch subscribers of a guild scheduled event
       * @typedef {Object} FetchGuildScheduledEventSubscribersOptions
       * @property {number} [limit] The maximum numbers of users to fetch
       * @property {boolean} [withMember] Whether to fetch guild member data of the users
       * @property {Snowflake} [before] Consider only users before this user id
       * @property {Snowflake} [after] Consider only users after this user id
       * <warn>If both `before` and `after` are provided, only `before` is respected</warn>
       */
      /**
       * Represents a subscriber of a {@link GuildScheduledEvent}
       * @typedef {Object} GuildScheduledEventUser
       * @property {Snowflake} guildScheduledEventId The id of the guild scheduled event which the user subscribed to
       * @property {User} user The user that subscribed to the guild scheduled event
       * @property {?GuildMember} member The guild member associated with the user, if any
       */
      /**
       * Fetches subscribers of a guild scheduled event.
       * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to fetch subscribers of
       * @param {FetchGuildScheduledEventSubscribersOptions} [options={}] Options for fetching the subscribers
       * @returns {Promise<Collection<Snowflake, GuildScheduledEventUser>>}
       */
      async fetchSubscribers(guildScheduledEvent, options = {}) {
        const guildScheduledEventId = this.resolveId(guildScheduledEvent);
        if (!guildScheduledEventId)
          throw new DiscordjsError2(ErrorCodes2.GuildScheduledEventResolve);
        const query = makeURLSearchParams2({
          limit: options.limit,
          with_member: options.withMember,
          before: options.before,
          after: options.after
        });
        const data = await this.client.rest.get(Routes2.guildScheduledEventUsers(this.guild.id, guildScheduledEventId), {
          query
        });
        return data.reduce(
          (coll, rawData) => coll.set(rawData.user.id, {
            guildScheduledEventId: rawData.guild_scheduled_event_id,
            user: this.client.users._add(rawData.user),
            member: rawData.member ? this.guild.members._add({ ...rawData.member, user: rawData.user }) : null
          }),
          new Collection2()
        );
      }
    };
    module2.exports = GuildScheduledEventManager;
  }
});

// node_modules/discord.js/src/managers/GuildStickerManager.js
var require_GuildStickerManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildStickerManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var MessagePayload = require_MessagePayload();
    var { Sticker: Sticker2 } = require_Sticker();
    var GuildStickerManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, Sticker2, iterable);
        this.guild = guild;
      }
      /**
       * The cache of Guild Stickers
       * @type {Collection<Snowflake, Sticker>}
       * @name GuildStickerManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.guild] });
      }
      /**
       * Options used to create a guild sticker.
       * @typedef {Object} GuildStickerCreateOptions
       * @property {BufferResolvable|Stream|JSONEncodable<AttachmentPayload>} file The file for the sticker
       * @property {string} name The name for the sticker
       * @property {string} tags The Discord name of a unicode emoji representing the sticker's expression
       * @property {?string} [description] The description for the sticker
       * @property {string} [reason] Reason for creating the sticker
       */
      /**
       * Creates a new custom sticker in the guild.
       * @param {GuildStickerCreateOptions} options Options for creating a guild sticker
       * @returns {Promise<Sticker>} The created sticker
       * @example
       * // Create a new sticker from a URL
       * guild.stickers.create({ file: 'https://i.imgur.com/w3duR07.png', name: 'rip', tags: 'headstone' })
       *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))
       *   .catch(console.error);
       * @example
       * // Create a new sticker from a file on your computer
       * guild.stickers.create({ file: './memes/banana.png', name: 'banana', tags: 'banana' })
       *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))
       *   .catch(console.error);
       */
      async create({ file, name, tags, description, reason } = {}) {
        const resolvedFile = await MessagePayload.resolveFile(file);
        if (!resolvedFile)
          throw new DiscordjsTypeError2(ErrorCodes2.ReqResourceType);
        file = { ...resolvedFile, key: "file" };
        const body = { name, tags, description: description ?? "" };
        const sticker = await this.client.rest.post(Routes2.guildStickers(this.guild.id), {
          appendToFormData: true,
          body,
          files: [file],
          reason
        });
        return this.client.actions.GuildStickerCreate.handle(this.guild, sticker).sticker;
      }
      /**
       * Data that resolves to give a Sticker object. This can be:
       * * A Sticker object
       * * A Snowflake
       * @typedef {Sticker|Snowflake} StickerResolvable
       */
      /**
       * Resolves a StickerResolvable to a Sticker object.
       * @method resolve
       * @memberof GuildStickerManager
       * @instance
       * @param {StickerResolvable} sticker The Sticker resolvable to identify
       * @returns {?Sticker}
       */
      /**
       * Resolves a StickerResolvable to a Sticker id string.
       * @method resolveId
       * @memberof GuildStickerManager
       * @instance
       * @param {StickerResolvable} sticker The Sticker resolvable to identify
       * @returns {?Snowflake}
       */
      /**
       * Edits a sticker.
       * @param {StickerResolvable} sticker The sticker to edit
       * @param {GuildStickerEditOptions} [options={}] The new data for the sticker
       * @returns {Promise<Sticker>}
       */
      async edit(sticker, options = {}) {
        const stickerId = this.resolveId(sticker);
        if (!stickerId)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "sticker", "StickerResolvable");
        const d = await this.client.rest.patch(Routes2.guildSticker(this.guild.id, stickerId), {
          body: options,
          reason: options.reason
        });
        const existing = this.cache.get(stickerId);
        if (existing) {
          const clone = existing._clone();
          clone._patch(d);
          return clone;
        }
        return this._add(d);
      }
      /**
       * Deletes a sticker.
       * @param {StickerResolvable} sticker The sticker to delete
       * @param {string} [reason] Reason for deleting this sticker
       * @returns {Promise<void>}
       */
      async delete(sticker, reason) {
        sticker = this.resolveId(sticker);
        if (!sticker)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "sticker", "StickerResolvable");
        await this.client.rest.delete(Routes2.guildSticker(this.guild.id, sticker), { reason });
      }
      /**
       * Obtains one or more stickers from Discord, or the sticker cache if they're already available.
       * @param {Snowflake} [id] The Sticker's id
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<Sticker|Collection<Snowflake, Sticker>>}
       * @example
       * // Fetch all stickers from the guild
       * message.guild.stickers.fetch()
       *   .then(stickers => console.log(`There are ${stickers.size} stickers.`))
       *   .catch(console.error);
       * @example
       * // Fetch a single sticker
       * message.guild.stickers.fetch('222078108977594368')
       *   .then(sticker => console.log(`The sticker name is: ${sticker.name}`))
       *   .catch(console.error);
       */
      async fetch(id, { cache = true, force = false } = {}) {
        if (id) {
          if (!force) {
            const existing = this.cache.get(id);
            if (existing)
              return existing;
          }
          const sticker = await this.client.rest.get(Routes2.guildSticker(this.guild.id, id));
          return this._add(sticker, cache);
        }
        const data = await this.client.rest.get(Routes2.guildStickers(this.guild.id));
        return new Collection2(data.map((sticker) => [sticker.id, this._add(sticker, cache)]));
      }
      /**
       * Fetches the user who uploaded this sticker, if this is a guild sticker.
       * @param {StickerResolvable} sticker The sticker to fetch the user for
       * @returns {Promise<?User>}
       */
      async fetchUser(sticker) {
        sticker = this.resolve(sticker);
        if (!sticker)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "sticker", "StickerResolvable");
        const data = await this.client.rest.get(Routes2.guildSticker(this.guild.id, sticker.id));
        sticker._patch(data);
        return sticker.user;
      }
    };
    module2.exports = GuildStickerManager;
  }
});

// node_modules/discord.js/src/util/ActivityFlagsBitField.js
var require_ActivityFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/ActivityFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { ActivityFlags } = require_v106();
    var BitField = require_BitField();
    var ActivityFlagsBitField = class extends BitField {
    };
    /**
     * Numeric activity flags.
     * @type {ActivityFlags}
     * @memberof ActivityFlagsBitField
     */
    __publicField(ActivityFlagsBitField, "Flags", ActivityFlags);
    module2.exports = ActivityFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/Presence.js
var require_Presence = __commonJS({
  "node_modules/discord.js/src/structures/Presence.js"(exports2) {
    "use strict";
    var Base = require_Base();
    var { Emoji } = require_Emoji();
    var ActivityFlagsBitField = require_ActivityFlagsBitField();
    var { flatten } = require_Util();
    var Presence = class extends Base {
      constructor(client, data = {}) {
        super(client);
        this.userId = data.user.id;
        this.guild = data.guild ?? null;
        this._patch(data);
      }
      /**
       * The user of this presence
       * @type {?User}
       * @readonly
       */
      get user() {
        return this.client.users.resolve(this.userId);
      }
      /**
       * The member of this presence
       * @type {?GuildMember}
       * @readonly
       */
      get member() {
        return this.guild.members.resolve(this.userId);
      }
      _patch(data) {
        if ("status" in data) {
          this.status = data.status;
        } else {
          this.status ??= "offline";
        }
        if ("activities" in data) {
          this.activities = data.activities.map((activity) => new Activity(this, activity));
        } else {
          this.activities ??= [];
        }
        if ("client_status" in data) {
          this.clientStatus = data.client_status;
        } else {
          this.clientStatus ??= null;
        }
        return this;
      }
      _clone() {
        const clone = Object.assign(Object.create(this), this);
        clone.activities = this.activities.map((activity) => activity._clone());
        return clone;
      }
      /**
       * Whether this presence is equal to another.
       * @param {Presence} presence The presence to compare with
       * @returns {boolean}
       */
      equals(presence) {
        return this === presence || presence && this.status === presence.status && this.activities.length === presence.activities.length && this.activities.every((activity, index) => activity.equals(presence.activities[index])) && this.clientStatus?.web === presence.clientStatus?.web && this.clientStatus?.mobile === presence.clientStatus?.mobile && this.clientStatus?.desktop === presence.clientStatus?.desktop;
      }
      toJSON() {
        return flatten(this);
      }
    };
    var Activity = class {
      constructor(presence, data) {
        Object.defineProperty(this, "presence", { value: presence });
        this.name = data.name;
        this.type = data.type;
        this.url = data.url ?? null;
        this.details = data.details ?? null;
        this.state = data.state ?? null;
        this.applicationId = data.application_id ?? null;
        this.timestamps = data.timestamps ? {
          start: data.timestamps.start ? new Date(Number(data.timestamps.start)) : null,
          end: data.timestamps.end ? new Date(Number(data.timestamps.end)) : null
        } : null;
        this.party = data.party ?? null;
        this.assets = data.assets ? new RichPresenceAssets(this, data.assets) : null;
        this.flags = new ActivityFlagsBitField(data.flags).freeze();
        this.emoji = data.emoji ? new Emoji(presence.client, data.emoji) : null;
        this.buttons = data.buttons ?? [];
        this.createdTimestamp = data.created_at;
      }
      /**
       * Whether this activity is equal to another activity.
       * @param {Activity} activity The activity to compare with
       * @returns {boolean}
       */
      equals(activity) {
        return this === activity || activity && this.name === activity.name && this.type === activity.type && this.url === activity.url && this.state === activity.state && this.details === activity.details && this.emoji?.id === activity.emoji?.id && this.emoji?.name === activity.emoji?.name;
      }
      /**
       * The time the activity was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * When concatenated with a string, this automatically returns the activity's name instead of the Activity object.
       * @returns {string}
       */
      toString() {
        return this.name;
      }
      _clone() {
        return Object.assign(Object.create(this), this);
      }
    };
    var RichPresenceAssets = class {
      constructor(activity, assets) {
        Object.defineProperty(this, "activity", { value: activity });
        this.largeText = assets.large_text ?? null;
        this.smallText = assets.small_text ?? null;
        this.largeImage = assets.large_image ?? null;
        this.smallImage = assets.small_image ?? null;
      }
      /**
       * Gets the URL of the small image asset
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      smallImageURL(options = {}) {
        if (!this.smallImage)
          return null;
        if (this.smallImage.includes(":")) {
          const [platform, id] = this.smallImage.split(":");
          switch (platform) {
            case "mp":
              return `https://media.discordapp.net/${id}`;
            default:
              return null;
          }
        }
        return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.smallImage, options);
      }
      /**
       * Gets the URL of the large image asset
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      largeImageURL(options = {}) {
        if (!this.largeImage)
          return null;
        if (this.largeImage.includes(":")) {
          const [platform, id] = this.largeImage.split(":");
          switch (platform) {
            case "mp":
              return `https://media.discordapp.net/${id}`;
            default:
              return null;
          }
        }
        return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.largeImage, options);
      }
    };
    exports2.Presence = Presence;
    exports2.Activity = Activity;
    exports2.RichPresenceAssets = RichPresenceAssets;
  }
});

// node_modules/discord.js/src/managers/PresenceManager.js
var require_PresenceManager = __commonJS({
  "node_modules/discord.js/src/managers/PresenceManager.js"(exports2, module2) {
    "use strict";
    var CachedManager = require_CachedManager();
    var { Presence } = require_Presence();
    var PresenceManager = class extends CachedManager {
      constructor(client, iterable) {
        super(client, Presence, iterable);
      }
      /**
       * The cache of Presences
       * @type {Collection<Snowflake, Presence>}
       * @name PresenceManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { id: data.user.id });
      }
      /**
       * Data that can be resolved to a Presence object. This can be:
       * * A Presence
       * * A UserResolvable
       * * A Snowflake
       * @typedef {Presence|UserResolvable|Snowflake} PresenceResolvable
       */
      /**
       * Resolves a {@link PresenceResolvable} to a {@link Presence} object.
       * @param {PresenceResolvable} presence The presence resolvable to resolve
       * @returns {?Presence}
       */
      resolve(presence) {
        const presenceResolvable = super.resolve(presence);
        if (presenceResolvable)
          return presenceResolvable;
        const UserResolvable = this.client.users.resolveId(presence);
        return super.resolve(UserResolvable);
      }
      /**
       * Resolves a {@link PresenceResolvable} to a {@link Presence} id.
       * @param {PresenceResolvable} presence The presence resolvable to resolve
       * @returns {?Snowflake}
       */
      resolveId(presence) {
        const presenceResolvable = super.resolveId(presence);
        if (presenceResolvable)
          return presenceResolvable;
        const userResolvable = this.client.users.resolveId(presence);
        return this.cache.has(userResolvable) ? userResolvable : null;
      }
    };
    module2.exports = PresenceManager;
  }
});

// node_modules/discord.js/src/managers/RoleManager.js
var require_RoleManager = __commonJS({
  "node_modules/discord.js/src/managers/RoleManager.js"(exports2, module2) {
    "use strict";
    var process2 = require("node:process");
    var { Collection: Collection2 } = require_dist();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { Role } = require_Role();
    var DataResolver2 = require_DataResolver();
    var PermissionsBitField2 = require_PermissionsBitField();
    var { setPosition, resolveColor } = require_Util();
    var cacheWarningEmitted = false;
    var RoleManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, Role, iterable);
        if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
          cacheWarningEmitted = true;
          process2.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
        this.guild = guild;
      }
      /**
       * The role cache of this manager
       * @type {Collection<Snowflake, Role>}
       * @name RoleManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.guild] });
      }
      /**
       * Obtains a role from Discord, or the role cache if they're already available.
       * @param {Snowflake} [id] The role's id
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<?Role|Collection<Snowflake, Role>>}
       * @example
       * // Fetch all roles from the guild
       * message.guild.roles.fetch()
       *   .then(roles => console.log(`There are ${roles.size} roles.`))
       *   .catch(console.error);
       * @example
       * // Fetch a single role
       * message.guild.roles.fetch('222078108977594368')
       *   .then(role => console.log(`The role color is: ${role.color}`))
       *   .catch(console.error);
       */
      async fetch(id, { cache = true, force = false } = {}) {
        if (id && !force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.guildRoles(this.guild.id));
        const roles = new Collection2();
        for (const role of data)
          roles.set(role.id, this._add(role, cache));
        return id ? roles.get(id) ?? null : roles;
      }
      /**
       * Data that can be resolved to a Role object. This can be:
       * * A Role
       * * A Snowflake
       * @typedef {Role|Snowflake} RoleResolvable
       */
      /**
       * Resolves a {@link RoleResolvable} to a {@link Role} object.
       * @method resolve
       * @memberof RoleManager
       * @instance
       * @param {RoleResolvable} role The role resolvable to resolve
       * @returns {?Role}
       */
      /**
       * Resolves a {@link RoleResolvable} to a {@link Role} id.
       * @method resolveId
       * @memberof RoleManager
       * @instance
       * @param {RoleResolvable} role The role resolvable to resolve
       * @returns {?Snowflake}
       */
      /**
       * Options used to create a new role.
       * @typedef {Object} RoleCreateOptions
       * @property {string} [name] The name of the new role
       * @property {ColorResolvable} [color] The data to create the role with
       * @property {boolean} [hoist] Whether or not the new role should be hoisted
       * @property {PermissionResolvable} [permissions] The permissions for the new role
       * @property {number} [position] The position of the new role
       * @property {boolean} [mentionable] Whether or not the new role should be mentionable
       * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role
       * <warn>The `EmojiResolvable` should belong to the same guild as the role.
       * If not, pass the emoji's URL directly</warn>
       * @property {?string} [unicodeEmoji] The unicode emoji for the role
       * @property {string} [reason] The reason for creating this role
       */
      /**
       * Creates a new role in the guild with given information.
       * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>
       * @param {RoleCreateOptions} [options] Options for creating the new role
       * @returns {Promise<Role>}
       * @example
       * // Create a new role
       * guild.roles.create()
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Create a new role with data and a reason
       * guild.roles.create({
       *   name: 'Super Cool Blue People',
       *   color: Colors.Blue,
       *   reason: 'we needed a role for Super Cool People',
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async create(options = {}) {
        let { name, color, hoist, permissions, position, mentionable, reason, icon, unicodeEmoji } = options;
        color &&= resolveColor(color);
        if (permissions !== void 0)
          permissions = new PermissionsBitField2(permissions);
        if (icon) {
          const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;
          icon = guildEmojiURL ? await DataResolver2.resolveImage(guildEmojiURL) : await DataResolver2.resolveImage(icon);
          if (typeof icon !== "string")
            icon = void 0;
        }
        const data = await this.client.rest.post(Routes2.guildRoles(this.guild.id), {
          body: {
            name,
            color,
            hoist,
            permissions,
            mentionable,
            icon,
            unicode_emoji: unicodeEmoji
          },
          reason
        });
        const { role } = this.client.actions.GuildRoleCreate.handle({
          guild_id: this.guild.id,
          role: data
        });
        if (position)
          return this.setPosition(role, position, { reason });
        return role;
      }
      /**
       * Options for editing a role
       * @typedef {RoleData} RoleEditOptions
       * @property {string} [reason] The reason for editing this role
       */
      /**
       * Edits a role of the guild.
       * @param {RoleResolvable} role The role to edit
       * @param {RoleEditOptions} options The options to provide
       * @returns {Promise<Role>}
       * @example
       * // Edit a role
       * guild.roles.edit('222079219327434752', { name: 'buddies' })
       *   .then(updated => console.log(`Edited role name to ${updated.name}`))
       *   .catch(console.error);
       */
      async edit(role, options) {
        role = this.resolve(role);
        if (!role)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "role", "RoleResolvable");
        if (typeof options.position === "number") {
          await this.setPosition(role, options.position, { reason: options.reason });
        }
        let icon = options.icon;
        if (icon) {
          const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;
          icon = guildEmojiURL ? await DataResolver2.resolveImage(guildEmojiURL) : await DataResolver2.resolveImage(icon);
          if (typeof icon !== "string")
            icon = void 0;
        }
        const body = {
          name: options.name,
          color: options.color === void 0 ? void 0 : resolveColor(options.color),
          hoist: options.hoist,
          permissions: options.permissions === void 0 ? void 0 : new PermissionsBitField2(options.permissions),
          mentionable: options.mentionable,
          icon,
          unicode_emoji: options.unicodeEmoji
        };
        const d = await this.client.rest.patch(Routes2.guildRole(this.guild.id, role.id), { body, reason: options.reason });
        const clone = role._clone();
        clone._patch(d);
        return clone;
      }
      /**
       * Deletes a role.
       * @param {RoleResolvable} role The role to delete
       * @param {string} [reason] Reason for deleting the role
       * @returns {Promise<void>}
       * @example
       * // Delete a role
       * guild.roles.delete('222079219327434752', 'The role needed to go')
       *   .then(() => console.log('Deleted the role'))
       *   .catch(console.error);
       */
      async delete(role, reason) {
        const id = this.resolveId(role);
        await this.client.rest.delete(Routes2.guildRole(this.guild.id, id), { reason });
        this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: id });
      }
      /**
       * Sets the new position of the role.
       * @param {RoleResolvable} role The role to change the position of
       * @param {number} position The new position for the role
       * @param {SetRolePositionOptions} [options] Options for setting the position
       * @returns {Promise<Role>}
       * @example
       * // Set the position of the role
       * guild.roles.setPosition('222197033908436994', 1)
       *   .then(updated => console.log(`Role position: ${updated.position}`))
       *   .catch(console.error);
       */
      async setPosition(role, position, { relative, reason } = {}) {
        role = this.resolve(role);
        if (!role)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "role", "RoleResolvable");
        const updatedRoles = await setPosition(
          role,
          position,
          relative,
          this.guild._sortedRoles(),
          this.client,
          Routes2.guildRoles(this.guild.id),
          reason
        );
        this.client.actions.GuildRolesPositionUpdate.handle({
          guild_id: this.guild.id,
          roles: updatedRoles
        });
        return role;
      }
      /**
       * The data needed for updating a guild role's position
       * @typedef {Object} GuildRolePosition
       * @property {RoleResolvable} role The role's id
       * @property {number} position The position to update
       */
      /**
       * Batch-updates the guild's role positions
       * @param {GuildRolePosition[]} rolePositions Role positions to update
       * @returns {Promise<Guild>}
       * @example
       * guild.roles.setPositions([{ role: roleId, position: updatedRoleIndex }])
       *  .then(guild => console.log(`Role positions updated for ${guild}`))
       *  .catch(console.error);
       */
      async setPositions(rolePositions) {
        rolePositions = rolePositions.map((o) => ({
          id: this.resolveId(o.role),
          position: o.position
        }));
        await this.client.rest.patch(Routes2.guildRoles(this.guild.id), { body: rolePositions });
        return this.client.actions.GuildRolesPositionUpdate.handle({
          guild_id: this.guild.id,
          roles: rolePositions
        }).guild;
      }
      /**
       * Compares the positions of two roles.
       * @param {RoleResolvable} role1 First role to compare
       * @param {RoleResolvable} role2 Second role to compare
       * @returns {number} Negative number if the first role's position is lower (second role's is higher),
       * positive number if the first's is higher (second's is lower), 0 if equal
       */
      comparePositions(role1, role2) {
        const resolvedRole1 = this.resolve(role1);
        const resolvedRole2 = this.resolve(role2);
        if (!resolvedRole1 || !resolvedRole2) {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "role", "Role nor a Snowflake");
        }
        if (resolvedRole1.position === resolvedRole2.position) {
          return Number(BigInt(resolvedRole2.id) - BigInt(resolvedRole1.id));
        }
        return resolvedRole1.position - resolvedRole2.position;
      }
      /**
       * Gets the managed role a user created when joining the guild, if any
       * <info>Only ever available for bots</info>
       * @param {UserResolvable} user The user to access the bot role for
       * @returns {?Role}
       */
      botRoleFor(user) {
        const userId = this.client.users.resolveId(user);
        if (!userId)
          return null;
        return this.cache.find((role) => role.tags?.botId === userId) ?? null;
      }
      /**
       * The `@everyone` role of the guild
       * @type {Role}
       * @readonly
       */
      get everyone() {
        return this.cache.get(this.guild.id);
      }
      /**
       * The premium subscriber role of the guild, if any
       * @type {?Role}
       * @readonly
       */
      get premiumSubscriberRole() {
        return this.cache.find((role) => role.tags?.premiumSubscriberRole) ?? null;
      }
      /**
       * The role with the highest position in the cache
       * @type {Role}
       * @readonly
       */
      get highest() {
        return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
      }
    };
    module2.exports = RoleManager;
  }
});

// node_modules/discord.js/src/managers/StageInstanceManager.js
var require_StageInstanceManager = __commonJS({
  "node_modules/discord.js/src/managers/StageInstanceManager.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { StageInstance } = require_StageInstance();
    var StageInstanceManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, StageInstance, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, StageInstance>}
       * @name StageInstanceManager#cache
       */
      /**
       * Options used to create a stage instance.
       * @typedef {Object} StageInstanceCreateOptions
       * @property {string} topic The topic of the stage instance
       * @property {StageInstancePrivacyLevel} [privacyLevel] The privacy level of the stage instance
       * @property {boolean} [sendStartNotification] Whether to notify `@everyone` that the stage instance has started
       */
      /**
       * Data that can be resolved to a Stage Channel object. This can be:
       * * A StageChannel
       * * A Snowflake
       * @typedef {StageChannel|Snowflake} StageChannelResolvable
       */
      /**
       * Creates a new stage instance.
       * @param {StageChannelResolvable} channel The stage channel to associate the created stage instance to
       * @param {StageInstanceCreateOptions} options The options to create the stage instance
       * @returns {Promise<StageInstance>}
       * @example
       * // Create a stage instance
       * guild.stageInstances.create('1234567890123456789', {
       *  topic: 'A very creative topic',
       *  privacyLevel: GuildPrivacyLevel.GuildOnly
       * })
       *  .then(stageInstance => console.log(stageInstance))
       *  .catch(console.error);
       */
      async create(channel, options) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId)
          throw new DiscordjsError2(ErrorCodes2.StageChannelResolve);
        if (typeof options !== "object")
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        let { topic, privacyLevel, sendStartNotification } = options;
        const data = await this.client.rest.post(Routes2.stageInstances(), {
          body: {
            channel_id: channelId,
            topic,
            privacy_level: privacyLevel,
            send_start_notification: sendStartNotification
          }
        });
        return this._add(data);
      }
      /**
       * Fetches the stage instance associated with a stage channel, if it exists.
       * @param {StageChannelResolvable} channel The stage channel whose associated stage instance is to be fetched
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<StageInstance>}
       * @example
       * // Fetch a stage instance
       * guild.stageInstances.fetch('1234567890123456789')
       *  .then(stageInstance => console.log(stageInstance))
       *  .catch(console.error);
       */
      async fetch(channel, { cache = true, force = false } = {}) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId)
          throw new DiscordjsError2(ErrorCodes2.StageChannelResolve);
        if (!force) {
          const existing = this.cache.find((stageInstance) => stageInstance.channelId === channelId);
          if (existing)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.stageInstance(channelId));
        return this._add(data, cache);
      }
      /**
       * Options used to edit an existing stage instance.
       * @typedef {Object} StageInstanceEditOptions
       * @property {string} [topic] The new topic of the stage instance
       * @property {StageInstancePrivacyLevel} [privacyLevel] The new privacy level of the stage instance
       */
      /**
       * Edits an existing stage instance.
       * @param {StageChannelResolvable} channel The stage channel whose associated stage instance is to be edited
       * @param {StageInstanceEditOptions} options The options to edit the stage instance
       * @returns {Promise<StageInstance>}
       * @example
       * // Edit a stage instance
       * guild.stageInstances.edit('1234567890123456789', { topic: 'new topic' })
       *  .then(stageInstance => console.log(stageInstance))
       *  .catch(console.error);
       */
      async edit(channel, options) {
        if (typeof options !== "object")
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId)
          throw new DiscordjsError2(ErrorCodes2.StageChannelResolve);
        let { topic, privacyLevel } = options;
        const data = await this.client.rest.patch(Routes2.stageInstance(channelId), {
          body: {
            topic,
            privacy_level: privacyLevel
          }
        });
        if (this.cache.has(data.id)) {
          const clone = this.cache.get(data.id)._clone();
          clone._patch(data);
          return clone;
        }
        return this._add(data);
      }
      /**
       * Deletes an existing stage instance.
       * @param {StageChannelResolvable} channel The stage channel whose associated stage instance is to be deleted
       * @returns {Promise<void>}
       */
      async delete(channel) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId)
          throw new DiscordjsError2(ErrorCodes2.StageChannelResolve);
        await this.client.rest.delete(Routes2.stageInstance(channelId));
      }
    };
    module2.exports = StageInstanceManager;
  }
});

// node_modules/discord.js/src/managers/VoiceStateManager.js
var require_VoiceStateManager = __commonJS({
  "node_modules/discord.js/src/managers/VoiceStateManager.js"(exports2, module2) {
    "use strict";
    var CachedManager = require_CachedManager();
    var VoiceState = require_VoiceState();
    var VoiceStateManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, VoiceState, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, VoiceState>}
       * @name VoiceStateManager#cache
       */
      _add(data, cache = true) {
        const existing = this.cache.get(data.user_id);
        if (existing)
          return existing._patch(data);
        const entry = new this.holds(this.guild, data);
        if (cache)
          this.cache.set(data.user_id, entry);
        return entry;
      }
    };
    module2.exports = VoiceStateManager;
  }
});

// node_modules/discord.js/src/util/SystemChannelFlagsBitField.js
var require_SystemChannelFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/SystemChannelFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { GuildSystemChannelFlags } = require_v106();
    var BitField = require_BitField();
    var SystemChannelFlagsBitField = class extends BitField {
    };
    /**
     * Numeric system channel flags.
     * @type {GuildSystemChannelFlags}
     * @memberof SystemChannelFlagsBitField
     */
    __publicField(SystemChannelFlagsBitField, "Flags", GuildSystemChannelFlags);
    module2.exports = SystemChannelFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/Guild.js
var require_Guild = __commonJS({
  "node_modules/discord.js/src/structures/Guild.js"(exports2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { ChannelType, GuildPremiumTier, Routes: Routes2, GuildFeature } = require_v106();
    var AnonymousGuild = require_AnonymousGuild();
    var GuildAuditLogs = require_GuildAuditLogs();
    var GuildPreview2 = require_GuildPreview();
    var GuildTemplate2 = require_GuildTemplate();
    var Integration = require_Integration();
    var Webhook2 = require_Webhook();
    var WelcomeScreen = require_WelcomeScreen();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var AutoModerationRuleManager = require_AutoModerationRuleManager();
    var GuildApplicationCommandManager = require_GuildApplicationCommandManager();
    var GuildBanManager = require_GuildBanManager();
    var GuildChannelManager = require_GuildChannelManager();
    var GuildEmojiManager = require_GuildEmojiManager();
    var GuildInviteManager = require_GuildInviteManager();
    var GuildMemberManager = require_GuildMemberManager();
    var GuildScheduledEventManager = require_GuildScheduledEventManager();
    var GuildStickerManager = require_GuildStickerManager();
    var PresenceManager = require_PresenceManager();
    var RoleManager = require_RoleManager();
    var StageInstanceManager = require_StageInstanceManager();
    var VoiceStateManager = require_VoiceStateManager();
    var DataResolver2 = require_DataResolver();
    var Status2 = require_Status();
    var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
    var { discordSort } = require_Util();
    var Guild = class extends AnonymousGuild {
      constructor(client, data) {
        super(client, data, false);
        this.commands = new GuildApplicationCommandManager(this);
        this.members = new GuildMemberManager(this);
        this.channels = new GuildChannelManager(this);
        this.bans = new GuildBanManager(this);
        this.roles = new RoleManager(this);
        this.presences = new PresenceManager(this.client);
        this.voiceStates = new VoiceStateManager(this);
        this.stageInstances = new StageInstanceManager(this);
        this.invites = new GuildInviteManager(this);
        this.scheduledEvents = new GuildScheduledEventManager(this);
        this.autoModerationRules = new AutoModerationRuleManager(this);
        if (!data)
          return;
        if (data.unavailable) {
          this.available = false;
        } else {
          this._patch(data);
          if (!data.channels)
            this.available = false;
        }
        this.shardId = data.shardId;
      }
      /**
       * The Shard this Guild belongs to.
       * @type {WebSocketShard}
       * @readonly
       */
      get shard() {
        return this.client.ws.shards.get(this.shardId);
      }
      _patch(data) {
        super._patch(data);
        this.id = data.id;
        if ("name" in data)
          this.name = data.name;
        if ("icon" in data)
          this.icon = data.icon;
        if ("unavailable" in data) {
          this.available = !data.unavailable;
        } else {
          this.available ??= true;
        }
        if ("discovery_splash" in data) {
          this.discoverySplash = data.discovery_splash;
        }
        if ("member_count" in data) {
          this.memberCount = data.member_count;
        }
        if ("large" in data) {
          this.large = Boolean(data.large);
        }
        if ("premium_progress_bar_enabled" in data) {
          this.premiumProgressBarEnabled = data.premium_progress_bar_enabled;
        }
        if ("application_id" in data) {
          this.applicationId = data.application_id;
        }
        if ("afk_timeout" in data) {
          this.afkTimeout = data.afk_timeout;
        }
        if ("afk_channel_id" in data) {
          this.afkChannelId = data.afk_channel_id;
        }
        if ("system_channel_id" in data) {
          this.systemChannelId = data.system_channel_id;
        }
        if ("premium_tier" in data) {
          this.premiumTier = data.premium_tier;
        }
        if ("widget_enabled" in data) {
          this.widgetEnabled = data.widget_enabled;
        } else {
          this.widgetEnabled ??= null;
        }
        if ("widget_channel_id" in data) {
          this.widgetChannelId = data.widget_channel_id;
        } else {
          this.widgetChannelId ??= null;
        }
        if ("explicit_content_filter" in data) {
          this.explicitContentFilter = data.explicit_content_filter;
        }
        if ("mfa_level" in data) {
          this.mfaLevel = data.mfa_level;
        }
        if ("joined_at" in data) {
          this.joinedTimestamp = Date.parse(data.joined_at);
        }
        if ("default_message_notifications" in data) {
          this.defaultMessageNotifications = data.default_message_notifications;
        }
        if ("system_channel_flags" in data) {
          this.systemChannelFlags = new SystemChannelFlagsBitField(data.system_channel_flags).freeze();
        }
        if ("max_members" in data) {
          this.maximumMembers = data.max_members;
        } else {
          this.maximumMembers ??= null;
        }
        if ("max_presences" in data) {
          this.maximumPresences = data.max_presences;
        } else {
          this.maximumPresences ??= null;
        }
        if ("max_video_channel_users" in data) {
          this.maxVideoChannelUsers = data.max_video_channel_users;
        } else {
          this.maxVideoChannelUsers ??= null;
        }
        if ("max_stage_video_channel_users" in data) {
          this.maxStageVideoChannelUsers = data.max_stage_video_channel_users;
        } else {
          this.maxStageVideoChannelUsers ??= null;
        }
        if ("approximate_member_count" in data) {
          this.approximateMemberCount = data.approximate_member_count;
        } else {
          this.approximateMemberCount ??= null;
        }
        if ("approximate_presence_count" in data) {
          this.approximatePresenceCount = data.approximate_presence_count;
        } else {
          this.approximatePresenceCount ??= null;
        }
        this.vanityURLUses ??= null;
        if ("rules_channel_id" in data) {
          this.rulesChannelId = data.rules_channel_id;
        }
        if ("public_updates_channel_id" in data) {
          this.publicUpdatesChannelId = data.public_updates_channel_id;
        }
        if ("preferred_locale" in data) {
          this.preferredLocale = data.preferred_locale;
        }
        if (data.channels) {
          this.channels.cache.clear();
          for (const rawChannel of data.channels) {
            this.client.channels._add(rawChannel, this);
          }
        }
        if (data.threads) {
          for (const rawThread of data.threads) {
            this.client.channels._add(rawThread, this);
          }
        }
        if (data.roles) {
          this.roles.cache.clear();
          for (const role of data.roles)
            this.roles._add(role);
        }
        if (data.members) {
          this.members.cache.clear();
          for (const guildUser of data.members)
            this.members._add(guildUser);
        }
        if ("owner_id" in data) {
          this.ownerId = data.owner_id;
        }
        if (data.presences) {
          for (const presence of data.presences) {
            this.presences._add(Object.assign(presence, { guild: this }));
          }
        }
        if (data.stage_instances) {
          this.stageInstances.cache.clear();
          for (const stageInstance of data.stage_instances) {
            this.stageInstances._add(stageInstance);
          }
        }
        if (data.guild_scheduled_events) {
          this.scheduledEvents.cache.clear();
          for (const scheduledEvent of data.guild_scheduled_events) {
            this.scheduledEvents._add(scheduledEvent);
          }
        }
        if (data.voice_states) {
          this.voiceStates.cache.clear();
          for (const voiceState of data.voice_states) {
            this.voiceStates._add(voiceState);
          }
        }
        if (!this.emojis) {
          this.emojis = new GuildEmojiManager(this);
          if (data.emojis)
            for (const emoji of data.emojis)
              this.emojis._add(emoji);
        } else if (data.emojis) {
          this.client.actions.GuildEmojisUpdate.handle({
            guild_id: this.id,
            emojis: data.emojis
          });
        }
        if (!this.stickers) {
          this.stickers = new GuildStickerManager(this);
          if (data.stickers)
            for (const sticker of data.stickers)
              this.stickers._add(sticker);
        } else if (data.stickers) {
          this.client.actions.GuildStickersUpdate.handle({
            guild_id: this.id,
            stickers: data.stickers
          });
        }
      }
      /**
       * The time the client user joined the guild
       * @type {Date}
       * @readonly
       */
      get joinedAt() {
        return new Date(this.joinedTimestamp);
      }
      /**
       * The URL to this guild's discovery splash image.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      discoverySplashURL(options = {}) {
        return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
      }
      /**
       * Fetches the owner of the guild.
       * If the member object isn't needed, use {@link Guild#ownerId} instead.
       * @param {BaseFetchOptions} [options] The options for fetching the member
       * @returns {Promise<GuildMember>}
       */
      async fetchOwner(options) {
        if (!this.ownerId) {
          throw new DiscordjsError2(ErrorCodes2.FetchOwnerId);
        }
        const member = await this.members.fetch({ ...options, user: this.ownerId });
        return member;
      }
      /**
       * AFK voice channel for this guild
       * @type {?VoiceChannel}
       * @readonly
       */
      get afkChannel() {
        return this.client.channels.resolve(this.afkChannelId);
      }
      /**
       * System channel for this guild
       * @type {?TextChannel}
       * @readonly
       */
      get systemChannel() {
        return this.client.channels.resolve(this.systemChannelId);
      }
      /**
       * Widget channel for this guild
       * @type {?(TextChannel|NewsChannel|VoiceChannel|StageChannel|ForumChannel)}
       * @readonly
       */
      get widgetChannel() {
        return this.client.channels.resolve(this.widgetChannelId);
      }
      /**
       * Rules channel for this guild
       * @type {?TextChannel}
       * @readonly
       */
      get rulesChannel() {
        return this.client.channels.resolve(this.rulesChannelId);
      }
      /**
       * Public updates channel for this guild
       * @type {?TextChannel}
       * @readonly
       */
      get publicUpdatesChannel() {
        return this.client.channels.resolve(this.publicUpdatesChannelId);
      }
      /**
       * The maximum bitrate available for this guild
       * @type {number}
       * @readonly
       */
      get maximumBitrate() {
        if (this.features.includes(GuildFeature.VIPRegions)) {
          return 384e3;
        }
        switch (this.premiumTier) {
          case GuildPremiumTier.Tier1:
            return 128e3;
          case GuildPremiumTier.Tier2:
            return 256e3;
          case GuildPremiumTier.Tier3:
            return 384e3;
          default:
            return 96e3;
        }
      }
      /**
       * Fetches a collection of integrations to this guild.
       * Resolves with a collection mapping integrations by their ids.
       * @returns {Promise<Collection<Snowflake|string, Integration>>}
       * @example
       * // Fetch integrations
       * guild.fetchIntegrations()
       *   .then(integrations => console.log(`Fetched ${integrations.size} integrations`))
       *   .catch(console.error);
       */
      async fetchIntegrations() {
        const data = await this.client.rest.get(Routes2.guildIntegrations(this.id));
        return data.reduce(
          (collection, integration) => collection.set(integration.id, new Integration(this.client, integration, this)),
          new Collection2()
        );
      }
      /**
       * Fetches a collection of templates from this guild.
       * Resolves with a collection mapping templates by their codes.
       * @returns {Promise<Collection<string, GuildTemplate>>}
       */
      async fetchTemplates() {
        const templates = await this.client.rest.get(Routes2.guildTemplates(this.id));
        return templates.reduce((col, data) => col.set(data.code, new GuildTemplate2(this.client, data)), new Collection2());
      }
      /**
       * Fetches the welcome screen for this guild.
       * @returns {Promise<WelcomeScreen>}
       */
      async fetchWelcomeScreen() {
        const data = await this.client.rest.get(Routes2.guildWelcomeScreen(this.id));
        return new WelcomeScreen(this, data);
      }
      /**
       * Creates a template for the guild.
       * @param {string} name The name for the template
       * @param {string} [description] The description for the template
       * @returns {Promise<GuildTemplate>}
       */
      async createTemplate(name, description) {
        const data = await this.client.rest.post(Routes2.guildTemplates(this.id), { body: { name, description } });
        return new GuildTemplate2(this.client, data);
      }
      /**
       * Obtains a guild preview for this guild from Discord.
       * @returns {Promise<GuildPreview>}
       */
      async fetchPreview() {
        const data = await this.client.rest.get(Routes2.guildPreview(this.id));
        return new GuildPreview2(this.client, data);
      }
      /**
       * An object containing information about a guild's vanity invite.
       * @typedef {Object} Vanity
       * @property {?string} code Vanity invite code
       * @property {number} uses How many times this invite has been used
       */
      /**
       * Fetches the vanity URL invite object to this guild.
       * Resolves with an object containing the vanity URL invite code and the use count
       * @returns {Promise<Vanity>}
       * @example
       * // Fetch invite data
       * guild.fetchVanityData()
       *   .then(res => {
       *     console.log(`Vanity URL: https://discord.gg/${res.code} with ${res.uses} uses`);
       *   })
       *   .catch(console.error);
       */
      async fetchVanityData() {
        const data = await this.client.rest.get(Routes2.guildVanityUrl(this.id));
        this.vanityURLCode = data.code;
        this.vanityURLUses = data.uses;
        return data;
      }
      /**
       * Fetches all webhooks for the guild.
       * @returns {Promise<Collection<Snowflake, Webhook>>}
       * @example
       * // Fetch webhooks
       * guild.fetchWebhooks()
       *   .then(webhooks => console.log(`Fetched ${webhooks.size} webhooks`))
       *   .catch(console.error);
       */
      async fetchWebhooks() {
        const apiHooks = await this.client.rest.get(Routes2.guildWebhooks(this.id));
        const hooks = new Collection2();
        for (const hook of apiHooks)
          hooks.set(hook.id, new Webhook2(this.client, hook));
        return hooks;
      }
      /**
       * Fetches the guild widget data, requires the widget to be enabled.
       * @returns {Promise<Widget>}
       * @example
       * // Fetches the guild widget data
       * guild.fetchWidget()
       *   .then(widget => console.log(`The widget shows ${widget.channels.size} channels`))
       *   .catch(console.error);
       */
      fetchWidget() {
        return this.client.fetchGuildWidget(this.id);
      }
      /**
       * Data for the Guild Widget Settings object
       * @typedef {Object} GuildWidgetSettings
       * @property {boolean} enabled Whether the widget is enabled
       * @property {?(TextChannel|NewsChannel|VoiceChannel|StageChannel|ForumChannel)} channel The widget invite channel
       */
      /**
       * The Guild Widget Settings object
       * @typedef {Object} GuildWidgetSettingsData
       * @property {boolean} enabled Whether the widget is enabled
       * @property {?(TextChannel|NewsChannel|VoiceChannel|StageChannel|ForumChannel|Snowflake)} channel
       * The widget invite channel
       */
      /**
       * Fetches the guild widget settings.
       * @returns {Promise<GuildWidgetSettings>}
       * @example
       * // Fetches the guild widget settings
       * guild.fetchWidgetSettings()
       *   .then(widget => console.log(`The widget is ${widget.enabled ? 'enabled' : 'disabled'}`))
       *   .catch(console.error);
       */
      async fetchWidgetSettings() {
        const data = await this.client.rest.get(Routes2.guildWidgetSettings(this.id));
        this.widgetEnabled = data.enabled;
        this.widgetChannelId = data.channel_id;
        return {
          enabled: data.enabled,
          channel: data.channel_id ? this.channels.cache.get(data.channel_id) : null
        };
      }
      /**
       * Options used to fetch audit logs.
       * @typedef {Object} GuildAuditLogsFetchOptions
       * @property {Snowflake|GuildAuditLogsEntry} [before] Consider only entries before this entry
       * @property {Snowflake|GuildAuditLogsEntry} [after] Consider only entries after this entry
       * @property {number} [limit] The number of entries to return
       * @property {UserResolvable} [user] Only return entries for actions made by this user
       * @property {?AuditLogEvent} [type] Only return entries for this action type
       */
      /**
       * Fetches audit logs for this guild.
       * @param {GuildAuditLogsFetchOptions} [options={}] Options for fetching audit logs
       * @returns {Promise<GuildAuditLogs>}
       * @example
       * // Output audit log entries
       * guild.fetchAuditLogs()
       *   .then(audit => console.log(audit.entries.first()))
       *   .catch(console.error);
       */
      async fetchAuditLogs({ before, after, limit, user, type } = {}) {
        const query = makeURLSearchParams2({
          before: before?.id ?? before,
          after: after?.id ?? after,
          limit,
          action_type: type
        });
        if (user) {
          const userId = this.client.users.resolveId(user);
          if (!userId)
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "user", "UserResolvable");
          query.set("user_id", userId);
        }
        const data = await this.client.rest.get(Routes2.guildAuditLog(this.id), { query });
        return new GuildAuditLogs(this, data);
      }
      /**
       * The data for editing a guild.
       * @typedef {Object} GuildEditOptions
       * @property {string} [name] The name of the guild
       * @property {?GuildVerificationLevel} [verificationLevel] The verification level of the guild
       * @property {?GuildDefaultMessageNotifications} [defaultMessageNotifications] The default message
       * notification level of the guild
       * @property {?GuildExplicitContentFilter} [explicitContentFilter] The level of the explicit content filter
       * @property {?VoiceChannelResolvable} [afkChannel] The AFK channel of the guild
       * @property {number} [afkTimeout] The AFK timeout of the guild
       * @property {?(BufferResolvable|Base64Resolvable)} [icon] The icon of the guild
       * @property {GuildMemberResolvable} [owner] The owner of the guild
       * @property {?(BufferResolvable|Base64Resolvable)} [splash] The invite splash image of the guild
       * @property {?(BufferResolvable|Base64Resolvable)} [discoverySplash] The discovery splash image of the guild
       * @property {?(BufferResolvable|Base64Resolvable)} [banner] The banner of the guild
       * @property {?TextChannelResolvable} [systemChannel] The system channel of the guild
       * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The system channel flags of the guild
       * @property {?TextChannelResolvable} [rulesChannel] The rules channel of the guild
       * @property {?TextChannelResolvable} [publicUpdatesChannel] The community updates channel of the guild
       * @property {?string} [preferredLocale] The preferred locale of the guild
       * @property {GuildFeature[]} [features] The features of the guild
       * @property {?string} [description] The discovery description of the guild
       * @property {boolean} [premiumProgressBarEnabled] Whether the guild's premium progress bar is enabled
       * @property {string} [reason] Reason for editing this guild
       */
      /**
       * Data that can be resolved to a Text Channel object. This can be:
       * * A TextChannel
       * * A Snowflake
       * @typedef {TextChannel|Snowflake} TextChannelResolvable
       */
      /**
       * Data that can be resolved to a Voice Channel object. This can be:
       * * A VoiceChannel
       * * A Snowflake
       * @typedef {VoiceChannel|Snowflake} VoiceChannelResolvable
       */
      /**
       * Updates the guild with new information - e.g. a new name.
       * @param {GuildEditOptions} options The options to provide
       * @returns {Promise<Guild>}
       * @example
       * // Set the guild name
       * guild.edit({
       *   name: 'Discord Guild',
       * })
       *   .then(updated => console.log(`New guild name ${updated}`))
       *   .catch(console.error);
       */
      async edit({
        verificationLevel,
        defaultMessageNotifications,
        explicitContentFilter,
        afkChannel,
        afkTimeout,
        icon,
        owner,
        splash,
        discoverySplash,
        banner,
        systemChannel,
        systemChannelFlags,
        rulesChannel,
        publicUpdatesChannel,
        preferredLocale,
        premiumProgressBarEnabled,
        ...options
      }) {
        const data = await this.client.rest.patch(Routes2.guild(this.id), {
          body: {
            ...options,
            verification_level: verificationLevel,
            default_message_notifications: defaultMessageNotifications,
            explicit_content_filter: explicitContentFilter,
            afk_channel_id: afkChannel && this.client.channels.resolveId(afkChannel),
            afk_timeout: afkTimeout,
            icon: icon && await DataResolver2.resolveImage(icon),
            owner_id: owner && this.client.users.resolveId(owner),
            splash: splash && await DataResolver2.resolveImage(splash),
            discovery_splash: discoverySplash && await DataResolver2.resolveImage(discoverySplash),
            banner: banner && await DataResolver2.resolveImage(banner),
            system_channel_id: systemChannel && this.client.channels.resolveId(systemChannel),
            system_channel_flags: systemChannelFlags === void 0 ? void 0 : SystemChannelFlagsBitField.resolve(systemChannelFlags),
            rules_channel_id: rulesChannel && this.client.channels.resolveId(rulesChannel),
            public_updates_channel_id: publicUpdatesChannel && this.client.channels.resolveId(publicUpdatesChannel),
            preferred_locale: preferredLocale,
            premium_progress_bar_enabled: premiumProgressBarEnabled
          },
          reason: options.reason
        });
        return this.client.actions.GuildUpdate.handle(data).updated;
      }
      /**
       * Welcome channel data
       * @typedef {Object} WelcomeChannelData
       * @property {string} description The description to show for this welcome channel
       * @property {TextChannel|NewsChannel|ForumChannel|Snowflake} channel The channel to link for this welcome channel
       * @property {EmojiIdentifierResolvable} [emoji] The emoji to display for this welcome channel
       */
      /**
       * Welcome screen edit data
       * @typedef {Object} WelcomeScreenEditOptions
       * @property {boolean} [enabled] Whether the welcome screen is enabled
       * @property {string} [description] The description for the welcome screen
       * @property {WelcomeChannelData[]} [welcomeChannels] The welcome channel data for the welcome screen
       */
      /**
       * Data that can be resolved to a GuildTextChannel object. This can be:
       * * A TextChannel
       * * A NewsChannel
       * * A Snowflake
       * @typedef {TextChannel|NewsChannel|Snowflake} GuildTextChannelResolvable
       */
      /**
       * Data that can be resolved to a GuildVoiceChannel object. This can be:
       * * A VoiceChannel
       * * A StageChannel
       * * A Snowflake
       * @typedef {VoiceChannel|StageChannel|Snowflake} GuildVoiceChannelResolvable
       */
      /**
       * Updates the guild's welcome screen
       * @param {WelcomeScreenEditOptions} options The options to provide
       * @returns {Promise<WelcomeScreen>}
       * @example
       * guild.editWelcomeScreen({
       *   description: 'Hello World',
       *   enabled: true,
       *   welcomeChannels: [
       *     {
       *       description: 'foobar',
       *       channel: '222197033908436994',
       *     }
       *   ],
       * })
       */
      async editWelcomeScreen(options) {
        const { enabled, description, welcomeChannels } = options;
        const welcome_channels = welcomeChannels?.map((welcomeChannelData) => {
          const emoji = this.emojis.resolve(welcomeChannelData.emoji);
          return {
            emoji_id: emoji?.id,
            emoji_name: emoji?.name ?? welcomeChannelData.emoji,
            channel_id: this.channels.resolveId(welcomeChannelData.channel),
            description: welcomeChannelData.description
          };
        });
        const patchData = await this.client.rest.patch(Routes2.guildWelcomeScreen(this.id), {
          body: {
            welcome_channels,
            description,
            enabled
          }
        });
        return new WelcomeScreen(this, patchData);
      }
      /**
       * Edits the level of the explicit content filter.
       * @param {?GuildExplicitContentFilter} explicitContentFilter The new level of the explicit content filter
       * @param {string} [reason] Reason for changing the level of the guild's explicit content filter
       * @returns {Promise<Guild>}
       */
      setExplicitContentFilter(explicitContentFilter, reason) {
        return this.edit({ explicitContentFilter, reason });
      }
      /**
       * Edits the setting of the default message notifications of the guild.
       * @param {?GuildDefaultMessageNotifications} defaultMessageNotifications
       * The new default message notification level of the guild
       * @param {string} [reason] Reason for changing the setting of the default message notifications
       * @returns {Promise<Guild>}
       */
      setDefaultMessageNotifications(defaultMessageNotifications, reason) {
        return this.edit({ defaultMessageNotifications, reason });
      }
      /**
       * Edits the flags of the default message notifications of the guild.
       * @param {SystemChannelFlagsResolvable} systemChannelFlags The new flags for the default message notifications
       * @param {string} [reason] Reason for changing the flags of the default message notifications
       * @returns {Promise<Guild>}
       */
      setSystemChannelFlags(systemChannelFlags, reason) {
        return this.edit({ systemChannelFlags, reason });
      }
      /**
       * Edits the name of the guild.
       * @param {string} name The new name of the guild
       * @param {string} [reason] Reason for changing the guild's name
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild name
       * guild.setName('Discord Guild')
       *  .then(updated => console.log(`Updated guild name to ${updated.name}`))
       *  .catch(console.error);
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Edits the verification level of the guild.
       * @param {?GuildVerificationLevel} verificationLevel The new verification level of the guild
       * @param {string} [reason] Reason for changing the guild's verification level
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild verification level
       * guild.setVerificationLevel(1)
       *  .then(updated => console.log(`Updated guild verification level to ${guild.verificationLevel}`))
       *  .catch(console.error);
       */
      setVerificationLevel(verificationLevel, reason) {
        return this.edit({ verificationLevel, reason });
      }
      /**
       * Edits the AFK channel of the guild.
       * @param {?VoiceChannelResolvable} afkChannel The new AFK channel
       * @param {string} [reason] Reason for changing the guild's AFK channel
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild AFK channel
       * guild.setAFKChannel(channel)
       *  .then(updated => console.log(`Updated guild AFK channel to ${guild.afkChannel.name}`))
       *  .catch(console.error);
       */
      setAFKChannel(afkChannel, reason) {
        return this.edit({ afkChannel, reason });
      }
      /**
       * Edits the system channel of the guild.
       * @param {?TextChannelResolvable} systemChannel The new system channel
       * @param {string} [reason] Reason for changing the guild's system channel
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild system channel
       * guild.setSystemChannel(channel)
       *  .then(updated => console.log(`Updated guild system channel to ${guild.systemChannel.name}`))
       *  .catch(console.error);
       */
      setSystemChannel(systemChannel, reason) {
        return this.edit({ systemChannel, reason });
      }
      /**
       * Edits the AFK timeout of the guild.
       * @param {number} afkTimeout The time in seconds that a user must be idle to be considered AFK
       * @param {string} [reason] Reason for changing the guild's AFK timeout
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild AFK channel
       * guild.setAFKTimeout(60)
       *  .then(updated => console.log(`Updated guild AFK timeout to ${guild.afkTimeout}`))
       *  .catch(console.error);
       */
      setAFKTimeout(afkTimeout, reason) {
        return this.edit({ afkTimeout, reason });
      }
      /**
       * Sets a new guild icon.
       * @param {?(Base64Resolvable|BufferResolvable)} icon The new icon of the guild
       * @param {string} [reason] Reason for changing the guild's icon
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild icon
       * guild.setIcon('./icon.png')
       *  .then(updated => console.log('Updated the guild icon'))
       *  .catch(console.error);
       */
      setIcon(icon, reason) {
        return this.edit({ icon, reason });
      }
      /**
       * Sets a new owner of the guild.
       * @param {GuildMemberResolvable} owner The new owner of the guild
       * @param {string} [reason] Reason for setting the new owner
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild owner
       * guild.setOwner(guild.members.cache.first())
       *  .then(guild => guild.fetchOwner())
       *  .then(owner => console.log(`Updated the guild owner to ${owner.displayName}`))
       *  .catch(console.error);
       */
      setOwner(owner, reason) {
        return this.edit({ owner, reason });
      }
      /**
       * Sets a new guild invite splash image.
       * @param {?(Base64Resolvable|BufferResolvable)} splash The new invite splash image of the guild
       * @param {string} [reason] Reason for changing the guild's invite splash image
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild splash
       * guild.setSplash('./splash.png')
       *  .then(updated => console.log('Updated the guild splash'))
       *  .catch(console.error);
       */
      setSplash(splash, reason) {
        return this.edit({ splash, reason });
      }
      /**
       * Sets a new guild discovery splash image.
       * @param {?(Base64Resolvable|BufferResolvable)} discoverySplash The new discovery splash image of the guild
       * @param {string} [reason] Reason for changing the guild's discovery splash image
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild discovery splash
       * guild.setDiscoverySplash('./discoverysplash.png')
       *   .then(updated => console.log('Updated the guild discovery splash'))
       *   .catch(console.error);
       */
      setDiscoverySplash(discoverySplash, reason) {
        return this.edit({ discoverySplash, reason });
      }
      /**
       * Sets a new guild banner.
       * @param {?(Base64Resolvable|BufferResolvable)} banner The new banner of the guild
       * @param {string} [reason] Reason for changing the guild's banner
       * @returns {Promise<Guild>}
       * @example
       * guild.setBanner('./banner.png')
       *  .then(updated => console.log('Updated the guild banner'))
       *  .catch(console.error);
       */
      setBanner(banner, reason) {
        return this.edit({ banner, reason });
      }
      /**
       * Edits the rules channel of the guild.
       * @param {?TextChannelResolvable} rulesChannel The new rules channel
       * @param {string} [reason] Reason for changing the guild's rules channel
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild rules channel
       * guild.setRulesChannel(channel)
       *  .then(updated => console.log(`Updated guild rules channel to ${guild.rulesChannel.name}`))
       *  .catch(console.error);
       */
      setRulesChannel(rulesChannel, reason) {
        return this.edit({ rulesChannel, reason });
      }
      /**
       * Edits the community updates channel of the guild.
       * @param {?TextChannelResolvable} publicUpdatesChannel The new community updates channel
       * @param {string} [reason] Reason for changing the guild's community updates channel
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild community updates channel
       * guild.setPublicUpdatesChannel(channel)
       *  .then(updated => console.log(`Updated guild community updates channel to ${guild.publicUpdatesChannel.name}`))
       *  .catch(console.error);
       */
      setPublicUpdatesChannel(publicUpdatesChannel, reason) {
        return this.edit({ publicUpdatesChannel, reason });
      }
      /**
       * Edits the preferred locale of the guild.
       * @param {?Locale} preferredLocale The new preferred locale of the guild
       * @param {string} [reason] Reason for changing the guild's preferred locale
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild preferred locale
       * guild.setPreferredLocale('en-US')
       *  .then(updated => console.log(`Updated guild preferred locale to ${guild.preferredLocale}`))
       *  .catch(console.error);
       */
      setPreferredLocale(preferredLocale, reason) {
        return this.edit({ preferredLocale, reason });
      }
      /**
       * Edits the enabled state of the guild's premium progress bar
       * @param {boolean} [enabled=true] The new enabled state of the guild's premium progress bar
       * @param {string} [reason] Reason for changing the state of the guild's premium progress bar
       * @returns {Promise<Guild>}
       */
      setPremiumProgressBarEnabled(enabled = true, reason) {
        return this.edit({ premiumProgressBarEnabled: enabled, reason });
      }
      /**
       * Edits the guild's widget settings.
       * @param {GuildWidgetSettingsData} settings The widget settings for the guild
       * @param {string} [reason] Reason for changing the guild's widget settings
       * @returns {Promise<Guild>}
       */
      async setWidgetSettings(settings, reason) {
        await this.client.rest.patch(Routes2.guildWidgetSettings(this.id), {
          body: {
            enabled: settings.enabled,
            channel_id: this.channels.resolveId(settings.channel)
          },
          reason
        });
        return this;
      }
      /**
       * Sets the guild's MFA level
       * <info>An elevated MFA level requires guild moderators to have 2FA enabled.</info>
       * @param {GuildMFALevel} level The MFA level
       * @param {string} [reason] Reason for changing the guild's MFA level
       * @returns {Promise<Guild>}
       * @example
       * // Set the MFA level of the guild to Elevated
       * guild.setMFALevel(GuildMFALevel.Elevated)
       *   .then(guild => console.log("Set guild's MFA level to Elevated"))
       *   .catch(console.error);
       */
      async setMFALevel(level, reason) {
        await this.client.rest.post(Routes2.guildMFA(this.id), {
          body: {
            level
          },
          reason
        });
        return this;
      }
      /**
       * Leaves the guild.
       * @returns {Promise<Guild>}
       * @example
       * // Leave a guild
       * guild.leave()
       *   .then(guild => console.log(`Left the guild: ${guild.name}`))
       *   .catch(console.error);
       */
      async leave() {
        if (this.ownerId === this.client.user.id)
          throw new DiscordjsError2(ErrorCodes2.GuildOwned);
        await this.client.rest.delete(Routes2.userGuild(this.id));
        return this;
      }
      /**
       * Deletes the guild.
       * @returns {Promise<Guild>}
       * @example
       * // Delete a guild
       * guild.delete()
       *   .then(g => console.log(`Deleted the guild ${g}`))
       *   .catch(console.error);
       */
      async delete() {
        await this.client.rest.delete(Routes2.guild(this.id));
        return this;
      }
      /**
       * Sets whether this guild's invites are disabled.
       * @param {boolean} [disabled=true] Whether the invites are disabled
       * @returns {Promise<Guild>}
       */
      async disableInvites(disabled = true) {
        const features = this.features.filter((feature) => feature !== GuildFeature.InvitesDisabled);
        if (disabled)
          features.push(GuildFeature.InvitesDisabled);
        return this.edit({ features });
      }
      /**
       * Whether this guild equals another guild. It compares all properties, so for most operations
       * it is advisable to just compare `guild.id === guild2.id` as it is much faster and is often
       * what most users need.
       * @param {Guild} guild The guild to compare with
       * @returns {boolean}
       */
      equals(guild) {
        return guild && guild instanceof this.constructor && this.id === guild.id && this.available === guild.available && this.splash === guild.splash && this.discoverySplash === guild.discoverySplash && this.name === guild.name && this.memberCount === guild.memberCount && this.large === guild.large && this.icon === guild.icon && this.ownerId === guild.ownerId && this.verificationLevel === guild.verificationLevel && (this.features === guild.features || this.features.length === guild.features.length && this.features.every((feat, i) => feat === guild.features[i]));
      }
      toJSON() {
        const json2 = super.toJSON({
          available: false,
          createdTimestamp: true,
          nameAcronym: true,
          presences: false,
          voiceStates: false
        });
        json2.iconURL = this.iconURL();
        json2.splashURL = this.splashURL();
        json2.discoverySplashURL = this.discoverySplashURL();
        json2.bannerURL = this.bannerURL();
        return json2;
      }
      /**
       * The voice state adapter for this guild that can be used with @discordjs/voice to play audio in voice
       * and stage channels.
       * @type {Function}
       * @readonly
       */
      get voiceAdapterCreator() {
        return (methods) => {
          this.client.voice.adapters.set(this.id, methods);
          return {
            sendPayload: (data) => {
              if (this.shard.status !== Status2.Ready)
                return false;
              this.shard.send(data);
              return true;
            },
            destroy: () => {
              this.client.voice.adapters.delete(this.id);
            }
          };
        };
      }
      /**
       * Creates a collection of this guild's roles, sorted by their position and ids.
       * @returns {Collection<Snowflake, Role>}
       * @private
       */
      _sortedRoles() {
        return discordSort(this.roles.cache);
      }
      /**
       * Creates a collection of this guild's or a specific category's channels, sorted by their position and ids.
       * @param {GuildChannel} [channel] Category to get the channels of
       * @returns {Collection<Snowflake, GuildChannel>}
       * @private
       */
      _sortedChannels(channel) {
        const category = channel.type === ChannelType.GuildCategory;
        const channelTypes = [ChannelType.GuildText, ChannelType.GuildAnnouncement];
        return discordSort(
          this.channels.cache.filter(
            (c) => (channelTypes.includes(channel.type) ? channelTypes.includes(c.type) : c.type === channel.type) && (category || c.parent === channel.parent)
          )
        );
      }
    };
    exports2.Guild = Guild;
  }
});

// node_modules/discord.js/src/structures/OAuth2Guild.js
var require_OAuth2Guild = __commonJS({
  "node_modules/discord.js/src/structures/OAuth2Guild.js"(exports2, module2) {
    "use strict";
    var BaseGuild = require_BaseGuild();
    var PermissionsBitField2 = require_PermissionsBitField();
    var OAuth2Guild = class extends BaseGuild {
      constructor(client, data) {
        super(client, data);
        this.owner = data.owner;
        this.permissions = new PermissionsBitField2(BigInt(data.permissions)).freeze();
      }
    };
    module2.exports = OAuth2Guild;
  }
});

// node_modules/discord.js/src/managers/GuildManager.js
var require_GuildManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildManager.js"(exports2, module2) {
    "use strict";
    var process2 = require("node:process");
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require("node:timers");
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { Guild } = require_Guild();
    var GuildChannel = require_GuildChannel();
    var GuildEmoji = require_GuildEmoji();
    var { GuildMember } = require_GuildMember();
    var Invite2 = require_Invite();
    var OAuth2Guild = require_OAuth2Guild();
    var { Role } = require_Role();
    var DataResolver2 = require_DataResolver();
    var Events3 = require_Events();
    var PermissionsBitField2 = require_PermissionsBitField();
    var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
    var { resolveColor } = require_Util();
    var cacheWarningEmitted = false;
    var GuildManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, Guild, iterable);
        if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
          cacheWarningEmitted = true;
          process2.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, Guild>}
       * @name GuildManager#cache
       */
      /**
       * Data that resolves to give a Guild object. This can be:
       * * A Guild object
       * * A GuildChannel object
       * * A GuildEmoji object
       * * A Role object
       * * A Snowflake
       * * An Invite object
       * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable
       */
      /**
       * Partial data for a Role.
       * @typedef {Object} PartialRoleData
       * @property {Snowflake|number} [id] The role's id, used to set channel overrides.
       * This is a placeholder and will be replaced by the API after consumption
       * @property {string} [name] The name of the role
       * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number
       * @property {boolean} [hoist] Whether the role should be hoisted
       * @property {number} [position] The position of the role
       * @property {PermissionResolvable} [permissions] The permissions of the role
       * @property {boolean} [mentionable] Whether the role should be mentionable
       */
      /**
       * Partial overwrite data.
       * @typedef {Object} PartialOverwriteData
       * @property {Snowflake|number} id The id of the {@link Role} or {@link User} this overwrite belongs to
       * @property {OverwriteType} [type] The type of this overwrite
       * @property {PermissionResolvable} [allow] The permissions to allow
       * @property {PermissionResolvable} [deny] The permissions to deny
       */
      /**
       * Partial data for a Channel.
       * @typedef {Object} PartialChannelData
       * @property {Snowflake|number} [id] The channel's id, used to set its parent.
       * This is a placeholder and will be replaced by the API after consumption
       * @property {Snowflake|number} [parentId] The parent id for this channel
       * @property {ChannelType.GuildText|ChannelType.GuildVoice|ChannelType.GuildCategory} [type] The type of the channel
       * @property {string} name The name of the channel
       * @property {?string} [topic] The topic of the text channel
       * @property {boolean} [nsfw] Whether the channel is NSFW
       * @property {number} [bitrate] The bitrate of the voice channel
       * @property {number} [userLimit] The user limit of the channel
       * @property {?string} [rtcRegion] The RTC region of the channel
       * @property {VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel
       * @property {PartialOverwriteData[]} [permissionOverwrites]
       * Overwrites of the channel
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) of the channel in seconds
       */
      /**
       * Resolves a GuildResolvable to a Guild object.
       * @method resolve
       * @memberof GuildManager
       * @instance
       * @param {GuildResolvable} guild The guild resolvable to identify
       * @returns {?Guild}
       */
      resolve(guild) {
        if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite2 && guild.guild) {
          return super.resolve(guild.guild);
        }
        return super.resolve(guild);
      }
      /**
       * Resolves a {@link GuildResolvable} to a {@link Guild} id string.
       * @method resolveId
       * @memberof GuildManager
       * @instance
       * @param {GuildResolvable} guild The guild resolvable to identify
       * @returns {?Snowflake}
       */
      resolveId(guild) {
        if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite2 && guild.guild) {
          return super.resolveId(guild.guild.id);
        }
        return super.resolveId(guild);
      }
      /**
       * Options used to create a guild.
       * @typedef {Object} GuildCreateOptions
       * @property {string} name The name of the guild
       * @property {?(BufferResolvable|Base64Resolvable)} [icon=null] The icon for the guild
       * @property {GuildVerificationLevel} [verificationLevel] The verification level for the guild
       * @property {GuildDefaultMessageNotifications} [defaultMessageNotifications] The default message notifications
       * for the guild
       * @property {GuildExplicitContentFilter} [explicitContentFilter] The explicit content filter level for the guild
       * @property {PartialRoleData[]} [roles=[]] The roles for this guild,
       * @property {PartialChannelData[]} [channels=[]] The channels for this guild
       * @property {Snowflake|number} [afkChannelId] The AFK channel's id
       * @property {number} [afkTimeout] The AFK timeout in seconds
       * the first element of this array is used to change properties of the guild's everyone role.
       * @property {Snowflake|number} [systemChannelId] The system channel's id
       * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The flags of the system channel
       */
      /* eslint-enable max-len */
      /**
       * Creates a guild.
       * <warn>This is only available to bots in fewer than 10 guilds.</warn>
       * @param {GuildCreateOptions} options Options for creating the guild
       * @returns {Promise<Guild>} The guild that was created
       */
      async create({
        name,
        icon = null,
        verificationLevel,
        defaultMessageNotifications,
        explicitContentFilter,
        roles = [],
        channels = [],
        afkChannelId,
        afkTimeout,
        systemChannelId,
        systemChannelFlags
      }) {
        const data = await this.client.rest.post(Routes2.guilds(), {
          body: {
            name,
            icon: icon && await DataResolver2.resolveImage(icon),
            verification_level: verificationLevel,
            default_message_notifications: defaultMessageNotifications,
            explicit_content_filter: explicitContentFilter,
            roles: roles.map(({ color, permissions, ...options }) => ({
              ...options,
              color: color && resolveColor(color),
              permissions: permissions === void 0 ? void 0 : PermissionsBitField2.resolve(permissions).toString()
            })),
            channels: channels.map(
              ({
                parentId,
                userLimit,
                rtcRegion,
                videoQualityMode,
                permissionOverwrites,
                rateLimitPerUser,
                ...options
              }) => ({
                ...options,
                parent_id: parentId,
                user_limit: userLimit,
                rtc_region: rtcRegion,
                video_quality_mode: videoQualityMode,
                permission_overwrites: permissionOverwrites?.map(({ allow, deny, ...permissionOverwriteOptions }) => ({
                  ...permissionOverwriteOptions,
                  allow: allow === void 0 ? void 0 : PermissionsBitField2.resolve(allow).toString(),
                  deny: deny === void 0 ? void 0 : PermissionsBitField2.resolve(deny).toString()
                })),
                rate_limit_per_user: rateLimitPerUser
              })
            ),
            afk_channel_id: afkChannelId,
            afk_timeout: afkTimeout,
            system_channel_id: systemChannelId,
            system_channel_flags: systemChannelFlags === void 0 ? void 0 : SystemChannelFlagsBitField.resolve(systemChannelFlags)
          }
        });
        return this.client.guilds.cache.get(data.id) ?? new Promise((resolve) => {
          const handleGuild = (guild) => {
            if (guild.id === data.id) {
              clearTimeout2(timeout);
              this.client.decrementMaxListeners();
              resolve(guild);
            }
          };
          this.client.incrementMaxListeners();
          this.client.once(Events3.GuildCreate, handleGuild);
          const timeout = setTimeout2(() => {
            this.client.removeListener(Events3.GuildCreate, handleGuild);
            this.client.decrementMaxListeners();
            resolve(this.client.guilds._add(data));
          }, 1e4).unref();
        });
      }
      /**
       * Options used to fetch a single guild.
       * @typedef {BaseFetchOptions} FetchGuildOptions
       * @property {GuildResolvable} guild The guild to fetch
       * @property {boolean} [withCounts=true] Whether the approximate member and presence counts should be returned
       */
      /**
       * Options used to fetch multiple guilds.
       * @typedef {Object} FetchGuildsOptions
       * @property {Snowflake} [before] Get guilds before this guild id
       * @property {Snowflake} [after] Get guilds after this guild id
       * @property {number} [limit] Maximum number of guilds to request (1-200)
       */
      /**
       * Obtains one or multiple guilds from Discord, or the guild cache if it's already available.
       * @param {GuildResolvable|FetchGuildOptions|FetchGuildsOptions} [options] The guild's id or options
       * @returns {Promise<Guild|Collection<Snowflake, OAuth2Guild>>}
       */
      async fetch(options = {}) {
        const id = this.resolveId(options) ?? this.resolveId(options.guild);
        if (id) {
          if (!options.force) {
            const existing = this.cache.get(id);
            if (existing)
              return existing;
          }
          const data2 = await this.client.rest.get(Routes2.guild(id), {
            query: makeURLSearchParams2({ with_counts: options.withCounts ?? true })
          });
          return this._add(data2, options.cache);
        }
        const data = await this.client.rest.get(Routes2.userGuilds(), { query: makeURLSearchParams2(options) });
        return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection2());
      }
    };
    module2.exports = GuildManager2;
  }
});

// node_modules/discord.js/src/managers/UserManager.js
var require_UserManager = __commonJS({
  "node_modules/discord.js/src/managers/UserManager.js"(exports2, module2) {
    "use strict";
    var { ChannelType, Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { GuildMember } = require_GuildMember();
    var { Message } = require_Message();
    var ThreadMember = require_ThreadMember();
    var User = require_User();
    var UserManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, User, iterable);
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, User>}
       * @name UserManager#cache
       */
      /**
       * Data that resolves to give a User object. This can be:
       * * A User object
       * * A Snowflake
       * * A Message object (resolves to the message author)
       * * A GuildMember object
       * * A ThreadMember object
       * @typedef {User|Snowflake|Message|GuildMember|ThreadMember} UserResolvable
       */
      /**
       * The DM between the client's user and a user
       * @param {Snowflake} userId The user id
       * @returns {?DMChannel}
       * @private
       */
      dmChannel(userId) {
        return this.client.channels.cache.find((c) => c.type === ChannelType.DM && c.recipientId === userId) ?? null;
      }
      /**
       * Creates a {@link DMChannel} between the client and a user.
       * @param {UserResolvable} user The UserResolvable to identify
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<DMChannel>}
       */
      async createDM(user, { cache = true, force = false } = {}) {
        const id = this.resolveId(user);
        if (!force) {
          const dmChannel = this.dmChannel(id);
          if (dmChannel && !dmChannel.partial)
            return dmChannel;
        }
        const data = await this.client.rest.post(Routes2.userChannels(), { body: { recipient_id: id } });
        return this.client.channels._add(data, null, { cache });
      }
      /**
       * Deletes a {@link DMChannel} (if one exists) between the client and a user. Resolves with the channel if successful.
       * @param {UserResolvable} user The UserResolvable to identify
       * @returns {Promise<DMChannel>}
       */
      async deleteDM(user) {
        const id = this.resolveId(user);
        const dmChannel = this.dmChannel(id);
        if (!dmChannel)
          throw new DiscordjsError2(ErrorCodes2.UserNoDMChannel);
        await this.client.rest.delete(Routes2.channel(dmChannel.id));
        this.client.channels._remove(dmChannel.id);
        return dmChannel;
      }
      /**
       * Obtains a user from Discord, or the user cache if it's already available.
       * @param {UserResolvable} user The user to fetch
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<User>}
       */
      async fetch(user, { cache = true, force = false } = {}) {
        const id = this.resolveId(user);
        if (!force) {
          const existing = this.cache.get(id);
          if (existing && !existing.partial)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.user(id));
        return this._add(data, cache);
      }
      /**
       * Fetches a user's flags.
       * @param {UserResolvable} user The UserResolvable to identify
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<UserFlagsBitField>}
       */
      async fetchFlags(user, options) {
        return (await this.fetch(user, options)).flags;
      }
      /**
       * Sends a message to a user.
       * @param {UserResolvable} user The UserResolvable to identify
       * @param {string|MessagePayload|MessageCreateOptions} options The options to provide
       * @returns {Promise<Message>}
       */
      async send(user, options) {
        return (await this.createDM(user)).send(options);
      }
      /**
       * Resolves a {@link UserResolvable} to a {@link User} object.
       * @param {UserResolvable} user The UserResolvable to identify
       * @returns {?User}
       */
      resolve(user) {
        if (user instanceof GuildMember || user instanceof ThreadMember)
          return user.user;
        if (user instanceof Message)
          return user.author;
        return super.resolve(user);
      }
      /**
       * Resolves a {@link UserResolvable} to a {@link User} id.
       * @param {UserResolvable} user The UserResolvable to identify
       * @returns {?Snowflake}
       */
      resolveId(user) {
        if (user instanceof ThreadMember)
          return user.id;
        if (user instanceof GuildMember)
          return user.user.id;
        if (user instanceof Message)
          return user.author.id;
        return super.resolveId(user);
      }
    };
    module2.exports = UserManager2;
  }
});

// node_modules/discord.js/src/sharding/ShardClientUtil.js
var require_ShardClientUtil = __commonJS({
  "node_modules/discord.js/src/sharding/ShardClientUtil.js"(exports2, module2) {
    "use strict";
    var process2 = require("node:process");
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Events3 = require_Events();
    var { makeError, makePlainError } = require_Util();
    var ShardClientUtil2 = class {
      constructor(client, mode) {
        this.client = client;
        this.mode = mode;
        this.parentPort = null;
        switch (mode) {
          case "process":
            process2.on("message", this._handleMessage.bind(this));
            client.on("ready", () => {
              process2.send({ _ready: true });
            });
            client.on("disconnect", () => {
              process2.send({ _disconnect: true });
            });
            client.on("reconnecting", () => {
              process2.send({ _reconnecting: true });
            });
            break;
          case "worker":
            this.parentPort = require("node:worker_threads").parentPort;
            this.parentPort.on("message", this._handleMessage.bind(this));
            client.on("ready", () => {
              this.parentPort.postMessage({ _ready: true });
            });
            client.on("disconnect", () => {
              this.parentPort.postMessage({ _disconnect: true });
            });
            client.on("reconnecting", () => {
              this.parentPort.postMessage({ _reconnecting: true });
            });
            break;
        }
      }
      /**
       * Array of shard ids of this client
       * @type {number[]}
       * @readonly
       */
      get ids() {
        return this.client.options.shards;
      }
      /**
       * Total number of shards
       * @type {number}
       * @readonly
       */
      get count() {
        return this.client.options.shardCount;
      }
      /**
       * Sends a message to the master process.
       * @param {*} message Message to send
       * @returns {Promise<void>}
       * @emits Shard#message
       */
      send(message) {
        return new Promise((resolve, reject) => {
          switch (this.mode) {
            case "process":
              process2.send(message, (err) => {
                if (err)
                  reject(err);
                else
                  resolve();
              });
              break;
            case "worker":
              this.parentPort.postMessage(message);
              resolve();
              break;
          }
        });
      }
      /**
       * Fetches a client property value of each shard, or a given shard.
       * @param {string} prop Name of the client property to get, using periods for nesting
       * @param {number} [shard] Shard to fetch property from, all if undefined
       * @returns {Promise<*|Array<*>>}
       * @example
       * client.shard.fetchClientValues('guilds.cache.size')
       *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))
       *   .catch(console.error);
       * @see {@link ShardingManager#fetchClientValues}
       */
      fetchClientValues(prop, shard) {
        return new Promise((resolve, reject) => {
          const parent = this.parentPort ?? process2;
          const listener = (message) => {
            if (message?._sFetchProp !== prop || message._sFetchPropShard !== shard)
              return;
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            if (!message._error)
              resolve(message._result);
            else
              reject(makeError(message._error));
          };
          this.incrementMaxListeners(parent);
          parent.on("message", listener);
          this.send({ _sFetchProp: prop, _sFetchPropShard: shard }).catch((err) => {
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            reject(err);
          });
        });
      }
      /**
       * Evaluates a script or function on all shards, or a given shard, in the context of the {@link Client}s.
       * @param {Function} script JavaScript to run on each shard
       * @param {BroadcastEvalOptions} [options={}] The options for the broadcast
       * @returns {Promise<*|Array<*>>} Results of the script execution
       * @example
       * client.shard.broadcastEval(client => client.guilds.cache.size)
       *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))
       *   .catch(console.error);
       * @see {@link ShardingManager#broadcastEval}
       */
      broadcastEval(script2, options = {}) {
        return new Promise((resolve, reject) => {
          const parent = this.parentPort ?? process2;
          if (typeof script2 !== "function") {
            reject(new DiscordjsTypeError2(ErrorCodes2.ShardingInvalidEvalBroadcast));
            return;
          }
          script2 = `(${script2})(this, ${JSON.stringify(options.context)})`;
          const listener = (message) => {
            if (message?._sEval !== script2 || message._sEvalShard !== options.shard)
              return;
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            if (!message._error)
              resolve(message._result);
            else
              reject(makeError(message._error));
          };
          this.incrementMaxListeners(parent);
          parent.on("message", listener);
          this.send({ _sEval: script2, _sEvalShard: options.shard }).catch((err) => {
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            reject(err);
          });
        });
      }
      /**
       * Requests a respawn of all shards.
       * @param {MultipleShardRespawnOptions} [options] Options for respawning shards
       * @returns {Promise<void>} Resolves upon the message being sent
       * @see {@link ShardingManager#respawnAll}
       */
      respawnAll({ shardDelay = 5e3, respawnDelay = 500, timeout = 3e4 } = {}) {
        return this.send({ _sRespawnAll: { shardDelay, respawnDelay, timeout } });
      }
      /**
       * Handles an IPC message.
       * @param {*} message Message received
       * @private
       */
      async _handleMessage(message) {
        if (!message)
          return;
        if (message._fetchProp) {
          try {
            const props = message._fetchProp.split(".");
            let value = this.client;
            for (const prop of props)
              value = value[prop];
            this._respond("fetchProp", { _fetchProp: message._fetchProp, _result: value });
          } catch (err) {
            this._respond("fetchProp", { _fetchProp: message._fetchProp, _error: makePlainError(err) });
          }
        } else if (message._eval) {
          try {
            this._respond("eval", { _eval: message._eval, _result: await this.client._eval(message._eval) });
          } catch (err) {
            this._respond("eval", { _eval: message._eval, _error: makePlainError(err) });
          }
        }
      }
      /**
       * Sends a message to the master process, emitting an error from the client upon failure.
       * @param {string} type Type of response to send
       * @param {*} message Message to send
       * @private
       */
      _respond(type, message) {
        this.send(message).catch((err) => {
          const error = new Error(`Error when sending ${type} response to master process: ${err.message}`);
          error.stack = err.stack;
          this.client.emit(Events3.Error, error);
        });
      }
      /**
       * Creates/gets the singleton of this class.
       * @param {Client} client The client to use
       * @param {ShardingManagerMode} mode Mode the shard was spawned with
       * @returns {ShardClientUtil}
       */
      static singleton(client, mode) {
        if (!this._singleton) {
          this._singleton = new this(client, mode);
        } else {
          client.emit(
            Events3.Warn,
            "Multiple clients created in child process/worker; only the first will handle sharding helpers."
          );
        }
        return this._singleton;
      }
      /**
       * Get the shard id for a given guild id.
       * @param {Snowflake} guildId Snowflake guild id to get shard id for
       * @param {number} shardCount Number of shards
       * @returns {number}
       */
      static shardIdForGuildId(guildId, shardCount) {
        const shard = Number(BigInt(guildId) >> 22n) % shardCount;
        if (shard < 0)
          throw new DiscordjsError2(ErrorCodes2.ShardingShardMiscalculation, shard, guildId, shardCount);
        return shard;
      }
      /**
       * Increments max listeners by one for a given emitter, if they are not zero.
       * @param {EventEmitter|process} emitter The emitter that emits the events.
       * @private
       */
      incrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners + 1);
        }
      }
      /**
       * Decrements max listeners by one for a given emitter, if they are not zero.
       * @param {EventEmitter|process} emitter The emitter that emits the events.
       * @private
       */
      decrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners - 1);
        }
      }
    };
    module2.exports = ShardClientUtil2;
  }
});

// node_modules/discord.js/src/structures/ClientPresence.js
var require_ClientPresence = __commonJS({
  "node_modules/discord.js/src/structures/ClientPresence.js"(exports2, module2) {
    "use strict";
    var { GatewayOpcodes } = require_v106();
    var { Presence } = require_Presence();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ClientPresence2 = class extends Presence {
      constructor(client, data = {}) {
        super(client, Object.assign(data, { status: data.status ?? "online", user: { id: null } }));
      }
      /**
       * Sets the client's presence
       * @param {PresenceData} presence The data to set the presence to
       * @returns {ClientPresence}
       */
      set(presence) {
        const packet = this._parse(presence);
        this._patch(packet);
        if (presence.shardId === void 0) {
          this.client.ws.broadcast({ op: GatewayOpcodes.PresenceUpdate, d: packet });
        } else if (Array.isArray(presence.shardId)) {
          for (const shardId of presence.shardId) {
            this.client.ws.shards.get(shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
          }
        } else {
          this.client.ws.shards.get(presence.shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
        }
        return this;
      }
      /**
       * Parses presence data into a packet ready to be sent to Discord
       * @param {PresenceData} presence The data to parse
       * @returns {APIPresence}
       * @private
       */
      _parse({ status, since, afk, activities }) {
        const data = {
          activities: [],
          afk: typeof afk === "boolean" ? afk : false,
          since: typeof since === "number" && !Number.isNaN(since) ? since : null,
          status: status ?? this.status
        };
        if (activities?.length) {
          for (const [i, activity] of activities.entries()) {
            if (typeof activity.name !== "string") {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, `activities[${i}].name`, "string");
            }
            activity.type ??= 0;
            data.activities.push({
              type: activity.type,
              name: activity.name,
              url: activity.url
            });
          }
        } else if (!activities && (status || afk || since) && this.activities.length) {
          data.activities.push(
            ...this.activities.map((a) => ({
              name: a.name,
              type: a.type,
              url: a.url ?? void 0
            }))
          );
        }
        return data;
      }
    };
    module2.exports = ClientPresence2;
  }
});

// node_modules/discord.js/src/structures/StickerPack.js
var require_StickerPack = __commonJS({
  "node_modules/discord.js/src/structures/StickerPack.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var { Sticker: Sticker2 } = require_Sticker();
    var StickerPack2 = class extends Base {
      constructor(client, pack) {
        super(client);
        this.id = pack.id;
        this.stickers = new Collection2(pack.stickers.map((s) => [s.id, new Sticker2(client, s)]));
        this.name = pack.name;
        this.skuId = pack.sku_id;
        this.coverStickerId = pack.cover_sticker_id ?? null;
        this.description = pack.description;
        this.bannerId = pack.banner_asset_id ?? null;
      }
      /**
       * The timestamp the sticker was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the sticker was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The sticker which is shown as the pack's icon
       * @type {?Sticker}
       * @readonly
       */
      get coverSticker() {
        return this.coverStickerId && this.stickers.get(this.coverStickerId);
      }
      /**
       * The URL to this sticker pack's banner.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      bannerURL(options = {}) {
        return this.bannerId && this.client.rest.cdn.stickerPackBanner(this.bannerId, options);
      }
    };
    module2.exports = StickerPack2;
  }
});

// node_modules/discord.js/src/structures/VoiceRegion.js
var require_VoiceRegion = __commonJS({
  "node_modules/discord.js/src/structures/VoiceRegion.js"(exports2, module2) {
    "use strict";
    var { flatten } = require_Util();
    var VoiceRegion2 = class {
      constructor(data) {
        this.id = data.id;
        this.name = data.name;
        this.deprecated = data.deprecated;
        this.optimal = data.optimal;
        this.custom = data.custom;
      }
      toJSON() {
        return flatten(this);
      }
    };
    module2.exports = VoiceRegion2;
  }
});

// node_modules/discord.js/src/structures/WidgetMember.js
var require_WidgetMember = __commonJS({
  "node_modules/discord.js/src/structures/WidgetMember.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var WidgetMember = class extends Base {
      /**
       * Activity sent in a {@link WidgetMember}.
       * @typedef {Object} WidgetActivity
       * @property {string} name The name of the activity
       */
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.username = data.username;
        this.discriminator = data.discriminator;
        this.avatar = data.avatar;
        this.status = data.status;
        this.deaf = data.deaf ?? null;
        this.mute = data.mute ?? null;
        this.selfDeaf = data.self_deaf ?? null;
        this.selfMute = data.self_mute ?? null;
        this.suppress = data.suppress ?? null;
        this.channelId = data.channel_id ?? null;
        this.avatarURL = data.avatar_url;
        this.activity = data.activity ?? null;
      }
    };
    module2.exports = WidgetMember;
  }
});

// node_modules/discord.js/src/structures/Widget.js
var require_Widget = __commonJS({
  "node_modules/discord.js/src/structures/Widget.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { Routes: Routes2 } = require_v106();
    var Base = require_Base();
    var WidgetMember = require_WidgetMember();
    var Widget2 = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      /**
       * Represents a channel in a Widget
       * @typedef {Object} WidgetChannel
       * @property {Snowflake} id Id of the channel
       * @property {string} name Name of the channel
       * @property {number} position Position of the channel
       */
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("instant_invite" in data) {
          this.instantInvite = data.instant_invite;
        }
        this.channels = new Collection2();
        for (const channel of data.channels) {
          this.channels.set(channel.id, channel);
        }
        this.members = new Collection2();
        for (const member of data.members) {
          this.members.set(member.id, new WidgetMember(this.client, member));
        }
        if ("presence_count" in data) {
          this.presenceCount = data.presence_count;
        }
      }
      /**
       * Update the Widget.
       * @returns {Promise<Widget>}
       */
      async fetch() {
        const data = await this.client.rest.get(Routes2.guildWidgetJSON(this.id));
        this._patch(data);
        return this;
      }
    };
    module2.exports = Widget2;
  }
});

// node_modules/discord.js/src/util/IntentsBitField.js
var require_IntentsBitField = __commonJS({
  "node_modules/discord.js/src/util/IntentsBitField.js"(exports2, module2) {
    "use strict";
    var { GatewayIntentBits: GatewayIntentBits2 } = require_v106();
    var BitField = require_BitField();
    var IntentsBitField2 = class extends BitField {
    };
    /**
     * Numeric WebSocket intents
     * @type {GatewayIntentBits}
     * @memberof IntentsBitField
     */
    __publicField(IntentsBitField2, "Flags", GatewayIntentBits2);
    module2.exports = IntentsBitField2;
  }
});

// node_modules/discord.js/src/util/Sweepers.js
var require_Sweepers = __commonJS({
  "node_modules/discord.js/src/util/Sweepers.js"(exports2, module2) {
    "use strict";
    var { setInterval: setInterval2, clearInterval: clearInterval2 } = require("node:timers");
    var { ThreadChannelTypes, SweeperKeys } = require_Constants();
    var Events3 = require_Events();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Sweepers2 = class {
      constructor(client, options) {
        Object.defineProperty(this, "client", { value: client });
        this.options = options;
        this.intervals = Object.fromEntries(SweeperKeys.map((key) => [key, null]));
        for (const key of SweeperKeys) {
          if (!(key in options))
            continue;
          this._validateProperties(key);
          const clonedOptions = { ...this.options[key] };
          if (!("filter" in clonedOptions)) {
            switch (key) {
              case "invites":
                clonedOptions.filter = this.constructor.expiredInviteSweepFilter(clonedOptions.lifetime);
                break;
              case "messages":
                clonedOptions.filter = this.constructor.outdatedMessageSweepFilter(clonedOptions.lifetime);
                break;
              case "threads":
                clonedOptions.filter = this.constructor.archivedThreadSweepFilter(clonedOptions.lifetime);
            }
          }
          this._initInterval(key, `sweep${key[0].toUpperCase()}${key.slice(1)}`, clonedOptions);
        }
      }
      /**
       * Sweeps all guild and global application commands and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which commands will be removed from the caches.
       * @returns {number} Amount of commands that were removed from the caches
       */
      sweepApplicationCommands(filter2) {
        const { guilds, items: guildCommands } = this._sweepGuildDirectProp("commands", filter2, { emit: false });
        const globalCommands = this.client.application?.commands.cache.sweep(filter2) ?? 0;
        this.client.emit(
          Events3.CacheSweep,
          `Swept ${globalCommands} global application commands and ${guildCommands} guild commands in ${guilds} guilds.`
        );
        return guildCommands + globalCommands;
      }
      /**
       * Sweeps all auto moderation rules and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine
       * which auto moderation rules will be removed from the caches
       * @returns {number} Amount of auto moderation rules that were removed from the caches
       */
      sweepAutoModerationRules(filter2) {
        return this._sweepGuildDirectProp("autoModerationRules", filter2).items;
      }
      /**
       * Sweeps all guild bans and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which bans will be removed from the caches.
       * @returns {number} Amount of bans that were removed from the caches
       */
      sweepBans(filter2) {
        return this._sweepGuildDirectProp("bans", filter2).items;
      }
      /**
       * Sweeps all guild emojis and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which emojis will be removed from the caches.
       * @returns {number} Amount of emojis that were removed from the caches
       */
      sweepEmojis(filter2) {
        return this._sweepGuildDirectProp("emojis", filter2).items;
      }
      /**
       * Sweeps all guild invites and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which invites will be removed from the caches.
       * @returns {number} Amount of invites that were removed from the caches
       */
      sweepInvites(filter2) {
        return this._sweepGuildDirectProp("invites", filter2).items;
      }
      /**
       * Sweeps all guild members and removes the ones which are indicated by the filter.
       * <info>It is highly recommended to keep the client guild member cached</info>
       * @param {Function} filter The function used to determine which guild members will be removed from the caches.
       * @returns {number} Amount of guild members that were removed from the caches
       */
      sweepGuildMembers(filter2) {
        return this._sweepGuildDirectProp("members", filter2, { outputName: "guild members" }).items;
      }
      /**
       * Sweeps all text-based channels' messages and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which messages will be removed from the caches.
       * @returns {number} Amount of messages that were removed from the caches
       * @example
       * // Remove all messages older than 1800 seconds from the messages cache
       * const amount = sweepers.sweepMessages(
       *   Sweepers.filterByLifetime({
       *     lifetime: 1800,
       *     getComparisonTimestamp: m => m.editedTimestamp ?? m.createdTimestamp,
       *   })(),
       * );
       * console.log(`Successfully removed ${amount} messages from the cache.`);
       */
      sweepMessages(filter2) {
        if (typeof filter2 !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        let channels = 0;
        let messages = 0;
        for (const channel of this.client.channels.cache.values()) {
          if (!channel.isTextBased())
            continue;
          channels++;
          messages += channel.messages.cache.sweep(filter2);
        }
        this.client.emit(Events3.CacheSweep, `Swept ${messages} messages in ${channels} text-based channels.`);
        return messages;
      }
      /**
       * Sweeps all presences and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which presences will be removed from the caches.
       * @returns {number} Amount of presences that were removed from the caches
       */
      sweepPresences(filter2) {
        return this._sweepGuildDirectProp("presences", filter2).items;
      }
      /**
       * Sweeps all message reactions and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which reactions will be removed from the caches.
       * @returns {number} Amount of reactions that were removed from the caches
       */
      sweepReactions(filter2) {
        if (typeof filter2 !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        let channels = 0;
        let messages = 0;
        let reactions = 0;
        for (const channel of this.client.channels.cache.values()) {
          if (!channel.isTextBased())
            continue;
          channels++;
          for (const message of channel.messages.cache.values()) {
            messages++;
            reactions += message.reactions.cache.sweep(filter2);
          }
        }
        this.client.emit(
          Events3.CacheSweep,
          `Swept ${reactions} reactions on ${messages} messages in ${channels} text-based channels.`
        );
        return reactions;
      }
      /**
       * Sweeps all guild stage instances and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which stage instances will be removed from the caches.
       * @returns {number} Amount of stage instances that were removed from the caches
       */
      sweepStageInstances(filter2) {
        return this._sweepGuildDirectProp("stageInstances", filter2, { outputName: "stage instances" }).items;
      }
      /**
       * Sweeps all guild stickers and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which stickers will be removed from the caches.
       * @returns {number} Amount of stickers that were removed from the caches
       */
      sweepStickers(filter2) {
        return this._sweepGuildDirectProp("stickers", filter2).items;
      }
      /**
       * Sweeps all thread members and removes the ones which are indicated by the filter.
       * <info>It is highly recommended to keep the client thread member cached</info>
       * @param {Function} filter The function used to determine which thread members will be removed from the caches.
       * @returns {number} Amount of thread members that were removed from the caches
       */
      sweepThreadMembers(filter2) {
        if (typeof filter2 !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        let threads = 0;
        let members = 0;
        for (const channel of this.client.channels.cache.values()) {
          if (!ThreadChannelTypes.includes(channel.type))
            continue;
          threads++;
          members += channel.members.cache.sweep(filter2);
        }
        this.client.emit(Events3.CacheSweep, `Swept ${members} thread members in ${threads} threads.`);
        return members;
      }
      /**
       * Sweeps all threads and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which threads will be removed from the caches.
       * @returns {number} filter Amount of threads that were removed from the caches
       * @example
       * // Remove all threads archived greater than 1 day ago from all the channel caches
       * const amount = sweepers.sweepThreads(
       *   Sweepers.filterByLifetime({
       *     getComparisonTimestamp: t => t.archivedTimestamp,
       *     excludeFromSweep: t => !t.archived,
       *   })(),
       * );
       * console.log(`Successfully removed ${amount} threads from the cache.`);
       */
      sweepThreads(filter2) {
        if (typeof filter2 !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        let threads = 0;
        for (const [key, val] of this.client.channels.cache.entries()) {
          if (!ThreadChannelTypes.includes(val.type))
            continue;
          if (filter2(val, key, this.client.channels.cache)) {
            threads++;
            this.client.channels._remove(key);
          }
        }
        this.client.emit(Events3.CacheSweep, `Swept ${threads} threads.`);
        return threads;
      }
      /**
       * Sweeps all users and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which users will be removed from the caches.
       * @returns {number} Amount of users that were removed from the caches
       */
      sweepUsers(filter2) {
        if (typeof filter2 !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        const users = this.client.users.cache.sweep(filter2);
        this.client.emit(Events3.CacheSweep, `Swept ${users} users.`);
        return users;
      }
      /**
       * Sweeps all guild voice states and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which voice states will be removed from the caches.
       * @returns {number} Amount of voice states that were removed from the caches
       */
      sweepVoiceStates(filter2) {
        return this._sweepGuildDirectProp("voiceStates", filter2, { outputName: "voice states" }).items;
      }
      /**
       * Cancels all sweeping intervals
       * @returns {void}
       */
      destroy() {
        for (const key of SweeperKeys) {
          if (this.intervals[key])
            clearInterval2(this.intervals[key]);
        }
      }
      /**
       * Options for generating a filter function based on lifetime
       * @typedef {Object} LifetimeFilterOptions
       * @property {number} [lifetime=14400] How long, in seconds, an entry should stay in the collection
       * before it is considered sweepable.
       * @property {Function} [getComparisonTimestamp=e => e?.createdTimestamp] A function that takes an entry, key,
       * and the collection and returns a timestamp to compare against in order to determine the lifetime of the entry.
       * @property {Function} [excludeFromSweep=() => false] A function that takes an entry, key, and the collection
       * and returns a boolean, `true` when the entry should not be checked for sweepability.
       */
      /**
       * Create a sweepFilter function that uses a lifetime to determine sweepability.
       * @param {LifetimeFilterOptions} [options={}] The options used to generate the filter function
       * @returns {GlobalSweepFilter}
       */
      static filterByLifetime({
        lifetime = 14400,
        getComparisonTimestamp = (e) => e?.createdTimestamp,
        excludeFromSweep = () => false
      } = {}) {
        if (typeof lifetime !== "number") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "lifetime", "number");
        }
        if (typeof getComparisonTimestamp !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "getComparisonTimestamp", "function");
        }
        if (typeof excludeFromSweep !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "excludeFromSweep", "function");
        }
        return () => {
          if (lifetime <= 0)
            return null;
          const lifetimeMs = lifetime * 1e3;
          const now = Date.now();
          return (entry, key, coll) => {
            if (excludeFromSweep(entry, key, coll)) {
              return false;
            }
            const comparisonTimestamp = getComparisonTimestamp(entry, key, coll);
            if (!comparisonTimestamp || typeof comparisonTimestamp !== "number")
              return false;
            return now - comparisonTimestamp > lifetimeMs;
          };
        };
      }
      /**
       * Creates a sweep filter that sweeps archived threads
       * @param {number} [lifetime=14400] How long a thread has to be archived to be valid for sweeping
       * @returns {GlobalSweepFilter}
       */
      static archivedThreadSweepFilter(lifetime = 14400) {
        return this.filterByLifetime({
          lifetime,
          getComparisonTimestamp: (e) => e.archiveTimestamp,
          excludeFromSweep: (e) => !e.archived
        });
      }
      /**
       * Creates a sweep filter that sweeps expired invites
       * @param {number} [lifetime=14400] How long ago an invite has to have expired to be valid for sweeping
       * @returns {GlobalSweepFilter}
       */
      static expiredInviteSweepFilter(lifetime = 14400) {
        return this.filterByLifetime({
          lifetime,
          getComparisonTimestamp: (i) => i.expiresTimestamp
        });
      }
      /**
       * Creates a sweep filter that sweeps outdated messages (edits taken into account)
       * @param {number} [lifetime=3600] How long ago a message has to have been sent or edited to be valid for sweeping
       * @returns {GlobalSweepFilter}
       */
      static outdatedMessageSweepFilter(lifetime = 3600) {
        return this.filterByLifetime({
          lifetime,
          getComparisonTimestamp: (m) => m.editedTimestamp ?? m.createdTimestamp
        });
      }
      /**
       * Configuration options for emitting the cache sweep client event
       * @typedef {Object} SweepEventOptions
       * @property {boolean} [emit=true] Whether to emit the client event in this method
       * @property {string} [outputName] A name to output in the client event if it should differ from the key
       * @private
       */
      /**
       * Sweep a direct sub property of all guilds
       * @param {string} key The name of the property
       * @param {Function} filter Filter function passed to sweep
       * @param {SweepEventOptions} [eventOptions={}] Options for the Client event emitted here
       * @returns {Object} Object containing the number of guilds swept and the number of items swept
       * @private
       */
      _sweepGuildDirectProp(key, filter2, { emit = true, outputName } = {}) {
        if (typeof filter2 !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        let guilds = 0;
        let items = 0;
        for (const guild of this.client.guilds.cache.values()) {
          const { cache } = guild[key];
          guilds++;
          items += cache.sweep(filter2);
        }
        if (emit) {
          this.client.emit(Events3.CacheSweep, `Swept ${items} ${outputName ?? key} in ${guilds} guilds.`);
        }
        return { guilds, items };
      }
      /**
       * Validates a set of properties
       * @param {string} key Key of the options object to check
       * @private
       */
      _validateProperties(key) {
        const props = this.options[key];
        if (typeof props !== "object") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, `sweepers.${key}`, "object", true);
        }
        if (typeof props.interval !== "number") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, `sweepers.${key}.interval`, "number");
        }
        if (["invites", "messages", "threads"].includes(key) && !("filter" in props)) {
          if (typeof props.lifetime !== "number") {
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, `sweepers.${key}.lifetime`, "number");
          }
          return;
        }
        if (typeof props.filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, `sweepers.${key}.filter`, "function");
        }
      }
      /**
       * Initialize an interval for sweeping
       * @param {string} intervalKey The name of the property that stores the interval for this sweeper
       * @param {string} sweepKey The name of the function that sweeps the desired caches
       * @param {Object} opts Validated options for a sweep
       * @private
       */
      _initInterval(intervalKey, sweepKey, opts) {
        if (opts.interval <= 0 || opts.interval === Infinity)
          return;
        this.intervals[intervalKey] = setInterval2(() => {
          const sweepFn = opts.filter();
          if (sweepFn === null)
            return;
          if (typeof sweepFn !== "function")
            throw new DiscordjsTypeError2(ErrorCodes2.SweepFilterReturn);
          this[sweepKey](sweepFn);
        }, opts.interval * 1e3).unref();
      }
    };
    module2.exports = Sweepers2;
  }
});

// node_modules/discord.js/src/client/Client.js
var require_Client = __commonJS({
  "node_modules/discord.js/src/client/Client.js"(exports, module) {
    "use strict";
    var process = require("node:process");
    var { Collection } = require_dist();
    var { makeURLSearchParams } = require_dist5();
    var { OAuth2Scopes, Routes } = require_v106();
    var BaseClient = require_BaseClient();
    var ActionsManager = require_ActionsManager();
    var ClientVoiceManager = require_ClientVoiceManager();
    var WebSocketManager = require_WebSocketManager();
    var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors2();
    var BaseGuildEmojiManager = require_BaseGuildEmojiManager();
    var ChannelManager = require_ChannelManager();
    var GuildManager = require_GuildManager();
    var UserManager = require_UserManager();
    var ShardClientUtil = require_ShardClientUtil();
    var ClientPresence = require_ClientPresence();
    var GuildPreview = require_GuildPreview();
    var GuildTemplate = require_GuildTemplate();
    var Invite = require_Invite();
    var { Sticker } = require_Sticker();
    var StickerPack = require_StickerPack();
    var VoiceRegion = require_VoiceRegion();
    var Webhook = require_Webhook();
    var Widget = require_Widget();
    var DataResolver = require_DataResolver();
    var Events = require_Events();
    var IntentsBitField = require_IntentsBitField();
    var Options = require_Options();
    var PermissionsBitField = require_PermissionsBitField();
    var Status = require_Status();
    var Sweepers = require_Sweepers();
    var Client = class extends BaseClient {
      /**
       * @param {ClientOptions} options Options for the client
       */
      constructor(options) {
        super(options);
        const data = require("node:worker_threads").workerData ?? process.env;
        const defaults2 = Options.createDefault();
        if (this.options.shards === defaults2.shards) {
          if ("SHARDS" in data) {
            this.options.shards = JSON.parse(data.SHARDS);
          }
        }
        if (this.options.shardCount === defaults2.shardCount) {
          if ("SHARD_COUNT" in data) {
            this.options.shardCount = Number(data.SHARD_COUNT);
          } else if (Array.isArray(this.options.shards)) {
            this.options.shardCount = this.options.shards.length;
          }
        }
        const typeofShards = typeof this.options.shards;
        if (typeofShards === "undefined" && typeof this.options.shardCount === "number") {
          this.options.shards = Array.from({ length: this.options.shardCount }, (_, i) => i);
        }
        if (typeofShards === "number")
          this.options.shards = [this.options.shards];
        if (Array.isArray(this.options.shards)) {
          this.options.shards = [
            ...new Set(
              this.options.shards.filter((item) => !isNaN(item) && item >= 0 && item < Infinity && item === (item | 0))
            )
          ];
        }
        this._validateOptions();
        this.ws = new WebSocketManager(this);
        this.actions = new ActionsManager(this);
        this.voice = new ClientVoiceManager(this);
        this.shard = process.env.SHARDING_MANAGER ? ShardClientUtil.singleton(this, process.env.SHARDING_MANAGER_MODE) : null;
        this.users = new UserManager(this);
        this.guilds = new GuildManager(this);
        this.channels = new ChannelManager(this);
        this.sweepers = new Sweepers(this, this.options.sweepers);
        this.presence = new ClientPresence(this, this.options.presence);
        Object.defineProperty(this, "token", { writable: true });
        if (!this.token && "DISCORD_TOKEN" in process.env) {
          this.token = process.env.DISCORD_TOKEN;
        } else {
          this.token = null;
        }
        this.user = null;
        this.application = null;
        this.readyTimestamp = null;
      }
      /**
       * All custom emojis that the client has access to, mapped by their ids
       * @type {BaseGuildEmojiManager}
       * @readonly
       */
      get emojis() {
        const emojis = new BaseGuildEmojiManager(this);
        for (const guild of this.guilds.cache.values()) {
          if (guild.available)
            for (const emoji of guild.emojis.cache.values())
              emojis.cache.set(emoji.id, emoji);
        }
        return emojis;
      }
      /**
       * Time at which the client was last regarded as being in the {@link Status.Ready} state
       * (each time the client disconnects and successfully reconnects, this will be overwritten)
       * @type {?Date}
       * @readonly
       */
      get readyAt() {
        return this.readyTimestamp && new Date(this.readyTimestamp);
      }
      /**
       * How long it has been since the client last entered the {@link Status.Ready} state in milliseconds
       * @type {?number}
       * @readonly
       */
      get uptime() {
        return this.readyTimestamp && Date.now() - this.readyTimestamp;
      }
      /**
       * Logs the client in, establishing a WebSocket connection to Discord.
       * @param {string} [token=this.token] Token of the account to log in with
       * @returns {Promise<string>} Token of the account used
       * @example
       * client.login('my token');
       */
      async login(token = this.token) {
        if (!token || typeof token !== "string")
          throw new DiscordjsError(ErrorCodes.TokenInvalid);
        this.token = token = token.replace(/^(Bot|Bearer)\s*/i, "");
        this.rest.setToken(token);
        this.emit(Events.Debug, `Provided token: ${this._censoredToken}`);
        if (this.options.presence) {
          this.options.ws.presence = this.presence._parse(this.options.presence);
        }
        this.emit(Events.Debug, "Preparing to connect to the gateway...");
        try {
          await this.ws.connect();
          return this.token;
        } catch (error) {
          this.destroy();
          throw error;
        }
      }
      /**
       * Returns whether the client has logged in, indicative of being able to access
       * properties such as `user` and `application`.
       * @returns {boolean}
       */
      isReady() {
        return this.ws.status === Status.Ready;
      }
      /**
       * Logs out, terminates the connection to Discord, and destroys the client.
       * @returns {void}
       */
      destroy() {
        super.destroy();
        this.sweepers.destroy();
        this.ws.destroy();
        this.token = null;
        this.rest.setToken(null);
      }
      /**
       * Options used when fetching an invite from Discord.
       * @typedef {Object} ClientFetchInviteOptions
       * @property {Snowflake} [guildScheduledEventId] The id of the guild scheduled event to include with
       * the invite
       */
      /**
       * Obtains an invite from Discord.
       * @param {InviteResolvable} invite Invite code or URL
       * @param {ClientFetchInviteOptions} [options] Options for fetching the invite
       * @returns {Promise<Invite>}
       * @example
       * client.fetchInvite('https://discord.gg/djs')
       *   .then(invite => console.log(`Obtained invite with code: ${invite.code}`))
       *   .catch(console.error);
       */
      async fetchInvite(invite, options) {
        const code = DataResolver.resolveInviteCode(invite);
        const query = makeURLSearchParams({
          with_counts: true,
          with_expiration: true,
          guild_scheduled_event_id: options?.guildScheduledEventId
        });
        const data = await this.rest.get(Routes.invite(code), { query });
        return new Invite(this, data);
      }
      /**
       * Obtains a template from Discord.
       * @param {GuildTemplateResolvable} template Template code or URL
       * @returns {Promise<GuildTemplate>}
       * @example
       * client.fetchGuildTemplate('https://discord.new/FKvmczH2HyUf')
       *   .then(template => console.log(`Obtained template with code: ${template.code}`))
       *   .catch(console.error);
       */
      async fetchGuildTemplate(template) {
        const code = DataResolver.resolveGuildTemplateCode(template);
        const data = await this.rest.get(Routes.template(code));
        return new GuildTemplate(this, data);
      }
      /**
       * Obtains a webhook from Discord.
       * @param {Snowflake} id The webhook's id
       * @param {string} [token] Token for the webhook
       * @returns {Promise<Webhook>}
       * @example
       * client.fetchWebhook('id', 'token')
       *   .then(webhook => console.log(`Obtained webhook with name: ${webhook.name}`))
       *   .catch(console.error);
       */
      async fetchWebhook(id, token) {
        const data = await this.rest.get(Routes.webhook(id, token), { auth: token === void 0 });
        return new Webhook(this, { token, ...data });
      }
      /**
       * Obtains the available voice regions from Discord.
       * @returns {Promise<Collection<string, VoiceRegion>>}
       * @example
       * client.fetchVoiceRegions()
       *   .then(regions => console.log(`Available regions are: ${regions.map(region => region.name).join(', ')}`))
       *   .catch(console.error);
       */
      async fetchVoiceRegions() {
        const apiRegions = await this.rest.get(Routes.voiceRegions());
        const regions = new Collection();
        for (const region of apiRegions)
          regions.set(region.id, new VoiceRegion(region));
        return regions;
      }
      /**
       * Obtains a sticker from Discord.
       * @param {Snowflake} id The sticker's id
       * @returns {Promise<Sticker>}
       * @example
       * client.fetchSticker('id')
       *   .then(sticker => console.log(`Obtained sticker with name: ${sticker.name}`))
       *   .catch(console.error);
       */
      async fetchSticker(id) {
        const data = await this.rest.get(Routes.sticker(id));
        return new Sticker(this, data);
      }
      /**
       * Obtains the list of sticker packs available to Nitro subscribers from Discord.
       * @returns {Promise<Collection<Snowflake, StickerPack>>}
       * @example
       * client.fetchPremiumStickerPacks()
       *   .then(packs => console.log(`Available sticker packs are: ${packs.map(pack => pack.name).join(', ')}`))
       *   .catch(console.error);
       */
      async fetchPremiumStickerPacks() {
        const data = await this.rest.get(Routes.nitroStickerPacks());
        return new Collection(data.sticker_packs.map((p) => [p.id, new StickerPack(this, p)]));
      }
      /**
       * Obtains a guild preview from Discord, available for all guilds the bot is in and all Discoverable guilds.
       * @param {GuildResolvable} guild The guild to fetch the preview for
       * @returns {Promise<GuildPreview>}
       */
      async fetchGuildPreview(guild) {
        const id = this.guilds.resolveId(guild);
        if (!id)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
        const data = await this.rest.get(Routes.guildPreview(id));
        return new GuildPreview(this, data);
      }
      /**
       * Obtains the widget data of a guild from Discord, available for guilds with the widget enabled.
       * @param {GuildResolvable} guild The guild to fetch the widget data for
       * @returns {Promise<Widget>}
       */
      async fetchGuildWidget(guild) {
        const id = this.guilds.resolveId(guild);
        if (!id)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
        const data = await this.rest.get(Routes.guildWidgetJSON(id));
        return new Widget(this, data);
      }
      /**
       * Options for {@link Client#generateInvite}.
       * @typedef {Object} InviteGenerationOptions
       * @property {OAuth2Scopes[]} scopes Scopes that should be requested
       * @property {PermissionResolvable} [permissions] Permissions to request
       * @property {GuildResolvable} [guild] Guild to preselect
       * @property {boolean} [disableGuildSelect] Whether to disable the guild selection
       */
      /**
       * Generates a link that can be used to invite the bot to a guild.
       * @param {InviteGenerationOptions} [options={}] Options for the invite
       * @returns {string}
       * @example
       * const link = client.generateInvite({
       *   scopes: [OAuth2Scopes.ApplicationsCommands],
       * });
       * console.log(`Generated application invite link: ${link}`);
       * @example
       * const link = client.generateInvite({
       *   permissions: [
       *     PermissionFlagsBits.SendMessages,
       *     PermissionFlagsBits.ManageGuild,
       *     PermissionFlagsBits.MentionEveryone,
       *   ],
       *   scopes: [OAuth2Scopes.Bot],
       * });
       * console.log(`Generated bot invite link: ${link}`);
       */
      generateInvite(options = {}) {
        if (typeof options !== "object")
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
        if (!this.application)
          throw new DiscordjsError(ErrorCodes.ClientNotReady, "generate an invite link");
        const { scopes } = options;
        if (scopes === void 0) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
        }
        if (!Array.isArray(scopes)) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "scopes", "Array of Invite Scopes", true);
        }
        if (!scopes.some((scope) => [OAuth2Scopes.Bot, OAuth2Scopes.ApplicationsCommands].includes(scope))) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
        }
        const validScopes = Object.values(OAuth2Scopes);
        const invalidScope = scopes.find((scope) => !validScopes.includes(scope));
        if (invalidScope) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "scopes", invalidScope);
        }
        const query = makeURLSearchParams({
          client_id: this.application.id,
          scope: scopes.join(" "),
          disable_guild_select: options.disableGuildSelect
        });
        if (options.permissions) {
          const permissions = PermissionsBitField.resolve(options.permissions);
          if (permissions)
            query.set("permissions", permissions.toString());
        }
        if (options.guild) {
          const guildId = this.guilds.resolveId(options.guild);
          if (!guildId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.guild", "GuildResolvable");
          query.set("guild_id", guildId);
        }
        return `${this.options.rest.api}${Routes.oauth2Authorization()}?${query}`;
      }
      toJSON() {
        return super.toJSON({
          actions: false,
          presence: false
        });
      }
      /**
       * Partially censored client token for debug logging purposes.
       * @type {?string}
       * @readonly
       * @private
       */
      get _censoredToken() {
        if (!this.token)
          return null;
        return this.token.split(".").map((val, i) => i > 1 ? val.replace(/./g, "*") : val).join(".");
      }
      /**
       * Calls {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval} on a script
       * with the client as `this`.
       * @param {string} script Script to eval
       * @returns {*}
       * @private
       */
      _eval(script) {
        return eval(script);
      }
      /**
       * Validates the client options.
       * @param {ClientOptions} [options=this.options] Options to validate
       * @private
       */
      _validateOptions(options = this.options) {
        if (options.intents === void 0) {
          throw new DiscordjsTypeError(ErrorCodes.ClientMissingIntents);
        } else {
          options.intents = new IntentsBitField(options.intents).freeze();
        }
        if (typeof options.shardCount !== "number" || isNaN(options.shardCount) || options.shardCount < 1) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardCount", "a number greater than or equal to 1");
        }
        if (options.shards && !(options.shards === "auto" || Array.isArray(options.shards))) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shards", "'auto', a number or array of numbers");
        }
        if (options.shards && !options.shards.length)
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidProvidedShards);
        if (typeof options.makeCache !== "function") {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "makeCache", "a function");
        }
        if (typeof options.sweepers !== "object" || options.sweepers === null) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "sweepers", "an object");
        }
        if (!Array.isArray(options.partials)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "partials", "an Array");
        }
        if (typeof options.waitGuildTimeout !== "number" || isNaN(options.waitGuildTimeout)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "waitGuildTimeout", "a number");
        }
        if (typeof options.failIfNotExists !== "boolean") {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "failIfNotExists", "a boolean");
        }
      }
    };
    module.exports = Client;
  }
});

// node_modules/discord.js/src/util/ShardEvents.js
var require_ShardEvents = __commonJS({
  "node_modules/discord.js/src/util/ShardEvents.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      Death: "death",
      Disconnect: "disconnect",
      Error: "error",
      Message: "message",
      Ready: "ready",
      Reconnecting: "reconnecting",
      Spawn: "spawn"
    };
  }
});

// node_modules/discord.js/src/sharding/Shard.js
var require_Shard = __commonJS({
  "node_modules/discord.js/src/sharding/Shard.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("node:events");
    var path = require("node:path");
    var process2 = require("node:process");
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require("node:timers");
    var { setTimeout: sleep } = require("node:timers/promises");
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ShardEvents = require_ShardEvents();
    var { makeError, makePlainError } = require_Util();
    var childProcess = null;
    var Worker = null;
    var Shard = class extends EventEmitter2 {
      constructor(manager, id) {
        super();
        switch (manager.mode) {
          case "process":
            childProcess = require("node:child_process");
            break;
          case "worker":
            Worker = require("node:worker_threads").Worker;
            break;
        }
        this.manager = manager;
        this.id = id;
        this.args = manager.shardArgs ?? [];
        this.execArgv = manager.execArgv;
        this.env = Object.assign({}, process2.env, {
          SHARDING_MANAGER: true,
          SHARDS: this.id,
          SHARD_COUNT: this.manager.totalShards,
          DISCORD_TOKEN: this.manager.token
        });
        this.ready = false;
        this.process = null;
        this.worker = null;
        this._evals = /* @__PURE__ */ new Map();
        this._fetches = /* @__PURE__ */ new Map();
        this._exitListener = null;
      }
      /**
       * Forks a child process or creates a worker thread for the shard.
       * <warn>You should not need to call this manually.</warn>
       * @param {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready
       * before resolving (`-1` or `Infinity` for no wait)
       * @returns {Promise<ChildProcess>}
       */
      spawn(timeout = 3e4) {
        if (this.process)
          throw new DiscordjsError2(ErrorCodes2.ShardingProcessExists, this.id);
        if (this.worker)
          throw new DiscordjsError2(ErrorCodes2.ShardingWorkerExists, this.id);
        this._exitListener = this._handleExit.bind(this, void 0, timeout);
        switch (this.manager.mode) {
          case "process":
            this.process = childProcess.fork(path.resolve(this.manager.file), this.args, {
              env: this.env,
              execArgv: this.execArgv
            }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
            break;
          case "worker":
            this.worker = new Worker(path.resolve(this.manager.file), { workerData: this.env }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
            break;
        }
        this._evals.clear();
        this._fetches.clear();
        const child = this.process ?? this.worker;
        this.emit(ShardEvents.Spawn, child);
        if (timeout === -1 || timeout === Infinity)
          return Promise.resolve(child);
        return new Promise((resolve, reject) => {
          const cleanup = () => {
            clearTimeout2(spawnTimeoutTimer);
            this.off("ready", onReady);
            this.off("disconnect", onDisconnect);
            this.off("death", onDeath);
          };
          const onReady = () => {
            cleanup();
            resolve(child);
          };
          const onDisconnect = () => {
            cleanup();
            reject(new DiscordjsError2(ErrorCodes2.ShardingReadyDisconnected, this.id));
          };
          const onDeath = () => {
            cleanup();
            reject(new DiscordjsError2(ErrorCodes2.ShardingReadyDied, this.id));
          };
          const onTimeout = () => {
            cleanup();
            reject(new DiscordjsError2(ErrorCodes2.ShardingReadyTimeout, this.id));
          };
          const spawnTimeoutTimer = setTimeout2(onTimeout, timeout);
          this.once("ready", onReady);
          this.once("disconnect", onDisconnect);
          this.once("death", onDeath);
        });
      }
      /**
       * Immediately kills the shard's process/worker and does not restart it.
       */
      kill() {
        if (this.process) {
          this.process.removeListener("exit", this._exitListener);
          this.process.kill();
        } else {
          this.worker.removeListener("exit", this._exitListener);
          this.worker.terminate();
        }
        this._handleExit(false);
      }
      /**
       * Options used to respawn a shard.
       * @typedef {Object} ShardRespawnOptions
       * @property {number} [delay=500] How long to wait between killing the process/worker and
       * restarting it (in milliseconds)
       * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client}
       * has become ready before resolving (`-1` or `Infinity` for no wait)
       */
      /**
       * Kills and restarts the shard's process/worker.
       * @param {ShardRespawnOptions} [options] Options for respawning the shard
       * @returns {Promise<ChildProcess>}
       */
      async respawn({ delay = 500, timeout = 3e4 } = {}) {
        this.kill();
        if (delay > 0)
          await sleep(delay);
        return this.spawn(timeout);
      }
      /**
       * Sends a message to the shard's process/worker.
       * @param {*} message Message to send to the shard
       * @returns {Promise<Shard>}
       */
      send(message) {
        return new Promise((resolve, reject) => {
          if (this.process) {
            this.process.send(message, (err) => {
              if (err)
                reject(err);
              else
                resolve(this);
            });
          } else {
            this.worker.postMessage(message);
            resolve(this);
          }
        });
      }
      /**
       * Fetches a client property value of the shard.
       * @param {string} prop Name of the client property to get, using periods for nesting
       * @returns {Promise<*>}
       * @example
       * shard.fetchClientValue('guilds.cache.size')
       *   .then(count => console.log(`${count} guilds in shard ${shard.id}`))
       *   .catch(console.error);
       */
      fetchClientValue(prop) {
        if (!this.process && !this.worker) {
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ShardingNoChildExists, this.id));
        }
        if (this._fetches.has(prop))
          return this._fetches.get(prop);
        const promise = new Promise((resolve, reject) => {
          const child = this.process ?? this.worker;
          const listener = (message) => {
            if (message?._fetchProp !== prop)
              return;
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._fetches.delete(prop);
            if (!message._error)
              resolve(message._result);
            else
              reject(makeError(message._error));
          };
          this.incrementMaxListeners(child);
          child.on("message", listener);
          this.send({ _fetchProp: prop }).catch((err) => {
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._fetches.delete(prop);
            reject(err);
          });
        });
        this._fetches.set(prop, promise);
        return promise;
      }
      /**
       * Evaluates a script or function on the shard, in the context of the {@link Client}.
       * @param {string|Function} script JavaScript to run on the shard
       * @param {*} [context] The context for the eval
       * @returns {Promise<*>} Result of the script execution
       */
      eval(script2, context) {
        const _eval = typeof script2 === "function" ? `(${script2})(this, ${JSON.stringify(context)})` : script2;
        if (!this.process && !this.worker) {
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ShardingNoChildExists, this.id));
        }
        if (this._evals.has(_eval))
          return this._evals.get(_eval);
        const promise = new Promise((resolve, reject) => {
          const child = this.process ?? this.worker;
          const listener = (message) => {
            if (message?._eval !== _eval)
              return;
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._evals.delete(_eval);
            if (!message._error)
              resolve(message._result);
            else
              reject(makeError(message._error));
          };
          this.incrementMaxListeners(child);
          child.on("message", listener);
          this.send({ _eval }).catch((err) => {
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._evals.delete(_eval);
            reject(err);
          });
        });
        this._evals.set(_eval, promise);
        return promise;
      }
      /**
       * Handles a message received from the child process/worker.
       * @param {*} message Message received
       * @private
       */
      _handleMessage(message) {
        if (message) {
          if (message._ready) {
            this.ready = true;
            this.emit(ShardEvents.Ready);
            return;
          }
          if (message._disconnect) {
            this.ready = false;
            this.emit(ShardEvents.Disconnect);
            return;
          }
          if (message._reconnecting) {
            this.ready = false;
            this.emit(ShardEvents.Reconnecting);
            return;
          }
          if (message._sFetchProp) {
            const resp = { _sFetchProp: message._sFetchProp, _sFetchPropShard: message._sFetchPropShard };
            this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then(
              (results) => this.send({ ...resp, _result: results }),
              (err) => this.send({ ...resp, _error: makePlainError(err) })
            );
            return;
          }
          if (message._sEval) {
            const resp = { _sEval: message._sEval, _sEvalShard: message._sEvalShard };
            this.manager._performOnShards("eval", [message._sEval], message._sEvalShard).then(
              (results) => this.send({ ...resp, _result: results }),
              (err) => this.send({ ...resp, _error: makePlainError(err) })
            );
            return;
          }
          if (message._sRespawnAll) {
            const { shardDelay, respawnDelay, timeout } = message._sRespawnAll;
            this.manager.respawnAll({ shardDelay, respawnDelay, timeout }).catch(() => {
            });
            return;
          }
        }
        this.emit(ShardEvents.Message, message);
      }
      /**
       * Handles the shard's process/worker exiting.
       * @param {boolean} [respawn=this.manager.respawn] Whether to spawn the shard again
       * @param {number} [timeout] The amount in milliseconds to wait until the {@link Client}
       * has become ready (`-1` or `Infinity` for no wait)
       * @private
       */
      _handleExit(respawn = this.manager.respawn, timeout) {
        this.emit(ShardEvents.Death, this.process ?? this.worker);
        this.ready = false;
        this.process = null;
        this.worker = null;
        this._evals.clear();
        this._fetches.clear();
        if (respawn)
          this.spawn(timeout).catch((err) => this.emit(ShardEvents.Error, err));
      }
      /**
       * Increments max listeners by one for a given emitter, if they are not zero.
       * @param {EventEmitter|process} emitter The emitter that emits the events.
       * @private
       */
      incrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners + 1);
        }
      }
      /**
       * Decrements max listeners by one for a given emitter, if they are not zero.
       * @param {EventEmitter|process} emitter The emitter that emits the events.
       * @private
       */
      decrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners - 1);
        }
      }
    };
    module2.exports = Shard;
  }
});

// node_modules/discord.js/src/sharding/ShardingManager.js
var require_ShardingManager = __commonJS({
  "node_modules/discord.js/src/sharding/ShardingManager.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("node:events");
    var fs2 = require("node:fs");
    var path = require("node:path");
    var process2 = require("node:process");
    var { setTimeout: sleep } = require("node:timers/promises");
    var { Collection: Collection2 } = require_dist();
    var Shard = require_Shard();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, DiscordjsRangeError: DiscordjsRangeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { mergeDefault, fetchRecommendedShardCount } = require_Util();
    var ShardingManager = class extends EventEmitter2 {
      /**
       * The mode to spawn shards with for a {@link ShardingManager}. Can be either one of:
       * * 'process' to use child processes
       * * 'worker' to use [Worker threads](https://nodejs.org/api/worker_threads.html)
       * @typedef {string} ShardingManagerMode
       */
      /**
       * The options to spawn shards with for a {@link ShardingManager}.
       * @typedef {Object} ShardingManagerOptions
       * @property {string|number} [totalShards='auto'] Number of total shards of all shard managers or "auto"
       * @property {string|number[]} [shardList='auto'] List of shards to spawn or "auto"
       * @property {ShardingManagerMode} [mode='process'] Which mode to use for shards
       * @property {boolean} [respawn=true] Whether shards should automatically respawn upon exiting
       * @property {string[]} [shardArgs=[]] Arguments to pass to the shard script when spawning
       * (only available when mode is set to 'process')
       * @property {string[]} [execArgv=[]] Arguments to pass to the shard script executable when spawning
       * (only available when mode is set to 'process')
       * @property {string} [token] Token to use for automatic shard count and passing to shards
       */
      /**
       * @param {string} file Path to your shard script file
       * @param {ShardingManagerOptions} [options] Options for the sharding manager
       */
      constructor(file, options = {}) {
        super();
        options = mergeDefault(
          {
            totalShards: "auto",
            mode: "process",
            respawn: true,
            shardArgs: [],
            execArgv: [],
            token: process2.env.DISCORD_TOKEN
          },
          options
        );
        this.file = file;
        if (!file)
          throw new DiscordjsError2(ErrorCodes2.ClientInvalidOption, "File", "specified.");
        if (!path.isAbsolute(file))
          this.file = path.resolve(process2.cwd(), file);
        const stats = fs2.statSync(this.file);
        if (!stats.isFile())
          throw new DiscordjsError2(ErrorCodes2.ClientInvalidOption, "File", "a file");
        this.shardList = options.shardList ?? "auto";
        if (this.shardList !== "auto") {
          if (!Array.isArray(this.shardList)) {
            throw new DiscordjsTypeError2(ErrorCodes2.ClientInvalidOption, "shardList", "an array.");
          }
          this.shardList = [...new Set(this.shardList)];
          if (this.shardList.length < 1) {
            throw new DiscordjsRangeError2(ErrorCodes2.ClientInvalidOption, "shardList", "at least 1 id.");
          }
          if (this.shardList.some(
            (shardId) => typeof shardId !== "number" || isNaN(shardId) || !Number.isInteger(shardId) || shardId < 0
          )) {
            throw new DiscordjsTypeError2(ErrorCodes2.ClientInvalidOption, "shardList", "an array of positive integers.");
          }
        }
        this.totalShards = options.totalShards || "auto";
        if (this.totalShards !== "auto") {
          if (typeof this.totalShards !== "number" || isNaN(this.totalShards)) {
            throw new DiscordjsTypeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "a number.");
          }
          if (this.totalShards < 1) {
            throw new DiscordjsRangeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "at least 1.");
          }
          if (!Number.isInteger(this.totalShards)) {
            throw new DiscordjsRangeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "an integer.");
          }
        }
        this.mode = options.mode;
        if (this.mode !== "process" && this.mode !== "worker") {
          throw new DiscordjsRangeError2(ErrorCodes2.ClientInvalidOption, "Sharding mode", '"process" or "worker"');
        }
        this.respawn = options.respawn;
        this.shardArgs = options.shardArgs;
        this.execArgv = options.execArgv;
        this.token = options.token?.replace(/^Bot\s*/i, "") ?? null;
        this.shards = new Collection2();
        process2.env.SHARDING_MANAGER = true;
        process2.env.SHARDING_MANAGER_MODE = this.mode;
        process2.env.DISCORD_TOKEN = this.token;
      }
      /**
       * Creates a single shard.
       * <warn>Using this method is usually not necessary if you use the spawn method.</warn>
       * @param {number} [id=this.shards.size] Id of the shard to create
       * <info>This is usually not necessary to manually specify.</info>
       * @returns {Shard} Note that the created shard needs to be explicitly spawned using its spawn method.
       */
      createShard(id = this.shards.size) {
        const shard = new Shard(this, id);
        this.shards.set(id, shard);
        this.emit("shardCreate", shard);
        return shard;
      }
      /**
       * Options used to spawn multiple shards.
       * @typedef {Object} MultipleShardSpawnOptions
       * @property {number|string} [amount=this.totalShards] Number of shards to spawn
       * @property {number} [delay=5500] How long to wait in between spawning each shard (in milliseconds)
       * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready
       */
      /**
       * Spawns multiple shards.
       * @param {MultipleShardSpawnOptions} [options] Options for spawning shards
       * @returns {Promise<Collection<number, Shard>>}
       */
      async spawn({ amount = this.totalShards, delay = 5500, timeout = 3e4 } = {}) {
        if (amount === "auto") {
          amount = await fetchRecommendedShardCount(this.token);
        } else {
          if (typeof amount !== "number" || isNaN(amount)) {
            throw new DiscordjsTypeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "a number.");
          }
          if (amount < 1)
            throw new DiscordjsRangeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "at least 1.");
          if (!Number.isInteger(amount)) {
            throw new DiscordjsTypeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "an integer.");
          }
        }
        if (this.shards.size >= amount)
          throw new DiscordjsError2(ErrorCodes2.ShardingAlreadySpawned, this.shards.size);
        if (this.shardList === "auto" || this.totalShards === "auto" || this.totalShards !== amount) {
          this.shardList = [...Array(amount).keys()];
        }
        if (this.totalShards === "auto" || this.totalShards !== amount) {
          this.totalShards = amount;
        }
        if (this.shardList.some((shardId) => shardId >= amount)) {
          throw new DiscordjsRangeError2(
            ErrorCodes2.ClientInvalidOption,
            "Amount of shards",
            "bigger than the highest shardId in the shardList option."
          );
        }
        for (const shardId of this.shardList) {
          const promises = [];
          const shard = this.createShard(shardId);
          promises.push(shard.spawn(timeout));
          if (delay > 0 && this.shards.size !== this.shardList.length)
            promises.push(sleep(delay));
          await Promise.all(promises);
        }
        return this.shards;
      }
      /**
       * Sends a message to all shards.
       * @param {*} message Message to be sent to the shards
       * @returns {Promise<Shard[]>}
       */
      broadcast(message) {
        const promises = [];
        for (const shard of this.shards.values())
          promises.push(shard.send(message));
        return Promise.all(promises);
      }
      /**
       * Options for {@link ShardingManager#broadcastEval} and {@link ShardClientUtil#broadcastEval}.
       * @typedef {Object} BroadcastEvalOptions
       * @property {number} [shard] Shard to run script on, all if undefined
       * @property {*} [context] The JSON-serializable values to call the script with
       */
      /**
       * Evaluates a script on all shards, or a given shard, in the context of the {@link Client}s.
       * @param {Function} script JavaScript to run on each shard
       * @param {BroadcastEvalOptions} [options={}] The options for the broadcast
       * @returns {Promise<*|Array<*>>} Results of the script execution
       */
      broadcastEval(script2, options = {}) {
        if (typeof script2 !== "function") {
          return Promise.reject(new DiscordjsTypeError2(ErrorCodes2.ShardingInvalidEvalBroadcast));
        }
        return this._performOnShards("eval", [`(${script2})(this, ${JSON.stringify(options.context)})`], options.shard);
      }
      /**
       * Fetches a client property value of each shard, or a given shard.
       * @param {string} prop Name of the client property to get, using periods for nesting
       * @param {number} [shard] Shard to fetch property from, all if undefined
       * @returns {Promise<*|Array<*>>}
       * @example
       * manager.fetchClientValues('guilds.cache.size')
       *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))
       *   .catch(console.error);
       */
      fetchClientValues(prop, shard) {
        return this._performOnShards("fetchClientValue", [prop], shard);
      }
      /**
       * Runs a method with given arguments on all shards, or a given shard.
       * @param {string} method Method name to run on each shard
       * @param {Array<*>} args Arguments to pass through to the method call
       * @param {number} [shard] Shard to run on, all if undefined
       * @returns {Promise<*|Array<*>>} Results of the method execution
       * @private
       */
      _performOnShards(method, args, shard) {
        if (this.shards.size === 0)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ShardingNoShards));
        if (typeof shard === "number") {
          if (this.shards.has(shard))
            return this.shards.get(shard)[method](...args);
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ShardingShardNotFound, shard));
        }
        if (this.shards.size !== this.shardList.length) {
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ShardingInProcess));
        }
        const promises = [];
        for (const sh of this.shards.values())
          promises.push(sh[method](...args));
        return Promise.all(promises);
      }
      /**
       * Options used to respawn all shards.
       * @typedef {Object} MultipleShardRespawnOptions
       * @property {number} [shardDelay=5000] How long to wait between shards (in milliseconds)
       * @property {number} [respawnDelay=500] How long to wait between killing a shard's process and restarting it
       * (in milliseconds)
       * @property {number} [timeout=30000] The amount in milliseconds to wait for a shard to become ready before
       * continuing to another (`-1` or `Infinity` for no wait)
       */
      /**
       * Kills all running shards and respawns them.
       * @param {MultipleShardRespawnOptions} [options] Options for respawning shards
       * @returns {Promise<Collection<number, Shard>>}
       */
      async respawnAll({ shardDelay = 5e3, respawnDelay = 500, timeout = 3e4 } = {}) {
        let s = 0;
        for (const shard of this.shards.values()) {
          const promises = [shard.respawn({ delay: respawnDelay, timeout })];
          if (++s < this.shards.size && shardDelay > 0)
            promises.push(sleep(shardDelay));
          await Promise.all(promises);
        }
        return this.shards;
      }
    };
    module2.exports = ShardingManager;
  }
});

// node_modules/discord.js/src/util/Formatters.js
var require_Formatters = __commonJS({
  "node_modules/discord.js/src/util/Formatters.js"(exports2, module2) {
    "use strict";
    var { deprecate } = require("node:util");
    var {
      blockQuote,
      bold,
      channelMention,
      codeBlock,
      formatEmoji,
      hideLinkEmbed,
      hyperlink,
      inlineCode,
      italic,
      quote,
      roleMention,
      spoiler,
      strikethrough,
      time,
      TimestampStyles,
      underscore,
      userMention
    } = require_dist8();
    var Formatters = class extends null {
    };
    /**
     * Formats the content into a block quote.
     * <info>This needs to be at the start of the line for Discord to format it.</info>
     * @method blockQuote
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "blockQuote", deprecate(
      blockQuote,
      "Formatters.blockQuote() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats the content into bold text.
     * @method bold
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "bold", deprecate(
      bold,
      "Formatters.bold() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats a channel id into a channel mention.
     * @method channelMention
     * @memberof Formatters
     * @param {Snowflake} channelId The channel id to format
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "channelMention", deprecate(
      channelMention,
      "Formatters.channelMention() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Wraps the content inside a code block with an optional language.
     * @method codeBlock
     * @memberof Formatters
     * @param {string} contentOrLanguage The language to use or content if a second parameter isn't provided
     * @param {string} [content] The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "codeBlock", deprecate(
      codeBlock,
      "Formatters.codeBlock() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats an emoji id into a fully qualified emoji identifier.
     * @method formatEmoji
     * @memberof Formatters
     * @param {string} emojiId The emoji id to format
     * @param {boolean} [animated=false] Whether the emoji is animated
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "formatEmoji", deprecate(
      formatEmoji,
      "Formatters.formatEmoji() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Wraps the URL into `<>`, which stops it from embedding.
     * @method hideLinkEmbed
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "hideLinkEmbed", deprecate(
      hideLinkEmbed,
      "Formatters.hideLinkEmbed() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats the content and the URL into a masked URL with an optional title.
     * @method hyperlink
     * @memberof Formatters
     * @param {string} content The content to display
     * @param {string} url The URL the content links to
     * @param {string} [title] The title shown when hovering on the masked link
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "hyperlink", deprecate(
      hyperlink,
      "Formatters.hyperlink() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Wraps the content inside \`backticks\`, which formats it as inline code.
     * @method inlineCode
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "inlineCode", deprecate(
      inlineCode,
      "Formatters.inlineCode() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats the content into italic text.
     * @method italic
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "italic", deprecate(
      italic,
      "Formatters.italic() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats the content into a quote. This needs to be at the start of the line for Discord to format it.
     * @method quote
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "quote", deprecate(
      quote,
      "Formatters.quote() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats a role id into a role mention.
     * @method roleMention
     * @memberof Formatters
     * @param {Snowflake} roleId The role id to format
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "roleMention", deprecate(
      roleMention,
      "Formatters.roleMention() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats the content into spoiler text.
     * @method spoiler
     * @memberof Formatters
     * @param {string} content The content to spoiler
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "spoiler", deprecate(
      spoiler,
      "Formatters.spoiler() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats the content into strike-through text.
     * @method strikethrough
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "strikethrough", deprecate(
      strikethrough,
      "Formatters.strikethrough() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats a date into a short date-time string.
     * @method time
     * @memberof Formatters
     * @param {number|Date} [date] The date to format
     * @param {TimestampStylesString} [style] The style to use
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "time", deprecate(
      time,
      "Formatters.time() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * The message formatting timestamp
     * [styles](https://discord.com/developers/docs/reference#message-formatting-timestamp-styles) supported by Discord.
     * @type {Object<string, TimestampStylesString>}
     * @memberof Formatters
     * @deprecated Import this property directly from discord.js instead.
     */
    __publicField(Formatters, "TimestampStyles", TimestampStyles);
    /**
     * Formats the content into underscored text.
     * @method underscore
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "underscore", deprecate(
      underscore,
      "Formatters.underscore() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats a user id into a user mention.
     * @method userMention
     * @memberof Formatters
     * @param {Snowflake} userId The user id to format
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "userMention", deprecate(
      userMention,
      "Formatters.userMention() is deprecated. Import this method directly from discord.js instead."
    ));
    module2.exports = Formatters;
  }
});

// node_modules/discord.js/src/structures/EmbedBuilder.js
var require_EmbedBuilder = __commonJS({
  "node_modules/discord.js/src/structures/EmbedBuilder.js"(exports2, module2) {
    "use strict";
    var { EmbedBuilder: BuildersEmbed, isJSONEncodable } = require_dist8();
    var { toSnakeCase } = require_Transformers();
    var { resolveColor } = require_Util();
    var EmbedBuilder = class extends BuildersEmbed {
      constructor(data) {
        super(toSnakeCase(data));
      }
      /**
       * Sets the color of this embed
       * @param {?ColorResolvable} color The color of the embed
       * @returns {EmbedBuilder}
       */
      setColor(color) {
        return super.setColor(color && resolveColor(color));
      }
      /**
       * Creates a new embed builder from JSON data
       * @param {JSONEncodable<APIEmbed>|APIEmbed} other The other data
       * @returns {EmbedBuilder}
       */
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = EmbedBuilder;
  }
});

// node_modules/discord.js/src/structures/AttachmentBuilder.js
var require_AttachmentBuilder = __commonJS({
  "node_modules/discord.js/src/structures/AttachmentBuilder.js"(exports2, module2) {
    "use strict";
    var { basename, flatten } = require_Util();
    var AttachmentBuilder = class {
      /**
       * @param {BufferResolvable|Stream} attachment The file
       * @param {AttachmentData} [data] Extra data
       */
      constructor(attachment, data = {}) {
        this.attachment = attachment;
        this.name = data.name;
        this.description = data.description;
      }
      /**
       * Sets the description of this attachment.
       * @param {string} description The description of the file
       * @returns {AttachmentBuilder} This attachment
       */
      setDescription(description) {
        this.description = description;
        return this;
      }
      /**
       * Sets the file of this attachment.
       * @param {BufferResolvable|Stream} attachment The file
       * @returns {AttachmentBuilder} This attachment
       */
      setFile(attachment) {
        this.attachment = attachment;
        return this;
      }
      /**
       * Sets the name of this attachment.
       * @param {string} name The name of the file
       * @returns {AttachmentBuilder} This attachment
       */
      setName(name) {
        this.name = name;
        return this;
      }
      /**
       * Sets whether this attachment is a spoiler
       * @param {boolean} [spoiler=true] Whether the attachment should be marked as a spoiler
       * @returns {AttachmentBuilder} This attachment
       */
      setSpoiler(spoiler = true) {
        if (spoiler === this.spoiler)
          return this;
        if (!spoiler) {
          while (this.spoiler) {
            this.name = this.name.slice("SPOILER_".length);
          }
          return this;
        }
        this.name = `SPOILER_${this.name}`;
        return this;
      }
      /**
       * Whether or not this attachment has been marked as a spoiler
       * @type {boolean}
       * @readonly
       */
      get spoiler() {
        return basename(this.name).startsWith("SPOILER_");
      }
      toJSON() {
        return flatten(this);
      }
      /**
       * Makes a new builder instance from a preexisting attachment structure.
       * @param {JSONEncodable<AttachmentPayload>} other The builder to construct a new instance from
       * @returns {AttachmentBuilder}
       */
      static from(other) {
        return new AttachmentBuilder(other.attachment, {
          name: other.name,
          description: other.description
        });
      }
    };
    module2.exports = AttachmentBuilder;
  }
});

// node_modules/discord.js/src/structures/ModalBuilder.js
var require_ModalBuilder = __commonJS({
  "node_modules/discord.js/src/structures/ModalBuilder.js"(exports2, module2) {
    "use strict";
    var { ModalBuilder: BuildersModal, ComponentBuilder, isJSONEncodable } = require_dist8();
    var { toSnakeCase } = require_Transformers();
    var ModalBuilder = class extends BuildersModal {
      constructor({ components, ...data } = {}) {
        super({
          ...toSnakeCase(data),
          components: components?.map((c) => c instanceof ComponentBuilder ? c : toSnakeCase(c))
        });
      }
      /**
       * Creates a new modal builder from JSON data
       * @param {JSONEncodable<APIModalComponent>|APIModalComponent} other The other data
       * @returns {ModalBuilder}
       */
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = ModalBuilder;
  }
});

// node_modules/discord.js/src/structures/SelectMenuBuilder.js
var require_SelectMenuBuilder = __commonJS({
  "node_modules/discord.js/src/structures/SelectMenuBuilder.js"(exports2, module2) {
    "use strict";
    var process2 = require("node:process");
    var StringSelectMenuBuilder = require_StringSelectMenuBuilder();
    var deprecationEmitted = false;
    var SelectMenuBuilder2 = class extends StringSelectMenuBuilder {
      constructor(...params) {
        super(...params);
        if (!deprecationEmitted) {
          process2.emitWarning(
            "The SelectMenuBuilder class is deprecated. Use StringSelectMenuBuilder instead.",
            "DeprecationWarning"
          );
          deprecationEmitted = true;
        }
      }
    };
    module2.exports = SelectMenuBuilder2;
  }
});

// node_modules/discord.js/src/structures/SelectMenuComponent.js
var require_SelectMenuComponent = __commonJS({
  "node_modules/discord.js/src/structures/SelectMenuComponent.js"(exports2, module2) {
    "use strict";
    var process2 = require("node:process");
    var StringSelectMenuComponent = require_StringSelectMenuComponent();
    var deprecationEmitted = false;
    var SelectMenuComponent = class extends StringSelectMenuComponent {
      constructor(...params) {
        super(...params);
        if (!deprecationEmitted) {
          process2.emitWarning(
            "The SelectMenuComponent class is deprecated. Use StringSelectMenuComponent instead.",
            "DeprecationWarning"
          );
          deprecationEmitted = true;
        }
      }
    };
    module2.exports = SelectMenuComponent;
  }
});

// node_modules/discord.js/src/structures/SelectMenuInteraction.js
var require_SelectMenuInteraction = __commonJS({
  "node_modules/discord.js/src/structures/SelectMenuInteraction.js"(exports2, module2) {
    "use strict";
    var process2 = require("node:process");
    var StringSelectMenuInteraction = require_StringSelectMenuInteraction();
    var deprecationEmitted = false;
    var SelectMenuInteraction = class extends StringSelectMenuInteraction {
      constructor(...params) {
        super(...params);
        if (!deprecationEmitted) {
          process2.emitWarning(
            "The SelectMenuInteraction class is deprecated. Use StringSelectMenuInteraction instead.",
            "DeprecationWarning"
          );
          deprecationEmitted = true;
        }
      }
    };
    module2.exports = SelectMenuInteraction;
  }
});

// node_modules/discord.js/src/structures/StringSelectMenuOptionBuilder.js
var require_StringSelectMenuOptionBuilder = __commonJS({
  "node_modules/discord.js/src/structures/StringSelectMenuOptionBuilder.js"(exports2, module2) {
    "use strict";
    var { SelectMenuOptionBuilder: BuildersSelectMenuOption, isJSONEncodable } = require_dist8();
    var { toSnakeCase } = require_Transformers();
    var { resolvePartialEmoji } = require_Util();
    var StringSelectMenuOptionBuilder = class extends BuildersSelectMenuOption {
      constructor({ emoji, ...data } = {}) {
        super(
          toSnakeCase({
            ...data,
            emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
          })
        );
      }
      /**
       * Sets the emoji to display on this option
       * @param {ComponentEmojiResolvable} emoji The emoji to display on this option
       * @returns {StringSelectMenuOptionBuilder}
       */
      setEmoji(emoji) {
        if (typeof emoji === "string") {
          return super.setEmoji(resolvePartialEmoji(emoji));
        }
        return super.setEmoji(emoji);
      }
      /**
       * Creates a new select menu option builder from JSON data
       * @param {JSONEncodable<APISelectMenuOption>|APISelectMenuOption} other The other data
       * @returns {StringSelectMenuOptionBuilder}
       */
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = StringSelectMenuOptionBuilder;
  }
});

// node_modules/discord.js/src/structures/SelectMenuOptionBuilder.js
var require_SelectMenuOptionBuilder = __commonJS({
  "node_modules/discord.js/src/structures/SelectMenuOptionBuilder.js"(exports2, module2) {
    "use strict";
    var process2 = require("node:process");
    var StringSelectMenuOptionBuilder = require_StringSelectMenuOptionBuilder();
    var deprecationEmitted = false;
    var SelectMenuOptionBuilder2 = class extends StringSelectMenuOptionBuilder {
      constructor(...params) {
        super(...params);
        if (!deprecationEmitted) {
          process2.emitWarning(
            "The SelectMenuOptionBuilder class is deprecated. Use StringSelectMenuOptionBuilder instead.",
            "DeprecationWarning"
          );
          deprecationEmitted = true;
        }
      }
    };
    module2.exports = SelectMenuOptionBuilder2;
  }
});

// node_modules/discord.js/src/index.js
var require_src = __commonJS({
  "node_modules/discord.js/src/index.js"(exports2) {
    "use strict";
    var { __exportStar: __exportStar2 } = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    exports2.BaseClient = require_BaseClient();
    exports2.Client = require_Client();
    exports2.Shard = require_Shard();
    exports2.ShardClientUtil = require_ShardClientUtil();
    exports2.ShardingManager = require_ShardingManager();
    exports2.WebhookClient = require_WebhookClient();
    exports2.DiscordjsError = require_DJSError().DiscordjsError;
    exports2.DiscordjsTypeError = require_DJSError().DiscordjsTypeError;
    exports2.DiscordjsRangeError = require_DJSError().DiscordjsRangeError;
    exports2.DiscordjsErrorCodes = require_ErrorCodes();
    exports2.ActivityFlagsBitField = require_ActivityFlagsBitField();
    exports2.ApplicationFlagsBitField = require_ApplicationFlagsBitField();
    exports2.BaseManager = require_BaseManager();
    exports2.BitField = require_BitField();
    exports2.ChannelFlagsBitField = require_ChannelFlagsBitField();
    exports2.Collection = require_dist().Collection;
    exports2.Constants = require_Constants();
    exports2.Colors = require_Colors();
    exports2.DataResolver = require_DataResolver();
    exports2.Events = require_Events();
    exports2.Formatters = require_Formatters();
    exports2.GuildMemberFlagsBitField = require_GuildMemberFlagsBitField().GuildMemberFlagsBitField;
    exports2.IntentsBitField = require_IntentsBitField();
    exports2.LimitedCollection = require_LimitedCollection();
    exports2.MessageFlagsBitField = require_MessageFlagsBitField();
    exports2.Options = require_Options();
    exports2.Partials = require_Partials();
    exports2.PermissionsBitField = require_PermissionsBitField();
    exports2.ShardEvents = require_ShardEvents();
    exports2.Status = require_Status();
    exports2.SnowflakeUtil = require_dist3().DiscordSnowflake;
    exports2.Sweepers = require_Sweepers();
    exports2.SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
    exports2.ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();
    exports2.UserFlagsBitField = require_UserFlagsBitField();
    __exportStar2(require_Util(), exports2);
    exports2.WebSocketShardEvents = require_WebSocketShardEvents();
    exports2.version = require_package2().version;
    exports2.ApplicationCommandManager = require_ApplicationCommandManager();
    exports2.ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
    exports2.AutoModerationRuleManager = require_AutoModerationRuleManager();
    exports2.BaseGuildEmojiManager = require_BaseGuildEmojiManager();
    exports2.CachedManager = require_CachedManager();
    exports2.ChannelManager = require_ChannelManager();
    exports2.ClientVoiceManager = require_ClientVoiceManager();
    exports2.DataManager = require_DataManager();
    exports2.GuildApplicationCommandManager = require_GuildApplicationCommandManager();
    exports2.GuildBanManager = require_GuildBanManager();
    exports2.GuildChannelManager = require_GuildChannelManager();
    exports2.GuildEmojiManager = require_GuildEmojiManager();
    exports2.GuildEmojiRoleManager = require_GuildEmojiRoleManager();
    exports2.GuildForumThreadManager = require_GuildForumThreadManager();
    exports2.GuildInviteManager = require_GuildInviteManager();
    exports2.GuildManager = require_GuildManager();
    exports2.GuildMemberManager = require_GuildMemberManager();
    exports2.GuildMemberRoleManager = require_GuildMemberRoleManager();
    exports2.GuildScheduledEventManager = require_GuildScheduledEventManager();
    exports2.GuildStickerManager = require_GuildStickerManager();
    exports2.GuildTextThreadManager = require_GuildTextThreadManager();
    exports2.MessageManager = require_MessageManager();
    exports2.PermissionOverwriteManager = require_PermissionOverwriteManager();
    exports2.PresenceManager = require_PresenceManager();
    exports2.ReactionManager = require_ReactionManager();
    exports2.ReactionUserManager = require_ReactionUserManager();
    exports2.RoleManager = require_RoleManager();
    exports2.StageInstanceManager = require_StageInstanceManager();
    exports2.ThreadManager = require_ThreadManager();
    exports2.ThreadMemberManager = require_ThreadMemberManager();
    exports2.UserManager = require_UserManager();
    exports2.VoiceStateManager = require_VoiceStateManager();
    exports2.WebSocketManager = require_WebSocketManager();
    exports2.WebSocketShard = require_WebSocketShard();
    exports2.ActionRow = require_ActionRow();
    exports2.ActionRowBuilder = require_ActionRowBuilder();
    exports2.Activity = require_Presence().Activity;
    exports2.AnonymousGuild = require_AnonymousGuild();
    exports2.Application = require_Application();
    exports2.ApplicationCommand = require_ApplicationCommand();
    exports2.ApplicationRoleConnectionMetadata = require_ApplicationRoleConnectionMetadata().ApplicationRoleConnectionMetadata;
    exports2.AutocompleteInteraction = require_AutocompleteInteraction();
    exports2.AutoModerationActionExecution = require_AutoModerationActionExecution();
    exports2.AutoModerationRule = require_AutoModerationRule();
    exports2.Base = require_Base();
    exports2.BaseGuild = require_BaseGuild();
    exports2.BaseGuildEmoji = require_BaseGuildEmoji();
    exports2.BaseGuildTextChannel = require_BaseGuildTextChannel();
    exports2.BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    exports2.ButtonBuilder = require_ButtonBuilder();
    exports2.ButtonComponent = require_ButtonComponent();
    exports2.ButtonInteraction = require_ButtonInteraction();
    exports2.CategoryChannel = require_CategoryChannel();
    exports2.BaseChannel = require_BaseChannel().BaseChannel;
    exports2.ChatInputCommandInteraction = require_ChatInputCommandInteraction();
    exports2.ClientApplication = require_ClientApplication();
    exports2.ClientPresence = require_ClientPresence();
    exports2.ClientUser = require_ClientUser();
    exports2.CommandInteraction = require_CommandInteraction();
    exports2.Collector = require_Collector();
    exports2.CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
    exports2.Component = require_Component();
    exports2.ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();
    exports2.DMChannel = require_DMChannel();
    exports2.Embed = require_Embed();
    exports2.EmbedBuilder = require_EmbedBuilder();
    exports2.Emoji = require_Emoji().Emoji;
    exports2.ForumChannel = require_ForumChannel();
    exports2.Guild = require_Guild().Guild;
    exports2.GuildAuditLogs = require_GuildAuditLogs();
    exports2.GuildAuditLogsEntry = require_GuildAuditLogsEntry();
    exports2.GuildBan = require_GuildBan();
    exports2.GuildChannel = require_GuildChannel();
    exports2.GuildEmoji = require_GuildEmoji();
    exports2.GuildMember = require_GuildMember().GuildMember;
    exports2.GuildPreview = require_GuildPreview();
    exports2.GuildPreviewEmoji = require_GuildPreviewEmoji();
    exports2.GuildScheduledEvent = require_GuildScheduledEvent().GuildScheduledEvent;
    exports2.GuildTemplate = require_GuildTemplate();
    exports2.Integration = require_Integration();
    exports2.IntegrationApplication = require_IntegrationApplication();
    exports2.BaseInteraction = require_BaseInteraction();
    exports2.InteractionCollector = require_InteractionCollector();
    exports2.InteractionResponse = require_InteractionResponse();
    exports2.InteractionWebhook = require_InteractionWebhook();
    exports2.Invite = require_Invite();
    exports2.InviteStageInstance = require_InviteStageInstance();
    exports2.InviteGuild = require_InviteGuild();
    exports2.Message = require_Message().Message;
    exports2.Attachment = require_Attachment();
    exports2.AttachmentBuilder = require_AttachmentBuilder();
    exports2.ModalBuilder = require_ModalBuilder();
    exports2.MessageCollector = require_MessageCollector();
    exports2.MessageComponentInteraction = require_MessageComponentInteraction();
    exports2.MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
    exports2.MessageMentions = require_MessageMentions();
    exports2.MessagePayload = require_MessagePayload();
    exports2.MessageReaction = require_MessageReaction();
    exports2.ModalSubmitInteraction = require_ModalSubmitInteraction();
    exports2.ModalSubmitFields = require_ModalSubmitFields();
    exports2.NewsChannel = require_NewsChannel();
    exports2.OAuth2Guild = require_OAuth2Guild();
    exports2.PartialGroupDMChannel = require_PartialGroupDMChannel();
    exports2.PermissionOverwrites = require_PermissionOverwrites();
    exports2.Presence = require_Presence().Presence;
    exports2.ReactionCollector = require_ReactionCollector();
    exports2.ReactionEmoji = require_ReactionEmoji();
    exports2.RichPresenceAssets = require_Presence().RichPresenceAssets;
    exports2.Role = require_Role().Role;
    exports2.SelectMenuBuilder = require_SelectMenuBuilder();
    exports2.ChannelSelectMenuBuilder = require_ChannelSelectMenuBuilder();
    exports2.MentionableSelectMenuBuilder = require_MentionableSelectMenuBuilder();
    exports2.RoleSelectMenuBuilder = require_RoleSelectMenuBuilder();
    exports2.StringSelectMenuBuilder = require_StringSelectMenuBuilder();
    exports2.UserSelectMenuBuilder = require_UserSelectMenuBuilder();
    exports2.BaseSelectMenuComponent = require_BaseSelectMenuComponent();
    exports2.SelectMenuComponent = require_SelectMenuComponent();
    exports2.ChannelSelectMenuComponent = require_ChannelSelectMenuComponent();
    exports2.MentionableSelectMenuComponent = require_MentionableSelectMenuComponent();
    exports2.RoleSelectMenuComponent = require_RoleSelectMenuComponent();
    exports2.StringSelectMenuComponent = require_StringSelectMenuComponent();
    exports2.UserSelectMenuComponent = require_UserSelectMenuComponent();
    exports2.SelectMenuInteraction = require_SelectMenuInteraction();
    exports2.ChannelSelectMenuInteraction = require_ChannelSelectMenuInteraction();
    exports2.MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
    exports2.MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
    exports2.RoleSelectMenuInteraction = require_RoleSelectMenuInteraction();
    exports2.StringSelectMenuInteraction = require_StringSelectMenuInteraction();
    exports2.UserSelectMenuInteraction = require_UserSelectMenuInteraction();
    exports2.SelectMenuOptionBuilder = require_SelectMenuOptionBuilder();
    exports2.StringSelectMenuOptionBuilder = require_StringSelectMenuOptionBuilder();
    exports2.StageChannel = require_StageChannel();
    exports2.StageInstance = require_StageInstance().StageInstance;
    exports2.Sticker = require_Sticker().Sticker;
    exports2.StickerPack = require_StickerPack();
    exports2.Team = require_Team();
    exports2.TeamMember = require_TeamMember();
    exports2.TextChannel = require_TextChannel();
    exports2.TextInputBuilder = require_TextInputBuilder();
    exports2.TextInputComponent = require_TextInputComponent();
    exports2.ThreadChannel = require_ThreadChannel();
    exports2.ThreadMember = require_ThreadMember();
    exports2.Typing = require_Typing();
    exports2.User = require_User();
    exports2.UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
    exports2.VoiceChannel = require_VoiceChannel();
    exports2.VoiceRegion = require_VoiceRegion();
    exports2.VoiceState = require_VoiceState();
    exports2.Webhook = require_Webhook();
    exports2.Widget = require_Widget();
    exports2.WidgetMember = require_WidgetMember();
    exports2.WelcomeChannel = require_WelcomeChannel();
    exports2.WelcomeScreen = require_WelcomeScreen();
    exports2.WebSocket = require_WebSocket();
    __exportStar2(require_v106(), exports2);
    __exportStar2(require_dist8(), exports2);
    __exportStar2(require_dist7(), exports2);
    __exportStar2(require_dist5(), exports2);
    __exportStar2(require_dist2(), exports2);
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isFunction.js
var require_isFunction2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isFunction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isFunction = void 0;
    function isFunction2(value) {
      return typeof value === "function";
    }
    exports2.isFunction = isFunction2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
var require_createErrorClass = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createErrorClass = void 0;
    function createErrorClass(createImpl) {
      var _super = function(instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
      };
      var ctorFunc = createImpl(_super);
      ctorFunc.prototype = Object.create(Error.prototype);
      ctorFunc.prototype.constructor = ctorFunc;
      return ctorFunc;
    }
    exports2.createErrorClass = createErrorClass;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnsubscriptionError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
      return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
          return i + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
var require_arrRemove = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/arrRemove.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.arrRemove = void 0;
    function arrRemove(arr, item) {
      if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
      }
    }
    exports2.arrRemove = arrRemove;
  }
});

// node_modules/rxjs/dist/cjs/internal/Subscription.js
var require_Subscription = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subscription.js"(exports2) {
    "use strict";
    var __values2 = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSubscription = exports2.EMPTY_SUBSCRIPTION = exports2.Subscription = void 0;
    var isFunction_1 = require_isFunction2();
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    var arrRemove_1 = require_arrRemove();
    var Subscription = function() {
      function Subscription2(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
      }
      Subscription2.prototype.unsubscribe = function() {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
          this.closed = true;
          var _parentage = this._parentage;
          if (_parentage) {
            this._parentage = null;
            if (Array.isArray(_parentage)) {
              try {
                for (var _parentage_1 = __values2(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                  var parent_1 = _parentage_1_1.value;
                  parent_1.remove(this);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                    _a.call(_parentage_1);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
            } else {
              _parentage.remove(this);
            }
          }
          var initialFinalizer = this.initialTeardown;
          if (isFunction_1.isFunction(initialFinalizer)) {
            try {
              initialFinalizer();
            } catch (e) {
              errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
            }
          }
          var _finalizers = this._finalizers;
          if (_finalizers) {
            this._finalizers = null;
            try {
              for (var _finalizers_1 = __values2(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                var finalizer = _finalizers_1_1.value;
                try {
                  execFinalizer(finalizer);
                } catch (err) {
                  errors = errors !== null && errors !== void 0 ? errors : [];
                  if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                    errors = __spreadArray2(__spreadArray2([], __read2(errors)), __read2(err.errors));
                  } else {
                    errors.push(err);
                  }
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                  _b.call(_finalizers_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
          if (errors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
          }
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var _a;
        if (teardown && teardown !== this) {
          if (this.closed) {
            execFinalizer(teardown);
          } else {
            if (teardown instanceof Subscription2) {
              if (teardown.closed || teardown._hasParent(this)) {
                return;
              }
              teardown._addParent(this);
            }
            (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
          }
        }
      };
      Subscription2.prototype._hasParent = function(parent) {
        var _parentage = this._parentage;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
      };
      Subscription2.prototype._addParent = function(parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      };
      Subscription2.prototype._removeParent = function(parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
          this._parentage = null;
        } else if (Array.isArray(_parentage)) {
          arrRemove_1.arrRemove(_parentage, parent);
        }
      };
      Subscription2.prototype.remove = function(teardown) {
        var _finalizers = this._finalizers;
        _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
        if (teardown instanceof Subscription2) {
          teardown._removeParent(this);
        }
      };
      Subscription2.EMPTY = function() {
        var empty = new Subscription2();
        empty.closed = true;
        return empty;
      }();
      return Subscription2;
    }();
    exports2.Subscription = Subscription;
    exports2.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    function isSubscription(value) {
      return value instanceof Subscription || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
    }
    exports2.isSubscription = isSubscription;
    function execFinalizer(finalizer) {
      if (isFunction_1.isFunction(finalizer)) {
        finalizer();
      } else {
        finalizer.unsubscribe();
      }
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/config.js
var require_config = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.config = void 0;
    exports2.config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: void 0,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
var require_timeoutProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeoutProvider = void 0;
    exports2.timeoutProvider = {
      setTimeout: function(handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports2.timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout.apply(delegate, __spreadArray2([handler, timeout], __read2(args)));
        }
        return setTimeout.apply(void 0, __spreadArray2([handler, timeout], __read2(args)));
      },
      clearTimeout: function(handle) {
        var delegate = exports2.timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
var require_reportUnhandledError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportUnhandledError = void 0;
    var config_1 = require_config();
    var timeoutProvider_1 = require_timeoutProvider();
    function reportUnhandledError(err) {
      timeoutProvider_1.timeoutProvider.setTimeout(function() {
        var onUnhandledError = config_1.config.onUnhandledError;
        if (onUnhandledError) {
          onUnhandledError(err);
        } else {
          throw err;
        }
      });
    }
    exports2.reportUnhandledError = reportUnhandledError;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/noop.js
var require_noop2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/noop.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.noop = void 0;
    function noop2() {
    }
    exports2.noop = noop2;
  }
});

// node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
var require_NotificationFactories = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/NotificationFactories.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createNotification = exports2.nextNotification = exports2.errorNotification = exports2.COMPLETE_NOTIFICATION = void 0;
    exports2.COMPLETE_NOTIFICATION = function() {
      return createNotification("C", void 0, void 0);
    }();
    function errorNotification(error) {
      return createNotification("E", void 0, error);
    }
    exports2.errorNotification = errorNotification;
    function nextNotification(value) {
      return createNotification("N", value, void 0);
    }
    exports2.nextNotification = nextNotification;
    function createNotification(kind, value, error) {
      return {
        kind,
        value,
        error
      };
    }
    exports2.createNotification = createNotification;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/errorContext.js
var require_errorContext = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/errorContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.captureError = exports2.errorContext = void 0;
    var config_1 = require_config();
    var context = null;
    function errorContext(cb) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context;
        if (isRoot) {
          context = { errorThrown: false, error: null };
        }
        cb();
        if (isRoot) {
          var _a = context, errorThrown = _a.errorThrown, error = _a.error;
          context = null;
          if (errorThrown) {
            throw error;
          }
        }
      } else {
        cb();
      }
    }
    exports2.errorContext = errorContext;
    function captureError(err) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
        context.errorThrown = true;
        context.error = err;
      }
    }
    exports2.captureError = captureError;
  }
});

// node_modules/rxjs/dist/cjs/internal/Subscriber.js
var require_Subscriber = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subscriber.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EMPTY_OBSERVER = exports2.SafeSubscriber = exports2.Subscriber = void 0;
    var isFunction_1 = require_isFunction2();
    var Subscription_1 = require_Subscription();
    var config_1 = require_config();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var noop_1 = require_noop2();
    var NotificationFactories_1 = require_NotificationFactories();
    var timeoutProvider_1 = require_timeoutProvider();
    var errorContext_1 = require_errorContext();
    var Subscriber = function(_super) {
      __extends2(Subscriber2, _super);
      function Subscriber2(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
          _this.destination = destination;
          if (Subscription_1.isSubscription(destination)) {
            destination.add(_this);
          }
        } else {
          _this.destination = exports2.EMPTY_OBSERVER;
        }
        return _this;
      }
      Subscriber2.create = function(next, error, complete) {
        return new SafeSubscriber(next, error, complete);
      };
      Subscriber2.prototype.next = function(value) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
        } else {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
          this.destination = null;
        }
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      };
      Subscriber2.prototype._complete = function() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      };
      return Subscriber2;
    }(Subscription_1.Subscription);
    exports2.Subscriber = Subscriber;
    var _bind = Function.prototype.bind;
    function bind2(fn, thisArg) {
      return _bind.call(fn, thisArg);
    }
    var ConsumerObserver = function() {
      function ConsumerObserver2(partialObserver) {
        this.partialObserver = partialObserver;
      }
      ConsumerObserver2.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      ConsumerObserver2.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error) {
            handleUnhandledError(error);
          }
        } else {
          handleUnhandledError(err);
        }
      };
      ConsumerObserver2.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      return ConsumerObserver2;
    }();
    var SafeSubscriber = function(_super) {
      __extends2(SafeSubscriber2, _super);
      function SafeSubscriber2(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error !== null && error !== void 0 ? error : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          var context_1;
          if (_this && config_1.config.useDeprecatedNextContext) {
            context_1 = Object.create(observerOrNext);
            context_1.unsubscribe = function() {
              return _this.unsubscribe();
            };
            partialObserver = {
              next: observerOrNext.next && bind2(observerOrNext.next, context_1),
              error: observerOrNext.error && bind2(observerOrNext.error, context_1),
              complete: observerOrNext.complete && bind2(observerOrNext.complete, context_1)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
      }
      return SafeSubscriber2;
    }(Subscriber);
    exports2.SafeSubscriber = SafeSubscriber;
    function handleUnhandledError(error) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        errorContext_1.captureError(error);
      } else {
        reportUnhandledError_1.reportUnhandledError(error);
      }
    }
    function defaultErrorHandler(err) {
      throw err;
    }
    function handleStoppedNotification(notification, subscriber) {
      var onStoppedNotification = config_1.config.onStoppedNotification;
      onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
        return onStoppedNotification(notification, subscriber);
      });
    }
    exports2.EMPTY_OBSERVER = {
      closed: true,
      next: noop_1.noop,
      error: defaultErrorHandler,
      complete: noop_1.noop
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/symbol/observable.js
var require_observable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/symbol/observable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observable = void 0;
    exports2.observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/identity.js
var require_identity = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/identity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.identity = void 0;
    function identity(x) {
      return x;
    }
    exports2.identity = identity;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/pipe.js
var require_pipe = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/pipe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pipeFromArray = exports2.pipe = void 0;
    var identity_1 = require_identity();
    function pipe() {
      var fns = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
      }
      return pipeFromArray(fns);
    }
    exports2.pipe = pipe;
    function pipeFromArray(fns) {
      if (fns.length === 0) {
        return identity_1.identity;
      }
      if (fns.length === 1) {
        return fns[0];
      }
      return function piped(input) {
        return fns.reduce(function(prev, fn) {
          return fn(prev);
        }, input);
      };
    }
    exports2.pipeFromArray = pipeFromArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/Observable.js
var require_Observable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Observable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Observable = void 0;
    var Subscriber_1 = require_Subscriber();
    var Subscription_1 = require_Subscription();
    var observable_1 = require_observable();
    var pipe_1 = require_pipe();
    var config_1 = require_config();
    var isFunction_1 = require_isFunction2();
    var errorContext_1 = require_errorContext();
    var Observable2 = function() {
      function Observable3(subscribe) {
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable3.prototype.lift = function(operator) {
        var observable = new Observable3();
        observable.source = this;
        observable.operator = operator;
        return observable;
      };
      Observable3.prototype.subscribe = function(observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);
        errorContext_1.errorContext(function() {
          var _a = _this, operator = _a.operator, source = _a.source;
          subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
        });
        return subscriber;
      };
      Observable3.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      };
      Observable3.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscriber = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscriber.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
          _this.subscribe(subscriber);
        });
      };
      Observable3.prototype._subscribe = function(subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
      };
      Observable3.prototype[observable_1.observable] = function() {
        return this;
      };
      Observable3.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        return pipe_1.pipeFromArray(operations)(this);
      };
      Observable3.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x) {
            return value = x;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable3.create = function(subscribe) {
        return new Observable3(subscribe);
      };
      return Observable3;
    }();
    exports2.Observable = Observable2;
    function getPromiseCtor(promiseCtor) {
      var _a;
      return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
    }
    function isObserver(value) {
      return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
    }
    function isSubscriber(value) {
      return value && value instanceof Subscriber_1.Subscriber || isObserver(value) && Subscription_1.isSubscription(value);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/lift.js
var require_lift = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/lift.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.operate = exports2.hasLift = void 0;
    var isFunction_1 = require_isFunction2();
    function hasLift(source) {
      return isFunction_1.isFunction(source === null || source === void 0 ? void 0 : source.lift);
    }
    exports2.hasLift = hasLift;
    function operate(init) {
      return function(source) {
        if (hasLift(source)) {
          return source.lift(function(liftedSource) {
            try {
              return init(liftedSource, this);
            } catch (err) {
              this.error(err);
            }
          });
        }
        throw new TypeError("Unable to lift unknown Observable type");
      };
    }
    exports2.operate = operate;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
var require_OperatorSubscriber = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OperatorSubscriber = exports2.createOperatorSubscriber = void 0;
    var Subscriber_1 = require_Subscriber();
    function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
      return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
    }
    exports2.createOperatorSubscriber = createOperatorSubscriber;
    var OperatorSubscriber = function(_super) {
      __extends2(OperatorSubscriber2, _super);
      function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext ? function(value) {
          try {
            onNext(value);
          } catch (err) {
            destination.error(err);
          }
        } : _super.prototype._next;
        _this._error = onError ? function(err) {
          try {
            onError(err);
          } catch (err2) {
            destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._error;
        _this._complete = onComplete ? function() {
          try {
            onComplete();
          } catch (err) {
            destination.error(err);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._complete;
        return _this;
      }
      OperatorSubscriber2.prototype.unsubscribe = function() {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          var closed_1 = this.closed;
          _super.prototype.unsubscribe.call(this);
          !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        }
      };
      return OperatorSubscriber2;
    }(Subscriber_1.Subscriber);
    exports2.OperatorSubscriber = OperatorSubscriber;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/refCount.js
var require_refCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/refCount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.refCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function refCount() {
      return lift_1.operate(function(source, subscriber) {
        var connection = null;
        source._refCount++;
        var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
          if (!source || source._refCount <= 0 || 0 < --source._refCount) {
            connection = null;
            return;
          }
          var sharedConnection = source._connection;
          var conn = connection;
          connection = null;
          if (sharedConnection && (!conn || sharedConnection === conn)) {
            sharedConnection.unsubscribe();
          }
          subscriber.unsubscribe();
        });
        source.subscribe(refCounter);
        if (!refCounter.closed) {
          connection = source.connect();
        }
      });
    }
    exports2.refCount = refCount;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
var require_ConnectableObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectableObservable = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var refCount_1 = require_refCount();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    var ConnectableObservable = function(_super) {
      __extends2(ConnectableObservable2, _super);
      function ConnectableObservable2(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._subject = null;
        _this._refCount = 0;
        _this._connection = null;
        if (lift_1.hasLift(source)) {
          _this.lift = source.lift;
        }
        return _this;
      }
      ConnectableObservable2.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable2.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable2.prototype._teardown = function() {
        this._refCount = 0;
        var _connection = this._connection;
        this._subject = this._connection = null;
        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
      };
      ConnectableObservable2.prototype.connect = function() {
        var _this = this;
        var connection = this._connection;
        if (!connection) {
          connection = this._connection = new Subscription_1.Subscription();
          var subject_1 = this.getSubject();
          connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, void 0, function() {
            _this._teardown();
            subject_1.complete();
          }, function(err) {
            _this._teardown();
            subject_1.error(err);
          }, function() {
            return _this._teardown();
          })));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription_1.Subscription.EMPTY;
          }
        }
        return connection;
      };
      ConnectableObservable2.prototype.refCount = function() {
        return refCount_1.refCount()(this);
      };
      return ConnectableObservable2;
    }(Observable_1.Observable);
    exports2.ConnectableObservable = ConnectableObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
var require_performanceTimestampProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.performanceTimestampProvider = void 0;
    exports2.performanceTimestampProvider = {
      now: function() {
        return (exports2.performanceTimestampProvider.delegate || performance).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
var require_animationFrameProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.animationFrameProvider = void 0;
    var Subscription_1 = require_Subscription();
    exports2.animationFrameProvider = {
      schedule: function(callback) {
        var request = requestAnimationFrame;
        var cancel = cancelAnimationFrame;
        var delegate = exports2.animationFrameProvider.delegate;
        if (delegate) {
          request = delegate.requestAnimationFrame;
          cancel = delegate.cancelAnimationFrame;
        }
        var handle = request(function(timestamp2) {
          cancel = void 0;
          callback(timestamp2);
        });
        return new Subscription_1.Subscription(function() {
          return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
        });
      },
      requestAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports2.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray2([], __read2(args)));
      },
      cancelAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports2.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray2([], __read2(args)));
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
var require_animationFrames = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.animationFrames = void 0;
    var Observable_1 = require_Observable();
    var performanceTimestampProvider_1 = require_performanceTimestampProvider();
    var animationFrameProvider_1 = require_animationFrameProvider();
    function animationFrames(timestampProvider) {
      return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
    }
    exports2.animationFrames = animationFrames;
    function animationFramesFactory(timestampProvider) {
      return new Observable_1.Observable(function(subscriber) {
        var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
        var start = provider.now();
        var id = 0;
        var run = function() {
          if (!subscriber.closed) {
            id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp2) {
              id = 0;
              var now = provider.now();
              subscriber.next({
                timestamp: timestampProvider ? now : timestamp2,
                elapsed: now - start
              });
              run();
            });
          }
        };
        run();
        return function() {
          if (id) {
            animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
          }
        };
      });
    }
    var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ObjectUnsubscribedError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
      return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = "ObjectUnsubscribedError";
        this.message = "object unsubscribed";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/Subject.js
var require_Subject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subject.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __values2 = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnonymousSubject = exports2.Subject = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    var arrRemove_1 = require_arrRemove();
    var errorContext_1 = require_errorContext();
    var Subject2 = function(_super) {
      __extends2(Subject3, _super);
      function Subject3() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject3.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject3.prototype._throwIfClosed = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
      };
      Subject3.prototype.next = function(value) {
        var _this = this;
        errorContext_1.errorContext(function() {
          var e_1, _a;
          _this._throwIfClosed();
          if (!_this.isStopped) {
            if (!_this.currentObservers) {
              _this.currentObservers = Array.from(_this.observers);
            }
            try {
              for (var _b = __values2(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var observer = _c.value;
                observer.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b.return))
                  _a.call(_b);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
        });
      };
      Subject3.prototype.error = function(err) {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.hasError = _this.isStopped = true;
            _this.thrownError = err;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().error(err);
            }
          }
        });
      };
      Subject3.prototype.complete = function() {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.isStopped = true;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().complete();
            }
          }
        });
      };
      Subject3.prototype.unsubscribe = function() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
      };
      Object.defineProperty(Subject3.prototype, "observed", {
        get: function() {
          var _a;
          return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
      });
      Subject3.prototype._trySubscribe = function(subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
      };
      Subject3.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
      };
      Subject3.prototype._innerSubscribe = function(subscriber) {
        var _this = this;
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        if (hasError || isStopped) {
          return Subscription_1.EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new Subscription_1.Subscription(function() {
          _this.currentObservers = null;
          arrRemove_1.arrRemove(observers, subscriber);
        });
      };
      Subject3.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped) {
          subscriber.complete();
        }
      };
      Subject3.prototype.asObservable = function() {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
      };
      Subject3.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject3;
    }(Observable_1.Observable);
    exports2.Subject = Subject2;
    var AnonymousSubject = function(_super) {
      __extends2(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
      };
      AnonymousSubject2.prototype.error = function(err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
      };
      AnonymousSubject2.prototype.complete = function() {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
      };
      return AnonymousSubject2;
    }(Subject2);
    exports2.AnonymousSubject = AnonymousSubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
var require_BehaviorSubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BehaviorSubject = void 0;
    var Subject_1 = require_Subject();
    var BehaviorSubject = function(_super) {
      __extends2(BehaviorSubject2, _super);
      function BehaviorSubject2(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject2.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: false,
        configurable: true
      });
      BehaviorSubject2.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
      };
      BehaviorSubject2.prototype.getValue = function() {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) {
          throw thrownError;
        }
        this._throwIfClosed();
        return _value;
      };
      BehaviorSubject2.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject2;
    }(Subject_1.Subject);
    exports2.BehaviorSubject = BehaviorSubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
var require_dateTimestampProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dateTimestampProvider = void 0;
    exports2.dateTimestampProvider = {
      now: function() {
        return (exports2.dateTimestampProvider.delegate || Date).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
var require_ReplaySubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/ReplaySubject.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReplaySubject = void 0;
    var Subject_1 = require_Subject();
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var ReplaySubject = function(_super) {
      __extends2(ReplaySubject2, _super);
      function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
        if (_bufferSize === void 0) {
          _bufferSize = Infinity;
        }
        if (_windowTime === void 0) {
          _windowTime = Infinity;
        }
        if (_timestampProvider === void 0) {
          _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
        }
        var _this = _super.call(this) || this;
        _this._bufferSize = _bufferSize;
        _this._windowTime = _windowTime;
        _this._timestampProvider = _timestampProvider;
        _this._buffer = [];
        _this._infiniteTimeWindow = true;
        _this._infiniteTimeWindow = _windowTime === Infinity;
        _this._bufferSize = Math.max(1, _bufferSize);
        _this._windowTime = Math.max(1, _windowTime);
        return _this;
      }
      ReplaySubject2.prototype.next = function(value) {
        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
        if (!isStopped) {
          _buffer.push(value);
          !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        var subscription = this._innerSubscribe(subscriber);
        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
        var copy = _buffer.slice();
        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
          subscriber.next(copy[i]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
      };
      ReplaySubject2.prototype._trimBuffer = function() {
        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
          var now = _timestampProvider.now();
          var last = 0;
          for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
            last = i;
          }
          last && _buffer.splice(0, last + 1);
        }
      };
      return ReplaySubject2;
    }(Subject_1.Subject);
    exports2.ReplaySubject = ReplaySubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
var require_AsyncSubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/AsyncSubject.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncSubject = void 0;
    var Subject_1 = require_Subject();
    var AsyncSubject = function(_super) {
      __extends2(AsyncSubject2, _super);
      function AsyncSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._value = null;
        _this._hasValue = false;
        _this._isComplete = false;
        return _this;
      }
      AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped || _isComplete) {
          _hasValue && subscriber.next(_value);
          subscriber.complete();
        }
      };
      AsyncSubject2.prototype.next = function(value) {
        if (!this.isStopped) {
          this._value = value;
          this._hasValue = true;
        }
      };
      AsyncSubject2.prototype.complete = function() {
        var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
        if (!_isComplete) {
          this._isComplete = true;
          _hasValue && _super.prototype.next.call(this, _value);
          _super.prototype.complete.call(this);
        }
      };
      return AsyncSubject2;
    }(Subject_1.Subject);
    exports2.AsyncSubject = AsyncSubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
var require_Action2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/Action.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Action = void 0;
    var Subscription_1 = require_Subscription();
    var Action = function(_super) {
      __extends2(Action2, _super);
      function Action2(scheduler, work) {
        return _super.call(this) || this;
      }
      Action2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return this;
      };
      return Action2;
    }(Subscription_1.Subscription);
    exports2.Action = Action;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
var require_intervalProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.intervalProvider = void 0;
    exports2.intervalProvider = {
      setInterval: function(handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports2.intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
          return delegate.setInterval.apply(delegate, __spreadArray2([handler, timeout], __read2(args)));
        }
        return setInterval.apply(void 0, __spreadArray2([handler, timeout], __read2(args)));
      },
      clearInterval: function(handle) {
        var delegate = exports2.intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
var require_AsyncAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncAction = void 0;
    var Action_1 = require_Action2();
    var intervalProvider_1 = require_intervalProvider();
    var arrRemove_1 = require_arrRemove();
    var AsyncAction = function(_super) {
      __extends2(AsyncAction2, _super);
      function AsyncAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction2.prototype.schedule = function(state, delay) {
        var _a;
        if (delay === void 0) {
          delay = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
      };
      AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null && this.delay === delay && this.pending === false) {
          return id;
        }
        if (id != null) {
          intervalProvider_1.intervalProvider.clearInterval(id);
        }
        return void 0;
      };
      AsyncAction2.prototype.execute = function(state, delay) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state, _delay) {
        var errored = false;
        var errorValue;
        try {
          this.work(state);
        } catch (e) {
          errored = true;
          errorValue = e ? e : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype.unsubscribe = function() {
        if (!this.closed) {
          var _a = this, id = _a.id, scheduler = _a.scheduler;
          var actions = scheduler.actions;
          this.work = this.state = this.scheduler = null;
          this.pending = false;
          arrRemove_1.arrRemove(actions, this);
          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
          }
          this.delay = null;
          _super.prototype.unsubscribe.call(this);
        }
      };
      return AsyncAction2;
    }(Action_1.Action);
    exports2.AsyncAction = AsyncAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/Immediate.js
var require_Immediate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/Immediate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TestTools = exports2.Immediate = void 0;
    var nextHandle = 1;
    var resolved;
    var activeHandles = {};
    function findAndClearHandle(handle) {
      if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
      }
      return false;
    }
    exports2.Immediate = {
      setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        if (!resolved) {
          resolved = Promise.resolve();
        }
        resolved.then(function() {
          return findAndClearHandle(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function(handle) {
        findAndClearHandle(handle);
      }
    };
    exports2.TestTools = {
      pending: function() {
        return Object.keys(activeHandles).length;
      }
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
var require_immediateProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.immediateProvider = void 0;
    var Immediate_1 = require_Immediate();
    var setImmediate2 = Immediate_1.Immediate.setImmediate;
    var clearImmediate2 = Immediate_1.Immediate.clearImmediate;
    exports2.immediateProvider = {
      setImmediate: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports2.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate2).apply(void 0, __spreadArray2([], __read2(args)));
      },
      clearImmediate: function(handle) {
        var delegate = exports2.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate2)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
var require_AsapAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsapAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var immediateProvider_1 = require_immediateProvider();
    var AsapAction = function(_super) {
      __extends2(AsapAction2, _super);
      function AsapAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay !== null && delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
      };
      AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        var _a;
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null ? delay > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        var actions = scheduler.actions;
        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
          immediateProvider_1.immediateProvider.clearImmediate(id);
          scheduler._scheduled = void 0;
        }
        return void 0;
      };
      return AsapAction2;
    }(AsyncAction_1.AsyncAction);
    exports2.AsapAction = AsapAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/Scheduler.js
var require_Scheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Scheduler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Scheduler = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var Scheduler = function() {
      function Scheduler2(schedulerActionCtor, now) {
        if (now === void 0) {
          now = Scheduler2.now;
        }
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
      }
      Scheduler2.prototype.schedule = function(work, delay, state) {
        if (delay === void 0) {
          delay = 0;
        }
        return new this.schedulerActionCtor(this, work).schedule(state, delay);
      };
      Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
      return Scheduler2;
    }();
    exports2.Scheduler = Scheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
var require_AsyncScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncScheduler = void 0;
    var Scheduler_1 = require_Scheduler();
    var AsyncScheduler = function(_super) {
      __extends2(AsyncScheduler2, _super);
      function AsyncScheduler2(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler_1.Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, now) || this;
        _this.actions = [];
        _this._active = false;
        return _this;
      }
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this._active) {
          actions.push(action);
          return;
        }
        var error;
        this._active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this._active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsyncScheduler2;
    }(Scheduler_1.Scheduler);
    exports2.AsyncScheduler = AsyncScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
var require_AsapScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsapScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AsapScheduler = function(_super) {
      __extends2(AsapScheduler2, _super);
      function AsapScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AsapScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsapScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports2.AsapScheduler = AsapScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
var require_asap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/asap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.asap = exports2.asapScheduler = void 0;
    var AsapAction_1 = require_AsapAction();
    var AsapScheduler_1 = require_AsapScheduler();
    exports2.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
    exports2.asap = exports2.asapScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/async.js
var require_async = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.async = exports2.asyncScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var AsyncScheduler_1 = require_AsyncScheduler();
    exports2.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
    exports2.async = exports2.asyncScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
var require_QueueAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueueAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var QueueAction = function(_super) {
      __extends2(QueueAction2, _super);
      function QueueAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      QueueAction2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay > 0) {
          return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      };
      QueueAction2.prototype.execute = function(state, delay) {
        return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
      };
      QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null && delay > 0 || delay == null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.flush(this);
        return 0;
      };
      return QueueAction2;
    }(AsyncAction_1.AsyncAction);
    exports2.QueueAction = QueueAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
var require_QueueScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueueScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var QueueScheduler = function(_super) {
      __extends2(QueueScheduler2, _super);
      function QueueScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports2.QueueScheduler = QueueScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
var require_queue = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/queue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.queue = exports2.queueScheduler = void 0;
    var QueueAction_1 = require_QueueAction();
    var QueueScheduler_1 = require_QueueScheduler();
    exports2.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
    exports2.queue = exports2.queueScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
var require_AnimationFrameAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnimationFrameAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var animationFrameProvider_1 = require_animationFrameProvider();
    var AnimationFrameAction = function(_super) {
      __extends2(AnimationFrameAction2, _super);
      function AnimationFrameAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay !== null && delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
          return scheduler.flush(void 0);
        }));
      };
      AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        var _a;
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null ? delay > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        var actions = scheduler.actions;
        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
          scheduler._scheduled = void 0;
        }
        return void 0;
      };
      return AnimationFrameAction2;
    }(AsyncAction_1.AsyncAction);
    exports2.AnimationFrameAction = AnimationFrameAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
var require_AnimationFrameScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnimationFrameScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AnimationFrameScheduler = function(_super) {
      __extends2(AnimationFrameScheduler2, _super);
      function AnimationFrameScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnimationFrameScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AnimationFrameScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports2.AnimationFrameScheduler = AnimationFrameScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
var require_animationFrame = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.animationFrame = exports2.animationFrameScheduler = void 0;
    var AnimationFrameAction_1 = require_AnimationFrameAction();
    var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
    exports2.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
    exports2.animationFrame = exports2.animationFrameScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
var require_VirtualTimeScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VirtualAction = exports2.VirtualTimeScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var Subscription_1 = require_Subscription();
    var AsyncScheduler_1 = require_AsyncScheduler();
    var VirtualTimeScheduler = function(_super) {
      __extends2(VirtualTimeScheduler2, _super);
      function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
        if (schedulerActionCtor === void 0) {
          schedulerActionCtor = VirtualAction;
        }
        if (maxFrames === void 0) {
          maxFrames = Infinity;
        }
        var _this = _super.call(this, schedulerActionCtor, function() {
          return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      VirtualTimeScheduler2.prototype.flush = function() {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error;
        var action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        }
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      VirtualTimeScheduler2.frameTimeFactor = 10;
      return VirtualTimeScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports2.VirtualTimeScheduler = VirtualTimeScheduler;
    var VirtualAction = function(_super) {
      __extends2(VirtualAction2, _super);
      function VirtualAction2(scheduler, work, index) {
        if (index === void 0) {
          index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
      }
      VirtualAction2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (Number.isFinite(delay)) {
          if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
          }
          this.active = false;
          var action = new VirtualAction2(this.scheduler, this.work);
          this.add(action);
          return action.schedule(state, delay);
        } else {
          return Subscription_1.Subscription.EMPTY;
        }
      };
      VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction2.sortActions);
        return 1;
      };
      VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return void 0;
      };
      VirtualAction2.prototype._execute = function(state, delay) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state, delay);
        }
      };
      VirtualAction2.sortActions = function(a, b) {
        if (a.delay === b.delay) {
          if (a.index === b.index) {
            return 0;
          } else if (a.index > b.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a.delay > b.delay) {
          return 1;
        } else {
          return -1;
        }
      };
      return VirtualAction2;
    }(AsyncAction_1.AsyncAction);
    exports2.VirtualAction = VirtualAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/empty.js
var require_empty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/empty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.empty = exports2.EMPTY = void 0;
    var Observable_1 = require_Observable();
    exports2.EMPTY = new Observable_1.Observable(function(subscriber) {
      return subscriber.complete();
    });
    function empty(scheduler) {
      return scheduler ? emptyScheduled(scheduler) : exports2.EMPTY;
    }
    exports2.empty = empty;
    function emptyScheduled(scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        return scheduler.schedule(function() {
          return subscriber.complete();
        });
      });
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
var require_isScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isScheduler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isScheduler = void 0;
    var isFunction_1 = require_isFunction2();
    function isScheduler(value) {
      return value && isFunction_1.isFunction(value.schedule);
    }
    exports2.isScheduler = isScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/args.js
var require_args = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/args.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.popNumber = exports2.popScheduler = exports2.popResultSelector = void 0;
    var isFunction_1 = require_isFunction2();
    var isScheduler_1 = require_isScheduler();
    function last(arr) {
      return arr[arr.length - 1];
    }
    function popResultSelector(args) {
      return isFunction_1.isFunction(last(args)) ? args.pop() : void 0;
    }
    exports2.popResultSelector = popResultSelector;
    function popScheduler(args) {
      return isScheduler_1.isScheduler(last(args)) ? args.pop() : void 0;
    }
    exports2.popScheduler = popScheduler;
    function popNumber(args, defaultValue) {
      return typeof last(args) === "number" ? args.pop() : defaultValue;
    }
    exports2.popNumber = popNumber;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isArrayLike = void 0;
    exports2.isArrayLike = function(x) {
      return x && typeof x.length === "number" && typeof x !== "function";
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPromise = void 0;
    var isFunction_1 = require_isFunction2();
    function isPromise(value) {
      return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);
    }
    exports2.isPromise = isPromise;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
var require_isInteropObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isInteropObservable = void 0;
    var observable_1 = require_observable();
    var isFunction_1 = require_isFunction2();
    function isInteropObservable(input) {
      return isFunction_1.isFunction(input[observable_1.observable]);
    }
    exports2.isInteropObservable = isInteropObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsyncIterable = void 0;
    var isFunction_1 = require_isFunction2();
    function isAsyncIterable(obj) {
      return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
    }
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
var require_throwUnobservableError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createInvalidObservableTypeError = void 0;
    function createInvalidObservableTypeError(input) {
      return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
    }
    exports2.createInvalidObservableTypeError = createInvalidObservableTypeError;
  }
});

// node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
var require_iterator = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/symbol/iterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.iterator = exports2.getSymbolIterator = void 0;
    function getSymbolIterator() {
      if (typeof Symbol !== "function" || !Symbol.iterator) {
        return "@@iterator";
      }
      return Symbol.iterator;
    }
    exports2.getSymbolIterator = getSymbolIterator;
    exports2.iterator = getSymbolIterator();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isIterable.js
var require_isIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isIterable = void 0;
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction2();
    function isIterable(input) {
      return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);
    }
    exports2.isIterable = isIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
var require_isReadableStreamLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js"(exports2) {
    "use strict";
    var __generator2 = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __await2 = exports2 && exports2.__await || function(v) {
      return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
    };
    var __asyncGenerator2 = exports2 && exports2.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle2(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle2(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle2(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isReadableStreamLike = exports2.readableStreamLikeToAsyncGenerator = void 0;
    var isFunction_1 = require_isFunction2();
    function readableStreamLikeToAsyncGenerator(readableStream) {
      return __asyncGenerator2(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
        var reader, _a, value, done;
        return __generator2(this, function(_b) {
          switch (_b.label) {
            case 0:
              reader = readableStream.getReader();
              _b.label = 1;
            case 1:
              _b.trys.push([1, , 9, 10]);
              _b.label = 2;
            case 2:
              if (false)
                return [3, 8];
              return [4, __await2(reader.read())];
            case 3:
              _a = _b.sent(), value = _a.value, done = _a.done;
              if (!done)
                return [3, 5];
              return [4, __await2(void 0)];
            case 4:
              return [2, _b.sent()];
            case 5:
              return [4, __await2(value)];
            case 6:
              return [4, _b.sent()];
            case 7:
              _b.sent();
              return [3, 2];
            case 8:
              return [3, 10];
            case 9:
              reader.releaseLock();
              return [7];
            case 10:
              return [2];
          }
        });
      });
    }
    exports2.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
    function isReadableStreamLike(obj) {
      return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
    }
    exports2.isReadableStreamLike = isReadableStreamLike;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
var require_innerFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __asyncValues2 = exports2 && exports2.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle2(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle2(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    var __values2 = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromReadableStreamLike = exports2.fromAsyncIterable = exports2.fromIterable = exports2.fromPromise = exports2.fromArrayLike = exports2.fromInteropObservable = exports2.innerFrom = void 0;
    var isArrayLike_1 = require_isArrayLike();
    var isPromise_1 = require_isPromise();
    var Observable_1 = require_Observable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isIterable_1 = require_isIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var isFunction_1 = require_isFunction2();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var observable_1 = require_observable();
    function innerFrom(input) {
      if (input instanceof Observable_1.Observable) {
        return input;
      }
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return fromInteropObservable(input);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return fromArrayLike(input);
        }
        if (isPromise_1.isPromise(input)) {
          return fromPromise(input);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return fromAsyncIterable(input);
        }
        if (isIterable_1.isIterable(input)) {
          return fromIterable(input);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return fromReadableStreamLike(input);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports2.innerFrom = innerFrom;
    function fromInteropObservable(obj) {
      return new Observable_1.Observable(function(subscriber) {
        var obs = obj[observable_1.observable]();
        if (isFunction_1.isFunction(obs.subscribe)) {
          return obs.subscribe(subscriber);
        }
        throw new TypeError("Provided object does not correctly implement Symbol.observable");
      });
    }
    exports2.fromInteropObservable = fromInteropObservable;
    function fromArrayLike(array) {
      return new Observable_1.Observable(function(subscriber) {
        for (var i = 0; i < array.length && !subscriber.closed; i++) {
          subscriber.next(array[i]);
        }
        subscriber.complete();
      });
    }
    exports2.fromArrayLike = fromArrayLike;
    function fromPromise(promise) {
      return new Observable_1.Observable(function(subscriber) {
        promise.then(function(value) {
          if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
          }
        }, function(err) {
          return subscriber.error(err);
        }).then(null, reportUnhandledError_1.reportUnhandledError);
      });
    }
    exports2.fromPromise = fromPromise;
    function fromIterable(iterable) {
      return new Observable_1.Observable(function(subscriber) {
        var e_1, _a;
        try {
          for (var iterable_1 = __values2(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
            var value = iterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
              _a.call(iterable_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        subscriber.complete();
      });
    }
    exports2.fromIterable = fromIterable;
    function fromAsyncIterable(asyncIterable) {
      return new Observable_1.Observable(function(subscriber) {
        process2(asyncIterable, subscriber).catch(function(err) {
          return subscriber.error(err);
        });
      });
    }
    exports2.fromAsyncIterable = fromAsyncIterable;
    function fromReadableStreamLike(readableStream) {
      return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
    }
    exports2.fromReadableStreamLike = fromReadableStreamLike;
    function process2(asyncIterable, subscriber) {
      var asyncIterable_1, asyncIterable_1_1;
      var e_2, _a;
      return __awaiter2(this, void 0, void 0, function() {
        var value, e_2_1;
        return __generator2(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 5, 6, 11]);
              asyncIterable_1 = __asyncValues2(asyncIterable);
              _b.label = 1;
            case 1:
              return [4, asyncIterable_1.next()];
            case 2:
              if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
                return [3, 4];
              value = asyncIterable_1_1.value;
              subscriber.next(value);
              if (subscriber.closed) {
                return [2];
              }
              _b.label = 3;
            case 3:
              return [3, 1];
            case 4:
              return [3, 11];
            case 5:
              e_2_1 = _b.sent();
              e_2 = { error: e_2_1 };
              return [3, 11];
            case 6:
              _b.trys.push([6, , 9, 10]);
              if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
                return [3, 8];
              return [4, _a.call(asyncIterable_1)];
            case 7:
              _b.sent();
              _b.label = 8;
            case 8:
              return [3, 10];
            case 9:
              if (e_2)
                throw e_2.error;
              return [7];
            case 10:
              return [7];
            case 11:
              subscriber.complete();
              return [2];
          }
        });
      });
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
var require_executeSchedule = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.executeSchedule = void 0;
    function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
      if (delay === void 0) {
        delay = 0;
      }
      if (repeat === void 0) {
        repeat = false;
      }
      var scheduleSubscription = scheduler.schedule(function() {
        work();
        if (repeat) {
          parentSubscription.add(this.schedule(null, delay));
        } else {
          this.unsubscribe();
        }
      }, delay);
      parentSubscription.add(scheduleSubscription);
      if (!repeat) {
        return scheduleSubscription;
      }
    }
    exports2.executeSchedule = executeSchedule;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
var require_observeOn = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/observeOn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observeOn = void 0;
    var executeSchedule_1 = require_executeSchedule();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function observeOn(scheduler, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.next(value);
          }, delay);
        }, function() {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.complete();
          }, delay);
        }, function(err) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.error(err);
          }, delay);
        }));
      });
    }
    exports2.observeOn = observeOn;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
var require_subscribeOn = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.subscribeOn = void 0;
    var lift_1 = require_lift();
    function subscribeOn(scheduler, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        subscriber.add(scheduler.schedule(function() {
          return source.subscribe(subscriber);
        }, delay));
      });
    }
    exports2.subscribeOn = subscribeOn;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleObservable = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function scheduleObservable(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports2.scheduleObservable = scheduleObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.schedulePromise = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function schedulePromise(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports2.schedulePromise = schedulePromise;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleArray = void 0;
    var Observable_1 = require_Observable();
    function scheduleArray(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var i = 0;
        return scheduler.schedule(function() {
          if (i === input.length) {
            subscriber.complete();
          } else {
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
              this.schedule();
            }
          }
        });
      });
    }
    exports2.scheduleArray = scheduleArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleIterable = void 0;
    var Observable_1 = require_Observable();
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction2();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleIterable(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var iterator;
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          iterator = input[iterator_1.iterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            var _a;
            var value;
            var done;
            try {
              _a = iterator.next(), value = _a.value, done = _a.done;
            } catch (err) {
              subscriber.error(err);
              return;
            }
            if (done) {
              subscriber.complete();
            } else {
              subscriber.next(value);
            }
          }, 0, true);
        });
        return function() {
          return isFunction_1.isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();
        };
      });
    }
    exports2.scheduleIterable = scheduleIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
var require_scheduleAsyncIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleAsyncIterable = void 0;
    var Observable_1 = require_Observable();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleAsyncIterable(input, scheduler) {
      if (!input) {
        throw new Error("Iterable cannot be null");
      }
      return new Observable_1.Observable(function(subscriber) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          var iterator = input[Symbol.asyncIterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            iterator.next().then(function(result) {
              if (result.done) {
                subscriber.complete();
              } else {
                subscriber.next(result.value);
              }
            });
          }, 0, true);
        });
      });
    }
    exports2.scheduleAsyncIterable = scheduleAsyncIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
var require_scheduleReadableStreamLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleReadableStreamLike = void 0;
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    function scheduleReadableStreamLike(input, scheduler) {
      return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
    }
    exports2.scheduleReadableStreamLike = scheduleReadableStreamLike;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
var require_scheduled = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduled = void 0;
    var scheduleObservable_1 = require_scheduleObservable();
    var schedulePromise_1 = require_schedulePromise();
    var scheduleArray_1 = require_scheduleArray();
    var scheduleIterable_1 = require_scheduleIterable();
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isPromise_1 = require_isPromise();
    var isArrayLike_1 = require_isArrayLike();
    var isIterable_1 = require_isIterable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
    function scheduled(input, scheduler) {
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return scheduleObservable_1.scheduleObservable(input, scheduler);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return scheduleArray_1.scheduleArray(input, scheduler);
        }
        if (isPromise_1.isPromise(input)) {
          return schedulePromise_1.schedulePromise(input, scheduler);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
        }
        if (isIterable_1.isIterable(input)) {
          return scheduleIterable_1.scheduleIterable(input, scheduler);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports2.scheduled = scheduled;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/from.js
var require_from = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/from.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.from = void 0;
    var scheduled_1 = require_scheduled();
    var innerFrom_1 = require_innerFrom();
    function from(input, scheduler) {
      return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
    }
    exports2.from = from;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/of.js
var require_of = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/of.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.of = void 0;
    var args_1 = require_args();
    var from_1 = require_from();
    function of2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return from_1.from(args, scheduler);
    }
    exports2.of = of2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/throwError.js
var require_throwError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/throwError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throwError = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction2();
    function throwError(errorOrErrorFactory, scheduler) {
      var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
        return errorOrErrorFactory;
      };
      var init = function(subscriber) {
        return subscriber.error(errorFactory());
      };
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        return scheduler.schedule(init, 0, subscriber);
      } : init);
    }
    exports2.throwError = throwError;
  }
});

// node_modules/rxjs/dist/cjs/internal/Notification.js
var require_Notification = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Notification.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observeNotification = exports2.Notification = exports2.NotificationKind = void 0;
    var empty_1 = require_empty();
    var of_1 = require_of();
    var throwError_1 = require_throwError();
    var isFunction_1 = require_isFunction2();
    var NotificationKind;
    (function(NotificationKind2) {
      NotificationKind2["NEXT"] = "N";
      NotificationKind2["ERROR"] = "E";
      NotificationKind2["COMPLETE"] = "C";
    })(NotificationKind = exports2.NotificationKind || (exports2.NotificationKind = {}));
    var Notification = function() {
      function Notification2(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
      }
      Notification2.prototype.observe = function(observer) {
        return observeNotification(this, observer);
      };
      Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
      };
      Notification2.prototype.accept = function(nextOrObserver, error, complete) {
        var _a;
        return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
      };
      Notification2.prototype.toObservable = function() {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
          return error;
        }) : kind === "C" ? empty_1.EMPTY : 0;
        if (!result) {
          throw new TypeError("Unexpected notification kind " + kind);
        }
        return result;
      };
      Notification2.createNext = function(value) {
        return new Notification2("N", value);
      };
      Notification2.createError = function(err) {
        return new Notification2("E", void 0, err);
      };
      Notification2.createComplete = function() {
        return Notification2.completeNotification;
      };
      Notification2.completeNotification = new Notification2("C");
      return Notification2;
    }();
    exports2.Notification = Notification;
    function observeNotification(notification, observer) {
      var _a, _b, _c;
      var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
      if (typeof kind !== "string") {
        throw new TypeError('Invalid notification, missing "kind"');
      }
      kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
    }
    exports2.observeNotification = observeNotification;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isObservable.js
var require_isObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isObservable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isObservable = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction2();
    function isObservable(obj) {
      return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
    }
    exports2.isObservable = isObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
var require_EmptyError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/EmptyError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EmptyError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
      return function EmptyErrorImpl() {
        _super(this);
        this.name = "EmptyError";
        this.message = "no elements in sequence";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
var require_lastValueFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/lastValueFrom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.lastValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    function lastValueFrom2(source, config) {
      var hasConfig = typeof config === "object";
      return new Promise(function(resolve, reject) {
        var _hasValue = false;
        var _value;
        source.subscribe({
          next: function(value) {
            _value = value;
            _hasValue = true;
          },
          error: reject,
          complete: function() {
            if (_hasValue) {
              resolve(_value);
            } else if (hasConfig) {
              resolve(config.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
      });
    }
    exports2.lastValueFrom = lastValueFrom2;
  }
});

// node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
var require_firstValueFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/firstValueFrom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.firstValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    var Subscriber_1 = require_Subscriber();
    function firstValueFrom(source, config) {
      var hasConfig = typeof config === "object";
      return new Promise(function(resolve, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            resolve(value);
            subscriber.unsubscribe();
          },
          error: reject,
          complete: function() {
            if (hasConfig) {
              resolve(config.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
        source.subscribe(subscriber);
      });
    }
    exports2.firstValueFrom = firstValueFrom;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArgumentOutOfRangeError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
      return function ArgumentOutOfRangeErrorImpl() {
        _super(this);
        this.name = "ArgumentOutOfRangeError";
        this.message = "argument out of range";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
var require_NotFoundError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotFoundError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
      return function NotFoundErrorImpl(message) {
        _super(this);
        this.name = "NotFoundError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
var require_SequenceError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/SequenceError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SequenceError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
      return function SequenceErrorImpl(message) {
        _super(this);
        this.name = "SequenceError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isDate.js
var require_isDate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isDate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidDate = void 0;
    function isValidDate(value) {
      return value instanceof Date && !isNaN(value);
    }
    exports2.isValidDate = isValidDate;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeout.js
var require_timeout = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeout = exports2.TimeoutError = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var createErrorClass_1 = require_createErrorClass();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    exports2.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
      return function TimeoutErrorImpl(info) {
        if (info === void 0) {
          info = null;
        }
        _super(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        this.info = info;
      };
    });
    function timeout(config, schedulerArg) {
      var _a = isDate_1.isValidDate(config) ? { first: config } : typeof config === "number" ? { each: config } : config, first = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
      if (first == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return lift_1.operate(function(source, subscriber) {
        var originalSourceSubscription;
        var timerSubscription;
        var lastValue = null;
        var seen = 0;
        var startTimer = function(delay) {
          timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            try {
              originalSourceSubscription.unsubscribe();
              innerFrom_1.innerFrom(_with({
                meta,
                lastValue,
                seen
              })).subscribe(subscriber);
            } catch (err) {
              subscriber.error(err);
            }
          }, delay);
        };
        originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          seen++;
          subscriber.next(lastValue = value);
          each > 0 && startTimer(each);
        }, void 0, void 0, function() {
          if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          }
          lastValue = null;
        }));
        !seen && startTimer(first != null ? typeof first === "number" ? first : +first - scheduler.now() : each);
      });
    }
    exports2.timeout = timeout;
    function timeoutErrorFactory(info) {
      throw new exports2.TimeoutError(info);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/map.js
var require_map = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.map = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function map(project, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(project.call(thisArg, value, index++));
        }));
      });
    }
    exports2.map = map;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
var require_mapOneOrManyArgs = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapOneOrManyArgs = void 0;
    var map_1 = require_map();
    var isArray2 = Array.isArray;
    function callOrApply(fn, args) {
      return isArray2(args) ? fn.apply(void 0, __spreadArray2([], __read2(args))) : fn(args);
    }
    function mapOneOrManyArgs(fn) {
      return map_1.map(function(args) {
        return callOrApply(fn, args);
      });
    }
    exports2.mapOneOrManyArgs = mapOneOrManyArgs;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
var require_bindCallbackInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bindCallbackInternals = void 0;
    var isScheduler_1 = require_isScheduler();
    var Observable_1 = require_Observable();
    var subscribeOn_1 = require_subscribeOn();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var observeOn_1 = require_observeOn();
    var AsyncSubject_1 = require_AsyncSubject();
    function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
      if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
          scheduler = resultSelector;
        } else {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
          };
        }
      }
      if (scheduler) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
        };
      }
      return function() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var subject = new AsyncSubject_1.AsyncSubject();
        var uninitialized = true;
        return new Observable_1.Observable(function(subscriber) {
          var subs = subject.subscribe(subscriber);
          if (uninitialized) {
            uninitialized = false;
            var isAsync_1 = false;
            var isComplete_1 = false;
            callbackFunc.apply(_this, __spreadArray2(__spreadArray2([], __read2(args)), [
              function() {
                var results = [];
                for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                  results[_i2] = arguments[_i2];
                }
                if (isNodeStyle) {
                  var err = results.shift();
                  if (err != null) {
                    subject.error(err);
                    return;
                  }
                }
                subject.next(1 < results.length ? results : results[0]);
                isComplete_1 = true;
                if (isAsync_1) {
                  subject.complete();
                }
              }
            ]));
            if (isComplete_1) {
              subject.complete();
            }
            isAsync_1 = true;
          }
          return subs;
        });
      };
    }
    exports2.bindCallbackInternals = bindCallbackInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
var require_bindCallback = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bindCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindCallback(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
    }
    exports2.bindCallback = bindCallback;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
var require_bindNodeCallback = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bindNodeCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
    }
    exports2.bindNodeCallback = bindNodeCallback;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
var require_argsArgArrayOrObject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.argsArgArrayOrObject = void 0;
    var isArray2 = Array.isArray;
    var getPrototypeOf2 = Object.getPrototypeOf;
    var objectProto = Object.prototype;
    var getKeys = Object.keys;
    function argsArgArrayOrObject(args) {
      if (args.length === 1) {
        var first_1 = args[0];
        if (isArray2(first_1)) {
          return { args: first_1, keys: null };
        }
        if (isPOJO(first_1)) {
          var keys = getKeys(first_1);
          return {
            args: keys.map(function(key) {
              return first_1[key];
            }),
            keys
          };
        }
      }
      return { args, keys: null };
    }
    exports2.argsArgArrayOrObject = argsArgArrayOrObject;
    function isPOJO(obj) {
      return obj && typeof obj === "object" && getPrototypeOf2(obj) === objectProto;
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/createObject.js
var require_createObject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/createObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createObject = void 0;
    function createObject(keys, values) {
      return keys.reduce(function(result, key, i) {
        return result[key] = values[i], result;
      }, {});
    }
    exports2.createObject = createObject;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
var require_combineLatest = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineLatestInit = exports2.combineLatest = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var from_1 = require_from();
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var args_1 = require_args();
    var createObject_1 = require_createObject();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    function combineLatest() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var resultSelector = args_1.popResultSelector(args);
      var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
      if (observables.length === 0) {
        return from_1.from([], scheduler);
      }
      var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
        return createObject_1.createObject(keys, values);
      } : identity_1.identity));
      return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
    }
    exports2.combineLatest = combineLatest;
    function combineLatestInit(observables, scheduler, valueTransform) {
      if (valueTransform === void 0) {
        valueTransform = identity_1.identity;
      }
      return function(subscriber) {
        maybeSchedule(scheduler, function() {
          var length = observables.length;
          var values = new Array(length);
          var active = length;
          var remainingFirstValues = length;
          var _loop_1 = function(i2) {
            maybeSchedule(scheduler, function() {
              var source = from_1.from(observables[i2], scheduler);
              var hasFirstValue = false;
              source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                values[i2] = value;
                if (!hasFirstValue) {
                  hasFirstValue = true;
                  remainingFirstValues--;
                }
                if (!remainingFirstValues) {
                  subscriber.next(valueTransform(values.slice()));
                }
              }, function() {
                if (!--active) {
                  subscriber.complete();
                }
              }));
            }, subscriber);
          };
          for (var i = 0; i < length; i++) {
            _loop_1(i);
          }
        }, subscriber);
      };
    }
    exports2.combineLatestInit = combineLatestInit;
    function maybeSchedule(scheduler, execute, subscription) {
      if (scheduler) {
        executeSchedule_1.executeSchedule(subscription, scheduler, execute);
      } else {
        execute();
      }
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
var require_mergeInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeInternals = void 0;
    var innerFrom_1 = require_innerFrom();
    var executeSchedule_1 = require_executeSchedule();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
      var buffer = [];
      var active = 0;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        if (isComplete && !buffer.length && !active) {
          subscriber.complete();
        }
      };
      var outerNext = function(value) {
        return active < concurrent ? doInnerSub(value) : buffer.push(value);
      };
      var doInnerSub = function(value) {
        expand && subscriber.next(value);
        active++;
        var innerComplete = false;
        innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
          if (expand) {
            outerNext(innerValue);
          } else {
            subscriber.next(innerValue);
          }
        }, function() {
          innerComplete = true;
        }, void 0, function() {
          if (innerComplete) {
            try {
              active--;
              var _loop_1 = function() {
                var bufferedValue = buffer.shift();
                if (innerSubScheduler) {
                  executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                    return doInnerSub(bufferedValue);
                  });
                } else {
                  doInnerSub(bufferedValue);
                }
              };
              while (buffer.length && active < concurrent) {
                _loop_1();
              }
              checkComplete();
            } catch (err) {
              subscriber.error(err);
            }
          }
        }));
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
        isComplete = true;
        checkComplete();
      }));
      return function() {
        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
      };
    }
    exports2.mergeInternals = mergeInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
var require_mergeMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeMap = void 0;
    var map_1 = require_map();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    var isFunction_1 = require_isFunction2();
    function mergeMap(project, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap(function(a, i) {
          return map_1.map(function(b, ii) {
            return resultSelector(a, b, i, ii);
          })(innerFrom_1.innerFrom(project(a, i)));
        }, concurrent);
      } else if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
      });
    }
    exports2.mergeMap = mergeMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
var require_mergeAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeAll = void 0;
    var mergeMap_1 = require_mergeMap();
    var identity_1 = require_identity();
    function mergeAll(concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return mergeMap_1.mergeMap(identity_1.identity, concurrent);
    }
    exports2.mergeAll = mergeAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
var require_concatAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatAll = void 0;
    var mergeAll_1 = require_mergeAll();
    function concatAll() {
      return mergeAll_1.mergeAll(1);
    }
    exports2.concatAll = concatAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/concat.js
var require_concat = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/concat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concat = void 0;
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function concat() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
    }
    exports2.concat = concat;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/defer.js
var require_defer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/defer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defer = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    function defer(observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
      });
    }
    exports2.defer = defer;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/connectable.js
var require_connectable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/connectable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.connectable = void 0;
    var Subject_1 = require_Subject();
    var Observable_1 = require_Observable();
    var defer_1 = require_defer();
    var DEFAULT_CONFIG = {
      connector: function() {
        return new Subject_1.Subject();
      },
      resetOnDisconnect: true
    };
    function connectable(source, config) {
      if (config === void 0) {
        config = DEFAULT_CONFIG;
      }
      var connection = null;
      var connector = config.connector, _a = config.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
      var subject = connector();
      var result = new Observable_1.Observable(function(subscriber) {
        return subject.subscribe(subscriber);
      });
      result.connect = function() {
        if (!connection || connection.closed) {
          connection = defer_1.defer(function() {
            return source;
          }).subscribe(subject);
          if (resetOnDisconnect) {
            connection.add(function() {
              return subject = connector();
            });
          }
        }
        return connection;
      };
      return result;
    }
    exports2.connectable = connectable;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
var require_forkJoin = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forkJoin = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var innerFrom_1 = require_innerFrom();
    var args_1 = require_args();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var createObject_1 = require_createObject();
    function forkJoin() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
      var result = new Observable_1.Observable(function(subscriber) {
        var length = sources.length;
        if (!length) {
          subscriber.complete();
          return;
        }
        var values = new Array(length);
        var remainingCompletions = length;
        var remainingEmissions = length;
        var _loop_1 = function(sourceIndex2) {
          var hasValue = false;
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (!hasValue) {
              hasValue = true;
              remainingEmissions--;
            }
            values[sourceIndex2] = value;
          }, function() {
            return remainingCompletions--;
          }, void 0, function() {
            if (!remainingCompletions || !hasValue) {
              if (!remainingEmissions) {
                subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
              }
              subscriber.complete();
            }
          }));
        };
        for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
          _loop_1(sourceIndex);
        }
      });
      return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
    }
    exports2.forkJoin = forkJoin;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
var require_fromEvent = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromEvent = void 0;
    var innerFrom_1 = require_innerFrom();
    var Observable_1 = require_Observable();
    var mergeMap_1 = require_mergeMap();
    var isArrayLike_1 = require_isArrayLike();
    var isFunction_1 = require_isFunction2();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var nodeEventEmitterMethods = ["addListener", "removeListener"];
    var eventTargetMethods = ["addEventListener", "removeEventListener"];
    var jqueryMethods = ["on", "off"];
    function fromEvent2(target, eventName, options, resultSelector) {
      if (isFunction_1.isFunction(options)) {
        resultSelector = options;
        options = void 0;
      }
      if (resultSelector) {
        return fromEvent2(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      var _a = __read2(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler, options);
        };
      }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
      if (!add) {
        if (isArrayLike_1.isArrayLike(target)) {
          return mergeMap_1.mergeMap(function(subTarget) {
            return fromEvent2(subTarget, eventName, options);
          })(innerFrom_1.innerFrom(target));
        }
      }
      if (!add) {
        throw new TypeError("Invalid event target");
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return subscriber.next(1 < args.length ? args : args[0]);
        };
        add(handler);
        return function() {
          return remove(handler);
        };
      });
    }
    exports2.fromEvent = fromEvent2;
    function toCommonHandlerRegistry(target, eventName) {
      return function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler);
        };
      };
    }
    function isNodeStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
    }
    function isJQueryStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
    }
    function isEventTarget(target) {
      return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
var require_fromEventPattern = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromEventPattern = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction2();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    function fromEventPattern(addHandler, removeHandler, resultSelector) {
      if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var e = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            e[_i] = arguments[_i];
          }
          return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue = addHandler(handler);
        return isFunction_1.isFunction(removeHandler) ? function() {
          return removeHandler(handler, retValue);
        } : void 0;
      });
    }
    exports2.fromEventPattern = fromEventPattern;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/generate.js
var require_generate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/generate.js"(exports2) {
    "use strict";
    var __generator2 = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generate = void 0;
    var identity_1 = require_identity();
    var isScheduler_1 = require_isScheduler();
    var defer_1 = require_defer();
    var scheduleIterable_1 = require_scheduleIterable();
    function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
      var _a, _b;
      var resultSelector;
      var initialState;
      if (arguments.length === 1) {
        _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1.identity : _b, scheduler = _a.scheduler;
      } else {
        initialState = initialStateOrOptions;
        if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
          resultSelector = identity_1.identity;
          scheduler = resultSelectorOrScheduler;
        } else {
          resultSelector = resultSelectorOrScheduler;
        }
      }
      function gen() {
        var state;
        return __generator2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              state = initialState;
              _a2.label = 1;
            case 1:
              if (!(!condition || condition(state)))
                return [3, 4];
              return [4, resultSelector(state)];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              state = iterate(state);
              return [3, 1];
            case 4:
              return [2];
          }
        });
      }
      return defer_1.defer(scheduler ? function() {
        return scheduleIterable_1.scheduleIterable(gen(), scheduler);
      } : gen);
    }
    exports2.generate = generate;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/iif.js
var require_iif = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/iif.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.iif = void 0;
    var defer_1 = require_defer();
    function iif(condition, trueResult, falseResult) {
      return defer_1.defer(function() {
        return condition() ? trueResult : falseResult;
      });
    }
    exports2.iif = iif;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/timer.js
var require_timer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/timer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timer = void 0;
    var Observable_1 = require_Observable();
    var async_1 = require_async();
    var isScheduler_1 = require_isScheduler();
    var isDate_1 = require_isDate();
    function timer(dueTime, intervalOrScheduler, scheduler) {
      if (dueTime === void 0) {
        dueTime = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.async;
      }
      var intervalDuration = -1;
      if (intervalOrScheduler != null) {
        if (isScheduler_1.isScheduler(intervalOrScheduler)) {
          scheduler = intervalOrScheduler;
        } else {
          intervalDuration = intervalOrScheduler;
        }
      }
      return new Observable_1.Observable(function(subscriber) {
        var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
        if (due < 0) {
          due = 0;
        }
        var n = 0;
        return scheduler.schedule(function() {
          if (!subscriber.closed) {
            subscriber.next(n++);
            if (0 <= intervalDuration) {
              this.schedule(void 0, intervalDuration);
            } else {
              subscriber.complete();
            }
          }
        }, due);
      });
    }
    exports2.timer = timer;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/interval.js
var require_interval = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/interval.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.interval = void 0;
    var async_1 = require_async();
    var timer_1 = require_timer();
    function interval(period, scheduler) {
      if (period === void 0) {
        period = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      if (period < 0) {
        period = 0;
      }
      return timer_1.timer(period, period, scheduler);
    }
    exports2.interval = interval;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/merge.js
var require_merge = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/merge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var mergeAll_1 = require_mergeAll();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    var args_1 = require_args();
    var from_1 = require_from();
    function merge2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      var sources = args;
      return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
    }
    exports2.merge = merge2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/never.js
var require_never = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/never.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.never = exports2.NEVER = void 0;
    var Observable_1 = require_Observable();
    var noop_1 = require_noop2();
    exports2.NEVER = new Observable_1.Observable(noop_1.noop);
    function never() {
      return exports2.NEVER;
    }
    exports2.never = never;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
var require_argsOrArgArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.argsOrArgArray = void 0;
    var isArray2 = Array.isArray;
    function argsOrArgArray(args) {
      return args.length === 1 && isArray2(args[0]) ? args[0] : args;
    }
    exports2.argsOrArgArray = argsOrArgArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
var require_onErrorResumeNext = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.onErrorResumeNext = void 0;
    var Observable_1 = require_Observable();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop2();
    var innerFrom_1 = require_innerFrom();
    function onErrorResumeNext() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
      return new Observable_1.Observable(function(subscriber) {
        var sourceIndex = 0;
        var subscribeNext = function() {
          if (sourceIndex < nextSources.length) {
            var nextSource = void 0;
            try {
              nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
            } catch (err) {
              subscribeNext();
              return;
            }
            var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, void 0, noop_1.noop, noop_1.noop);
            nextSource.subscribe(innerSubscriber);
            innerSubscriber.add(subscribeNext);
          } else {
            subscriber.complete();
          }
        };
        subscribeNext();
      });
    }
    exports2.onErrorResumeNext = onErrorResumeNext;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/pairs.js
var require_pairs = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/pairs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pairs = void 0;
    var from_1 = require_from();
    function pairs(obj, scheduler) {
      return from_1.from(Object.entries(obj), scheduler);
    }
    exports2.pairs = pairs;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/not.js
var require_not = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.not = void 0;
    function not(pred, thisArg) {
      return function(value, index) {
        return !pred.call(thisArg, value, index);
      };
    }
    exports2.not = not;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/filter.js
var require_filter = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/filter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filter = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function filter2(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return predicate.call(thisArg, value, index++) && subscriber.next(value);
        }));
      });
    }
    exports2.filter = filter2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/partition.js
var require_partition = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/partition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.partition = void 0;
    var not_1 = require_not();
    var filter_1 = require_filter();
    var innerFrom_1 = require_innerFrom();
    function partition(source, predicate, thisArg) {
      return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
    }
    exports2.partition = partition;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/race.js
var require_race = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/race.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.raceInit = exports2.race = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function race() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      sources = argsOrArgArray_1.argsOrArgArray(sources);
      return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
    }
    exports2.race = race;
    function raceInit(sources) {
      return function(subscriber) {
        var subscriptions = [];
        var _loop_1 = function(i2) {
          subscriptions.push(innerFrom_1.innerFrom(sources[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (subscriptions) {
              for (var s = 0; s < subscriptions.length; s++) {
                s !== i2 && subscriptions[s].unsubscribe();
              }
              subscriptions = null;
            }
            subscriber.next(value);
          })));
        };
        for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
          _loop_1(i);
        }
      };
    }
    exports2.raceInit = raceInit;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/range.js
var require_range = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/range.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.range = void 0;
    var Observable_1 = require_Observable();
    var empty_1 = require_empty();
    function range(start, count, scheduler) {
      if (count == null) {
        count = start;
        start = 0;
      }
      if (count <= 0) {
        return empty_1.EMPTY;
      }
      var end = count + start;
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        var n = start;
        return scheduler.schedule(function() {
          if (n < end) {
            subscriber.next(n++);
            this.schedule();
          } else {
            subscriber.complete();
          }
        });
      } : function(subscriber) {
        var n = start;
        while (n < end && !subscriber.closed) {
          subscriber.next(n++);
        }
        subscriber.complete();
      });
    }
    exports2.range = range;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/using.js
var require_using = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/using.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.using = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    function using(resourceFactory, observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        var resource = resourceFactory();
        var result = observableFactory(resource);
        var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
        source.subscribe(subscriber);
        return function() {
          if (resource) {
            resource.unsubscribe();
          }
        };
      });
    }
    exports2.using = using;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/zip.js
var require_zip = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/zip.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zip = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var empty_1 = require_empty();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var args_1 = require_args();
    function zip() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var sources = argsOrArgArray_1.argsOrArgArray(args);
      return sources.length ? new Observable_1.Observable(function(subscriber) {
        var buffers = sources.map(function() {
          return [];
        });
        var completed = sources.map(function() {
          return false;
        });
        subscriber.add(function() {
          buffers = completed = null;
        });
        var _loop_1 = function(sourceIndex2) {
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            buffers[sourceIndex2].push(value);
            if (buffers.every(function(buffer) {
              return buffer.length;
            })) {
              var result = buffers.map(function(buffer) {
                return buffer.shift();
              });
              subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray2([], __read2(result))) : result);
              if (buffers.some(function(buffer, i) {
                return !buffer.length && completed[i];
              })) {
                subscriber.complete();
              }
            }
          }, function() {
            completed[sourceIndex2] = true;
            !buffers[sourceIndex2].length && subscriber.complete();
          }));
        };
        for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
          _loop_1(sourceIndex);
        }
        return function() {
          buffers = completed = null;
        };
      }) : empty_1.EMPTY;
    }
    exports2.zip = zip;
  }
});

// node_modules/rxjs/dist/cjs/internal/types.js
var require_types = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/audit.js
var require_audit = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/audit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.audit = void 0;
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function audit(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var isComplete = false;
        var endDuration = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
          isComplete && subscriber.complete();
        };
        var cleanupDuration = function() {
          durationSubscriber = null;
          isComplete && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
          if (!durationSubscriber) {
            innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
          }
        }, function() {
          isComplete = true;
          (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
        }));
      });
    }
    exports2.audit = audit;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
var require_auditTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/auditTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.auditTime = void 0;
    var async_1 = require_async();
    var audit_1 = require_audit();
    var timer_1 = require_timer();
    function auditTime(duration, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return audit_1.audit(function() {
        return timer_1.timer(duration, scheduler);
      });
    }
    exports2.auditTime = auditTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/buffer.js
var require_buffer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buffer = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop2();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function buffer(closingNotifier) {
      return lift_1.operate(function(source, subscriber) {
        var currentBuffer = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return currentBuffer.push(value);
        }, function() {
          subscriber.next(currentBuffer);
          subscriber.complete();
        }));
        innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          var b = currentBuffer;
          currentBuffer = [];
          subscriber.next(b);
        }, noop_1.noop));
        return function() {
          currentBuffer = null;
        };
      });
    }
    exports2.buffer = buffer;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
var require_bufferCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js"(exports2) {
    "use strict";
    var __values2 = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    function bufferCount(bufferSize, startBufferEvery) {
      if (startBufferEvery === void 0) {
        startBufferEvery = null;
      }
      startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        var count = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a, e_2, _b;
          var toEmit = null;
          if (count++ % startBufferEvery === 0) {
            buffers.push([]);
          }
          try {
            for (var buffers_1 = __values2(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer = buffers_1_1.value;
              buffer.push(value);
              if (bufferSize <= buffer.length) {
                toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                toEmit.push(buffer);
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
                _a.call(buffers_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          if (toEmit) {
            try {
              for (var toEmit_1 = __values2(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
                var buffer = toEmit_1_1.value;
                arrRemove_1.arrRemove(buffers, buffer);
                subscriber.next(buffer);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
                  _b.call(toEmit_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
        }, function() {
          var e_3, _a;
          try {
            for (var buffers_2 = __values2(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
              var buffer = buffers_2_1.value;
              subscriber.next(buffer);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
                _a.call(buffers_2);
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffers = null;
        }));
      });
    }
    exports2.bufferCount = bufferCount;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
var require_bufferTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js"(exports2) {
    "use strict";
    var __values2 = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferTime = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var async_1 = require_async();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function bufferTime(bufferTimeSpan) {
      var _a, _b;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
      var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
      var maxBufferSize2 = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var bufferRecords = [];
        var restartOnEmit = false;
        var emit = function(record) {
          var buffer = record.buffer, subs = record.subs;
          subs.unsubscribe();
          arrRemove_1.arrRemove(bufferRecords, record);
          subscriber.next(buffer);
          restartOnEmit && startBuffer();
        };
        var startBuffer = function() {
          if (bufferRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var buffer = [];
            var record_1 = {
              buffer,
              subs
            };
            bufferRecords.push(record_1);
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return emit(record_1);
            }, bufferTimeSpan);
          }
        };
        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
        } else {
          restartOnEmit = true;
        }
        startBuffer();
        var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a2;
          var recordsCopy = bufferRecords.slice();
          try {
            for (var recordsCopy_1 = __values2(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
              var record = recordsCopy_1_1.value;
              var buffer = record.buffer;
              buffer.push(value);
              maxBufferSize2 <= buffer.length && emit(record);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
                _a2.call(recordsCopy_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }, function() {
          while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
            subscriber.next(bufferRecords.shift().buffer);
          }
          bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
          subscriber.complete();
          subscriber.unsubscribe();
        }, void 0, function() {
          return bufferRecords = null;
        });
        source.subscribe(bufferTimeSubscriber);
      });
    }
    exports2.bufferTime = bufferTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
var require_bufferToggle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js"(exports2) {
    "use strict";
    var __values2 = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferToggle = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop2();
    var arrRemove_1 = require_arrRemove();
    function bufferToggle(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var buffer = [];
          buffers.push(buffer);
          var closingSubscription = new Subscription_1.Subscription();
          var emitBuffer = function() {
            arrRemove_1.arrRemove(buffers, buffer);
            subscriber.next(buffer);
            closingSubscription.unsubscribe();
          };
          closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          try {
            for (var buffers_1 = __values2(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer = buffers_1_1.value;
              buffer.push(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
                _a.call(buffers_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }, function() {
          while (buffers.length > 0) {
            subscriber.next(buffers.shift());
          }
          subscriber.complete();
        }));
      });
    }
    exports2.bufferToggle = bufferToggle;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
var require_bufferWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferWhen = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop2();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function bufferWhen(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffer = null;
        var closingSubscriber = null;
        var openBuffer = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          var b = buffer;
          buffer = [];
          b && subscriber.next(b);
          innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
        };
        openBuffer();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return buffer === null || buffer === void 0 ? void 0 : buffer.push(value);
        }, function() {
          buffer && subscriber.next(buffer);
          subscriber.complete();
        }, void 0, function() {
          return buffer = closingSubscriber = null;
        }));
      });
    }
    exports2.bufferWhen = bufferWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/catchError.js
var require_catchError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/catchError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.catchError = void 0;
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    function catchError(selector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub = null;
        var syncUnsub = false;
        var handledResult;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
          handledResult = innerFrom_1.innerFrom(selector(err, catchError(selector)(source)));
          if (innerSub) {
            innerSub.unsubscribe();
            innerSub = null;
            handledResult.subscribe(subscriber);
          } else {
            syncUnsub = true;
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        }
      });
    }
    exports2.catchError = catchError;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
var require_scanInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scanInternals = void 0;
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
      return function(source, subscriber) {
        var hasState = hasSeed;
        var state = seed;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i = index++;
          state = hasState ? accumulator(state, value, i) : (hasState = true, value);
          emitOnNext && subscriber.next(state);
        }, emitBeforeComplete && function() {
          hasState && subscriber.next(state);
          subscriber.complete();
        }));
      };
    }
    exports2.scanInternals = scanInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/reduce.js
var require_reduce = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/reduce.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reduce = void 0;
    var scanInternals_1 = require_scanInternals();
    var lift_1 = require_lift();
    function reduce(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
    }
    exports2.reduce = reduce;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/toArray.js
var require_toArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/toArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toArray = void 0;
    var reduce_1 = require_reduce();
    var lift_1 = require_lift();
    var arrReducer = function(arr, value) {
      return arr.push(value), arr;
    };
    function toArray2() {
      return lift_1.operate(function(source, subscriber) {
        reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
      });
    }
    exports2.toArray = toArray2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
var require_joinAllInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinAllInternals = void 0;
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var mergeMap_1 = require_mergeMap();
    var toArray_1 = require_toArray();
    function joinAllInternals(joinFn, project) {
      return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
        return joinFn(sources);
      }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
    }
    exports2.joinAllInternals = joinAllInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
var require_combineLatestAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineLatestAll = void 0;
    var combineLatest_1 = require_combineLatest();
    var joinAllInternals_1 = require_joinAllInternals();
    function combineLatestAll(project) {
      return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
    }
    exports2.combineLatestAll = combineLatestAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
var require_combineAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineAll = void 0;
    var combineLatestAll_1 = require_combineLatestAll();
    exports2.combineAll = combineLatestAll_1.combineLatestAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
var require_combineLatest2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineLatest = void 0;
    var combineLatest_1 = require_combineLatest();
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var args_1 = require_args();
    function combineLatest() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      return resultSelector ? pipe_1.pipe(combineLatest.apply(void 0, __spreadArray2([], __read2(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
        combineLatest_1.combineLatestInit(__spreadArray2([source], __read2(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
      });
    }
    exports2.combineLatest = combineLatest;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
var require_combineLatestWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineLatestWith = void 0;
    var combineLatest_1 = require_combineLatest2();
    function combineLatestWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return combineLatest_1.combineLatest.apply(void 0, __spreadArray2([], __read2(otherSources)));
    }
    exports2.combineLatestWith = combineLatestWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
var require_concatMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction2();
    function concatMap(project, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
    }
    exports2.concatMap = concatMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
var require_concatMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatMapTo = void 0;
    var concatMap_1 = require_concatMap();
    var isFunction_1 = require_isFunction2();
    function concatMapTo(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
        return innerObservable;
      }, resultSelector) : concatMap_1.concatMap(function() {
        return innerObservable;
      });
    }
    exports2.concatMapTo = concatMapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concat.js
var require_concat2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concat.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concat = void 0;
    var lift_1 = require_lift();
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function concat() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return lift_1.operate(function(source, subscriber) {
        concatAll_1.concatAll()(from_1.from(__spreadArray2([source], __read2(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports2.concat = concat;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
var require_concatWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatWith.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatWith = void 0;
    var concat_1 = require_concat2();
    function concatWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return concat_1.concat.apply(void 0, __spreadArray2([], __read2(otherSources)));
    }
    exports2.concatWith = concatWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
var require_fromSubscribable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromSubscribable = void 0;
    var Observable_1 = require_Observable();
    function fromSubscribable(subscribable) {
      return new Observable_1.Observable(function(subscriber) {
        return subscribable.subscribe(subscriber);
      });
    }
    exports2.fromSubscribable = fromSubscribable;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/connect.js
var require_connect2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/connect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.connect = void 0;
    var Subject_1 = require_Subject();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var fromSubscribable_1 = require_fromSubscribable();
    var DEFAULT_CONFIG = {
      connector: function() {
        return new Subject_1.Subject();
      }
    };
    function connect(selector, config) {
      if (config === void 0) {
        config = DEFAULT_CONFIG;
      }
      var connector = config.connector;
      return lift_1.operate(function(source, subscriber) {
        var subject = connector();
        innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
        subscriber.add(source.subscribe(subject));
      });
    }
    exports2.connect = connect;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/count.js
var require_count = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/count.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.count = void 0;
    var reduce_1 = require_reduce();
    function count(predicate) {
      return reduce_1.reduce(function(total, value, i) {
        return !predicate || predicate(value, i) ? total + 1 : total;
      }, 0);
    }
    exports2.count = count;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/debounce.js
var require_debounce = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/debounce.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.debounce = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop2();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function debounce(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var emit = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          hasValue = true;
          lastValue = value;
          durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
          innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = durationSubscriber = null;
        }));
      });
    }
    exports2.debounce = debounce;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
var require_debounceTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.debounceTime = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function debounceTime(dueTime, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var activeTask = null;
        var lastValue = null;
        var lastTime = null;
        var emit = function() {
          if (activeTask) {
            activeTask.unsubscribe();
            activeTask = null;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        function emitWhenIdle() {
          var targetTime = lastTime + dueTime;
          var now = scheduler.now();
          if (now < targetTime) {
            activeTask = this.schedule(void 0, targetTime - now);
            subscriber.add(activeTask);
            return;
          }
          emit();
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          lastValue = value;
          lastTime = scheduler.now();
          if (!activeTask) {
            activeTask = scheduler.schedule(emitWhenIdle, dueTime);
            subscriber.add(activeTask);
          }
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = activeTask = null;
        }));
      });
    }
    exports2.debounceTime = debounceTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
var require_defaultIfEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultIfEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function defaultIfEmpty(defaultValue) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          if (!hasValue) {
            subscriber.next(defaultValue);
          }
          subscriber.complete();
        }));
      });
    }
    exports2.defaultIfEmpty = defaultIfEmpty;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/take.js
var require_take = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/take.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.take = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function take(count) {
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (++seen <= count) {
            subscriber.next(value);
            if (count <= seen) {
              subscriber.complete();
            }
          }
        }));
      });
    }
    exports2.take = take;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
var require_ignoreElements = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ignoreElements = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop2();
    function ignoreElements() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
      });
    }
    exports2.ignoreElements = ignoreElements;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
var require_mapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mapTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapTo = void 0;
    var map_1 = require_map();
    function mapTo(value) {
      return map_1.map(function() {
        return value;
      });
    }
    exports2.mapTo = mapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
var require_delayWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.delayWhen = void 0;
    var concat_1 = require_concat();
    var take_1 = require_take();
    var ignoreElements_1 = require_ignoreElements();
    var mapTo_1 = require_mapTo();
    var mergeMap_1 = require_mergeMap();
    var innerFrom_1 = require_innerFrom();
    function delayWhen(delayDurationSelector, subscriptionDelay) {
      if (subscriptionDelay) {
        return function(source) {
          return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
        };
      }
      return mergeMap_1.mergeMap(function(value, index) {
        return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value));
      });
    }
    exports2.delayWhen = delayWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/delay.js
var require_delay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/delay.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.delay = void 0;
    var async_1 = require_async();
    var delayWhen_1 = require_delayWhen();
    var timer_1 = require_timer();
    function delay(due, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      var duration = timer_1.timer(due, scheduler);
      return delayWhen_1.delayWhen(function() {
        return duration;
      });
    }
    exports2.delay = delay;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
var require_dematerialize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dematerialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function dematerialize() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
          return Notification_1.observeNotification(notification, subscriber);
        }));
      });
    }
    exports2.dematerialize = dematerialize;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinct.js
var require_distinct = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinct.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.distinct = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop2();
    var innerFrom_1 = require_innerFrom();
    function distinct(keySelector, flushes) {
      return lift_1.operate(function(source, subscriber) {
        var distinctKeys = /* @__PURE__ */ new Set();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var key = keySelector ? keySelector(value) : value;
          if (!distinctKeys.has(key)) {
            distinctKeys.add(key);
            subscriber.next(value);
          }
        }));
        flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return distinctKeys.clear();
        }, noop_1.noop));
      });
    }
    exports2.distinct = distinct;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
var require_distinctUntilChanged = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.distinctUntilChanged = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function distinctUntilChanged(comparator, keySelector) {
      if (keySelector === void 0) {
        keySelector = identity_1.identity;
      }
      comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
      return lift_1.operate(function(source, subscriber) {
        var previousKey;
        var first = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var currentKey = keySelector(value);
          if (first || !comparator(previousKey, currentKey)) {
            first = false;
            previousKey = currentKey;
            subscriber.next(value);
          }
        }));
      });
    }
    exports2.distinctUntilChanged = distinctUntilChanged;
    function defaultCompare(a, b) {
      return a === b;
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
var require_distinctUntilKeyChanged = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.distinctUntilKeyChanged = void 0;
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    function distinctUntilKeyChanged(key, compare) {
      return distinctUntilChanged_1.distinctUntilChanged(function(x, y) {
        return compare ? compare(x[key], y[key]) : x[key] === y[key];
      });
    }
    exports2.distinctUntilKeyChanged = distinctUntilKeyChanged;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
var require_throwIfEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throwIfEmpty = void 0;
    var EmptyError_1 = require_EmptyError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function throwIfEmpty(errorFactory) {
      if (errorFactory === void 0) {
        errorFactory = defaultErrorFactory;
      }
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
        }));
      });
    }
    exports2.throwIfEmpty = throwIfEmpty;
    function defaultErrorFactory() {
      return new EmptyError_1.EmptyError();
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
var require_elementAt = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/elementAt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.elementAt = void 0;
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    var filter_1 = require_filter();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var take_1 = require_take();
    function elementAt(index, defaultValue) {
      if (index < 0) {
        throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
      }
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(filter_1.filter(function(v, i) {
          return i === index;
        }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }));
      };
    }
    exports2.elementAt = elementAt;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/endWith.js
var require_endWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/endWith.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.endWith = void 0;
    var concat_1 = require_concat();
    var of_1 = require_of();
    function endWith() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      return function(source) {
        return concat_1.concat(source, of_1.of.apply(void 0, __spreadArray2([], __read2(values))));
      };
    }
    exports2.endWith = endWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/every.js
var require_every = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/every.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.every = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function every(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (!predicate.call(thisArg, value, index++, source)) {
            subscriber.next(false);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports2.every = every;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
var require_exhaustMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exhaustMap = void 0;
    var map_1 = require_map();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function exhaustMap(project, resultSelector) {
      if (resultSelector) {
        return function(source) {
          return source.pipe(exhaustMap(function(a, i) {
            return innerFrom_1.innerFrom(project(a, i)).pipe(map_1.map(function(b, ii) {
              return resultSelector(a, b, i, ii);
            }));
          }));
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        var innerSub = null;
        var isComplete = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
          if (!innerSub) {
            innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
              innerSub = null;
              isComplete && subscriber.complete();
            });
            innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
          }
        }, function() {
          isComplete = true;
          !innerSub && subscriber.complete();
        }));
      });
    }
    exports2.exhaustMap = exhaustMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
var require_exhaustAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exhaustAll = void 0;
    var exhaustMap_1 = require_exhaustMap();
    var identity_1 = require_identity();
    function exhaustAll() {
      return exhaustMap_1.exhaustMap(identity_1.identity);
    }
    exports2.exhaustAll = exhaustAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
var require_exhaust = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaust.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exhaust = void 0;
    var exhaustAll_1 = require_exhaustAll();
    exports2.exhaust = exhaustAll_1.exhaustAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/expand.js
var require_expand = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/expand.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.expand = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function expand(project, concurrent, scheduler) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, void 0, true, scheduler);
      });
    }
    exports2.expand = expand;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/finalize.js
var require_finalize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/finalize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.finalize = void 0;
    var lift_1 = require_lift();
    function finalize(callback) {
      return lift_1.operate(function(source, subscriber) {
        try {
          source.subscribe(subscriber);
        } finally {
          subscriber.add(callback);
        }
      });
    }
    exports2.finalize = finalize;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/find.js
var require_find = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/find.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFind = exports2.find = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function find(predicate, thisArg) {
      return lift_1.operate(createFind(predicate, thisArg, "value"));
    }
    exports2.find = find;
    function createFind(predicate, thisArg, emit) {
      var findIndex = emit === "index";
      return function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i = index++;
          if (predicate.call(thisArg, value, i, source)) {
            subscriber.next(findIndex ? i : value);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(findIndex ? -1 : void 0);
          subscriber.complete();
        }));
      };
    }
    exports2.createFind = createFind;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
var require_findIndex = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/findIndex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findIndex = void 0;
    var lift_1 = require_lift();
    var find_1 = require_find();
    function findIndex(predicate, thisArg) {
      return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
    }
    exports2.findIndex = findIndex;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/first.js
var require_first = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/first.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.first = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var take_1 = require_take();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var identity_1 = require_identity();
    function first(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i) {
          return predicate(v, i, source);
        }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports2.first = first;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/groupBy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.groupBy = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function groupBy(keySelector, elementOrOptions, duration, connector) {
      return lift_1.operate(function(source, subscriber) {
        var element;
        if (!elementOrOptions || typeof elementOrOptions === "function") {
          element = elementOrOptions;
        } else {
          duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
        }
        var groups = /* @__PURE__ */ new Map();
        var notify = function(cb) {
          groups.forEach(cb);
          cb(subscriber);
        };
        var handleError = function(err) {
          return notify(function(consumer) {
            return consumer.error(err);
          });
        };
        var activeGroups = 0;
        var teardownAttempted = false;
        var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
          try {
            var key_1 = keySelector(value);
            var group_1 = groups.get(key_1);
            if (!group_1) {
              groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject());
              var grouped = createGroupedObservable(key_1, group_1);
              subscriber.next(grouped);
              if (duration) {
                var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                  group_1.complete();
                  durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                }, void 0, void 0, function() {
                  return groups.delete(key_1);
                });
                groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
              }
            }
            group_1.next(element ? element(value) : value);
          } catch (err) {
            handleError(err);
          }
        }, function() {
          return notify(function(consumer) {
            return consumer.complete();
          });
        }, handleError, function() {
          return groups.clear();
        }, function() {
          teardownAttempted = true;
          return activeGroups === 0;
        });
        source.subscribe(groupBySourceSubscriber);
        function createGroupedObservable(key, groupSubject) {
          var result = new Observable_1.Observable(function(groupSubscriber) {
            activeGroups++;
            var innerSub = groupSubject.subscribe(groupSubscriber);
            return function() {
              innerSub.unsubscribe();
              --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
            };
          });
          result.key = key;
          return result;
        }
      });
    }
    exports2.groupBy = groupBy;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function isEmpty() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          subscriber.next(false);
          subscriber.complete();
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports2.isEmpty = isEmpty;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
var require_takeLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeLast.js"(exports2) {
    "use strict";
    var __values2 = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.takeLast = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeLast(count) {
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var buffer = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          buffer.push(value);
          count < buffer.length && buffer.shift();
        }, function() {
          var e_1, _a;
          try {
            for (var buffer_1 = __values2(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
              var value = buffer_1_1.value;
              subscriber.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
                _a.call(buffer_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffer = null;
        }));
      });
    }
    exports2.takeLast = takeLast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/last.js
var require_last = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/last.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.last = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var takeLast_1 = require_takeLast();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var identity_1 = require_identity();
    function last(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i) {
          return predicate(v, i, source);
        }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports2.last = last;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/materialize.js
var require_materialize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/materialize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.materialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function materialize() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(Notification_1.Notification.createNext(value));
        }, function() {
          subscriber.next(Notification_1.Notification.createComplete());
          subscriber.complete();
        }, function(err) {
          subscriber.next(Notification_1.Notification.createError(err));
          subscriber.complete();
        }));
      });
    }
    exports2.materialize = materialize;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/max.js
var require_max = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/max.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.max = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction2();
    function max(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
        return comparer(x, y) > 0 ? x : y;
      } : function(x, y) {
        return x > y ? x : y;
      });
    }
    exports2.max = max;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
var require_flatMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/flatMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    exports2.flatMap = mergeMap_1.mergeMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
var require_mergeMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeMapTo = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction2();
    function mergeMapTo(innerObservable, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap_1.mergeMap(function() {
          return innerObservable;
        }, resultSelector, concurrent);
      }
      if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, concurrent);
    }
    exports2.mergeMapTo = mergeMapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
var require_mergeScan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeScan = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function mergeScan(accumulator, seed, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
          return accumulator(state, value, index);
        }, concurrent, function(value) {
          state = value;
        }, false, void 0, function() {
          return state = null;
        });
      });
    }
    exports2.mergeScan = mergeScan;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/merge.js
var require_merge2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/merge.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mergeAll_1 = require_mergeAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function merge2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      args = argsOrArgArray_1.argsOrArgArray(args);
      return lift_1.operate(function(source, subscriber) {
        mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray2([source], __read2(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports2.merge = merge2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
var require_mergeWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeWith = void 0;
    var merge_1 = require_merge2();
    function mergeWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return merge_1.merge.apply(void 0, __spreadArray2([], __read2(otherSources)));
    }
    exports2.mergeWith = mergeWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/min.js
var require_min = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/min.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.min = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction2();
    function min(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
        return comparer(x, y) < 0 ? x : y;
      } : function(x, y) {
        return x < y ? x : y;
      });
    }
    exports2.min = min;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/multicast.js
var require_multicast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/multicast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.multicast = void 0;
    var ConnectableObservable_1 = require_ConnectableObservable();
    var isFunction_1 = require_isFunction2();
    var connect_1 = require_connect2();
    function multicast(subjectOrSubjectFactory, selector) {
      var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
        return subjectOrSubjectFactory;
      };
      if (isFunction_1.isFunction(selector)) {
        return connect_1.connect(selector, {
          connector: subjectFactory
        });
      }
      return function(source) {
        return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
      };
    }
    exports2.multicast = multicast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
var require_onErrorResumeNextWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.onErrorResumeNext = exports2.onErrorResumeNextWith = void 0;
    var argsOrArgArray_1 = require_argsOrArgArray();
    var onErrorResumeNext_1 = require_onErrorResumeNext();
    function onErrorResumeNextWith() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
      return function(source) {
        return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray2([source], __read2(nextSources)));
      };
    }
    exports2.onErrorResumeNextWith = onErrorResumeNextWith;
    exports2.onErrorResumeNext = onErrorResumeNextWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
var require_pairwise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/pairwise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pairwise = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function pairwise() {
      return lift_1.operate(function(source, subscriber) {
        var prev;
        var hasPrev = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var p = prev;
          prev = value;
          hasPrev && subscriber.next([p, value]);
          hasPrev = true;
        }));
      });
    }
    exports2.pairwise = pairwise;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/pluck.js
var require_pluck = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/pluck.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pluck = void 0;
    var map_1 = require_map();
    function pluck() {
      var properties = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
      }
      var length = properties.length;
      if (length === 0) {
        throw new Error("list of properties cannot be empty.");
      }
      return map_1.map(function(x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
          var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
          if (typeof p !== "undefined") {
            currentProp = p;
          } else {
            return void 0;
          }
        }
        return currentProp;
      });
    }
    exports2.pluck = pluck;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publish.js
var require_publish = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publish.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publish = void 0;
    var Subject_1 = require_Subject();
    var multicast_1 = require_multicast();
    var connect_1 = require_connect2();
    function publish(selector) {
      return selector ? function(source) {
        return connect_1.connect(selector)(source);
      } : function(source) {
        return multicast_1.multicast(new Subject_1.Subject())(source);
      };
    }
    exports2.publish = publish;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
var require_publishBehavior = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publishBehavior = void 0;
    var BehaviorSubject_1 = require_BehaviorSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishBehavior(initialValue) {
      return function(source) {
        var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports2.publishBehavior = publishBehavior;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
var require_publishLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishLast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publishLast = void 0;
    var AsyncSubject_1 = require_AsyncSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishLast() {
      return function(source) {
        var subject = new AsyncSubject_1.AsyncSubject();
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports2.publishLast = publishLast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
var require_publishReplay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publishReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var multicast_1 = require_multicast();
    var isFunction_1 = require_isFunction2();
    function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
      if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
        timestampProvider = selectorOrScheduler;
      }
      var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
      return function(source) {
        return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
      };
    }
    exports2.publishReplay = publishReplay;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
var require_raceWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/raceWith.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.raceWith = void 0;
    var race_1 = require_race();
    var lift_1 = require_lift();
    var identity_1 = require_identity();
    function raceWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        race_1.raceInit(__spreadArray2([source], __read2(otherSources)))(subscriber);
      });
    }
    exports2.raceWith = raceWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/repeat.js
var require_repeat = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/repeat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.repeat = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var timer_1 = require_timer();
    function repeat(countOrConfig) {
      var _a;
      var count = Infinity;
      var delay;
      if (countOrConfig != null) {
        if (typeof countOrConfig === "object") {
          _a = countOrConfig.count, count = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay;
        } else {
          count = countOrConfig;
        }
      }
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var sourceSub;
        var resubscribe = function() {
          sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
          sourceSub = null;
          if (delay != null) {
            var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
            var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              subscribeToSource();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            subscribeToSource();
          }
        };
        var subscribeToSource = function() {
          var syncUnsub = false;
          sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            if (++soFar < count) {
              if (sourceSub) {
                resubscribe();
              } else {
                syncUnsub = true;
              }
            } else {
              subscriber.complete();
            }
          }));
          if (syncUnsub) {
            resubscribe();
          }
        };
        subscribeToSource();
      });
    }
    exports2.repeat = repeat;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
var require_repeatWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.repeatWhen = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function repeatWhen(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var completions$;
        var isNotifierComplete = false;
        var isMainComplete = false;
        var checkComplete = function() {
          return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
        };
        var getCompletionSubject = function() {
          if (!completions$) {
            completions$ = new Subject_1.Subject();
            innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              if (innerSub) {
                subscribeForRepeatWhen();
              } else {
                syncResub = true;
              }
            }, function() {
              isNotifierComplete = true;
              checkComplete();
            }));
          }
          return completions$;
        };
        var subscribeForRepeatWhen = function() {
          isMainComplete = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            isMainComplete = true;
            !checkComplete() && getCompletionSubject().next();
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRepeatWhen();
          }
        };
        subscribeForRepeatWhen();
      });
    }
    exports2.repeatWhen = repeatWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/retry.js
var require_retry = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/retry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retry = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    var timer_1 = require_timer();
    var innerFrom_1 = require_innerFrom();
    function retry(configOrCount) {
      if (configOrCount === void 0) {
        configOrCount = Infinity;
      }
      var config;
      if (configOrCount && typeof configOrCount === "object") {
        config = configOrCount;
      } else {
        config = {
          count: configOrCount
        };
      }
      var _a = config.count, count = _a === void 0 ? Infinity : _a, delay = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
      return count <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var innerSub;
        var subscribeForRetry = function() {
          var syncUnsub = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (resetOnSuccess) {
              soFar = 0;
            }
            subscriber.next(value);
          }, void 0, function(err) {
            if (soFar++ < count) {
              var resub_1 = function() {
                if (innerSub) {
                  innerSub.unsubscribe();
                  innerSub = null;
                  subscribeForRetry();
                } else {
                  syncUnsub = true;
                }
              };
              if (delay != null) {
                var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err, soFar));
                var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  notifierSubscriber_1.unsubscribe();
                  resub_1();
                }, function() {
                  subscriber.complete();
                });
                notifier.subscribe(notifierSubscriber_1);
              } else {
                resub_1();
              }
            } else {
              subscriber.error(err);
            }
          }));
          if (syncUnsub) {
            innerSub.unsubscribe();
            innerSub = null;
            subscribeForRetry();
          }
        };
        subscribeForRetry();
      });
    }
    exports2.retry = retry;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
var require_retryWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retryWhen = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function retryWhen(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var errors$;
        var subscribeForRetryWhen = function() {
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
            if (!errors$) {
              errors$ = new Subject_1.Subject();
              innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                return innerSub ? subscribeForRetryWhen() : syncResub = true;
              }));
            }
            if (errors$) {
              errors$.next(err);
            }
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRetryWhen();
          }
        };
        subscribeForRetryWhen();
      });
    }
    exports2.retryWhen = retryWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sample.js
var require_sample = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sample.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sample = void 0;
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var noop_1 = require_noop2();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function sample(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
        }));
        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        }, noop_1.noop));
      });
    }
    exports2.sample = sample;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
var require_sampleTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sampleTime = void 0;
    var async_1 = require_async();
    var sample_1 = require_sample();
    var interval_1 = require_interval();
    function sampleTime(period, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return sample_1.sample(interval_1.interval(period, scheduler));
    }
    exports2.sampleTime = sampleTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/scan.js
var require_scan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/scan.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scan = void 0;
    var lift_1 = require_lift();
    var scanInternals_1 = require_scanInternals();
    function scan(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
    }
    exports2.scan = scan;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
var require_sequenceEqual = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sequenceEqual = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function sequenceEqual(compareTo, comparator) {
      if (comparator === void 0) {
        comparator = function(a, b) {
          return a === b;
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var aState = createState();
        var bState = createState();
        var emit = function(isEqual) {
          subscriber.next(isEqual);
          subscriber.complete();
        };
        var createSubscriber = function(selfState, otherState) {
          var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
            var buffer = otherState.buffer, complete = otherState.complete;
            if (buffer.length === 0) {
              complete ? emit(false) : selfState.buffer.push(a);
            } else {
              !comparator(a, buffer.shift()) && emit(false);
            }
          }, function() {
            selfState.complete = true;
            var complete = otherState.complete, buffer = otherState.buffer;
            complete && emit(buffer.length === 0);
            sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
          });
          return sequenceEqualSubscriber;
        };
        source.subscribe(createSubscriber(aState, bState));
        innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
      });
    }
    exports2.sequenceEqual = sequenceEqual;
    function createState() {
      return {
        buffer: [],
        complete: false
      };
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/share.js
var require_share = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/share.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.share = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var Subscriber_1 = require_Subscriber();
    var lift_1 = require_lift();
    function share(options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.connector, connector = _a === void 0 ? function() {
        return new Subject_1.Subject();
      } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
      return function(wrapperSource) {
        var connection;
        var resetConnection;
        var subject;
        var refCount = 0;
        var hasCompleted = false;
        var hasErrored = false;
        var cancelReset = function() {
          resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
          resetConnection = void 0;
        };
        var reset = function() {
          cancelReset();
          connection = subject = void 0;
          hasCompleted = hasErrored = false;
        };
        var resetAndUnsubscribe = function() {
          var conn = connection;
          reset();
          conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
        };
        return lift_1.operate(function(source, subscriber) {
          refCount++;
          if (!hasErrored && !hasCompleted) {
            cancelReset();
          }
          var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
          subscriber.add(function() {
            refCount--;
            if (refCount === 0 && !hasErrored && !hasCompleted) {
              resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
            }
          });
          dest.subscribe(subscriber);
          if (!connection && refCount > 0) {
            connection = new Subscriber_1.SafeSubscriber({
              next: function(value) {
                return dest.next(value);
              },
              error: function(err) {
                hasErrored = true;
                cancelReset();
                resetConnection = handleReset(reset, resetOnError, err);
                dest.error(err);
              },
              complete: function() {
                hasCompleted = true;
                cancelReset();
                resetConnection = handleReset(reset, resetOnComplete);
                dest.complete();
              }
            });
            innerFrom_1.innerFrom(source).subscribe(connection);
          }
        })(wrapperSource);
      };
    }
    exports2.share = share;
    function handleReset(reset, on) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (on === true) {
        reset();
        return;
      }
      if (on === false) {
        return;
      }
      var onSubscriber = new Subscriber_1.SafeSubscriber({
        next: function() {
          onSubscriber.unsubscribe();
          reset();
        }
      });
      return innerFrom_1.innerFrom(on.apply(void 0, __spreadArray2([], __read2(args)))).subscribe(onSubscriber);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
var require_shareReplay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shareReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var share_1 = require_share();
    function shareReplay(configOrBufferSize, windowTime, scheduler) {
      var _a, _b, _c;
      var bufferSize;
      var refCount = false;
      if (configOrBufferSize && typeof configOrBufferSize === "object") {
        _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
      } else {
        bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
      }
      return share_1.share({
        connector: function() {
          return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
        },
        resetOnError: true,
        resetOnComplete: false,
        resetOnRefCountZero: refCount
      });
    }
    exports2.shareReplay = shareReplay;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/single.js
var require_single = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/single.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.single = void 0;
    var EmptyError_1 = require_EmptyError();
    var SequenceError_1 = require_SequenceError();
    var NotFoundError_1 = require_NotFoundError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function single(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var singleValue;
        var seenValue = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          seenValue = true;
          if (!predicate || predicate(value, index++, source)) {
            hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
            hasValue = true;
            singleValue = value;
          }
        }, function() {
          if (hasValue) {
            subscriber.next(singleValue);
            subscriber.complete();
          } else {
            subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
          }
        }));
      });
    }
    exports2.single = single;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skip.js
var require_skip = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skip.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.skip = void 0;
    var filter_1 = require_filter();
    function skip(count) {
      return filter_1.filter(function(_, index) {
        return count <= index;
      });
    }
    exports2.skip = skip;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
var require_skipLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipLast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.skipLast = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipLast(skipCount) {
      return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var ring = new Array(skipCount);
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var valueIndex = seen++;
          if (valueIndex < skipCount) {
            ring[valueIndex] = value;
          } else {
            var index = valueIndex % skipCount;
            var oldValue = ring[index];
            ring[index] = value;
            subscriber.next(oldValue);
          }
        }));
        return function() {
          ring = null;
        };
      });
    }
    exports2.skipLast = skipLast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
var require_skipUntil = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.skipUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop2();
    function skipUntil(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
          taking = true;
        }, noop_1.noop);
        innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return taking && subscriber.next(value);
        }));
      });
    }
    exports2.skipUntil = skipUntil;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
var require_skipWhile = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.skipWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipWhile(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
        }));
      });
    }
    exports2.skipWhile = skipWhile;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/startWith.js
var require_startWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/startWith.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.startWith = void 0;
    var concat_1 = require_concat();
    var args_1 = require_args();
    var lift_1 = require_lift();
    function startWith() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(values);
      return lift_1.operate(function(source, subscriber) {
        (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
      });
    }
    exports2.startWith = startWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
var require_switchMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.switchMap = void 0;
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function switchMap(project, resultSelector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSubscriber = null;
        var index = 0;
        var isComplete = false;
        var checkComplete = function() {
          return isComplete && !innerSubscriber && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
          var innerIndex = 0;
          var outerIndex = index++;
          innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
            return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
          }, function() {
            innerSubscriber = null;
            checkComplete();
          }));
        }, function() {
          isComplete = true;
          checkComplete();
        }));
      });
    }
    exports2.switchMap = switchMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
var require_switchAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.switchAll = void 0;
    var switchMap_1 = require_switchMap();
    var identity_1 = require_identity();
    function switchAll() {
      return switchMap_1.switchMap(identity_1.identity);
    }
    exports2.switchAll = switchAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
var require_switchMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.switchMapTo = void 0;
    var switchMap_1 = require_switchMap();
    var isFunction_1 = require_isFunction2();
    function switchMapTo(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
        return innerObservable;
      }, resultSelector) : switchMap_1.switchMap(function() {
        return innerObservable;
      });
    }
    exports2.switchMapTo = switchMapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
var require_switchScan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchScan.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.switchScan = void 0;
    var switchMap_1 = require_switchMap();
    var lift_1 = require_lift();
    function switchScan(accumulator, seed) {
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        switchMap_1.switchMap(function(value, index) {
          return accumulator(state, value, index);
        }, function(_, innerValue) {
          return state = innerValue, innerValue;
        })(source).subscribe(subscriber);
        return function() {
          state = null;
        };
      });
    }
    exports2.switchScan = switchScan;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
var require_takeUntil = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.takeUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop2();
    function takeUntil(notifier) {
      return lift_1.operate(function(source, subscriber) {
        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return subscriber.complete();
        }, noop_1.noop));
        !subscriber.closed && source.subscribe(subscriber);
      });
    }
    exports2.takeUntil = takeUntil;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
var require_takeWhile = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.takeWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeWhile(predicate, inclusive) {
      if (inclusive === void 0) {
        inclusive = false;
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var result = predicate(value, index++);
          (result || inclusive) && subscriber.next(value);
          !result && subscriber.complete();
        }));
      });
    }
    exports2.takeWhile = takeWhile;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/tap.js
var require_tap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/tap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tap = void 0;
    var isFunction_1 = require_isFunction2();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    function tap(observerOrNext, error, complete) {
      var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
      return tapObserver ? lift_1.operate(function(source, subscriber) {
        var _a;
        (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
        var isUnsub = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var _a2;
          (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
          subscriber.next(value);
        }, function() {
          var _a2;
          isUnsub = false;
          (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
          subscriber.complete();
        }, function(err) {
          var _a2;
          isUnsub = false;
          (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
          subscriber.error(err);
        }, function() {
          var _a2, _b;
          if (isUnsub) {
            (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
          }
          (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
        }));
      }) : identity_1.identity;
    }
    exports2.tap = tap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throttle.js
var require_throttle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throttle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throttle = exports2.defaultThrottleConfig = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    exports2.defaultThrottleConfig = {
      leading: true,
      trailing: false
    };
    function throttle2(durationSelector, config) {
      if (config === void 0) {
        config = exports2.defaultThrottleConfig;
      }
      return lift_1.operate(function(source, subscriber) {
        var leading = config.leading, trailing = config.trailing;
        var hasValue = false;
        var sendValue = null;
        var throttled = null;
        var isComplete = false;
        var endThrottling = function() {
          throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
          throttled = null;
          if (trailing) {
            send();
            isComplete && subscriber.complete();
          }
        };
        var cleanupThrottling = function() {
          throttled = null;
          isComplete && subscriber.complete();
        };
        var startThrottle = function(value) {
          return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
        };
        var send = function() {
          if (hasValue) {
            hasValue = false;
            var value = sendValue;
            sendValue = null;
            subscriber.next(value);
            !isComplete && startThrottle(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          sendValue = value;
          !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
        }, function() {
          isComplete = true;
          !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
        }));
      });
    }
    exports2.throttle = throttle2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
var require_throttleTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throttleTime = void 0;
    var async_1 = require_async();
    var throttle_1 = require_throttle();
    var timer_1 = require_timer();
    function throttleTime(duration, scheduler, config) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      if (config === void 0) {
        config = throttle_1.defaultThrottleConfig;
      }
      var duration$ = timer_1.timer(duration, scheduler);
      return throttle_1.throttle(function() {
        return duration$;
      }, config);
    }
    exports2.throttleTime = throttleTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
var require_timeInterval = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimeInterval = exports2.timeInterval = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function timeInterval(scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var last = scheduler.now();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var now = scheduler.now();
          var interval = now - last;
          last = now;
          subscriber.next(new TimeInterval(value, interval));
        }));
      });
    }
    exports2.timeInterval = timeInterval;
    var TimeInterval = function() {
      function TimeInterval2(value, interval) {
        this.value = value;
        this.interval = interval;
      }
      return TimeInterval2;
    }();
    exports2.TimeInterval = TimeInterval;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
var require_timeoutWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeoutWith = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var timeout_1 = require_timeout();
    function timeoutWith(due, withObservable, scheduler) {
      var first;
      var each;
      var _with;
      scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1.async;
      if (isDate_1.isValidDate(due)) {
        first = due;
      } else if (typeof due === "number") {
        each = due;
      }
      if (withObservable) {
        _with = function() {
          return withObservable;
        };
      } else {
        throw new TypeError("No observable provided to switch to");
      }
      if (first == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return timeout_1.timeout({
        first,
        each,
        scheduler,
        with: _with
      });
    }
    exports2.timeoutWith = timeoutWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timestamp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timestamp = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var map_1 = require_map();
    function timestamp2(timestampProvider) {
      if (timestampProvider === void 0) {
        timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      return map_1.map(function(value) {
        return { value, timestamp: timestampProvider.now() };
      });
    }
    exports2.timestamp = timestamp2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/window.js
var require_window = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/window.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.window = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop2();
    var innerFrom_1 = require_innerFrom();
    function window2(windowBoundaries) {
      return lift_1.operate(function(source, subscriber) {
        var windowSubject = new Subject_1.Subject();
        subscriber.next(windowSubject.asObservable());
        var errorHandler = function(err) {
          windowSubject.error(err);
          subscriber.error(err);
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
        }, function() {
          windowSubject.complete();
          subscriber.complete();
        }, errorHandler));
        innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          windowSubject.complete();
          subscriber.next(windowSubject = new Subject_1.Subject());
        }, noop_1.noop, errorHandler));
        return function() {
          windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
          windowSubject = null;
        };
      });
    }
    exports2.window = window2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
var require_windowCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowCount.js"(exports2) {
    "use strict";
    var __values2 = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.windowCount = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function windowCount(windowSize, startWindowEvery) {
      if (startWindowEvery === void 0) {
        startWindowEvery = 0;
      }
      var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
      return lift_1.operate(function(source, subscriber) {
        var windows = [new Subject_1.Subject()];
        var starts = [];
        var count = 0;
        subscriber.next(windows[0].asObservable());
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          try {
            for (var windows_1 = __values2(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
              var window_1 = windows_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
                _a.call(windows_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          var c = count - windowSize + 1;
          if (c >= 0 && c % startEvery === 0) {
            windows.shift().complete();
          }
          if (++count % startEvery === 0) {
            var window_2 = new Subject_1.Subject();
            windows.push(window_2);
            subscriber.next(window_2.asObservable());
          }
        }, function() {
          while (windows.length > 0) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, function(err) {
          while (windows.length > 0) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        }, function() {
          starts = null;
          windows = null;
        }));
      });
    }
    exports2.windowCount = windowCount;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
var require_windowTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.windowTime = void 0;
    var Subject_1 = require_Subject();
    var async_1 = require_async();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function windowTime(windowTimeSpan) {
      var _a, _b;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
      var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
      var maxWindowSize = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var windowRecords = [];
        var restartOnClose = false;
        var closeWindow = function(record) {
          var window2 = record.window, subs = record.subs;
          window2.complete();
          subs.unsubscribe();
          arrRemove_1.arrRemove(windowRecords, record);
          restartOnClose && startWindow();
        };
        var startWindow = function() {
          if (windowRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var window_1 = new Subject_1.Subject();
            var record_1 = {
              window: window_1,
              subs,
              seen: 0
            };
            windowRecords.push(record_1);
            subscriber.next(window_1.asObservable());
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return closeWindow(record_1);
            }, windowTimeSpan);
          }
        };
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
        } else {
          restartOnClose = true;
        }
        startWindow();
        var loop = function(cb) {
          return windowRecords.slice().forEach(cb);
        };
        var terminate = function(cb) {
          loop(function(_a2) {
            var window2 = _a2.window;
            return cb(window2);
          });
          cb(subscriber);
          subscriber.unsubscribe();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          loop(function(record) {
            record.window.next(value);
            maxWindowSize <= ++record.seen && closeWindow(record);
          });
        }, function() {
          return terminate(function(consumer) {
            return consumer.complete();
          });
        }, function(err) {
          return terminate(function(consumer) {
            return consumer.error(err);
          });
        }));
        return function() {
          windowRecords = null;
        };
      });
    }
    exports2.windowTime = windowTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
var require_windowToggle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js"(exports2) {
    "use strict";
    var __values2 = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.windowToggle = void 0;
    var Subject_1 = require_Subject();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop2();
    var arrRemove_1 = require_arrRemove();
    function windowToggle(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var windows = [];
        var handleError = function(err) {
          while (0 < windows.length) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        };
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var window2 = new Subject_1.Subject();
          windows.push(window2);
          var closingSubscription = new Subscription_1.Subscription();
          var closeWindow = function() {
            arrRemove_1.arrRemove(windows, window2);
            window2.complete();
            closingSubscription.unsubscribe();
          };
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
          } catch (err) {
            handleError(err);
            return;
          }
          subscriber.next(window2.asObservable());
          closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          var windowsCopy = windows.slice();
          try {
            for (var windowsCopy_1 = __values2(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
              var window_1 = windowsCopy_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
                _a.call(windowsCopy_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }, function() {
          while (0 < windows.length) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, handleError, function() {
          while (0 < windows.length) {
            windows.shift().unsubscribe();
          }
        }));
      });
    }
    exports2.windowToggle = windowToggle;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
var require_windowWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.windowWhen = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function windowWhen(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var window2;
        var closingSubscriber;
        var handleError = function(err) {
          window2.error(err);
          subscriber.error(err);
        };
        var openWindow = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window2 === null || window2 === void 0 ? void 0 : window2.complete();
          window2 = new Subject_1.Subject();
          subscriber.next(window2.asObservable());
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector());
          } catch (err) {
            handleError(err);
            return;
          }
          closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
        };
        openWindow();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return window2.next(value);
        }, function() {
          window2.complete();
          subscriber.complete();
        }, handleError, function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window2 = null;
        }));
      });
    }
    exports2.windowWhen = windowWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
var require_withLatestFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withLatestFrom = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var identity_1 = require_identity();
    var noop_1 = require_noop2();
    var args_1 = require_args();
    function withLatestFrom() {
      var inputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        inputs[_i] = arguments[_i];
      }
      var project = args_1.popResultSelector(inputs);
      return lift_1.operate(function(source, subscriber) {
        var len = inputs.length;
        var otherValues = new Array(len);
        var hasValue = inputs.map(function() {
          return false;
        });
        var ready = false;
        var _loop_1 = function(i2) {
          innerFrom_1.innerFrom(inputs[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            otherValues[i2] = value;
            if (!ready && !hasValue[i2]) {
              hasValue[i2] = true;
              (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
            }
          }, noop_1.noop));
        };
        for (var i = 0; i < len; i++) {
          _loop_1(i);
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (ready) {
            var values = __spreadArray2([value], __read2(otherValues));
            subscriber.next(project ? project.apply(void 0, __spreadArray2([], __read2(values))) : values);
          }
        }));
      });
    }
    exports2.withLatestFrom = withLatestFrom;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
var require_zipAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zipAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zipAll = void 0;
    var zip_1 = require_zip();
    var joinAllInternals_1 = require_joinAllInternals();
    function zipAll(project) {
      return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
    }
    exports2.zipAll = zipAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zip.js
var require_zip2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zip.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zip = void 0;
    var zip_1 = require_zip();
    var lift_1 = require_lift();
    function zip() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      return lift_1.operate(function(source, subscriber) {
        zip_1.zip.apply(void 0, __spreadArray2([source], __read2(sources))).subscribe(subscriber);
      });
    }
    exports2.zip = zip;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
var require_zipWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zipWith.js"(exports2) {
    "use strict";
    var __read2 = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zipWith = void 0;
    var zip_1 = require_zip2();
    function zipWith() {
      var otherInputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherInputs[_i] = arguments[_i];
      }
      return zip_1.zip.apply(void 0, __spreadArray2([], __read2(otherInputs)));
    }
    exports2.zipWith = zipWith;
  }
});

// node_modules/rxjs/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/rxjs/dist/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.interval = exports2.iif = exports2.generate = exports2.fromEventPattern = exports2.fromEvent = exports2.from = exports2.forkJoin = exports2.empty = exports2.defer = exports2.connectable = exports2.concat = exports2.combineLatest = exports2.bindNodeCallback = exports2.bindCallback = exports2.UnsubscriptionError = exports2.TimeoutError = exports2.SequenceError = exports2.ObjectUnsubscribedError = exports2.NotFoundError = exports2.EmptyError = exports2.ArgumentOutOfRangeError = exports2.firstValueFrom = exports2.lastValueFrom = exports2.isObservable = exports2.identity = exports2.noop = exports2.pipe = exports2.NotificationKind = exports2.Notification = exports2.Subscriber = exports2.Subscription = exports2.Scheduler = exports2.VirtualAction = exports2.VirtualTimeScheduler = exports2.animationFrameScheduler = exports2.animationFrame = exports2.queueScheduler = exports2.queue = exports2.asyncScheduler = exports2.async = exports2.asapScheduler = exports2.asap = exports2.AsyncSubject = exports2.ReplaySubject = exports2.BehaviorSubject = exports2.Subject = exports2.animationFrames = exports2.observable = exports2.ConnectableObservable = exports2.Observable = void 0;
    exports2.filter = exports2.expand = exports2.exhaustMap = exports2.exhaustAll = exports2.exhaust = exports2.every = exports2.endWith = exports2.elementAt = exports2.distinctUntilKeyChanged = exports2.distinctUntilChanged = exports2.distinct = exports2.dematerialize = exports2.delayWhen = exports2.delay = exports2.defaultIfEmpty = exports2.debounceTime = exports2.debounce = exports2.count = exports2.connect = exports2.concatWith = exports2.concatMapTo = exports2.concatMap = exports2.concatAll = exports2.combineLatestWith = exports2.combineLatestAll = exports2.combineAll = exports2.catchError = exports2.bufferWhen = exports2.bufferToggle = exports2.bufferTime = exports2.bufferCount = exports2.buffer = exports2.auditTime = exports2.audit = exports2.config = exports2.NEVER = exports2.EMPTY = exports2.scheduled = exports2.zip = exports2.using = exports2.timer = exports2.throwError = exports2.range = exports2.race = exports2.partition = exports2.pairs = exports2.onErrorResumeNext = exports2.of = exports2.never = exports2.merge = void 0;
    exports2.switchMap = exports2.switchAll = exports2.subscribeOn = exports2.startWith = exports2.skipWhile = exports2.skipUntil = exports2.skipLast = exports2.skip = exports2.single = exports2.shareReplay = exports2.share = exports2.sequenceEqual = exports2.scan = exports2.sampleTime = exports2.sample = exports2.refCount = exports2.retryWhen = exports2.retry = exports2.repeatWhen = exports2.repeat = exports2.reduce = exports2.raceWith = exports2.publishReplay = exports2.publishLast = exports2.publishBehavior = exports2.publish = exports2.pluck = exports2.pairwise = exports2.onErrorResumeNextWith = exports2.observeOn = exports2.multicast = exports2.min = exports2.mergeWith = exports2.mergeScan = exports2.mergeMapTo = exports2.mergeMap = exports2.flatMap = exports2.mergeAll = exports2.max = exports2.materialize = exports2.mapTo = exports2.map = exports2.last = exports2.isEmpty = exports2.ignoreElements = exports2.groupBy = exports2.first = exports2.findIndex = exports2.find = exports2.finalize = void 0;
    exports2.zipWith = exports2.zipAll = exports2.withLatestFrom = exports2.windowWhen = exports2.windowToggle = exports2.windowTime = exports2.windowCount = exports2.window = exports2.toArray = exports2.timestamp = exports2.timeoutWith = exports2.timeout = exports2.timeInterval = exports2.throwIfEmpty = exports2.throttleTime = exports2.throttle = exports2.tap = exports2.takeWhile = exports2.takeUntil = exports2.takeLast = exports2.take = exports2.switchScan = exports2.switchMapTo = void 0;
    var Observable_1 = require_Observable();
    Object.defineProperty(exports2, "Observable", { enumerable: true, get: function() {
      return Observable_1.Observable;
    } });
    var ConnectableObservable_1 = require_ConnectableObservable();
    Object.defineProperty(exports2, "ConnectableObservable", { enumerable: true, get: function() {
      return ConnectableObservable_1.ConnectableObservable;
    } });
    var observable_1 = require_observable();
    Object.defineProperty(exports2, "observable", { enumerable: true, get: function() {
      return observable_1.observable;
    } });
    var animationFrames_1 = require_animationFrames();
    Object.defineProperty(exports2, "animationFrames", { enumerable: true, get: function() {
      return animationFrames_1.animationFrames;
    } });
    var Subject_1 = require_Subject();
    Object.defineProperty(exports2, "Subject", { enumerable: true, get: function() {
      return Subject_1.Subject;
    } });
    var BehaviorSubject_1 = require_BehaviorSubject();
    Object.defineProperty(exports2, "BehaviorSubject", { enumerable: true, get: function() {
      return BehaviorSubject_1.BehaviorSubject;
    } });
    var ReplaySubject_1 = require_ReplaySubject();
    Object.defineProperty(exports2, "ReplaySubject", { enumerable: true, get: function() {
      return ReplaySubject_1.ReplaySubject;
    } });
    var AsyncSubject_1 = require_AsyncSubject();
    Object.defineProperty(exports2, "AsyncSubject", { enumerable: true, get: function() {
      return AsyncSubject_1.AsyncSubject;
    } });
    var asap_1 = require_asap();
    Object.defineProperty(exports2, "asap", { enumerable: true, get: function() {
      return asap_1.asap;
    } });
    Object.defineProperty(exports2, "asapScheduler", { enumerable: true, get: function() {
      return asap_1.asapScheduler;
    } });
    var async_1 = require_async();
    Object.defineProperty(exports2, "async", { enumerable: true, get: function() {
      return async_1.async;
    } });
    Object.defineProperty(exports2, "asyncScheduler", { enumerable: true, get: function() {
      return async_1.asyncScheduler;
    } });
    var queue_1 = require_queue();
    Object.defineProperty(exports2, "queue", { enumerable: true, get: function() {
      return queue_1.queue;
    } });
    Object.defineProperty(exports2, "queueScheduler", { enumerable: true, get: function() {
      return queue_1.queueScheduler;
    } });
    var animationFrame_1 = require_animationFrame();
    Object.defineProperty(exports2, "animationFrame", { enumerable: true, get: function() {
      return animationFrame_1.animationFrame;
    } });
    Object.defineProperty(exports2, "animationFrameScheduler", { enumerable: true, get: function() {
      return animationFrame_1.animationFrameScheduler;
    } });
    var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
    Object.defineProperty(exports2, "VirtualTimeScheduler", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualTimeScheduler;
    } });
    Object.defineProperty(exports2, "VirtualAction", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualAction;
    } });
    var Scheduler_1 = require_Scheduler();
    Object.defineProperty(exports2, "Scheduler", { enumerable: true, get: function() {
      return Scheduler_1.Scheduler;
    } });
    var Subscription_1 = require_Subscription();
    Object.defineProperty(exports2, "Subscription", { enumerable: true, get: function() {
      return Subscription_1.Subscription;
    } });
    var Subscriber_1 = require_Subscriber();
    Object.defineProperty(exports2, "Subscriber", { enumerable: true, get: function() {
      return Subscriber_1.Subscriber;
    } });
    var Notification_1 = require_Notification();
    Object.defineProperty(exports2, "Notification", { enumerable: true, get: function() {
      return Notification_1.Notification;
    } });
    Object.defineProperty(exports2, "NotificationKind", { enumerable: true, get: function() {
      return Notification_1.NotificationKind;
    } });
    var pipe_1 = require_pipe();
    Object.defineProperty(exports2, "pipe", { enumerable: true, get: function() {
      return pipe_1.pipe;
    } });
    var noop_1 = require_noop2();
    Object.defineProperty(exports2, "noop", { enumerable: true, get: function() {
      return noop_1.noop;
    } });
    var identity_1 = require_identity();
    Object.defineProperty(exports2, "identity", { enumerable: true, get: function() {
      return identity_1.identity;
    } });
    var isObservable_1 = require_isObservable();
    Object.defineProperty(exports2, "isObservable", { enumerable: true, get: function() {
      return isObservable_1.isObservable;
    } });
    var lastValueFrom_1 = require_lastValueFrom();
    Object.defineProperty(exports2, "lastValueFrom", { enumerable: true, get: function() {
      return lastValueFrom_1.lastValueFrom;
    } });
    var firstValueFrom_1 = require_firstValueFrom();
    Object.defineProperty(exports2, "firstValueFrom", { enumerable: true, get: function() {
      return firstValueFrom_1.firstValueFrom;
    } });
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    Object.defineProperty(exports2, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
      return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    } });
    var EmptyError_1 = require_EmptyError();
    Object.defineProperty(exports2, "EmptyError", { enumerable: true, get: function() {
      return EmptyError_1.EmptyError;
    } });
    var NotFoundError_1 = require_NotFoundError();
    Object.defineProperty(exports2, "NotFoundError", { enumerable: true, get: function() {
      return NotFoundError_1.NotFoundError;
    } });
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    Object.defineProperty(exports2, "ObjectUnsubscribedError", { enumerable: true, get: function() {
      return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
    } });
    var SequenceError_1 = require_SequenceError();
    Object.defineProperty(exports2, "SequenceError", { enumerable: true, get: function() {
      return SequenceError_1.SequenceError;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports2, "TimeoutError", { enumerable: true, get: function() {
      return timeout_1.TimeoutError;
    } });
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    Object.defineProperty(exports2, "UnsubscriptionError", { enumerable: true, get: function() {
      return UnsubscriptionError_1.UnsubscriptionError;
    } });
    var bindCallback_1 = require_bindCallback();
    Object.defineProperty(exports2, "bindCallback", { enumerable: true, get: function() {
      return bindCallback_1.bindCallback;
    } });
    var bindNodeCallback_1 = require_bindNodeCallback();
    Object.defineProperty(exports2, "bindNodeCallback", { enumerable: true, get: function() {
      return bindNodeCallback_1.bindNodeCallback;
    } });
    var combineLatest_1 = require_combineLatest();
    Object.defineProperty(exports2, "combineLatest", { enumerable: true, get: function() {
      return combineLatest_1.combineLatest;
    } });
    var concat_1 = require_concat();
    Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var connectable_1 = require_connectable();
    Object.defineProperty(exports2, "connectable", { enumerable: true, get: function() {
      return connectable_1.connectable;
    } });
    var defer_1 = require_defer();
    Object.defineProperty(exports2, "defer", { enumerable: true, get: function() {
      return defer_1.defer;
    } });
    var empty_1 = require_empty();
    Object.defineProperty(exports2, "empty", { enumerable: true, get: function() {
      return empty_1.empty;
    } });
    var forkJoin_1 = require_forkJoin();
    Object.defineProperty(exports2, "forkJoin", { enumerable: true, get: function() {
      return forkJoin_1.forkJoin;
    } });
    var from_1 = require_from();
    Object.defineProperty(exports2, "from", { enumerable: true, get: function() {
      return from_1.from;
    } });
    var fromEvent_1 = require_fromEvent();
    Object.defineProperty(exports2, "fromEvent", { enumerable: true, get: function() {
      return fromEvent_1.fromEvent;
    } });
    var fromEventPattern_1 = require_fromEventPattern();
    Object.defineProperty(exports2, "fromEventPattern", { enumerable: true, get: function() {
      return fromEventPattern_1.fromEventPattern;
    } });
    var generate_1 = require_generate();
    Object.defineProperty(exports2, "generate", { enumerable: true, get: function() {
      return generate_1.generate;
    } });
    var iif_1 = require_iif();
    Object.defineProperty(exports2, "iif", { enumerable: true, get: function() {
      return iif_1.iif;
    } });
    var interval_1 = require_interval();
    Object.defineProperty(exports2, "interval", { enumerable: true, get: function() {
      return interval_1.interval;
    } });
    var merge_1 = require_merge();
    Object.defineProperty(exports2, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var never_1 = require_never();
    Object.defineProperty(exports2, "never", { enumerable: true, get: function() {
      return never_1.never;
    } });
    var of_1 = require_of();
    Object.defineProperty(exports2, "of", { enumerable: true, get: function() {
      return of_1.of;
    } });
    var onErrorResumeNext_1 = require_onErrorResumeNext();
    Object.defineProperty(exports2, "onErrorResumeNext", { enumerable: true, get: function() {
      return onErrorResumeNext_1.onErrorResumeNext;
    } });
    var pairs_1 = require_pairs();
    Object.defineProperty(exports2, "pairs", { enumerable: true, get: function() {
      return pairs_1.pairs;
    } });
    var partition_1 = require_partition();
    Object.defineProperty(exports2, "partition", { enumerable: true, get: function() {
      return partition_1.partition;
    } });
    var race_1 = require_race();
    Object.defineProperty(exports2, "race", { enumerable: true, get: function() {
      return race_1.race;
    } });
    var range_1 = require_range();
    Object.defineProperty(exports2, "range", { enumerable: true, get: function() {
      return range_1.range;
    } });
    var throwError_1 = require_throwError();
    Object.defineProperty(exports2, "throwError", { enumerable: true, get: function() {
      return throwError_1.throwError;
    } });
    var timer_1 = require_timer();
    Object.defineProperty(exports2, "timer", { enumerable: true, get: function() {
      return timer_1.timer;
    } });
    var using_1 = require_using();
    Object.defineProperty(exports2, "using", { enumerable: true, get: function() {
      return using_1.using;
    } });
    var zip_1 = require_zip();
    Object.defineProperty(exports2, "zip", { enumerable: true, get: function() {
      return zip_1.zip;
    } });
    var scheduled_1 = require_scheduled();
    Object.defineProperty(exports2, "scheduled", { enumerable: true, get: function() {
      return scheduled_1.scheduled;
    } });
    var empty_2 = require_empty();
    Object.defineProperty(exports2, "EMPTY", { enumerable: true, get: function() {
      return empty_2.EMPTY;
    } });
    var never_2 = require_never();
    Object.defineProperty(exports2, "NEVER", { enumerable: true, get: function() {
      return never_2.NEVER;
    } });
    __exportStar2(require_types(), exports2);
    var config_1 = require_config();
    Object.defineProperty(exports2, "config", { enumerable: true, get: function() {
      return config_1.config;
    } });
    var audit_1 = require_audit();
    Object.defineProperty(exports2, "audit", { enumerable: true, get: function() {
      return audit_1.audit;
    } });
    var auditTime_1 = require_auditTime();
    Object.defineProperty(exports2, "auditTime", { enumerable: true, get: function() {
      return auditTime_1.auditTime;
    } });
    var buffer_1 = require_buffer();
    Object.defineProperty(exports2, "buffer", { enumerable: true, get: function() {
      return buffer_1.buffer;
    } });
    var bufferCount_1 = require_bufferCount();
    Object.defineProperty(exports2, "bufferCount", { enumerable: true, get: function() {
      return bufferCount_1.bufferCount;
    } });
    var bufferTime_1 = require_bufferTime();
    Object.defineProperty(exports2, "bufferTime", { enumerable: true, get: function() {
      return bufferTime_1.bufferTime;
    } });
    var bufferToggle_1 = require_bufferToggle();
    Object.defineProperty(exports2, "bufferToggle", { enumerable: true, get: function() {
      return bufferToggle_1.bufferToggle;
    } });
    var bufferWhen_1 = require_bufferWhen();
    Object.defineProperty(exports2, "bufferWhen", { enumerable: true, get: function() {
      return bufferWhen_1.bufferWhen;
    } });
    var catchError_1 = require_catchError();
    Object.defineProperty(exports2, "catchError", { enumerable: true, get: function() {
      return catchError_1.catchError;
    } });
    var combineAll_1 = require_combineAll();
    Object.defineProperty(exports2, "combineAll", { enumerable: true, get: function() {
      return combineAll_1.combineAll;
    } });
    var combineLatestAll_1 = require_combineLatestAll();
    Object.defineProperty(exports2, "combineLatestAll", { enumerable: true, get: function() {
      return combineLatestAll_1.combineLatestAll;
    } });
    var combineLatestWith_1 = require_combineLatestWith();
    Object.defineProperty(exports2, "combineLatestWith", { enumerable: true, get: function() {
      return combineLatestWith_1.combineLatestWith;
    } });
    var concatAll_1 = require_concatAll();
    Object.defineProperty(exports2, "concatAll", { enumerable: true, get: function() {
      return concatAll_1.concatAll;
    } });
    var concatMap_1 = require_concatMap();
    Object.defineProperty(exports2, "concatMap", { enumerable: true, get: function() {
      return concatMap_1.concatMap;
    } });
    var concatMapTo_1 = require_concatMapTo();
    Object.defineProperty(exports2, "concatMapTo", { enumerable: true, get: function() {
      return concatMapTo_1.concatMapTo;
    } });
    var concatWith_1 = require_concatWith();
    Object.defineProperty(exports2, "concatWith", { enumerable: true, get: function() {
      return concatWith_1.concatWith;
    } });
    var connect_1 = require_connect2();
    Object.defineProperty(exports2, "connect", { enumerable: true, get: function() {
      return connect_1.connect;
    } });
    var count_1 = require_count();
    Object.defineProperty(exports2, "count", { enumerable: true, get: function() {
      return count_1.count;
    } });
    var debounce_1 = require_debounce();
    Object.defineProperty(exports2, "debounce", { enumerable: true, get: function() {
      return debounce_1.debounce;
    } });
    var debounceTime_1 = require_debounceTime();
    Object.defineProperty(exports2, "debounceTime", { enumerable: true, get: function() {
      return debounceTime_1.debounceTime;
    } });
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    Object.defineProperty(exports2, "defaultIfEmpty", { enumerable: true, get: function() {
      return defaultIfEmpty_1.defaultIfEmpty;
    } });
    var delay_1 = require_delay();
    Object.defineProperty(exports2, "delay", { enumerable: true, get: function() {
      return delay_1.delay;
    } });
    var delayWhen_1 = require_delayWhen();
    Object.defineProperty(exports2, "delayWhen", { enumerable: true, get: function() {
      return delayWhen_1.delayWhen;
    } });
    var dematerialize_1 = require_dematerialize();
    Object.defineProperty(exports2, "dematerialize", { enumerable: true, get: function() {
      return dematerialize_1.dematerialize;
    } });
    var distinct_1 = require_distinct();
    Object.defineProperty(exports2, "distinct", { enumerable: true, get: function() {
      return distinct_1.distinct;
    } });
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    Object.defineProperty(exports2, "distinctUntilChanged", { enumerable: true, get: function() {
      return distinctUntilChanged_1.distinctUntilChanged;
    } });
    var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
    Object.defineProperty(exports2, "distinctUntilKeyChanged", { enumerable: true, get: function() {
      return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
    } });
    var elementAt_1 = require_elementAt();
    Object.defineProperty(exports2, "elementAt", { enumerable: true, get: function() {
      return elementAt_1.elementAt;
    } });
    var endWith_1 = require_endWith();
    Object.defineProperty(exports2, "endWith", { enumerable: true, get: function() {
      return endWith_1.endWith;
    } });
    var every_1 = require_every();
    Object.defineProperty(exports2, "every", { enumerable: true, get: function() {
      return every_1.every;
    } });
    var exhaust_1 = require_exhaust();
    Object.defineProperty(exports2, "exhaust", { enumerable: true, get: function() {
      return exhaust_1.exhaust;
    } });
    var exhaustAll_1 = require_exhaustAll();
    Object.defineProperty(exports2, "exhaustAll", { enumerable: true, get: function() {
      return exhaustAll_1.exhaustAll;
    } });
    var exhaustMap_1 = require_exhaustMap();
    Object.defineProperty(exports2, "exhaustMap", { enumerable: true, get: function() {
      return exhaustMap_1.exhaustMap;
    } });
    var expand_1 = require_expand();
    Object.defineProperty(exports2, "expand", { enumerable: true, get: function() {
      return expand_1.expand;
    } });
    var filter_1 = require_filter();
    Object.defineProperty(exports2, "filter", { enumerable: true, get: function() {
      return filter_1.filter;
    } });
    var finalize_1 = require_finalize();
    Object.defineProperty(exports2, "finalize", { enumerable: true, get: function() {
      return finalize_1.finalize;
    } });
    var find_1 = require_find();
    Object.defineProperty(exports2, "find", { enumerable: true, get: function() {
      return find_1.find;
    } });
    var findIndex_1 = require_findIndex();
    Object.defineProperty(exports2, "findIndex", { enumerable: true, get: function() {
      return findIndex_1.findIndex;
    } });
    var first_1 = require_first();
    Object.defineProperty(exports2, "first", { enumerable: true, get: function() {
      return first_1.first;
    } });
    var groupBy_1 = require_groupBy();
    Object.defineProperty(exports2, "groupBy", { enumerable: true, get: function() {
      return groupBy_1.groupBy;
    } });
    var ignoreElements_1 = require_ignoreElements();
    Object.defineProperty(exports2, "ignoreElements", { enumerable: true, get: function() {
      return ignoreElements_1.ignoreElements;
    } });
    var isEmpty_1 = require_isEmpty();
    Object.defineProperty(exports2, "isEmpty", { enumerable: true, get: function() {
      return isEmpty_1.isEmpty;
    } });
    var last_1 = require_last();
    Object.defineProperty(exports2, "last", { enumerable: true, get: function() {
      return last_1.last;
    } });
    var map_1 = require_map();
    Object.defineProperty(exports2, "map", { enumerable: true, get: function() {
      return map_1.map;
    } });
    var mapTo_1 = require_mapTo();
    Object.defineProperty(exports2, "mapTo", { enumerable: true, get: function() {
      return mapTo_1.mapTo;
    } });
    var materialize_1 = require_materialize();
    Object.defineProperty(exports2, "materialize", { enumerable: true, get: function() {
      return materialize_1.materialize;
    } });
    var max_1 = require_max();
    Object.defineProperty(exports2, "max", { enumerable: true, get: function() {
      return max_1.max;
    } });
    var mergeAll_1 = require_mergeAll();
    Object.defineProperty(exports2, "mergeAll", { enumerable: true, get: function() {
      return mergeAll_1.mergeAll;
    } });
    var flatMap_1 = require_flatMap();
    Object.defineProperty(exports2, "flatMap", { enumerable: true, get: function() {
      return flatMap_1.flatMap;
    } });
    var mergeMap_1 = require_mergeMap();
    Object.defineProperty(exports2, "mergeMap", { enumerable: true, get: function() {
      return mergeMap_1.mergeMap;
    } });
    var mergeMapTo_1 = require_mergeMapTo();
    Object.defineProperty(exports2, "mergeMapTo", { enumerable: true, get: function() {
      return mergeMapTo_1.mergeMapTo;
    } });
    var mergeScan_1 = require_mergeScan();
    Object.defineProperty(exports2, "mergeScan", { enumerable: true, get: function() {
      return mergeScan_1.mergeScan;
    } });
    var mergeWith_1 = require_mergeWith();
    Object.defineProperty(exports2, "mergeWith", { enumerable: true, get: function() {
      return mergeWith_1.mergeWith;
    } });
    var min_1 = require_min();
    Object.defineProperty(exports2, "min", { enumerable: true, get: function() {
      return min_1.min;
    } });
    var multicast_1 = require_multicast();
    Object.defineProperty(exports2, "multicast", { enumerable: true, get: function() {
      return multicast_1.multicast;
    } });
    var observeOn_1 = require_observeOn();
    Object.defineProperty(exports2, "observeOn", { enumerable: true, get: function() {
      return observeOn_1.observeOn;
    } });
    var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
    Object.defineProperty(exports2, "onErrorResumeNextWith", { enumerable: true, get: function() {
      return onErrorResumeNextWith_1.onErrorResumeNextWith;
    } });
    var pairwise_1 = require_pairwise();
    Object.defineProperty(exports2, "pairwise", { enumerable: true, get: function() {
      return pairwise_1.pairwise;
    } });
    var pluck_1 = require_pluck();
    Object.defineProperty(exports2, "pluck", { enumerable: true, get: function() {
      return pluck_1.pluck;
    } });
    var publish_1 = require_publish();
    Object.defineProperty(exports2, "publish", { enumerable: true, get: function() {
      return publish_1.publish;
    } });
    var publishBehavior_1 = require_publishBehavior();
    Object.defineProperty(exports2, "publishBehavior", { enumerable: true, get: function() {
      return publishBehavior_1.publishBehavior;
    } });
    var publishLast_1 = require_publishLast();
    Object.defineProperty(exports2, "publishLast", { enumerable: true, get: function() {
      return publishLast_1.publishLast;
    } });
    var publishReplay_1 = require_publishReplay();
    Object.defineProperty(exports2, "publishReplay", { enumerable: true, get: function() {
      return publishReplay_1.publishReplay;
    } });
    var raceWith_1 = require_raceWith();
    Object.defineProperty(exports2, "raceWith", { enumerable: true, get: function() {
      return raceWith_1.raceWith;
    } });
    var reduce_1 = require_reduce();
    Object.defineProperty(exports2, "reduce", { enumerable: true, get: function() {
      return reduce_1.reduce;
    } });
    var repeat_1 = require_repeat();
    Object.defineProperty(exports2, "repeat", { enumerable: true, get: function() {
      return repeat_1.repeat;
    } });
    var repeatWhen_1 = require_repeatWhen();
    Object.defineProperty(exports2, "repeatWhen", { enumerable: true, get: function() {
      return repeatWhen_1.repeatWhen;
    } });
    var retry_1 = require_retry();
    Object.defineProperty(exports2, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var retryWhen_1 = require_retryWhen();
    Object.defineProperty(exports2, "retryWhen", { enumerable: true, get: function() {
      return retryWhen_1.retryWhen;
    } });
    var refCount_1 = require_refCount();
    Object.defineProperty(exports2, "refCount", { enumerable: true, get: function() {
      return refCount_1.refCount;
    } });
    var sample_1 = require_sample();
    Object.defineProperty(exports2, "sample", { enumerable: true, get: function() {
      return sample_1.sample;
    } });
    var sampleTime_1 = require_sampleTime();
    Object.defineProperty(exports2, "sampleTime", { enumerable: true, get: function() {
      return sampleTime_1.sampleTime;
    } });
    var scan_1 = require_scan();
    Object.defineProperty(exports2, "scan", { enumerable: true, get: function() {
      return scan_1.scan;
    } });
    var sequenceEqual_1 = require_sequenceEqual();
    Object.defineProperty(exports2, "sequenceEqual", { enumerable: true, get: function() {
      return sequenceEqual_1.sequenceEqual;
    } });
    var share_1 = require_share();
    Object.defineProperty(exports2, "share", { enumerable: true, get: function() {
      return share_1.share;
    } });
    var shareReplay_1 = require_shareReplay();
    Object.defineProperty(exports2, "shareReplay", { enumerable: true, get: function() {
      return shareReplay_1.shareReplay;
    } });
    var single_1 = require_single();
    Object.defineProperty(exports2, "single", { enumerable: true, get: function() {
      return single_1.single;
    } });
    var skip_1 = require_skip();
    Object.defineProperty(exports2, "skip", { enumerable: true, get: function() {
      return skip_1.skip;
    } });
    var skipLast_1 = require_skipLast();
    Object.defineProperty(exports2, "skipLast", { enumerable: true, get: function() {
      return skipLast_1.skipLast;
    } });
    var skipUntil_1 = require_skipUntil();
    Object.defineProperty(exports2, "skipUntil", { enumerable: true, get: function() {
      return skipUntil_1.skipUntil;
    } });
    var skipWhile_1 = require_skipWhile();
    Object.defineProperty(exports2, "skipWhile", { enumerable: true, get: function() {
      return skipWhile_1.skipWhile;
    } });
    var startWith_1 = require_startWith();
    Object.defineProperty(exports2, "startWith", { enumerable: true, get: function() {
      return startWith_1.startWith;
    } });
    var subscribeOn_1 = require_subscribeOn();
    Object.defineProperty(exports2, "subscribeOn", { enumerable: true, get: function() {
      return subscribeOn_1.subscribeOn;
    } });
    var switchAll_1 = require_switchAll();
    Object.defineProperty(exports2, "switchAll", { enumerable: true, get: function() {
      return switchAll_1.switchAll;
    } });
    var switchMap_1 = require_switchMap();
    Object.defineProperty(exports2, "switchMap", { enumerable: true, get: function() {
      return switchMap_1.switchMap;
    } });
    var switchMapTo_1 = require_switchMapTo();
    Object.defineProperty(exports2, "switchMapTo", { enumerable: true, get: function() {
      return switchMapTo_1.switchMapTo;
    } });
    var switchScan_1 = require_switchScan();
    Object.defineProperty(exports2, "switchScan", { enumerable: true, get: function() {
      return switchScan_1.switchScan;
    } });
    var take_1 = require_take();
    Object.defineProperty(exports2, "take", { enumerable: true, get: function() {
      return take_1.take;
    } });
    var takeLast_1 = require_takeLast();
    Object.defineProperty(exports2, "takeLast", { enumerable: true, get: function() {
      return takeLast_1.takeLast;
    } });
    var takeUntil_1 = require_takeUntil();
    Object.defineProperty(exports2, "takeUntil", { enumerable: true, get: function() {
      return takeUntil_1.takeUntil;
    } });
    var takeWhile_1 = require_takeWhile();
    Object.defineProperty(exports2, "takeWhile", { enumerable: true, get: function() {
      return takeWhile_1.takeWhile;
    } });
    var tap_1 = require_tap();
    Object.defineProperty(exports2, "tap", { enumerable: true, get: function() {
      return tap_1.tap;
    } });
    var throttle_1 = require_throttle();
    Object.defineProperty(exports2, "throttle", { enumerable: true, get: function() {
      return throttle_1.throttle;
    } });
    var throttleTime_1 = require_throttleTime();
    Object.defineProperty(exports2, "throttleTime", { enumerable: true, get: function() {
      return throttleTime_1.throttleTime;
    } });
    var throwIfEmpty_1 = require_throwIfEmpty();
    Object.defineProperty(exports2, "throwIfEmpty", { enumerable: true, get: function() {
      return throwIfEmpty_1.throwIfEmpty;
    } });
    var timeInterval_1 = require_timeInterval();
    Object.defineProperty(exports2, "timeInterval", { enumerable: true, get: function() {
      return timeInterval_1.timeInterval;
    } });
    var timeout_2 = require_timeout();
    Object.defineProperty(exports2, "timeout", { enumerable: true, get: function() {
      return timeout_2.timeout;
    } });
    var timeoutWith_1 = require_timeoutWith();
    Object.defineProperty(exports2, "timeoutWith", { enumerable: true, get: function() {
      return timeoutWith_1.timeoutWith;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports2, "timestamp", { enumerable: true, get: function() {
      return timestamp_1.timestamp;
    } });
    var toArray_1 = require_toArray();
    Object.defineProperty(exports2, "toArray", { enumerable: true, get: function() {
      return toArray_1.toArray;
    } });
    var window_1 = require_window();
    Object.defineProperty(exports2, "window", { enumerable: true, get: function() {
      return window_1.window;
    } });
    var windowCount_1 = require_windowCount();
    Object.defineProperty(exports2, "windowCount", { enumerable: true, get: function() {
      return windowCount_1.windowCount;
    } });
    var windowTime_1 = require_windowTime();
    Object.defineProperty(exports2, "windowTime", { enumerable: true, get: function() {
      return windowTime_1.windowTime;
    } });
    var windowToggle_1 = require_windowToggle();
    Object.defineProperty(exports2, "windowToggle", { enumerable: true, get: function() {
      return windowToggle_1.windowToggle;
    } });
    var windowWhen_1 = require_windowWhen();
    Object.defineProperty(exports2, "windowWhen", { enumerable: true, get: function() {
      return windowWhen_1.windowWhen;
    } });
    var withLatestFrom_1 = require_withLatestFrom();
    Object.defineProperty(exports2, "withLatestFrom", { enumerable: true, get: function() {
      return withLatestFrom_1.withLatestFrom;
    } });
    var zipAll_1 = require_zipAll();
    Object.defineProperty(exports2, "zipAll", { enumerable: true, get: function() {
      return zipAll_1.zipAll;
    } });
    var zipWith_1 = require_zipWith();
    Object.defineProperty(exports2, "zipWith", { enumerable: true, get: function() {
      return zipWith_1.zipWith;
    } });
  }
});

// node_modules/logform/format.js
var require_format = __commonJS({
  "node_modules/logform/format.js"(exports2, module2) {
    "use strict";
    var InvalidFormatError = class extends Error {
      constructor(formatFn) {
        super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split("\n")[0]}
`);
        Error.captureStackTrace(this, InvalidFormatError);
      }
    };
    module2.exports = (formatFn) => {
      if (formatFn.length > 2) {
        throw new InvalidFormatError(formatFn);
      }
      function Format(options = {}) {
        this.options = options;
      }
      Format.prototype.transform = formatFn;
      function createFormatWrap(opts) {
        return new Format(opts);
      }
      createFormatWrap.Format = Format;
      return createFormatWrap;
    };
  }
});

// node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS({
  "node_modules/@colors/colors/lib/styles.js"(exports2, module2) {
    var styles = {};
    module2["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag = __commonJS({
  "node_modules/@colors/colors/lib/system/has-flag.js"(exports2, module2) {
    "use strict";
    module2.exports = function(flag, argv) {
      argv = argv || process.argv;
      var terminatorPos = argv.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "node_modules/@colors/colors/lib/system/supports-colors.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream4) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream4 && !stream4.isTTY && forceColor !== true) {
        return 0;
      }
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
          return sign in env;
        }) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env) {
        var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream4) {
      var level = supportsColor(stream4);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "node_modules/@colors/colors/lib/custom/trap.js"(exports2, module2) {
    module2["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "node_modules/@colors/colors/lib/custom/zalgo.js"(exports2, module2) {
    module2["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all3 = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function isChar(character) {
        var bool = false;
        all3.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "";
        var counts;
        var l;
        options2 = options2 || {};
        options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
        options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
        options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
        options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text, options);
    };
  }
});

// node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS({
  "node_modules/@colors/colors/lib/maps/america.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        if (letter === " ")
          return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "node_modules/@colors/colors/lib/maps/zebra.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "node_modules/@colors/colors/lib/maps/rainbow.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS({
  "node_modules/@colors/colors/lib/maps/random.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS({
  "node_modules/@colors/colors/lib/colors.js"(exports2, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var util2 = require("util");
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors) {
        return colors[style](str);
      }
      return styleMap.open + str + styleMap.close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util2.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i in theme[style2]) {
                out = colors[theme[style2][i]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build([name]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split("");
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america()(colors);
    colors.maps.zebra = require_zebra()(colors);
    colors.maps.rainbow = require_rainbow()(colors);
    colors.maps.random = require_random()(colors);
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init());
  }
});

// node_modules/@colors/colors/safe.js
var require_safe = __commonJS({
  "node_modules/@colors/colors/safe.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// node_modules/triple-beam/config/cli.js
var require_cli = __commonJS({
  "node_modules/triple-beam/config/cli.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      help: 2,
      data: 3,
      info: 4,
      debug: 5,
      prompt: 6,
      verbose: 7,
      input: 8,
      silly: 9
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      help: "cyan",
      data: "grey",
      info: "green",
      debug: "blue",
      prompt: "grey",
      verbose: "cyan",
      input: "grey",
      silly: "magenta"
    };
  }
});

// node_modules/triple-beam/config/npm.js
var require_npm = __commonJS({
  "node_modules/triple-beam/config/npm.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      info: 2,
      http: 3,
      verbose: 4,
      debug: 5,
      silly: 6
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      info: "green",
      http: "green",
      verbose: "cyan",
      debug: "blue",
      silly: "magenta"
    };
  }
});

// node_modules/triple-beam/config/syslog.js
var require_syslog = __commonJS({
  "node_modules/triple-beam/config/syslog.js"(exports2) {
    "use strict";
    exports2.levels = {
      emerg: 0,
      alert: 1,
      crit: 2,
      error: 3,
      warning: 4,
      notice: 5,
      info: 6,
      debug: 7
    };
    exports2.colors = {
      emerg: "red",
      alert: "yellow",
      crit: "red",
      error: "red",
      warning: "red",
      notice: "yellow",
      info: "green",
      debug: "blue"
    };
  }
});

// node_modules/triple-beam/config/index.js
var require_config2 = __commonJS({
  "node_modules/triple-beam/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "cli", {
      value: require_cli()
    });
    Object.defineProperty(exports2, "npm", {
      value: require_npm()
    });
    Object.defineProperty(exports2, "syslog", {
      value: require_syslog()
    });
  }
});

// node_modules/triple-beam/index.js
var require_triple_beam = __commonJS({
  "node_modules/triple-beam/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "LEVEL", {
      value: Symbol.for("level")
    });
    Object.defineProperty(exports2, "MESSAGE", {
      value: Symbol.for("message")
    });
    Object.defineProperty(exports2, "SPLAT", {
      value: Symbol.for("splat")
    });
    Object.defineProperty(exports2, "configs", {
      value: require_config2()
    });
  }
});

// node_modules/logform/colorize.js
var require_colorize = __commonJS({
  "node_modules/logform/colorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var { LEVEL, MESSAGE } = require_triple_beam();
    colors.enabled = true;
    var hasSpace = /\s+/;
    var Colorizer = class {
      constructor(opts = {}) {
        if (opts.colors) {
          this.addColors(opts.colors);
        }
        this.options = opts;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      static addColors(clrs) {
        const nextColors = Object.keys(clrs).reduce((acc, level) => {
          acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
          return acc;
        }, {});
        Colorizer.allColors = Object.assign({}, Colorizer.allColors || {}, nextColors);
        return Colorizer.allColors;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      addColors(clrs) {
        return Colorizer.addColors(clrs);
      }
      /*
       * function colorize (lookup, level, message)
       * Performs multi-step colorization using @colors/colors/safe
       */
      colorize(lookup, level, message) {
        if (typeof message === "undefined") {
          message = level;
        }
        if (!Array.isArray(Colorizer.allColors[lookup])) {
          return colors[Colorizer.allColors[lookup]](message);
        }
        for (let i = 0, len = Colorizer.allColors[lookup].length; i < len; i++) {
          message = colors[Colorizer.allColors[lookup][i]](message);
        }
        return message;
      }
      /*
       * function transform (info, opts)
       * Attempts to colorize the { level, message } of the given
       * `logform` info object.
       */
      transform(info, opts) {
        if (opts.all && typeof info[MESSAGE] === "string") {
          info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
        }
        if (opts.level || opts.all || !opts.message) {
          info.level = this.colorize(info[LEVEL], info.level);
        }
        if (opts.all || opts.message) {
          info.message = this.colorize(info[LEVEL], info.level, info.message);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Colorizer(opts);
    module2.exports.Colorizer = module2.exports.Format = Colorizer;
  }
});

// node_modules/logform/levels.js
var require_levels = __commonJS({
  "node_modules/logform/levels.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    module2.exports = (config) => {
      Colorizer.addColors(config.colors || config);
      return config;
    };
  }
});

// node_modules/logform/align.js
var require_align = __commonJS({
  "node_modules/logform/align.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    module2.exports = format2((info) => {
      info.message = `	${info.message}`;
      return info;
    });
  }
});

// node_modules/logform/errors.js
var require_errors3 = __commonJS({
  "node_modules/logform/errors.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { LEVEL, MESSAGE } = require_triple_beam();
    module2.exports = format2((einfo, { stack, cause }) => {
      if (einfo instanceof Error) {
        const info = Object.assign({}, einfo, {
          level: einfo.level,
          [LEVEL]: einfo[LEVEL] || einfo.level,
          message: einfo.message,
          [MESSAGE]: einfo[MESSAGE] || einfo.message
        });
        if (stack)
          info.stack = einfo.stack;
        if (cause)
          info.cause = einfo.cause;
        return info;
      }
      if (!(einfo.message instanceof Error))
        return einfo;
      const err = einfo.message;
      Object.assign(einfo, err);
      einfo.message = err.message;
      einfo[MESSAGE] = err.message;
      if (stack)
        einfo.stack = err.stack;
      if (cause)
        einfo.cause = err.cause;
      return einfo;
    });
  }
});

// node_modules/logform/pad-levels.js
var require_pad_levels = __commonJS({
  "node_modules/logform/pad-levels.js"(exports2, module2) {
    "use strict";
    var { configs, LEVEL, MESSAGE } = require_triple_beam();
    var Padder = class {
      constructor(opts = { levels: configs.npm.levels }) {
        this.paddings = Padder.paddingForLevels(opts.levels, opts.filler);
        this.options = opts;
      }
      /**
       * Returns the maximum length of keys in the specified `levels` Object.
       * @param  {Object} levels Set of all levels to calculate longest level against.
       * @returns {Number} Maximum length of the longest level string.
       */
      static getLongestLevel(levels) {
        const lvls = Object.keys(levels).map((level) => level.length);
        return Math.max(...lvls);
      }
      /**
       * Returns the padding for the specified `level` assuming that the
       * maximum length of all levels it's associated with is `maxLength`.
       * @param  {String} level Level to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @param  {Number} maxLength Length of the longest level
       * @returns {String} Padding string for the `level`
       */
      static paddingForLevel(level, filler, maxLength) {
        const targetLen = maxLength + 1 - level.length;
        const rep = Math.floor(targetLen / filler.length);
        const padding = `${filler}${filler.repeat(rep)}`;
        return padding.slice(0, targetLen);
      }
      /**
       * Returns an object with the string paddings for the given `levels`
       * using the specified `filler`.
       * @param  {Object} levels Set of all levels to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @returns {Object} Mapping of level to desired padding.
       */
      static paddingForLevels(levels, filler = " ") {
        const maxLength = Padder.getLongestLevel(levels);
        return Object.keys(levels).reduce((acc, level) => {
          acc[level] = Padder.paddingForLevel(level, filler, maxLength);
          return acc;
        }, {});
      }
      /**
       * Prepends the padding onto the `message` based on the `LEVEL` of
       * the `info`. This is based on the behavior of `winston@2` which also
       * prepended the level onto the message.
       *
       * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201
       *
       * @param  {Info} info Logform info object
       * @param  {Object} opts Options passed along to this instance.
       * @returns {Info} Modified logform info object.
       */
      transform(info, opts) {
        info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
        if (info[MESSAGE]) {
          info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
        }
        return info;
      }
    };
    module2.exports = (opts) => new Padder(opts);
    module2.exports.Padder = module2.exports.Format = Padder;
  }
});

// node_modules/logform/cli.js
var require_cli2 = __commonJS({
  "node_modules/logform/cli.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    var { Padder } = require_pad_levels();
    var { configs, MESSAGE } = require_triple_beam();
    var CliFormat = class {
      constructor(opts = {}) {
        if (!opts.levels) {
          opts.levels = configs.cli.levels;
        }
        this.colorizer = new Colorizer(opts);
        this.padder = new Padder(opts);
        this.options = opts;
      }
      /*
       * function transform (info, opts)
       * Attempts to both:
       * 1. Pad the { level }
       * 2. Colorize the { level, message }
       * of the given `logform` info object depending on the `opts`.
       */
      transform(info, opts) {
        this.colorizer.transform(
          this.padder.transform(info, opts),
          opts
        );
        info[MESSAGE] = `${info.level}:${info.message}`;
        return info;
      }
    };
    module2.exports = (opts) => new CliFormat(opts);
    module2.exports.Format = CliFormat;
  }
});

// node_modules/logform/combine.js
var require_combine = __commonJS({
  "node_modules/logform/combine.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    function cascade(formats) {
      if (!formats.every(isValidFormat)) {
        return;
      }
      return (info) => {
        let obj = info;
        for (let i = 0; i < formats.length; i++) {
          obj = formats[i].transform(obj, formats[i].options);
          if (!obj) {
            return false;
          }
        }
        return obj;
      };
    }
    function isValidFormat(fmt) {
      if (typeof fmt.transform !== "function") {
        throw new Error([
          "No transform function found on format. Did you create a format instance?",
          "const myFormat = format(formatFn);",
          "const instance = myFormat();"
        ].join("\n"));
      }
      return true;
    }
    module2.exports = (...formats) => {
      const combinedFormat = format2(cascade(formats));
      const instance = combinedFormat();
      instance.Format = combinedFormat.Format;
      return instance;
    };
    module2.exports.cascade = cascade;
  }
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "node_modules/safe-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    var stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports2.stringify = stringify;
    exports2.configure = configure;
    module2.exports = stringify;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function insertSort(array) {
      if (array.length > 200) {
        return array.sort();
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty2.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty2.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty2.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty2.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function")
              message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getBooleanOption(options, "deterministic");
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  }
});

// node_modules/logform/json.js
var require_json = __commonJS({
  "node_modules/logform/json.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    var stringify = require_safe_stable_stringify();
    function replacer(key, value) {
      if (typeof value === "bigint")
        return value.toString();
      return value;
    }
    module2.exports = format2((info, opts) => {
      const jsonStringify = stringify.configure(opts);
      info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
      return info;
    });
  }
});

// node_modules/logform/label.js
var require_label = __commonJS({
  "node_modules/logform/label.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    module2.exports = format2((info, opts) => {
      if (opts.message) {
        info.message = `[${opts.label}] ${info.message}`;
        return info;
      }
      info.label = opts.label;
      return info;
    });
  }
});

// node_modules/logform/logstash.js
var require_logstash = __commonJS({
  "node_modules/logform/logstash.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format2((info) => {
      const logstash = {};
      if (info.message) {
        logstash["@message"] = info.message;
        delete info.message;
      }
      if (info.timestamp) {
        logstash["@timestamp"] = info.timestamp;
        delete info.timestamp;
      }
      logstash["@fields"] = info;
      info[MESSAGE] = jsonStringify(logstash);
      return info;
    });
  }
});

// node_modules/logform/metadata.js
var require_metadata = __commonJS({
  "node_modules/logform/metadata.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    function fillExcept(info, fillExceptKeys, metadataKey) {
      const savedKeys = fillExceptKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      const metadata = Object.keys(info).reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      Object.assign(info, savedKeys, {
        [metadataKey]: metadata
      });
      return info;
    }
    function fillWith(info, fillWithKeys, metadataKey) {
      info[metadataKey] = fillWithKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      return info;
    }
    module2.exports = format2((info, opts = {}) => {
      let metadataKey = "metadata";
      if (opts.key) {
        metadataKey = opts.key;
      }
      let fillExceptKeys = [];
      if (!opts.fillExcept && !opts.fillWith) {
        fillExceptKeys.push("level");
        fillExceptKeys.push("message");
      }
      if (opts.fillExcept) {
        fillExceptKeys = opts.fillExcept;
      }
      if (fillExceptKeys.length > 0) {
        return fillExcept(info, fillExceptKeys, metadataKey);
      }
      if (opts.fillWith) {
        return fillWith(info, opts.fillWith, metadataKey);
      }
      return info;
    });
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/logform/ms.js
var require_ms2 = __commonJS({
  "node_modules/logform/ms.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var ms = require_ms();
    module2.exports = format2((info) => {
      const curr = +/* @__PURE__ */ new Date();
      exports2.diff = curr - (exports2.prevTime || curr);
      exports2.prevTime = curr;
      info.ms = `+${ms(exports2.diff)}`;
      return info;
    });
  }
});

// node_modules/logform/pretty-print.js
var require_pretty_print = __commonJS({
  "node_modules/logform/pretty-print.js"(exports2, module2) {
    "use strict";
    var inspect = require("util").inspect;
    var format2 = require_format();
    var { LEVEL, MESSAGE, SPLAT } = require_triple_beam();
    module2.exports = format2((info, opts = {}) => {
      const stripped = Object.assign({}, info);
      delete stripped[LEVEL];
      delete stripped[MESSAGE];
      delete stripped[SPLAT];
      info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
      return info;
    });
  }
});

// node_modules/logform/printf.js
var require_printf = __commonJS({
  "node_modules/logform/printf.js"(exports2, module2) {
    "use strict";
    var { MESSAGE } = require_triple_beam();
    var Printf = class {
      constructor(templateFn) {
        this.template = templateFn;
      }
      transform(info) {
        info[MESSAGE] = this.template(info);
        return info;
      }
    };
    module2.exports = (opts) => new Printf(opts);
    module2.exports.Printf = module2.exports.Format = Printf;
  }
});

// node_modules/logform/simple.js
var require_simple = __commonJS({
  "node_modules/logform/simple.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format2((info) => {
      const stringifiedRest = jsonStringify(Object.assign({}, info, {
        level: void 0,
        message: void 0,
        splat: void 0
      }));
      const padding = info.padding && info.padding[info.level] || "";
      if (stringifiedRest !== "{}") {
        info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
      } else {
        info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
      }
      return info;
    });
  }
});

// node_modules/logform/splat.js
var require_splat = __commonJS({
  "node_modules/logform/splat.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var { SPLAT } = require_triple_beam();
    var formatRegExp = /%[scdjifoO%]/g;
    var escapedPercent = /%%/g;
    var Splatter = class {
      constructor(opts) {
        this.options = opts;
      }
      /**
         * Check to see if tokens <= splat.length, assign { splat, meta } into the
         * `info` accordingly, and write to this instance.
         *
         * @param  {Info} info Logform info message.
         * @param  {String[]} tokens Set of string interpolation tokens.
         * @returns {Info} Modified info message
         * @private
         */
      _splat(info, tokens) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat || [];
        const percents = msg.match(escapedPercent);
        const escapes = percents && percents.length || 0;
        const expectedSplat = tokens.length - escapes;
        const extraSplat = expectedSplat - splat.length;
        const metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];
        const metalen = metas.length;
        if (metalen) {
          for (let i = 0; i < metalen; i++) {
            Object.assign(info, metas[i]);
          }
        }
        info.message = util2.format(msg, ...splat);
        return info;
      }
      /**
        * Transforms the `info` message by using `util.format` to complete
        * any `info.message` provided it has string interpolation tokens.
        * If no tokens exist then `info` is immutable.
        *
        * @param  {Info} info Logform info message.
        * @param  {Object} opts Options for this instance.
        * @returns {Info} Modified info message
        */
      transform(info) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat;
        if (!splat || !splat.length) {
          return info;
        }
        const tokens = msg && msg.match && msg.match(formatRegExp);
        if (!tokens && (splat || splat.length)) {
          const metas = splat.length > 1 ? splat.splice(0) : splat;
          const metalen = metas.length;
          if (metalen) {
            for (let i = 0; i < metalen; i++) {
              Object.assign(info, metas[i]);
            }
          }
          return info;
        }
        if (tokens) {
          return this._splat(info, tokens);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Splatter(opts);
  }
});

// node_modules/fecha/lib/fecha.umd.js
var require_fecha_umd = __commonJS({
  "node_modules/fecha/lib/fecha.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.fecha = {});
    })(exports2, function(exports3) {
      "use strict";
      var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
      var twoDigitsOptional = "\\d\\d?";
      var twoDigits = "\\d\\d";
      var threeDigits = "\\d{3}";
      var fourDigits = "\\d{4}";
      var word = "[^\\s]+";
      var literal = /\[([^]*?)\]/gm;
      function shorten(arr, sLen) {
        var newArr = [];
        for (var i = 0, len = arr.length; i < len; i++) {
          newArr.push(arr[i].substr(0, sLen));
        }
        return newArr;
      }
      var monthUpdate = function(arrName) {
        return function(v, i18n) {
          var lowerCaseArr = i18n[arrName].map(function(v2) {
            return v2.toLowerCase();
          });
          var index = lowerCaseArr.indexOf(v.toLowerCase());
          if (index > -1) {
            return index;
          }
          return null;
        };
      };
      function assign(origObj) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
          var obj = args_1[_a];
          for (var key in obj) {
            origObj[key] = obj[key];
          }
        }
        return origObj;
      }
      var dayNames = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ];
      var monthNames = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ];
      var monthNamesShort = shorten(monthNames, 3);
      var dayNamesShort = shorten(dayNames, 3);
      var defaultI18n = {
        dayNamesShort,
        dayNames,
        monthNamesShort,
        monthNames,
        amPm: ["am", "pm"],
        DoFn: function(dayOfMonth) {
          return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
        }
      };
      var globalI18n = assign({}, defaultI18n);
      var setGlobalDateI18n = function(i18n) {
        return globalI18n = assign(globalI18n, i18n);
      };
      var regexEscape = function(str) {
        return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
      };
      var pad = function(val, len) {
        if (len === void 0) {
          len = 2;
        }
        val = String(val);
        while (val.length < len) {
          val = "0" + val;
        }
        return val;
      };
      var formatFlags = {
        D: function(dateObj) {
          return String(dateObj.getDate());
        },
        DD: function(dateObj) {
          return pad(dateObj.getDate());
        },
        Do: function(dateObj, i18n) {
          return i18n.DoFn(dateObj.getDate());
        },
        d: function(dateObj) {
          return String(dateObj.getDay());
        },
        dd: function(dateObj) {
          return pad(dateObj.getDay());
        },
        ddd: function(dateObj, i18n) {
          return i18n.dayNamesShort[dateObj.getDay()];
        },
        dddd: function(dateObj, i18n) {
          return i18n.dayNames[dateObj.getDay()];
        },
        M: function(dateObj) {
          return String(dateObj.getMonth() + 1);
        },
        MM: function(dateObj) {
          return pad(dateObj.getMonth() + 1);
        },
        MMM: function(dateObj, i18n) {
          return i18n.monthNamesShort[dateObj.getMonth()];
        },
        MMMM: function(dateObj, i18n) {
          return i18n.monthNames[dateObj.getMonth()];
        },
        YY: function(dateObj) {
          return pad(String(dateObj.getFullYear()), 4).substr(2);
        },
        YYYY: function(dateObj) {
          return pad(dateObj.getFullYear(), 4);
        },
        h: function(dateObj) {
          return String(dateObj.getHours() % 12 || 12);
        },
        hh: function(dateObj) {
          return pad(dateObj.getHours() % 12 || 12);
        },
        H: function(dateObj) {
          return String(dateObj.getHours());
        },
        HH: function(dateObj) {
          return pad(dateObj.getHours());
        },
        m: function(dateObj) {
          return String(dateObj.getMinutes());
        },
        mm: function(dateObj) {
          return pad(dateObj.getMinutes());
        },
        s: function(dateObj) {
          return String(dateObj.getSeconds());
        },
        ss: function(dateObj) {
          return pad(dateObj.getSeconds());
        },
        S: function(dateObj) {
          return String(Math.round(dateObj.getMilliseconds() / 100));
        },
        SS: function(dateObj) {
          return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
        },
        SSS: function(dateObj) {
          return pad(dateObj.getMilliseconds(), 3);
        },
        a: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
        },
        A: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
        },
        ZZ: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
        },
        Z: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
        }
      };
      var monthParse = function(v) {
        return +v - 1;
      };
      var emptyDigits = [null, twoDigitsOptional];
      var emptyWord = [null, word];
      var amPm = [
        "isPm",
        word,
        function(v, i18n) {
          var val = v.toLowerCase();
          if (val === i18n.amPm[0]) {
            return 0;
          } else if (val === i18n.amPm[1]) {
            return 1;
          }
          return null;
        }
      ];
      var timezoneOffset = [
        "timezoneOffset",
        "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
        function(v) {
          var parts = (v + "").match(/([+-]|\d\d)/gi);
          if (parts) {
            var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
            return parts[0] === "+" ? minutes : -minutes;
          }
          return 0;
        }
      ];
      var parseFlags = {
        D: ["day", twoDigitsOptional],
        DD: ["day", twoDigits],
        Do: ["day", twoDigitsOptional + word, function(v) {
          return parseInt(v, 10);
        }],
        M: ["month", twoDigitsOptional, monthParse],
        MM: ["month", twoDigits, monthParse],
        YY: [
          "year",
          twoDigits,
          function(v) {
            var now = /* @__PURE__ */ new Date();
            var cent = +("" + now.getFullYear()).substr(0, 2);
            return +("" + (+v > 68 ? cent - 1 : cent) + v);
          }
        ],
        h: ["hour", twoDigitsOptional, void 0, "isPm"],
        hh: ["hour", twoDigits, void 0, "isPm"],
        H: ["hour", twoDigitsOptional],
        HH: ["hour", twoDigits],
        m: ["minute", twoDigitsOptional],
        mm: ["minute", twoDigits],
        s: ["second", twoDigitsOptional],
        ss: ["second", twoDigits],
        YYYY: ["year", fourDigits],
        S: ["millisecond", "\\d", function(v) {
          return +v * 100;
        }],
        SS: ["millisecond", twoDigits, function(v) {
          return +v * 10;
        }],
        SSS: ["millisecond", threeDigits],
        d: emptyDigits,
        dd: emptyDigits,
        ddd: emptyWord,
        dddd: emptyWord,
        MMM: ["month", word, monthUpdate("monthNamesShort")],
        MMMM: ["month", word, monthUpdate("monthNames")],
        a: amPm,
        A: amPm,
        ZZ: timezoneOffset,
        Z: timezoneOffset
      };
      var globalMasks = {
        default: "ddd MMM DD YYYY HH:mm:ss",
        shortDate: "M/D/YY",
        mediumDate: "MMM D, YYYY",
        longDate: "MMMM D, YYYY",
        fullDate: "dddd, MMMM D, YYYY",
        isoDate: "YYYY-MM-DD",
        isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
        shortTime: "HH:mm",
        mediumTime: "HH:mm:ss",
        longTime: "HH:mm:ss.SSS"
      };
      var setGlobalDateMasks = function(masks) {
        return assign(globalMasks, masks);
      };
      var format2 = function(dateObj, mask, i18n) {
        if (mask === void 0) {
          mask = globalMasks["default"];
        }
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof dateObj === "number") {
          dateObj = new Date(dateObj);
        }
        if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
          throw new Error("Invalid Date pass to format");
        }
        mask = globalMasks[mask] || mask;
        var literals = [];
        mask = mask.replace(literal, function($0, $1) {
          literals.push($1);
          return "@@@";
        });
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        mask = mask.replace(token, function($0) {
          return formatFlags[$0](dateObj, combinedI18nSettings);
        });
        return mask.replace(/@@@/g, function() {
          return literals.shift();
        });
      };
      function parse(dateStr, format3, i18n) {
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof format3 !== "string") {
          throw new Error("Invalid format in fecha parse");
        }
        format3 = globalMasks[format3] || format3;
        if (dateStr.length > 1e3) {
          return null;
        }
        var today = /* @__PURE__ */ new Date();
        var dateInfo = {
          year: today.getFullYear(),
          month: 0,
          day: 1,
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0,
          isPm: null,
          timezoneOffset: null
        };
        var parseInfo = [];
        var literals = [];
        var newFormat = format3.replace(literal, function($0, $1) {
          literals.push(regexEscape($1));
          return "@@@";
        });
        var specifiedFields = {};
        var requiredFields = {};
        newFormat = regexEscape(newFormat).replace(token, function($0) {
          var info = parseFlags[$0];
          var field2 = info[0], regex = info[1], requiredField = info[3];
          if (specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " specified twice in format");
          }
          specifiedFields[field2] = true;
          if (requiredField) {
            requiredFields[requiredField] = true;
          }
          parseInfo.push(info);
          return "(" + regex + ")";
        });
        Object.keys(requiredFields).forEach(function(field2) {
          if (!specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " is required in specified format");
          }
        });
        newFormat = newFormat.replace(/@@@/g, function() {
          return literals.shift();
        });
        var matches = dateStr.match(new RegExp(newFormat, "i"));
        if (!matches) {
          return null;
        }
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        for (var i = 1; i < matches.length; i++) {
          var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];
          var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
          if (value == null) {
            return null;
          }
          dateInfo[field] = value;
        }
        if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
          dateInfo.hour = +dateInfo.hour + 12;
        } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
          dateInfo.hour = 0;
        }
        var dateTZ;
        if (dateInfo.timezoneOffset == null) {
          dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
          var validateFields = [
            ["month", "getMonth"],
            ["day", "getDate"],
            ["hour", "getHours"],
            ["minute", "getMinutes"],
            ["second", "getSeconds"]
          ];
          for (var i = 0, len = validateFields.length; i < len; i++) {
            if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
              return null;
            }
          }
        } else {
          dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
          if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
            return null;
          }
        }
        return dateTZ;
      }
      var fecha = {
        format: format2,
        parse,
        defaultI18n,
        setGlobalDateI18n,
        setGlobalDateMasks
      };
      exports3.assign = assign;
      exports3.default = fecha;
      exports3.format = format2;
      exports3.parse = parse;
      exports3.defaultI18n = defaultI18n;
      exports3.setGlobalDateI18n = setGlobalDateI18n;
      exports3.setGlobalDateMasks = setGlobalDateMasks;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/logform/timestamp.js
var require_timestamp2 = __commonJS({
  "node_modules/logform/timestamp.js"(exports2, module2) {
    "use strict";
    var fecha = require_fecha_umd();
    var format2 = require_format();
    module2.exports = format2((info, opts = {}) => {
      if (opts.format) {
        info.timestamp = typeof opts.format === "function" ? opts.format() : fecha.format(/* @__PURE__ */ new Date(), opts.format);
      }
      if (!info.timestamp) {
        info.timestamp = (/* @__PURE__ */ new Date()).toISOString();
      }
      if (opts.alias) {
        info[opts.alias] = info.timestamp;
      }
      return info;
    });
  }
});

// node_modules/logform/uncolorize.js
var require_uncolorize = __commonJS({
  "node_modules/logform/uncolorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    module2.exports = format2((info, opts) => {
      if (opts.level !== false) {
        info.level = colors.strip(info.level);
      }
      if (opts.message !== false) {
        info.message = colors.strip(String(info.message));
      }
      if (opts.raw !== false && info[MESSAGE]) {
        info[MESSAGE] = colors.strip(String(info[MESSAGE]));
      }
      return info;
    });
  }
});

// node_modules/logform/index.js
var require_logform = __commonJS({
  "node_modules/logform/index.js"(exports2) {
    "use strict";
    var format2 = exports2.format = require_format();
    exports2.levels = require_levels();
    function exposeFormat(name, requireFormat) {
      Object.defineProperty(format2, name, {
        get() {
          return requireFormat();
        },
        configurable: true
      });
    }
    exposeFormat("align", function() {
      return require_align();
    });
    exposeFormat("errors", function() {
      return require_errors3();
    });
    exposeFormat("cli", function() {
      return require_cli2();
    });
    exposeFormat("combine", function() {
      return require_combine();
    });
    exposeFormat("colorize", function() {
      return require_colorize();
    });
    exposeFormat("json", function() {
      return require_json();
    });
    exposeFormat("label", function() {
      return require_label();
    });
    exposeFormat("logstash", function() {
      return require_logstash();
    });
    exposeFormat("metadata", function() {
      return require_metadata();
    });
    exposeFormat("ms", function() {
      return require_ms2();
    });
    exposeFormat("padLevels", function() {
      return require_pad_levels();
    });
    exposeFormat("prettyPrint", function() {
      return require_pretty_print();
    });
    exposeFormat("printf", function() {
      return require_printf();
    });
    exposeFormat("simple", function() {
      return require_simple();
    });
    exposeFormat("splat", function() {
      return require_splat();
    });
    exposeFormat("timestamp", function() {
      return require_timestamp2();
    });
    exposeFormat("uncolorize", function() {
      return require_uncolorize();
    });
  }
});

// node_modules/winston/lib/winston/common.js
var require_common5 = __commonJS({
  "node_modules/winston/lib/winston/common.js"(exports2) {
    "use strict";
    var { format: format2 } = require("util");
    exports2.warn = {
      deprecated(prop) {
        return () => {
          throw new Error(format2("{ %s } was removed in winston@3.0.0.", prop));
        };
      },
      useFormat(prop) {
        return () => {
          throw new Error([
            format2("{ %s } was removed in winston@3.0.0.", prop),
            "Use a custom winston.format = winston.format(function) instead."
          ].join("\n"));
        };
      },
      forFunctions(obj, type, props) {
        props.forEach((prop) => {
          obj[prop] = exports2.warn[type](prop);
        });
      },
      moved(obj, movedTo, prop) {
        function movedNotice() {
          return () => {
            throw new Error([
              format2("winston.%s was moved in winston@3.0.0.", prop),
              format2("Use a winston.%s instead.", movedTo)
            ].join("\n"));
          };
        }
        Object.defineProperty(obj, prop, {
          get: movedNotice,
          set: movedNotice
        });
      },
      forProperties(obj, type, props) {
        props.forEach((prop) => {
          const notice = exports2.warn[type](prop);
          Object.defineProperty(obj, prop, {
            get: notice,
            set: notice
          });
        });
      }
    };
  }
});

// node_modules/winston/package.json
var require_package3 = __commonJS({
  "node_modules/winston/package.json"(exports2, module2) {
    module2.exports = {
      name: "winston",
      description: "A logger for just about everything.",
      version: "3.8.2",
      author: "Charlie Robbins <charlie.robbins@gmail.com>",
      maintainers: [
        "David Hyde <dabh@alumni.stanford.edu>"
      ],
      repository: {
        type: "git",
        url: "https://github.com/winstonjs/winston.git"
      },
      keywords: [
        "winston",
        "logger",
        "logging",
        "logs",
        "sysadmin",
        "bunyan",
        "pino",
        "loglevel",
        "tools",
        "json",
        "stream"
      ],
      dependencies: {
        "@dabh/diagnostics": "^2.0.2",
        "@colors/colors": "1.5.0",
        async: "^3.2.3",
        "is-stream": "^2.0.0",
        logform: "^2.4.0",
        "one-time": "^1.0.0",
        "readable-stream": "^3.4.0",
        "safe-stable-stringify": "^2.3.1",
        "stack-trace": "0.0.x",
        "triple-beam": "^1.3.0",
        "winston-transport": "^4.5.0"
      },
      devDependencies: {
        "@babel/cli": "^7.17.0",
        "@babel/core": "^7.17.2",
        "@babel/preset-env": "^7.16.7",
        "@dabh/eslint-config-populist": "^5.0.0",
        "@types/node": "^18.0.0",
        "abstract-winston-transport": "^0.5.1",
        assume: "^2.2.0",
        "cross-spawn-async": "^2.2.5",
        eslint: "^8.9.0",
        hock: "^1.4.1",
        mocha: "8.1.3",
        nyc: "^15.1.0",
        rimraf: "^3.0.2",
        split2: "^4.1.0",
        "std-mocks": "^1.0.1",
        through2: "^4.0.2",
        "winston-compat": "^0.1.5"
      },
      main: "./lib/winston.js",
      browser: "./dist/winston",
      types: "./index.d.ts",
      scripts: {
        lint: "eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist",
        test: "mocha",
        "test:coverage": "nyc npm run test:unit",
        "test:unit": "mocha test/unit",
        "test:integration": "mocha test/integration",
        build: "rimraf dist && babel lib -d dist",
        prepublishOnly: "npm run build"
      },
      engines: {
        node: ">= 12.0.0"
      },
      license: "MIT"
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream2 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream4, err) {
      var rState = stream4._readableState;
      var wState = stream4._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream4.destroy(err);
      else
        stream4.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors.js
var require_errors4 = __commonJS({
  "node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith2(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith2(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors4().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util2 = require("util");
      if (typeof util2.inherits !== "function")
        throw "";
      module2.exports = util2.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util2;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer5 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer5.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer5.alloc(0);
          var ret = Buffer5.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer5.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer5 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer5.from && Buffer5.alloc && Buffer5.allocUnsafe && Buffer5.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer5(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer5.prototype);
    copyProps(Buffer5, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer5(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer5(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer5(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer5 = require_safe_buffer().Buffer;
    var isEncoding = Buffer5.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer5.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer5.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors4().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream4) {
      return stream4.setHeader && typeof stream4.abort === "function";
    }
    function eos(stream4, opts, callback) {
      if (typeof opts === "function")
        return eos(stream4, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream4.readable;
      var writable = opts.writable || opts.writable !== false && stream4.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream4.writable)
          onfinish();
      };
      var writableEnded = stream4._writableState && stream4._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream4);
      };
      var readableEnded = stream4._readableState && stream4._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream4);
      };
      var onerror = function onerror2(err) {
        callback.call(stream4, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream4._readableState || !stream4._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream4, err);
        }
        if (writable && !writableEnded) {
          if (!stream4._writableState || !stream4._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream4, err);
        }
      };
      var onrequest = function onrequest2() {
        stream4.req.on("finish", onfinish);
      };
      if (isRequest(stream4)) {
        stream4.on("complete", onfinish);
        stream4.on("abort", onclose);
        if (stream4.req)
          onrequest();
        else
          stream4.on("request", onrequest);
      } else if (writable && !stream4._writableState) {
        stream4.on("end", onlegacyfinish);
        stream4.on("close", onlegacyfinish);
      }
      stream4.on("end", onend);
      stream4.on("finish", onfinish);
      if (opts.error !== false)
        stream4.on("error", onerror);
      stream4.on("close", onclose);
      return function() {
        stream4.removeListener("complete", onfinish);
        stream4.removeListener("abort", onclose);
        stream4.removeListener("request", onrequest);
        if (stream4.req)
          stream4.req.removeListener("finish", onfinish);
        stream4.removeListener("end", onlegacyfinish);
        stream4.removeListener("close", onlegacyfinish);
        stream4.removeListener("finish", onfinish);
        stream4.removeListener("end", onend);
        stream4.removeListener("error", onerror);
        stream4.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream4) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream4,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream4._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream4, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream4.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from2 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors4().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable2, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable2(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable2;
    var Duplex;
    Readable2.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream2();
    var Buffer5 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer5.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer5.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors4().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable2, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream4, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream4 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer5.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream4, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream4._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream4, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream4, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer5.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream4, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream4, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream4, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream4, state, chunk, false);
              else
                maybeReadMore(stream4, state);
            } else {
              addChunk(stream4, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream4, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream4, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream4.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream4);
      }
      maybeReadMore(stream4, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream4, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream4);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream4);
        }
      }
    }
    function emitReadable(stream4) {
      var state = stream4._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream4);
      }
    }
    function emitReadable_(stream4) {
      var state = stream4._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream4.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream4);
    }
    function maybeReadMore(stream4, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream4, state);
      }
    }
    function maybeReadMore_(stream4, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream4.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream4, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream4, state);
      }
    }
    function resume_(stream4, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream4.read(0);
      }
      state.resumeScheduled = false;
      stream4.emit("resume");
      flow(stream4);
      if (state.flowing && !state.reading)
        stream4.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream4) {
      var state = stream4._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream4.read() !== null)
        ;
    }
    Readable2.prototype.wrap = function(stream4) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream4.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream4.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream4.pause();
        }
      });
      for (var i in stream4) {
        if (this[i] === void 0 && typeof stream4[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream4[method].apply(stream4, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream4.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream4.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream4) {
      var state = stream4._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream4);
      }
    }
    function endReadableNT(state, stream4) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream4.readable = false;
        stream4.emit("end");
        if (state.autoDestroy) {
          var wState = stream4._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream4.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from2();
        }
        return from(Readable2, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable2 = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable2);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream2();
    var Buffer5 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer5.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer5.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors4().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream4, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream4 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream4, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream4, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream4, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream4, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream4, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer5.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer5.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream4, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream4, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream4, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream4._writev(chunk, state.onwrite);
      else
        stream4._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream4, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream4, state);
        stream4._writableState.errorEmitted = true;
        errorOrDestroy(stream4, er);
      } else {
        cb(er);
        stream4._writableState.errorEmitted = true;
        errorOrDestroy(stream4, er);
        finishMaybe(stream4, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream4, er) {
      var state = stream4._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream4, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream4.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream4, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream4, state, finished, cb);
        } else {
          afterWrite(stream4, state, finished, cb);
        }
      }
    }
    function afterWrite(stream4, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream4, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream4, state);
    }
    function onwriteDrain(stream4, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream4.emit("drain");
      }
    }
    function clearBuffer(stream4, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream4._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream4, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream4, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream4, state) {
      stream4._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream4, err);
        }
        state.prefinished = true;
        stream4.emit("prefinish");
        finishMaybe(stream4, state);
      });
    }
    function prefinish(stream4, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream4._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream4, state);
        } else {
          state.prefinished = true;
          stream4.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream4, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream4, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream4.emit("finish");
          if (state.autoDestroy) {
            var rState = stream4._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream4.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream4, state, cb) {
      state.ending = true;
      finishMaybe(stream4, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream4.once("finish", cb);
      }
      state.ended = true;
      stream4.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/winston-transport/legacy.js
var require_legacy = __commonJS({
  "node_modules/winston-transport/legacy.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var { LEVEL } = require_triple_beam();
    var TransportStream = require_winston_transport();
    var LegacyTransportStream = module2.exports = function LegacyTransportStream2(options = {}) {
      TransportStream.call(this, options);
      if (!options.transport || typeof options.transport.log !== "function") {
        throw new Error("Invalid transport, must be an object with a log method.");
      }
      this.transport = options.transport;
      this.level = this.level || options.transport.level;
      this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
      this._deprecated();
      function transportError(err) {
        this.emit("error", err, this.transport);
      }
      if (!this.transport.__winstonError) {
        this.transport.__winstonError = transportError.bind(this);
        this.transport.on("error", this.transport.__winstonError);
      }
    };
    util2.inherits(LegacyTransportStream, TransportStream);
    LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
        this.transport.log(info[LEVEL], info.message, info, this._nop);
      }
      callback(null);
    };
    LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
      for (let i = 0; i < chunks.length; i++) {
        if (this._accept(chunks[i])) {
          this.transport.log(
            chunks[i].chunk[LEVEL],
            chunks[i].chunk.message,
            chunks[i].chunk,
            this._nop
          );
          chunks[i].callback();
        }
      }
      return callback(null);
    };
    LegacyTransportStream.prototype._deprecated = function _deprecated() {
      console.error([
        `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
        "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
      ].join("\n"));
    };
    LegacyTransportStream.prototype.close = function close2() {
      if (this.transport.close) {
        this.transport.close();
      }
      if (this.transport.__winstonError) {
        this.transport.removeListener("error", this.transport.__winstonError);
        this.transport.__winstonError = null;
      }
    };
  }
});

// node_modules/winston-transport/index.js
var require_winston_transport = __commonJS({
  "node_modules/winston-transport/index.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var Writable = require_stream_writable();
    var { LEVEL } = require_triple_beam();
    var TransportStream = module2.exports = function TransportStream2(options = {}) {
      Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
      this.format = options.format;
      this.level = options.level;
      this.handleExceptions = options.handleExceptions;
      this.handleRejections = options.handleRejections;
      this.silent = options.silent;
      if (options.log)
        this.log = options.log;
      if (options.logv)
        this.logv = options.logv;
      if (options.close)
        this.close = options.close;
      this.once("pipe", (logger) => {
        this.levels = logger.levels;
        this.parent = logger;
      });
      this.once("unpipe", (src) => {
        if (src === this.parent) {
          this.parent = null;
          if (this.close) {
            this.close();
          }
        }
      });
    };
    util2.inherits(TransportStream, Writable);
    TransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      const level = this.level || this.parent && this.parent.level;
      if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (info && !this.format) {
          return this.log(info, callback);
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(Object.assign({}, info), this.format.options);
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          callback();
          if (errState)
            throw errState;
          return;
        }
        return this.log(transformed, callback);
      }
      this._writableState.sync = false;
      return callback(null);
    };
    TransportStream.prototype._writev = function _writev(chunks, callback) {
      if (this.logv) {
        const infos = chunks.filter(this._accept, this);
        if (!infos.length) {
          return callback(null);
        }
        return this.logv(infos, callback);
      }
      for (let i = 0; i < chunks.length; i++) {
        if (!this._accept(chunks[i]))
          continue;
        if (chunks[i].chunk && !this.format) {
          this.log(chunks[i].chunk, chunks[i].callback);
          continue;
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(
            Object.assign({}, chunks[i].chunk),
            this.format.options
          );
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          chunks[i].callback();
          if (errState) {
            callback(null);
            throw errState;
          }
        } else {
          this.log(transformed, chunks[i].callback);
        }
      }
      return callback(null);
    };
    TransportStream.prototype._accept = function _accept(write2) {
      const info = write2.chunk;
      if (this.silent) {
        return false;
      }
      const level = this.level || this.parent && this.parent.level;
      if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (this.handleExceptions || info.exception !== true) {
          return true;
        }
      }
      return false;
    };
    TransportStream.prototype._nop = function _nop() {
      return void 0;
    };
    module2.exports.LegacyTransportStream = require_legacy();
  }
});

// node_modules/winston/lib/winston/transports/console.js
var require_console = __commonJS({
  "node_modules/winston/lib/winston/transports/console.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var { LEVEL, MESSAGE } = require_triple_beam();
    var TransportStream = require_winston_transport();
    module2.exports = class Console extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "console";
        this.stderrLevels = this._stringArrayToSet(options.stderrLevels);
        this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.setMaxListeners(30);
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.stderrLevels[info[LEVEL]]) {
          if (console._stderr) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            console.error(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        } else if (this.consoleWarnLevels[info[LEVEL]]) {
          if (console._stderr) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            console.warn(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        }
        if (console._stdout) {
          console._stdout.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          console.log(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
      }
      /**
       * Returns a Set-like object with strArray's elements as keys (each with the
       * value true).
       * @param {Array} strArray - Array of Set-elements as strings.
       * @param {?string} [errMsg] - Custom error message thrown on invalid input.
       * @returns {Object} - TODO: add return description.
       * @private
       */
      _stringArrayToSet(strArray, errMsg) {
        if (!strArray)
          return {};
        errMsg = errMsg || "Cannot make set from type other than Array of string elements";
        if (!Array.isArray(strArray)) {
          throw new Error(errMsg);
        }
        return strArray.reduce((set, el) => {
          if (typeof el !== "string") {
            throw new Error(errMsg);
          }
          set[el] = true;
          return set;
        }, {});
      }
    };
  }
});

// node_modules/async/internal/isArrayLike.js
var require_isArrayLike2 = __commonJS({
  "node_modules/async/internal/isArrayLike.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isArrayLike;
    function isArrayLike(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "node_modules/async/internal/initialParams.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/async/internal/setImmediate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.fallback = fallback;
    exports2.wrap = wrap;
    var hasQueueMicrotask = exports2.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = exports2.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports2.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return (fn, ...args) => defer(() => fn(...args));
    }
    var _defer;
    if (hasQueueMicrotask) {
      _defer = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports2.default = wrap(_defer);
  }
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "node_modules/async/asyncify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncify;
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault(_setImmediate);
    var _wrapAsync = require_wrapAsync();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncify(func) {
      if ((0, _wrapAsync.isAsync)(func)) {
        return function(...args) {
          const callback = args.pop();
          const promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      }
      return (0, _initialParams2.default)(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function") {
          return handlePromise(result, callback);
        } else {
          callback(null, result);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && err.message ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (err) {
        (0, _setImmediate2.default)((e) => {
          throw e;
        }, err);
      }
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "node_modules/async/internal/wrapAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isAsyncIterable = exports2.isAsyncGenerator = exports2.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault(_asyncify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync2(asyncFn) {
      if (typeof asyncFn !== "function")
        throw new Error("expected a function");
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    exports2.default = wrapAsync2;
    exports2.isAsync = isAsync;
    exports2.isAsyncGenerator = isAsyncGenerator;
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS({
  "node_modules/async/internal/awaitify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = awaitify;
    function awaitify(asyncFn, arity = asyncFn.length) {
      if (!arity)
        throw new Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
          return asyncFn.apply(this, args);
        }
        return new Promise((resolve, reject) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err)
              return reject(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args);
        });
      }
      return awaitable;
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/parallel.js
var require_parallel = __commonJS({
  "node_modules/async/internal/parallel.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike2();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
      var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        (0, _wrapAsync2.default)(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results[key] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/once.js
var require_once = __commonJS({
  "node_modules/async/internal/once.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = once;
    function once(fn) {
      function wrapper(...args) {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "node_modules/async/internal/getIterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/iterator.js
var require_iterator2 = __commonJS({
  "node_modules/async/internal/iterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createIterator;
    var _isArrayLike = require_isArrayLike2();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault(_getIterator);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
        var item = iterator.next();
        if (item.done)
          return null;
        i++;
        return { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i];
        if (key === "__proto__") {
          return next();
        }
        return i < len ? { value: obj[key], key } : null;
      };
    }
    function createIterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = (0, _getIterator2.default)(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "node_modules/async/internal/onlyOnce.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = onlyOnce;
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      };
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "node_modules/async/internal/breakLoop.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var breakLoop = {};
    exports2.default = breakLoop;
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS({
  "node_modules/async/internal/asyncEachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncEachOfLimit;
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done)
          return;
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
          if (canceled || done)
            return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        running -= 1;
        if (canceled)
          return;
        if (err)
          return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled)
          return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "node_modules/async/internal/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _iterator = require_iterator2();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _asyncEachOfLimit = require_asyncEachOfLimit();
    var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = (limit) => {
      return (obj, iteratee, callback) => {
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled)
            return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === _breakLoop2.default || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "node_modules/async/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfLimit, 4);
    module2.exports = exports2["default"];
  }
});

// node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS({
  "node_modules/async/eachOfSeries.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfSeries(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfSeries, 3);
    module2.exports = exports2["default"];
  }
});

// node_modules/async/series.js
var require_series = __commonJS({
  "node_modules/async/series.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = series;
    var _parallel2 = require_parallel();
    var _parallel3 = _interopRequireDefault(_parallel2);
    var _eachOfSeries = require_eachOfSeries();
    var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function series(tasks, callback) {
      return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors4().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream4, er, data) {
      if (er)
        return stream4.emit("error", er);
      if (data != null)
        stream4.push(data);
      if (stream4._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream4._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream4.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors4().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err)
        throw err;
    }
    function isRequest(stream4) {
      return stream4.setHeader && typeof stream4.abort === "function";
    }
    function destroyer(stream4, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream4.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream4, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream4))
          return stream4.abort();
        if (typeof stream4.destroy === "function")
          return stream4.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop2;
      if (typeof streams[streams.length - 1] !== "function")
        return noop2;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream4, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream4, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable.js
var require_readable2 = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream();
      exports2.pipeline = require_pipeline();
    }
  }
});

// node_modules/@dabh/diagnostics/diagnostics.js
var require_diagnostics = __commonJS({
  "node_modules/@dabh/diagnostics/diagnostics.js"(exports2, module2) {
    var adapters = [];
    var modifiers = [];
    var logger = function devnull() {
    };
    function use(adapter) {
      if (~adapters.indexOf(adapter))
        return false;
      adapters.push(adapter);
      return true;
    }
    function set(custom) {
      logger = custom;
    }
    function enabled(namespace) {
      var async = [];
      for (var i = 0; i < adapters.length; i++) {
        if (adapters[i].async) {
          async.push(adapters[i]);
          continue;
        }
        if (adapters[i](namespace))
          return true;
      }
      if (!async.length)
        return false;
      return new Promise(function pinky(resolve) {
        Promise.all(
          async.map(function prebind(fn) {
            return fn(namespace);
          })
        ).then(function resolved(values) {
          resolve(values.some(Boolean));
        });
      });
    }
    function modify(fn) {
      if (~modifiers.indexOf(fn))
        return false;
      modifiers.push(fn);
      return true;
    }
    function write2() {
      logger.apply(logger, arguments);
    }
    function process2(message) {
      for (var i = 0; i < modifiers.length; i++) {
        message = modifiers[i].apply(modifiers[i], arguments);
      }
      return message;
    }
    function introduce(fn, options) {
      var has = Object.prototype.hasOwnProperty;
      for (var key in options) {
        if (has.call(options, key)) {
          fn[key] = options[key];
        }
      }
      return fn;
    }
    function nope(options) {
      options.enabled = false;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(function diagnopes() {
        return false;
      }, options);
    }
    function yep(options) {
      function diagnostics() {
        var args = Array.prototype.slice.call(arguments, 0);
        write2.call(write2, options, process2(args, options));
        return true;
      }
      options.enabled = true;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(diagnostics, options);
    }
    module2.exports = function create(diagnostics) {
      diagnostics.introduce = introduce;
      diagnostics.enabled = enabled;
      diagnostics.process = process2;
      diagnostics.modify = modify;
      diagnostics.write = write2;
      diagnostics.nope = nope;
      diagnostics.yep = yep;
      diagnostics.set = set;
      diagnostics.use = use;
      return diagnostics;
    };
  }
});

// node_modules/@dabh/diagnostics/node/production.js
var require_production = __commonJS({
  "node_modules/@dabh/diagnostics/node/production.js"(exports2, module2) {
    var create = require_diagnostics();
    var diagnostics = create(function prod(namespace, options) {
      options = options || {};
      options.namespace = namespace;
      options.prod = true;
      options.dev = false;
      if (!(options.force || prod.force))
        return prod.nope(options);
      return prod.yep(options);
    });
    module2.exports = diagnostics;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports2, module2) {
    module2.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports2, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module2.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len = args.length; i < len; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports2, module2) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty2 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty2.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty2.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var s = clamp(parseFloat(match[2]), 0, 100);
        var l = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match[2]), 0, 100);
        var b = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r = Math.round(rgba[0] / 255 * 100);
      var g = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/color/index.js
var require_color = __commonJS({
  "node_modules/color/index.js"(exports2, module2) {
    "use strict";
    var colorString = require_color_string();
    var convert = require_color_convert();
    var _slice = [].slice;
    var skippedModels = [
      // to be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // gray conflicts with some method names, and has its own method defined.
      "gray",
      // shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    Object.keys(convert).forEach(function(model) {
      hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
    });
    var limiters = {};
    function Color(obj, model) {
      if (!(this instanceof Color)) {
        return new Color(obj, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      var i;
      var channels;
      if (obj == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (obj instanceof Color) {
        this.model = obj.model;
        this.color = obj.color.slice();
        this.valpha = obj.valpha;
      } else if (typeof obj === "string") {
        var result = colorString.get(obj);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + obj);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (obj.length) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        var newArr = _slice.call(obj, 0, channels);
        this.color = zeroArray(newArr, channels);
        this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
      } else if (typeof obj === "number") {
        obj &= 16777215;
        this.model = "rgb";
        this.color = [
          obj >> 16 & 255,
          obj >> 8 & 255,
          obj & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        var keys = Object.keys(obj);
        if ("alpha" in obj) {
          keys.splice(keys.indexOf("alpha"), 1);
          this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
        }
        var hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
        }
        this.model = hashedModelKeys[hashedKeys];
        var labels = convert[this.model].labels;
        var color = [];
        for (i = 0; i < labels.length; i++) {
          color.push(obj[labels[i]]);
        }
        this.color = zeroArray(color);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i = 0; i < channels; i++) {
          var limit = limiters[this.model][i];
          if (limit) {
            this.color[i] = limit(this.color[i]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color.prototype = {
      toString: function() {
        return this.string();
      },
      toJSON: function() {
        return this[this.model]();
      },
      string: function(places) {
        var self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to[self2.model](args);
      },
      percentString: function(places) {
        var self2 = this.rgb().round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to.rgb.percent(args);
      },
      array: function() {
        return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
      },
      object: function() {
        var result = {};
        var channels = convert[this.model].channels;
        var labels = convert[this.model].labels;
        for (var i = 0; i < channels; i++) {
          result[labels[i]] = this.color[i];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray: function() {
        var rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject: function() {
        var rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round: function(places) {
        places = Math.max(places || 0, 0);
        return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
      },
      alpha: function(val) {
        if (arguments.length) {
          return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
        }
        return this.valpha;
      },
      // rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
        return (val % 360 + 360) % 360;
      }),
      // eslint-disable-line brace-style
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(100)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(100)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return convert[this.model].keyword(this.color);
      },
      hex: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      rgbNumber: function() {
        var rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity: function() {
        var rgb = this.rgb().color;
        var lum = [];
        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function(color2) {
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function(color2) {
        var contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7.1) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark: function() {
        var rgb = this.rgb().color;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
        return yiq < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      negate: function() {
        var rgb = this.rgb();
        for (var i = 0; i < 3; i++) {
          rgb.color[i] = 255 - rgb.color[i];
        }
        return rgb;
      },
      lighten: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten: function(ratio) {
        var hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken: function(ratio) {
        var hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale: function() {
        var rgb = this.rgb().color;
        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(val, val, val);
      },
      fade: function(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer: function(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate: function(degrees) {
        var hsl = this.hsl();
        var hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix: function(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        var color1 = mixinColor.rgb();
        var color2 = this.rgb();
        var p = weight === void 0 ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        var w2 = 1 - w1;
        return Color.rgb(
          w1 * color1.red() + w2 * color2.red(),
          w1 * color1.green() + w2 * color2.green(),
          w1 * color1.blue() + w2 * color2.blue(),
          color1.alpha() * p + color2.alpha() * (1 - p)
        );
      }
    };
    Object.keys(convert).forEach(function(model) {
      if (skippedModels.indexOf(model) !== -1) {
        return;
      }
      var channels = convert[model].channels;
      Color.prototype[model] = function() {
        if (this.model === model) {
          return new Color(this);
        }
        if (arguments.length) {
          return new Color(arguments, model);
        }
        var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
        return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
      };
      Color[model] = function(color) {
        if (typeof color === "number") {
          color = zeroArray(_slice.call(arguments), channels);
        }
        return new Color(color, model);
      };
    });
    function roundTo(num, places) {
      return Number(num.toFixed(places));
    }
    function roundToPlace(places) {
      return function(num) {
        return roundTo(num, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      model.forEach(function(m) {
        (limiters[m] || (limiters[m] = []))[channel] = modifier;
      });
      model = model[0];
      return function(val) {
        var result;
        if (arguments.length) {
          if (modifier) {
            val = modifier(val);
          }
          result = this[model]();
          result.color[channel] = val;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max) {
      return function(v) {
        return Math.max(0, Math.min(max, v));
      };
    }
    function assertArray(val) {
      return Array.isArray(val) ? val : [val];
    }
    function zeroArray(arr, length) {
      for (var i = 0; i < length; i++) {
        if (typeof arr[i] !== "number") {
          arr[i] = 0;
        }
      }
      return arr;
    }
    module2.exports = Color;
  }
});

// node_modules/text-hex/index.js
var require_text_hex = __commonJS({
  "node_modules/text-hex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function hex(str) {
      for (var i = 0, hash = 0; i < str.length; hash = str.charCodeAt(i++) + ((hash << 5) - hash))
        ;
      var color = Math.floor(
        Math.abs(
          Math.sin(hash) * 1e4 % 1 * 16777216
        )
      ).toString(16);
      return "#" + Array(6 - color.length + 1).join("0") + color;
    };
  }
});

// node_modules/colorspace/index.js
var require_colorspace = __commonJS({
  "node_modules/colorspace/index.js"(exports2, module2) {
    "use strict";
    var color = require_color();
    var hex = require_text_hex();
    module2.exports = function colorspace(namespace, delimiter) {
      var split = namespace.split(delimiter || ":");
      var base = hex(split[0]);
      if (!split.length)
        return base;
      for (var i = 0, l = split.length - 1; i < l; i++) {
        base = color(base).mix(color(hex(split[i + 1]))).saturate(1).hex();
      }
      return base;
    };
  }
});

// node_modules/kuler/index.js
var require_kuler = __commonJS({
  "node_modules/kuler/index.js"(exports2, module2) {
    "use strict";
    function Kuler(text, color) {
      if (color)
        return new Kuler(text).style(color);
      if (!(this instanceof Kuler))
        return new Kuler(text);
      this.text = text;
    }
    Kuler.prototype.prefix = "\x1B[";
    Kuler.prototype.suffix = "m";
    Kuler.prototype.hex = function hex(color) {
      color = color[0] === "#" ? color.substring(1) : color;
      if (color.length === 3) {
        color = color.split("");
        color[5] = color[2];
        color[4] = color[2];
        color[3] = color[1];
        color[2] = color[1];
        color[1] = color[0];
        color = color.join("");
      }
      var r = color.substring(0, 2), g = color.substring(2, 4), b = color.substring(4, 6);
      return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
    };
    Kuler.prototype.rgb = function rgb(r, g, b) {
      var red = r / 255 * 5, green = g / 255 * 5, blue = b / 255 * 5;
      return this.ansi(red, green, blue);
    };
    Kuler.prototype.ansi = function ansi(r, g, b) {
      var red = Math.round(r), green = Math.round(g), blue = Math.round(b);
      return 16 + red * 36 + green * 6 + blue;
    };
    Kuler.prototype.reset = function reset() {
      return this.prefix + "39;49" + this.suffix;
    };
    Kuler.prototype.style = function style(color) {
      return this.prefix + "38;5;" + this.rgb.apply(this, this.hex(color)) + this.suffix + this.text + this.reset();
    };
    module2.exports = Kuler;
  }
});

// node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js
var require_namespace_ansi = __commonJS({
  "node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js"(exports2, module2) {
    var colorspace = require_colorspace();
    var kuler = require_kuler();
    module2.exports = function ansiModifier(args, options) {
      var namespace = options.namespace;
      var ansi = options.colors !== false ? kuler(namespace + ":", colorspace(namespace)) : namespace + ":";
      args[0] = ansi + " " + args[0];
      return args;
    };
  }
});

// node_modules/enabled/index.js
var require_enabled = __commonJS({
  "node_modules/enabled/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function enabled(name, variable) {
      if (!variable)
        return false;
      var variables = variable.split(/[\s,]+/), i = 0;
      for (; i < variables.length; i++) {
        variable = variables[i].replace("*", ".*?");
        if ("-" === variable.charAt(0)) {
          if (new RegExp("^" + variable.substr(1) + "$").test(name)) {
            return false;
          }
          continue;
        }
        if (new RegExp("^" + variable + "$").test(name)) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/@dabh/diagnostics/adapters/index.js
var require_adapters = __commonJS({
  "node_modules/@dabh/diagnostics/adapters/index.js"(exports2, module2) {
    var enabled = require_enabled();
    module2.exports = function create(fn) {
      return function adapter(namespace) {
        try {
          return enabled(namespace, fn());
        } catch (e) {
        }
        return false;
      };
    };
  }
});

// node_modules/@dabh/diagnostics/adapters/process.env.js
var require_process_env = __commonJS({
  "node_modules/@dabh/diagnostics/adapters/process.env.js"(exports2, module2) {
    var adapter = require_adapters();
    module2.exports = adapter(function processenv() {
      return process.env.DEBUG || process.env.DIAGNOSTICS;
    });
  }
});

// node_modules/@dabh/diagnostics/logger/console.js
var require_console2 = __commonJS({
  "node_modules/@dabh/diagnostics/logger/console.js"(exports2, module2) {
    module2.exports = function(meta, messages) {
      try {
        Function.prototype.apply.call(console.log, console, messages);
      } catch (e) {
      }
    };
  }
});

// node_modules/@dabh/diagnostics/node/development.js
var require_development = __commonJS({
  "node_modules/@dabh/diagnostics/node/development.js"(exports2, module2) {
    var create = require_diagnostics();
    var tty = require("tty").isatty(1);
    var diagnostics = create(function dev(namespace, options) {
      options = options || {};
      options.colors = "colors" in options ? options.colors : tty;
      options.namespace = namespace;
      options.prod = false;
      options.dev = true;
      if (!dev.enabled(namespace) && !(options.force || dev.force)) {
        return dev.nope(options);
      }
      return dev.yep(options);
    });
    diagnostics.modify(require_namespace_ansi());
    diagnostics.use(require_process_env());
    diagnostics.set(require_console2());
    module2.exports = diagnostics;
  }
});

// node_modules/@dabh/diagnostics/node/index.js
var require_node2 = __commonJS({
  "node_modules/@dabh/diagnostics/node/index.js"(exports2, module2) {
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_production();
    } else {
      module2.exports = require_development();
    }
  }
});

// node_modules/winston/lib/winston/tail-file.js
var require_tail_file = __commonJS({
  "node_modules/winston/lib/winston/tail-file.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var { StringDecoder } = require("string_decoder");
    var { Stream } = require_readable2();
    function noop2() {
    }
    module2.exports = (options, iter) => {
      const buffer = Buffer.alloc(64 * 1024);
      const decode = new StringDecoder("utf8");
      const stream4 = new Stream();
      let buff = "";
      let pos = 0;
      let row = 0;
      if (options.start === -1) {
        delete options.start;
      }
      stream4.readable = true;
      stream4.destroy = () => {
        stream4.destroyed = true;
        stream4.emit("end");
        stream4.emit("close");
      };
      fs2.open(options.file, "a+", "0644", (err, fd) => {
        if (err) {
          if (!iter) {
            stream4.emit("error", err);
          } else {
            iter(err);
          }
          stream4.destroy();
          return;
        }
        (function read3() {
          if (stream4.destroyed) {
            fs2.close(fd, noop2);
            return;
          }
          return fs2.read(fd, buffer, 0, buffer.length, pos, (error, bytes) => {
            if (error) {
              if (!iter) {
                stream4.emit("error", error);
              } else {
                iter(error);
              }
              stream4.destroy();
              return;
            }
            if (!bytes) {
              if (buff) {
                if (options.start == null || row > options.start) {
                  if (!iter) {
                    stream4.emit("line", buff);
                  } else {
                    iter(null, buff);
                  }
                }
                row++;
                buff = "";
              }
              return setTimeout(read3, 1e3);
            }
            let data = decode.write(buffer.slice(0, bytes));
            if (!iter) {
              stream4.emit("data", data);
            }
            data = (buff + data).split(/\n+/);
            const l = data.length - 1;
            let i = 0;
            for (; i < l; i++) {
              if (options.start == null || row > options.start) {
                if (!iter) {
                  stream4.emit("line", data[i]);
                } else {
                  iter(null, data[i]);
                }
              }
              row++;
            }
            buff = data[l];
            pos += bytes;
            return read3();
          });
        })();
      });
      if (!iter) {
        return stream4;
      }
      return stream4.destroy;
    };
  }
});

// node_modules/winston/lib/winston/transports/file.js
var require_file2 = __commonJS({
  "node_modules/winston/lib/winston/transports/file.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var path = require("path");
    var asyncSeries = require_series();
    var zlib2 = require("zlib");
    var { MESSAGE } = require_triple_beam();
    var { Stream, PassThrough } = require_readable2();
    var TransportStream = require_winston_transport();
    var debug = require_node2()("winston:file");
    var os = require("os");
    var tailFile = require_tail_file();
    module2.exports = class File extends TransportStream {
      /**
       * Constructor function for the File transport object responsible for
       * persisting log messages and metadata to one or more files.
       * @param {Object} options - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "file";
        function throwIf(target, ...args) {
          args.slice(1).forEach((name) => {
            if (options[name]) {
              throw new Error(`Cannot set ${name} and ${target} together`);
            }
          });
        }
        this._stream = new PassThrough();
        this._stream.setMaxListeners(30);
        this._onError = this._onError.bind(this);
        if (options.filename || options.dirname) {
          throwIf("filename or dirname", "stream");
          this._basename = this.filename = options.filename ? path.basename(options.filename) : "winston.log";
          this.dirname = options.dirname || path.dirname(options.filename);
          this.options = options.options || { flags: "a" };
        } else if (options.stream) {
          console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream");
          throwIf("stream", "filename", "maxsize");
          this._dest = this._stream.pipe(this._setupStream(options.stream));
          this.dirname = path.dirname(this._dest.path);
        } else {
          throw new Error("Cannot log to file without filename or stream.");
        }
        this.maxsize = options.maxsize || null;
        this.rotationFormat = options.rotationFormat || false;
        this.zippedArchive = options.zippedArchive || false;
        this.maxFiles = options.maxFiles || null;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.tailable = options.tailable || false;
        this._size = 0;
        this._pendingSize = 0;
        this._created = 0;
        this._drain = false;
        this._opening = false;
        this._ending = false;
        if (this.dirname)
          this._createLogDirIfNotExist(this.dirname);
        this.open();
      }
      finishIfEnding() {
        if (this._ending) {
          if (this._opening) {
            this.once("open", () => {
              this._stream.once("finish", () => this.emit("finish"));
              setImmediate(() => this._stream.end());
            });
          } else {
            this._stream.once("finish", () => this.emit("finish"));
            setImmediate(() => this._stream.end());
          }
        }
      }
      /**
       * Core logging method exposed to Winston. Metadata is optional.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback = () => {
      }) {
        if (this.silent) {
          callback();
          return true;
        }
        if (this._drain) {
          this._stream.once("drain", () => {
            this._drain = false;
            this.log(info, callback);
          });
          return;
        }
        if (this._rotate) {
          this._stream.once("rotate", () => {
            this._rotate = false;
            this.log(info, callback);
          });
          return;
        }
        const output = `${info[MESSAGE]}${this.eol}`;
        const bytes = Buffer.byteLength(output);
        function logged() {
          this._size += bytes;
          this._pendingSize -= bytes;
          debug("logged %s %s", this._size, output);
          this.emit("logged", info);
          if (this._opening) {
            return;
          }
          if (!this._needsNewFile()) {
            return;
          }
          this._rotate = true;
          this._endStream(() => this._rotateFile());
        }
        this._pendingSize += bytes;
        if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
          this.rotatedWhileOpening = true;
        }
        const written = this._stream.write(output, logged.bind(this));
        if (!written) {
          this._drain = true;
          this._stream.once("drain", () => {
            this._drain = false;
            callback();
          });
        } else {
          callback();
        }
        debug("written", written, this._drain);
        this.finishIfEnding();
        return written;
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options - Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * TODO: Refactor me.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = normalizeQuery(options);
        const file = path.join(this.dirname, this.filename);
        let buff = "";
        let results = [];
        let row = 0;
        const stream4 = fs2.createReadStream(file, {
          encoding: "utf8"
        });
        stream4.on("error", (err) => {
          if (stream4.readable) {
            stream4.destroy();
          }
          if (!callback) {
            return;
          }
          return err.code !== "ENOENT" ? callback(err) : callback(null, results);
        });
        stream4.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            if (!options.start || row >= options.start) {
              add(data[i]);
            }
            row++;
          }
          buff = data[l];
        });
        stream4.on("close", () => {
          if (buff) {
            add(buff, true);
          }
          if (options.order === "desc") {
            results = results.reverse();
          }
          if (callback)
            callback(null, results);
        });
        function add(buff2, attempt) {
          try {
            const log = JSON.parse(buff2);
            if (check(log)) {
              push(log);
            }
          } catch (e) {
            if (!attempt) {
              stream4.emit("error", e);
            }
          }
        }
        function push(log) {
          if (options.rows && results.length >= options.rows && options.order !== "desc") {
            if (stream4.readable) {
              stream4.destroy();
            }
            return;
          }
          if (options.fields) {
            log = options.fields.reduce((obj, key) => {
              obj[key] = log[key];
              return obj;
            }, {});
          }
          if (options.order === "desc") {
            if (results.length >= options.rows) {
              results.shift();
            }
          }
          results.push(log);
        }
        function check(log) {
          if (!log) {
            return;
          }
          if (typeof log !== "object") {
            return;
          }
          const time = new Date(log.timestamp);
          if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
            return;
          }
          return true;
        }
        function normalizeQuery(options2) {
          options2 = options2 || {};
          options2.rows = options2.rows || options2.limit || 10;
          options2.start = options2.start || 0;
          options2.until = options2.until || /* @__PURE__ */ new Date();
          if (typeof options2.until !== "object") {
            options2.until = new Date(options2.until);
          }
          options2.from = options2.from || options2.until - 24 * 60 * 60 * 1e3;
          if (typeof options2.from !== "object") {
            options2.from = new Date(options2.from);
          }
          options2.order = options2.order || "desc";
          return options2;
        }
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       * TODO: Refactor me.
       */
      stream(options = {}) {
        const file = path.join(this.dirname, this.filename);
        const stream4 = new Stream();
        const tail = {
          file,
          start: options.start
        };
        stream4.destroy = tailFile(tail, (err, line) => {
          if (err) {
            return stream4.emit("error", err);
          }
          try {
            stream4.emit("data", line);
            line = JSON.parse(line);
            stream4.emit("log", line);
          } catch (e) {
            stream4.emit("error", e);
          }
        });
        return stream4;
      }
      /**
       * Checks to see the filesize of.
       * @returns {undefined}
       */
      open() {
        if (!this.filename)
          return;
        if (this._opening)
          return;
        this._opening = true;
        this.stat((err, size) => {
          if (err) {
            return this.emit("error", err);
          }
          debug("stat done: %s { size: %s }", this.filename, size);
          this._size = size;
          this._dest = this._createStream(this._stream);
          this._opening = false;
          this.once("open", () => {
            if (this._stream.eventNames().includes("rotate")) {
              this._stream.emit("rotate");
            } else {
              this._rotate = false;
            }
          });
        });
      }
      /**
       * Stat the file and assess information in order to create the proper stream.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      stat(callback) {
        const target = this._getFile();
        const fullpath = path.join(this.dirname, target);
        fs2.stat(fullpath, (err, stat2) => {
          if (err && err.code === "ENOENT") {
            debug("ENOENT\xA0ok", fullpath);
            this.filename = target;
            return callback(null, 0);
          }
          if (err) {
            debug(`err ${err.code} ${fullpath}`);
            return callback(err);
          }
          if (!stat2 || this._needsNewFile(stat2.size)) {
            return this._incFile(() => this.stat(callback));
          }
          this.filename = target;
          callback(null, stat2.size);
        });
      }
      /**
       * Closes the stream associated with this instance.
       * @param {function} cb - TODO: add param description.
       * @returns {undefined}
       */
      close(cb) {
        if (!this._stream) {
          return;
        }
        this._stream.end(() => {
          if (cb) {
            cb();
          }
          this.emit("flush");
          this.emit("closed");
        });
      }
      /**
       * TODO: add method description.
       * @param {number} size - TODO: add param description.
       * @returns {undefined}
       */
      _needsNewFile(size) {
        size = size || this._size;
        return this.maxsize && size >= this.maxsize;
      }
      /**
       * TODO: add method description.
       * @param {Error} err - TODO: add param description.
       * @returns {undefined}
       */
      _onError(err) {
        this.emit("error", err);
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _setupStream(stream4) {
        stream4.on("error", this._onError);
        return stream4;
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _cleanupStream(stream4) {
        stream4.removeListener("error", this._onError);
        return stream4;
      }
      /**
       * TODO: add method description.
       */
      _rotateFile() {
        this._incFile(() => this.open());
      }
      /**
       * Unpipe from the stream that has been marked as full and end it so it
       * flushes to disk.
       *
       * @param {function} callback - Callback for when the current file has closed.
       * @private
       */
      _endStream(callback = () => {
      }) {
        if (this._dest) {
          this._stream.unpipe(this._dest);
          this._dest.end(() => {
            this._cleanupStream(this._dest);
            callback();
          });
        } else {
          callback();
        }
      }
      /**
       * Returns the WritableStream for the active file on this instance. If we
       * should gzip the file then a zlib stream is returned.
       *
       * @param {ReadableStream} source – PassThrough to pipe to the file when open.
       * @returns {WritableStream} Stream that writes to disk for the active file.
       */
      _createStream(source) {
        const fullpath = path.join(this.dirname, this.filename);
        debug("create stream start", fullpath, this.options);
        const dest = fs2.createWriteStream(fullpath, this.options).on("error", (err) => debug(err)).on("close", () => debug("close", dest.path, dest.bytesWritten)).on("open", () => {
          debug("file open ok", fullpath);
          this.emit("open", fullpath);
          source.pipe(dest);
          if (this.rotatedWhileOpening) {
            this._stream = new PassThrough();
            this._stream.setMaxListeners(30);
            this._rotateFile();
            this.rotatedWhileOpening = false;
            this._cleanupStream(dest);
            source.end();
          }
        });
        debug("create stream ok", fullpath);
        if (this.zippedArchive) {
          const gzip = zlib2.createGzip();
          gzip.pipe(dest);
          return gzip;
        }
        return dest;
      }
      /**
       * TODO: add method description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      _incFile(callback) {
        debug("_incFile", this.filename);
        const ext = path.extname(this._basename);
        const basename = path.basename(this._basename, ext);
        if (!this.tailable) {
          this._created += 1;
          this._checkMaxFilesIncrementing(ext, basename, callback);
        } else {
          this._checkMaxFilesTailable(ext, basename, callback);
        }
      }
      /**
       * Gets the next filename to use for this instance in the case that log
       * filesizes are being capped.
       * @returns {string} - TODO: add return description.
       * @private
       */
      _getFile() {
        const ext = path.extname(this._basename);
        const basename = path.basename(this._basename, ext);
        const isRotation = this.rotationFormat ? this.rotationFormat() : this._created;
        const target = !this.tailable && this._created ? `${basename}${isRotation}${ext}` : `${basename}${ext}`;
        return this.zippedArchive && !this.tailable ? `${target}.gz` : target;
      }
      /**
       * Increment the number of files created or checked by this instance.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesIncrementing(ext, basename, callback) {
        if (!this.maxFiles || this._created < this.maxFiles) {
          return setImmediate(callback);
        }
        const oldest = this._created - this.maxFiles;
        const isOldest = oldest !== 0 ? oldest : "";
        const isZipped = this.zippedArchive ? ".gz" : "";
        const filePath = `${basename}${isOldest}${ext}${isZipped}`;
        const target = path.join(this.dirname, filePath);
        fs2.unlink(target, callback);
      }
      /**
       * Roll files forward based on integer, up to maxFiles. e.g. if base if
       * file.log and it becomes oversized, roll to file1.log, and allow file.log
       * to be re-used. If file is oversized again, roll file1.log to file2.log,
       * roll file.log to file1.log, and so on.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesTailable(ext, basename, callback) {
        const tasks = [];
        if (!this.maxFiles) {
          return;
        }
        const isZipped = this.zippedArchive ? ".gz" : "";
        for (let x = this.maxFiles - 1; x > 1; x--) {
          tasks.push(function(i, cb) {
            let fileName = `${basename}${i - 1}${ext}${isZipped}`;
            const tmppath = path.join(this.dirname, fileName);
            fs2.exists(tmppath, (exists) => {
              if (!exists) {
                return cb(null);
              }
              fileName = `${basename}${i}${ext}${isZipped}`;
              fs2.rename(tmppath, path.join(this.dirname, fileName), cb);
            });
          }.bind(this, x));
        }
        asyncSeries(tasks, () => {
          fs2.rename(
            path.join(this.dirname, `${basename}${ext}`),
            path.join(this.dirname, `${basename}1${ext}${isZipped}`),
            callback
          );
        });
      }
      _createLogDirIfNotExist(dirPath) {
        if (!fs2.existsSync(dirPath)) {
          fs2.mkdirSync(dirPath, { recursive: true });
        }
      }
    };
  }
});

// node_modules/winston/lib/winston/transports/http.js
var require_http = __commonJS({
  "node_modules/winston/lib/winston/transports/http.js"(exports2, module2) {
    "use strict";
    var http2 = require("http");
    var https2 = require("https");
    var { Stream } = require_readable2();
    var TransportStream = require_winston_transport();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = class Http extends TransportStream {
      /**
       * Constructor function for the Http transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      // eslint-disable-next-line max-statements
      constructor(options = {}) {
        super(options);
        this.options = options;
        this.name = options.name || "http";
        this.ssl = !!options.ssl;
        this.host = options.host || "localhost";
        this.port = options.port;
        this.auth = options.auth;
        this.path = options.path || "";
        this.agent = options.agent;
        this.headers = options.headers || {};
        this.headers["content-type"] = "application/json";
        this.batch = options.batch || false;
        this.batchInterval = options.batchInterval || 5e3;
        this.batchCount = options.batchCount || 10;
        this.batchOptions = [];
        this.batchTimeoutID = -1;
        this.batchCallback = {};
        if (!this.port) {
          this.port = this.ssl ? 443 : 80;
        }
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        this._request(info, (err, res) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            this.emit("warn", err);
          } else {
            this.emit("logged", info);
          }
        });
        if (callback) {
          setImmediate(callback);
        }
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options -  Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * @returns {undefined}
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = {
          method: "query",
          params: this.normalizeQuery(options)
        };
        if (options.params.path) {
          options.path = options.params.path;
          delete options.params.path;
        }
        if (options.params.auth) {
          options.auth = options.params.auth;
          delete options.params.auth;
        }
        this._request(options, (err, res, body) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            return callback(err);
          }
          if (typeof body === "string") {
            try {
              body = JSON.parse(body);
            } catch (e) {
              return callback(e);
            }
          }
          callback(null, body);
        });
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description
       */
      stream(options = {}) {
        const stream4 = new Stream();
        options = {
          method: "stream",
          params: options
        };
        if (options.params.path) {
          options.path = options.params.path;
          delete options.params.path;
        }
        if (options.params.auth) {
          options.auth = options.params.auth;
          delete options.params.auth;
        }
        let buff = "";
        const req = this._request(options);
        stream4.destroy = () => req.destroy();
        req.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            try {
              stream4.emit("log", JSON.parse(data[i]));
            } catch (e) {
              stream4.emit("error", e);
            }
          }
          buff = data[l];
        });
        req.on("error", (err) => stream4.emit("error", err));
        return stream4;
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       */
      _request(options, callback) {
        options = options || {};
        const auth = options.auth || this.auth;
        const path = options.path || this.path || "";
        delete options.auth;
        delete options.path;
        if (this.batch) {
          this._doBatch(options, callback, auth, path);
        } else {
          this._doRequest(options, callback, auth, path);
        }
      }
      /**
       * Send or memorize the options according to batch configuration
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatch(options, callback, auth, path) {
        this.batchOptions.push(options);
        if (this.batchOptions.length === 1) {
          const me = this;
          this.batchCallback = callback;
          this.batchTimeoutID = setTimeout(function() {
            me.batchTimeoutID = -1;
            me._doBatchRequest(me.batchCallback, auth, path);
          }, this.batchInterval);
        }
        if (this.batchOptions.length === this.batchCount) {
          this._doBatchRequest(this.batchCallback, auth, path);
        }
      }
      /**
       * Initiate a request with the memorized batch options, stop the batch timeout
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatchRequest(callback, auth, path) {
        if (this.batchTimeoutID > 0) {
          clearTimeout(this.batchTimeoutID);
          this.batchTimeoutID = -1;
        }
        const batchOptionsCopy = this.batchOptions.slice();
        this.batchOptions = [];
        this._doRequest(batchOptionsCopy, callback, auth, path);
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doRequest(options, callback, auth, path) {
        const headers = Object.assign({}, this.headers);
        if (auth && auth.bearer) {
          headers.Authorization = `Bearer ${auth.bearer}`;
        }
        const req = (this.ssl ? https2 : http2).request({
          ...this.options,
          method: "POST",
          host: this.host,
          port: this.port,
          path: `/${path.replace(/^\//, "")}`,
          headers,
          auth: auth && auth.username && auth.password ? `${auth.username}:${auth.password}` : "",
          agent: this.agent
        });
        req.on("error", callback);
        req.on("response", (res) => res.on("end", () => callback(null, res)).resume());
        req.end(Buffer.from(jsonStringify(options, this.options.replacer), "utf8"));
      }
    };
  }
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream2 = (stream4) => stream4 !== null && typeof stream4 === "object" && typeof stream4.pipe === "function";
    isStream2.writable = (stream4) => isStream2(stream4) && stream4.writable !== false && typeof stream4._write === "function" && typeof stream4._writableState === "object";
    isStream2.readable = (stream4) => isStream2(stream4) && stream4.readable !== false && typeof stream4._read === "function" && typeof stream4._readableState === "object";
    isStream2.duplex = (stream4) => isStream2.writable(stream4) && isStream2.readable(stream4);
    isStream2.transform = (stream4) => isStream2.duplex(stream4) && typeof stream4._transform === "function";
    module2.exports = isStream2;
  }
});

// node_modules/winston/lib/winston/transports/stream.js
var require_stream3 = __commonJS({
  "node_modules/winston/lib/winston/transports/stream.js"(exports2, module2) {
    "use strict";
    var isStream2 = require_is_stream();
    var { MESSAGE } = require_triple_beam();
    var os = require("os");
    var TransportStream = require_winston_transport();
    module2.exports = class Stream extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        if (!options.stream || !isStream2(options.stream)) {
          throw new Error("options.stream is required.");
        }
        this._stream = options.stream;
        this._stream.setMaxListeners(Infinity);
        this.isObjectMode = options.stream._writableState.objectMode;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.isObjectMode) {
          this._stream.write(info);
          if (callback) {
            callback();
          }
          return;
        }
        this._stream.write(`${info[MESSAGE]}${this.eol}`);
        if (callback) {
          callback();
        }
        return;
      }
    };
  }
});

// node_modules/winston/lib/winston/transports/index.js
var require_transports = __commonJS({
  "node_modules/winston/lib/winston/transports/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "Console", {
      configurable: true,
      enumerable: true,
      get() {
        return require_console();
      }
    });
    Object.defineProperty(exports2, "File", {
      configurable: true,
      enumerable: true,
      get() {
        return require_file2();
      }
    });
    Object.defineProperty(exports2, "Http", {
      configurable: true,
      enumerable: true,
      get() {
        return require_http();
      }
    });
    Object.defineProperty(exports2, "Stream", {
      configurable: true,
      enumerable: true,
      get() {
        return require_stream3();
      }
    });
  }
});

// node_modules/winston/lib/winston/config/index.js
var require_config3 = __commonJS({
  "node_modules/winston/lib/winston/config/index.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { configs } = require_triple_beam();
    exports2.cli = logform.levels(configs.cli);
    exports2.npm = logform.levels(configs.npm);
    exports2.syslog = logform.levels(configs.syslog);
    exports2.addColors = logform.levels;
  }
});

// node_modules/async/eachOf.js
var require_eachOf = __commonJS({
  "node_modules/async/eachOf.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike2();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback);
      var index = 0, completed = 0, { length } = coll, canceled = false;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true)
          return;
        if (err) {
          callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
          callback(null);
        }
      }
      for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOf, 3);
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "node_modules/async/internal/withoutIndex.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return (value, index, callback) => iteratee(value, callback);
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/forEach.js
var require_forEach = __commonJS({
  "node_modules/async/forEach.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachLimit(coll, iteratee, callback) {
      return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachLimit, 3);
    module2.exports = exports2["default"];
  }
});

// node_modules/fn.name/index.js
var require_fn = __commonJS({
  "node_modules/fn.name/index.js"(exports2, module2) {
    "use strict";
    var toString3 = Object.prototype.toString;
    module2.exports = function name(fn) {
      if ("string" === typeof fn.displayName && fn.constructor.name) {
        return fn.displayName;
      } else if ("string" === typeof fn.name && fn.name) {
        return fn.name;
      }
      if ("object" === typeof fn && fn.constructor && "string" === typeof fn.constructor.name)
        return fn.constructor.name;
      var named = fn.toString(), type = toString3.call(fn).slice(8, -1);
      if ("Function" === type) {
        named = named.substring(named.indexOf("(") + 1, named.indexOf(")"));
      } else {
        named = type;
      }
      return named || "anonymous";
    };
  }
});

// node_modules/one-time/index.js
var require_one_time = __commonJS({
  "node_modules/one-time/index.js"(exports2, module2) {
    "use strict";
    var name = require_fn();
    module2.exports = function one(fn) {
      var called = 0, value;
      function onetime() {
        if (called)
          return value;
        called = 1;
        value = fn.apply(this, arguments);
        fn = null;
        return value;
      }
      onetime.displayName = name(fn);
      return onetime;
    };
  }
});

// node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS({
  "node_modules/stack-trace/lib/stack-trace.js"(exports2) {
    exports2.get = function(belowFn) {
      var oldLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
      var dummyObject = {};
      var v8Handler = Error.prepareStackTrace;
      Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
        return v8StackTrace2;
      };
      Error.captureStackTrace(dummyObject, belowFn || exports2.get);
      var v8StackTrace = dummyObject.stack;
      Error.prepareStackTrace = v8Handler;
      Error.stackTraceLimit = oldLimit;
      return v8StackTrace;
    };
    exports2.parse = function(err) {
      if (!err.stack) {
        return [];
      }
      var self2 = this;
      var lines = err.stack.split("\n").slice(1);
      return lines.map(function(line) {
        if (line.match(/^\s*[-]{4,}$/)) {
          return self2._createParsedCallSite({
            fileName: line,
            lineNumber: null,
            functionName: null,
            typeName: null,
            methodName: null,
            columnNumber: null,
            "native": null
          });
        }
        var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (!lineMatch) {
          return;
        }
        var object = null;
        var method = null;
        var functionName = null;
        var typeName = null;
        var methodName = null;
        var isNative = lineMatch[5] === "native";
        if (lineMatch[1]) {
          functionName = lineMatch[1];
          var methodStart = functionName.lastIndexOf(".");
          if (functionName[methodStart - 1] == ".")
            methodStart--;
          if (methodStart > 0) {
            object = functionName.substr(0, methodStart);
            method = functionName.substr(methodStart + 1);
            var objectEnd = object.indexOf(".Module");
            if (objectEnd > 0) {
              functionName = functionName.substr(objectEnd + 1);
              object = object.substr(0, objectEnd);
            }
          }
          typeName = null;
        }
        if (method) {
          typeName = object;
          methodName = method;
        }
        if (method === "<anonymous>") {
          methodName = null;
          functionName = null;
        }
        var properties = {
          fileName: lineMatch[2] || null,
          lineNumber: parseInt(lineMatch[3], 10) || null,
          functionName,
          typeName,
          methodName,
          columnNumber: parseInt(lineMatch[4], 10) || null,
          "native": isNative
        };
        return self2._createParsedCallSite(properties);
      }).filter(function(callSite) {
        return !!callSite;
      });
    };
    function CallSite(properties) {
      for (var property in properties) {
        this[property] = properties[property];
      }
    }
    var strProperties = [
      "this",
      "typeName",
      "functionName",
      "methodName",
      "fileName",
      "lineNumber",
      "columnNumber",
      "function",
      "evalOrigin"
    ];
    var boolProperties = [
      "topLevel",
      "eval",
      "native",
      "constructor"
    ];
    strProperties.forEach(function(property) {
      CallSite.prototype[property] = null;
      CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    boolProperties.forEach(function(property) {
      CallSite.prototype[property] = false;
      CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    exports2._createParsedCallSite = function(properties) {
      return new CallSite(properties);
    };
  }
});

// node_modules/winston/lib/winston/exception-stream.js
var require_exception_stream = __commonJS({
  "node_modules/winston/lib/winston/exception-stream.js"(exports2, module2) {
    "use strict";
    var { Writable } = require_readable2();
    module2.exports = class ExceptionStream extends Writable {
      /**
       * Constructor function for the ExceptionStream responsible for wrapping a
       * TransportStream; only allowing writes of `info` objects with
       * `info.exception` set to true.
       * @param {!TransportStream} transport - Stream to filter to exceptions
       */
      constructor(transport) {
        super({ objectMode: true });
        if (!transport) {
          throw new Error("ExceptionStream requires a TransportStream instance.");
        }
        this.handleExceptions = true;
        this.transport = transport;
      }
      /**
       * Writes the info object to our transport instance if (and only if) the
       * `exception` property is set on the info.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _write(info, enc, callback) {
        if (info.exception) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    };
  }
});

// node_modules/winston/lib/winston/exception-handler.js
var require_exception_handler = __commonJS({
  "node_modules/winston/lib/winston/exception-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach();
    var debug = require_node2()("winston:exception");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var ExceptionStream = require_exception_stream();
    module2.exports = class ExceptionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger) {
        if (!logger) {
          throw new Error("Logger is required to handle exceptions");
        }
        this.logger = logger;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `uncaughtException` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._uncaughtException.bind(this);
          process.on("uncaughtException", this.catcher);
        }
      }
      /**
       * Removes any handlers to `uncaughtException` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("uncaughtException", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let { message } = err;
        if (!message && typeof err === "string") {
          message = err;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `uncaughtException: ${message || "(no error message)"}`,
            err.stack || "  No stack trace"
          ].join("\n"),
          stack: err.stack,
          exception: true,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleExceptions = true;
          const wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _uncaughtException(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getExceptionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no exception handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(handlers, (handler, next) => {
          const done = once(next);
          const transport = handler.transport || handler;
          function onDone(event) {
            return () => {
              debug(event);
              done();
            };
          }
          transport._ending = true;
          transport.once("finish", onDone("finished"));
          transport.once("error", onDone("error"));
        }, () => doExit && gracefulExit());
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getExceptionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleExceptions;
        });
      }
    };
  }
});

// node_modules/winston/lib/winston/rejection-handler.js
var require_rejection_handler = __commonJS({
  "node_modules/winston/lib/winston/rejection-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach();
    var debug = require_node2()("winston:rejection");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var ExceptionStream = require_exception_stream();
    module2.exports = class RejectionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger) {
        if (!logger) {
          throw new Error("Logger is required to handle rejections");
        }
        this.logger = logger;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `unhandledRejection` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._unhandledRejection.bind(this);
          process.on("unhandledRejection", this.catcher);
        }
      }
      /**
       * Removes any handlers to `unhandledRejection` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("unhandledRejection", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach(
            (wrapper) => this.logger.unpipe(wrapper)
          );
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `unhandledRejection: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          exception: true,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleRejections = true;
          const wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _unhandledRejection(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getRejectionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no rejection handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(
          handlers,
          (handler, next) => {
            const done = once(next);
            const transport = handler.transport || handler;
            function onDone(event) {
              return () => {
                debug(event);
                done();
              };
            }
            transport._ending = true;
            transport.once("finish", onDone("finished"));
            transport.once("error", onDone("error"));
          },
          () => doExit && gracefulExit()
        );
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getRejectionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleRejections;
        });
      }
    };
  }
});

// node_modules/winston/lib/winston/profiler.js
var require_profiler = __commonJS({
  "node_modules/winston/lib/winston/profiler.js"(exports2, module2) {
    "use strict";
    module2.exports = class Profiler {
      /**
       * Constructor function for the Profiler instance used by
       * `Logger.prototype.startTimer`. When done is called the timer will finish
       * and log the duration.
       * @param {!Logger} logger - TODO: add param description.
       * @private
       */
      constructor(logger) {
        if (!logger) {
          throw new Error("Logger is required for profiling.");
        }
        this.logger = logger;
        this.start = Date.now();
      }
      /**
       * Ends the current timer (i.e. Profiler) instance and logs the `msg` along
       * with the duration since creation.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      done(...args) {
        if (typeof args[args.length - 1] === "function") {
          console.warn("Callback function no longer supported as of winston@3.0.0");
          args.pop();
        }
        const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
        info.level = info.level || "info";
        info.durationMs = Date.now() - this.start;
        return this.logger.write(info);
      }
    };
  }
});

// node_modules/winston/lib/winston/logger.js
var require_logger = __commonJS({
  "node_modules/winston/lib/winston/logger.js"(exports2, module2) {
    "use strict";
    var { Stream, Transform } = require_readable2();
    var asyncForEach = require_forEach();
    var { LEVEL, SPLAT } = require_triple_beam();
    var isStream2 = require_is_stream();
    var ExceptionHandler = require_exception_handler();
    var RejectionHandler = require_rejection_handler();
    var LegacyTransportStream = require_legacy();
    var Profiler = require_profiler();
    var { warn } = require_common5();
    var config = require_config3();
    var formatRegExp = /%[scdjifoO%]/g;
    var Logger = class extends Transform {
      /**
       * Constructor function for the Logger object responsible for persisting log
       * messages and metadata to one or more transports.
       * @param {!Object} options - foo
       */
      constructor(options) {
        super({ objectMode: true });
        this.configure(options);
      }
      child(defaultRequestMetadata) {
        const logger = this;
        return Object.create(logger, {
          write: {
            value: function(info) {
              const infoClone = Object.assign(
                {},
                defaultRequestMetadata,
                info
              );
              if (info instanceof Error) {
                infoClone.stack = info.stack;
                infoClone.message = info.message;
              }
              logger.write(infoClone);
            }
          }
        });
      }
      /**
       * This will wholesale reconfigure this instance by:
       * 1. Resetting all transports. Older transports will be removed implicitly.
       * 2. Set all other options including levels, colors, rewriters, filters,
       *    exceptionHandlers, etc.
       * @param {!Object} options - TODO: add param description.
       * @returns {undefined}
       */
      configure({
        silent,
        format: format2,
        defaultMeta,
        levels,
        level = "info",
        exitOnError = true,
        transports: transports2,
        colors,
        emitErrs,
        formatters,
        padLevels: padLevels2,
        rewriters,
        stripColors,
        exceptionHandlers,
        rejectionHandlers
      } = {}) {
        if (this.transports.length) {
          this.clear();
        }
        this.silent = silent;
        this.format = format2 || this.format || require_json()();
        this.defaultMeta = defaultMeta || null;
        this.levels = levels || this.levels || config.npm.levels;
        this.level = level;
        if (this.exceptions) {
          this.exceptions.unhandle();
        }
        if (this.rejections) {
          this.rejections.unhandle();
        }
        this.exceptions = new ExceptionHandler(this);
        this.rejections = new RejectionHandler(this);
        this.profilers = {};
        this.exitOnError = exitOnError;
        if (transports2) {
          transports2 = Array.isArray(transports2) ? transports2 : [transports2];
          transports2.forEach((transport) => this.add(transport));
        }
        if (colors || emitErrs || formatters || padLevels2 || rewriters || stripColors) {
          throw new Error(
            [
              "{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
              "Use a custom winston.format(function) instead.",
              "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
            ].join("\n")
          );
        }
        if (exceptionHandlers) {
          this.exceptions.handle(exceptionHandlers);
        }
        if (rejectionHandlers) {
          this.rejections.handle(rejectionHandlers);
        }
      }
      isLevelEnabled(level) {
        const givenLevelValue = getLevelValue(this.levels, level);
        if (givenLevelValue === null) {
          return false;
        }
        const configuredLevelValue = getLevelValue(this.levels, this.level);
        if (configuredLevelValue === null) {
          return false;
        }
        if (!this.transports || this.transports.length === 0) {
          return configuredLevelValue >= givenLevelValue;
        }
        const index = this.transports.findIndex((transport) => {
          let transportLevelValue = getLevelValue(this.levels, transport.level);
          if (transportLevelValue === null) {
            transportLevelValue = configuredLevelValue;
          }
          return transportLevelValue >= givenLevelValue;
        });
        return index !== -1;
      }
      /* eslint-disable valid-jsdoc */
      /**
       * Ensure backwards compatibility with a `log` method
       * @param {mixed} level - Level the log message is written at.
       * @param {mixed} msg - TODO: add param description.
       * @param {mixed} meta - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       *
       * @example
       *    // Supports the existing API:
       *    logger.log('info', 'Hello world', { custom: true });
       *    logger.log('info', new Error('Yo, it\'s on fire'));
       *
       *    // Requires winston.format.splat()
       *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });
       *
       *    // And the new API with a single JSON literal:
       *    logger.log({ level: 'info', message: 'Hello world', custom: true });
       *    logger.log({ level: 'info', message: new Error('Yo, it\'s on fire') });
       *
       *    // Also requires winston.format.splat()
       *    logger.log({
       *      level: 'info',
       *      message: '%s %d%%',
       *      [SPLAT]: ['A string', 50],
       *      meta: { thisIsMeta: true }
       *    });
       *
       */
      /* eslint-enable valid-jsdoc */
      log(level, msg, ...splat) {
        if (arguments.length === 1) {
          level[LEVEL] = level.level;
          this._addDefaultMeta(level);
          this.write(level);
          return this;
        }
        if (arguments.length === 2) {
          if (msg && typeof msg === "object") {
            msg[LEVEL] = msg.level = level;
            this._addDefaultMeta(msg);
            this.write(msg);
            return this;
          }
          msg = { [LEVEL]: level, level, message: msg };
          this._addDefaultMeta(msg);
          this.write(msg);
          return this;
        }
        const [meta] = splat;
        if (typeof meta === "object" && meta !== null) {
          const tokens = msg && msg.match && msg.match(formatRegExp);
          if (!tokens) {
            const info = Object.assign({}, this.defaultMeta, meta, {
              [LEVEL]: level,
              [SPLAT]: splat,
              level,
              message: msg
            });
            if (meta.message)
              info.message = `${info.message} ${meta.message}`;
            if (meta.stack)
              info.stack = meta.stack;
            this.write(info);
            return this;
          }
        }
        this.write(Object.assign({}, this.defaultMeta, {
          [LEVEL]: level,
          [SPLAT]: splat,
          level,
          message: msg
        }));
        return this;
      }
      /**
       * Pushes data so that it can be picked up by all of our pipe targets.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - Continues stream processing.
       * @returns {undefined}
       * @private
       */
      _transform(info, enc, callback) {
        if (this.silent) {
          return callback();
        }
        if (!info[LEVEL]) {
          info[LEVEL] = info.level;
        }
        if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
          console.error("[winston] Unknown logger level: %s", info[LEVEL]);
        }
        if (!this._readableState.pipes) {
          console.error(
            "[winston] Attempt to write logs with no transports, which can increase memory usage: %j",
            info
          );
        }
        try {
          this.push(this.format.transform(info, this.format.options));
        } finally {
          this._writableState.sync = false;
          callback();
        }
      }
      /**
       * Delays the 'finish' event until all transport pipe targets have
       * also emitted 'finish' or are already finished.
       * @param {mixed} callback - Continues stream processing.
       */
      _final(callback) {
        const transports2 = this.transports.slice();
        asyncForEach(
          transports2,
          (transport, next) => {
            if (!transport || transport.finished)
              return setImmediate(next);
            transport.once("finish", next);
            transport.end();
          },
          callback
        );
      }
      /**
       * Adds the transport to this logger instance by piping to it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      add(transport) {
        const target = !isStream2(transport) || transport.log.length > 2 ? new LegacyTransportStream({ transport }) : transport;
        if (!target._writableState || !target._writableState.objectMode) {
          throw new Error(
            "Transports must WritableStreams in objectMode. Set { objectMode: true }."
          );
        }
        this._onEvent("error", target);
        this._onEvent("warn", target);
        this.pipe(target);
        if (transport.handleExceptions) {
          this.exceptions.handle();
        }
        if (transport.handleRejections) {
          this.rejections.handle();
        }
        return this;
      }
      /**
       * Removes the transport from this logger instance by unpiping from it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      remove(transport) {
        if (!transport)
          return this;
        let target = transport;
        if (!isStream2(transport) || transport.log.length > 2) {
          target = this.transports.filter(
            (match) => match.transport === transport
          )[0];
        }
        if (target) {
          this.unpipe(target);
        }
        return this;
      }
      /**
       * Removes all transports from this logger instance.
       * @returns {Logger} - TODO: add return description.
       */
      clear() {
        this.unpipe();
        return this;
      }
      /**
       * Cleans up resources (streams, event listeners) for all transports
       * associated with this instance (if necessary).
       * @returns {Logger} - TODO: add return description.
       */
      close() {
        this.exceptions.unhandle();
        this.rejections.unhandle();
        this.clear();
        this.emit("close");
        return this;
      }
      /**
       * Sets the `target` levels specified on this instance.
       * @param {Object} Target levels to use on this instance.
       */
      setLevels() {
        warn.deprecated("setLevels");
      }
      /**
       * Queries the all transports for this instance with the specified `options`.
       * This will aggregate each transport's results into one object containing
       * a property per transport.
       * @param {Object} options - Query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        const results = {};
        const queryObject = Object.assign({}, options.query || {});
        function queryTransport(transport, next) {
          if (options.query && typeof transport.formatQuery === "function") {
            options.query = transport.formatQuery(queryObject);
          }
          transport.query(options, (err, res) => {
            if (err) {
              return next(err);
            }
            if (typeof transport.formatResults === "function") {
              res = transport.formatResults(res, options.format);
            }
            next(null, res);
          });
        }
        function addResults(transport, next) {
          queryTransport(transport, (err, result) => {
            if (next) {
              result = err || result;
              if (result) {
                results[transport.name] = result;
              }
              next();
            }
            next = null;
          });
        }
        asyncForEach(
          this.transports.filter((transport) => !!transport.query),
          addResults,
          () => callback(null, results)
        );
      }
      /**
       * Returns a log stream for all transports. Options object is optional.
       * @param{Object} options={} - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       */
      stream(options = {}) {
        const out = new Stream();
        const streams = [];
        out._streams = streams;
        out.destroy = () => {
          let i = streams.length;
          while (i--) {
            streams[i].destroy();
          }
        };
        this.transports.filter((transport) => !!transport.stream).forEach((transport) => {
          const str = transport.stream(options);
          if (!str) {
            return;
          }
          streams.push(str);
          str.on("log", (log) => {
            log.transport = log.transport || [];
            log.transport.push(transport.name);
            out.emit("log", log);
          });
          str.on("error", (err) => {
            err.transport = err.transport || [];
            err.transport.push(transport.name);
            out.emit("error", err);
          });
        });
        return out;
      }
      /**
       * Returns an object corresponding to a specific timing. When done is called
       * the timer will finish and log the duration. e.g.:
       * @returns {Profile} - TODO: add return description.
       * @example
       *    const timer = winston.startTimer()
       *    setTimeout(() => {
       *      timer.done({
       *        message: 'Logging message'
       *      });
       *    }, 1000);
       */
      startTimer() {
        return new Profiler(this);
      }
      /**
       * Tracks the time inbetween subsequent calls to this method with the same
       * `id` parameter. The second call to this method will log the difference in
       * milliseconds along with the message.
       * @param {string} id Unique id of the profiler
       * @returns {Logger} - TODO: add return description.
       */
      profile(id, ...args) {
        const time = Date.now();
        if (this.profilers[id]) {
          const timeEnd = this.profilers[id];
          delete this.profilers[id];
          if (typeof args[args.length - 2] === "function") {
            console.warn(
              "Callback function no longer supported as of winston@3.0.0"
            );
            args.pop();
          }
          const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
          info.level = info.level || "info";
          info.durationMs = time - timeEnd;
          info.message = info.message || id;
          return this.write(info);
        }
        this.profilers[id] = time;
        return this;
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      handleExceptions(...args) {
        console.warn(
          "Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()"
        );
        this.exceptions.handle(...args);
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      unhandleExceptions(...args) {
        console.warn(
          "Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()"
        );
        this.exceptions.unhandle(...args);
      }
      /**
       * Throw a more meaningful deprecation notice
       * @throws {Error} - TODO: add throws description.
       */
      cli() {
        throw new Error(
          [
            "Logger.cli() was removed in winston@3.0.0",
            "Use a custom winston.formats.cli() instead.",
            "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
          ].join("\n")
        );
      }
      /**
       * Bubbles the `event` that occured on the specified `transport` up
       * from this instance.
       * @param {string} event - The event that occured
       * @param {Object} transport - Transport on which the event occured
       * @private
       */
      _onEvent(event, transport) {
        function transportEvent(err) {
          if (event === "error" && !this.transports.includes(transport)) {
            this.add(transport);
          }
          this.emit(event, err, transport);
        }
        if (!transport["__winston" + event]) {
          transport["__winston" + event] = transportEvent.bind(this);
          transport.on(event, transport["__winston" + event]);
        }
      }
      _addDefaultMeta(msg) {
        if (this.defaultMeta) {
          Object.assign(msg, this.defaultMeta);
        }
      }
    };
    function getLevelValue(levels, level) {
      const value = levels[level];
      if (!value && value !== 0) {
        return null;
      }
      return value;
    }
    Object.defineProperty(Logger.prototype, "transports", {
      configurable: false,
      enumerable: true,
      get() {
        const { pipes } = this._readableState;
        return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
      }
    });
    module2.exports = Logger;
  }
});

// node_modules/winston/lib/winston/create-logger.js
var require_create_logger = __commonJS({
  "node_modules/winston/lib/winston/create-logger.js"(exports2, module2) {
    "use strict";
    var { LEVEL } = require_triple_beam();
    var config = require_config3();
    var Logger = require_logger();
    var debug = require_node2()("winston:create-logger");
    function isLevelEnabledFunctionName(level) {
      return "is" + level.charAt(0).toUpperCase() + level.slice(1) + "Enabled";
    }
    module2.exports = function(opts = {}) {
      opts.levels = opts.levels || config.npm.levels;
      class DerivedLogger extends Logger {
        /**
         * Create a new class derived logger for which the levels can be attached to
         * the prototype of. This is a V8 optimization that is well know to increase
         * performance of prototype functions.
         * @param {!Object} options - Options for the created logger.
         */
        constructor(options) {
          super(options);
        }
      }
      const logger = new DerivedLogger(opts);
      Object.keys(opts.levels).forEach(function(level) {
        debug('Define prototype method for "%s"', level);
        if (level === "log") {
          console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
          return;
        }
        DerivedLogger.prototype[level] = function(...args) {
          const self2 = this || logger;
          if (args.length === 1) {
            const [msg] = args;
            const info = msg && msg.message && msg || { message: msg };
            info.level = info[LEVEL] = level;
            self2._addDefaultMeta(info);
            self2.write(info);
            return this || logger;
          }
          if (args.length === 0) {
            self2.log(level, "");
            return self2;
          }
          return self2.log(level, ...args);
        };
        DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function() {
          return (this || logger).isLevelEnabled(level);
        };
      });
      return logger;
    };
  }
});

// node_modules/winston/lib/winston/container.js
var require_container = __commonJS({
  "node_modules/winston/lib/winston/container.js"(exports2, module2) {
    "use strict";
    var createLogger2 = require_create_logger();
    module2.exports = class Container {
      /**
       * Constructor function for the Container object responsible for managing a
       * set of `winston.Logger` instances based on string ids.
       * @param {!Object} [options={}] - Default pass-thru options for Loggers.
       */
      constructor(options = {}) {
        this.loggers = /* @__PURE__ */ new Map();
        this.options = options;
      }
      /**
       * Retrieves a `winston.Logger` instance for the specified `id`. If an
       * instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      add(id, options) {
        if (!this.loggers.has(id)) {
          options = Object.assign({}, options || this.options);
          const existing = options.transports || this.options.transports;
          options.transports = existing ? existing.slice() : [];
          const logger = createLogger2(options);
          logger.on("close", () => this._delete(id));
          this.loggers.set(id, logger);
        }
        return this.loggers.get(id);
      }
      /**
       * Retreives a `winston.Logger` instance for the specified `id`. If
       * an instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      get(id, options) {
        return this.add(id, options);
      }
      /**
       * Check if the container has a logger with the id.
       * @param {?string} id - The id of the Logger instance to find.
       * @returns {boolean} - Boolean value indicating if this instance has a
       * logger with the specified `id`.
       */
      has(id) {
        return !!this.loggers.has(id);
      }
      /**
       * Closes a `Logger` instance with the specified `id` if it exists.
       * If no `id` is supplied then all Loggers are closed.
       * @param {?string} id - The id of the Logger instance to close.
       * @returns {undefined}
       */
      close(id) {
        if (id) {
          return this._removeLogger(id);
        }
        this.loggers.forEach((val, key) => this._removeLogger(key));
      }
      /**
       * Remove a logger based on the id.
       * @param {!string} id - The id of the logger to remove.
       * @returns {undefined}
       * @private
       */
      _removeLogger(id) {
        if (!this.loggers.has(id)) {
          return;
        }
        const logger = this.loggers.get(id);
        logger.close();
        this._delete(id);
      }
      /**
       * Deletes a `Logger` instance with the specified `id`.
       * @param {!string} id - The id of the Logger instance to delete from
       * container.
       * @returns {undefined}
       * @private
       */
      _delete(id) {
        this.loggers.delete(id);
      }
    };
  }
});

// node_modules/winston/lib/winston.js
var require_winston = __commonJS({
  "node_modules/winston/lib/winston.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { warn } = require_common5();
    exports2.version = require_package3().version;
    exports2.transports = require_transports();
    exports2.config = require_config3();
    exports2.addColors = logform.levels;
    exports2.format = logform.format;
    exports2.createLogger = require_create_logger();
    exports2.ExceptionHandler = require_exception_handler();
    exports2.RejectionHandler = require_rejection_handler();
    exports2.Container = require_container();
    exports2.Transport = require_winston_transport();
    exports2.loggers = new exports2.Container();
    var defaultLogger = exports2.createLogger();
    Object.keys(exports2.config.npm.levels).concat([
      "log",
      "query",
      "stream",
      "add",
      "remove",
      "clear",
      "profile",
      "startTimer",
      "handleExceptions",
      "unhandleExceptions",
      "handleRejections",
      "unhandleRejections",
      "configure",
      "child"
    ]).forEach(
      (method) => exports2[method] = (...args) => defaultLogger[method](...args)
    );
    Object.defineProperty(exports2, "level", {
      get() {
        return defaultLogger.level;
      },
      set(val) {
        defaultLogger.level = val;
      }
    });
    Object.defineProperty(exports2, "exceptions", {
      get() {
        return defaultLogger.exceptions;
      }
    });
    ["exitOnError"].forEach((prop) => {
      Object.defineProperty(exports2, prop, {
        get() {
          return defaultLogger[prop];
        },
        set(val) {
          defaultLogger[prop] = val;
        }
      });
    });
    Object.defineProperty(exports2, "default", {
      get() {
        return {
          exceptionHandlers: defaultLogger.exceptionHandlers,
          rejectionHandlers: defaultLogger.rejectionHandlers,
          transports: defaultLogger.transports
        };
      }
    });
    warn.deprecated(exports2, "setLevels");
    warn.forFunctions(exports2, "useFormat", ["cli"]);
    warn.forProperties(exports2, "useFormat", ["padLevels", "stripColors"]);
    warn.forFunctions(exports2, "deprecated", [
      "addRewriter",
      "addFilter",
      "clone",
      "extend"
    ]);
    warn.forProperties(exports2, "deprecated", ["emitErrs", "levelLength"]);
    warn.moved(exports2, "createLogger", "Logger");
  }
});

// node_modules/object-hash/index.js
var require_object_hash = __commonJS({
  "node_modules/object-hash/index.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    exports2 = module2.exports = objectHash;
    function objectHash(object, options) {
      options = applyDefaults(object, options);
      return hash(object, options);
    }
    exports2.sha1 = function(object) {
      return objectHash(object);
    };
    exports2.keys = function(object) {
      return objectHash(object, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
    };
    exports2.MD5 = function(object) {
      return objectHash(object, { algorithm: "md5", encoding: "hex" });
    };
    exports2.keysMD5 = function(object) {
      return objectHash(object, { algorithm: "md5", encoding: "hex", excludeValues: true });
    };
    var hashes = crypto.getHashes ? crypto.getHashes().slice() : ["sha1", "md5"];
    hashes.push("passthrough");
    var encodings = ["buffer", "hex", "binary", "base64"];
    function applyDefaults(object, sourceOptions) {
      sourceOptions = sourceOptions || {};
      var options = {};
      options.algorithm = sourceOptions.algorithm || "sha1";
      options.encoding = sourceOptions.encoding || "hex";
      options.excludeValues = sourceOptions.excludeValues ? true : false;
      options.algorithm = options.algorithm.toLowerCase();
      options.encoding = options.encoding.toLowerCase();
      options.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true;
      options.respectType = sourceOptions.respectType === false ? false : true;
      options.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true;
      options.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true;
      options.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true;
      options.unorderedSets = sourceOptions.unorderedSets === false ? false : true;
      options.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true;
      options.replacer = sourceOptions.replacer || void 0;
      options.excludeKeys = sourceOptions.excludeKeys || void 0;
      if (typeof object === "undefined") {
        throw new Error("Object argument required.");
      }
      for (var i = 0; i < hashes.length; ++i) {
        if (hashes[i].toLowerCase() === options.algorithm.toLowerCase()) {
          options.algorithm = hashes[i];
        }
      }
      if (hashes.indexOf(options.algorithm) === -1) {
        throw new Error('Algorithm "' + options.algorithm + '"  not supported. supported values: ' + hashes.join(", "));
      }
      if (encodings.indexOf(options.encoding) === -1 && options.algorithm !== "passthrough") {
        throw new Error('Encoding "' + options.encoding + '"  not supported. supported values: ' + encodings.join(", "));
      }
      return options;
    }
    function isNativeFunction(f) {
      if (typeof f !== "function") {
        return false;
      }
      var exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i;
      return exp.exec(Function.prototype.toString.call(f)) != null;
    }
    function hash(object, options) {
      var hashingStream;
      if (options.algorithm !== "passthrough") {
        hashingStream = crypto.createHash(options.algorithm);
      } else {
        hashingStream = new PassThrough();
      }
      if (typeof hashingStream.write === "undefined") {
        hashingStream.write = hashingStream.update;
        hashingStream.end = hashingStream.update;
      }
      var hasher = typeHasher(options, hashingStream);
      hasher.dispatch(object);
      if (!hashingStream.update) {
        hashingStream.end("");
      }
      if (hashingStream.digest) {
        return hashingStream.digest(options.encoding === "buffer" ? void 0 : options.encoding);
      }
      var buf = hashingStream.read();
      if (options.encoding === "buffer") {
        return buf;
      }
      return buf.toString(options.encoding);
    }
    exports2.writeToStream = function(object, options, stream4) {
      if (typeof stream4 === "undefined") {
        stream4 = options;
        options = {};
      }
      options = applyDefaults(object, options);
      return typeHasher(options, stream4).dispatch(object);
    };
    function typeHasher(options, writeTo, context) {
      context = context || [];
      var write2 = function(str) {
        if (writeTo.update) {
          return writeTo.update(str, "utf8");
        } else {
          return writeTo.write(str, "utf8");
        }
      };
      return {
        dispatch: function(value) {
          if (options.replacer) {
            value = options.replacer(value);
          }
          var type = typeof value;
          if (value === null) {
            type = "null";
          }
          return this["_" + type](value);
        },
        _object: function(object) {
          var pattern = /\[object (.*)\]/i;
          var objString = Object.prototype.toString.call(object);
          var objType = pattern.exec(objString);
          if (!objType) {
            objType = "unknown:[" + objString + "]";
          } else {
            objType = objType[1];
          }
          objType = objType.toLowerCase();
          var objectNumber = null;
          if ((objectNumber = context.indexOf(object)) >= 0) {
            return this.dispatch("[CIRCULAR:" + objectNumber + "]");
          } else {
            context.push(object);
          }
          if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object)) {
            write2("buffer:");
            return write2(object);
          }
          if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
            if (this["_" + objType]) {
              this["_" + objType](object);
            } else if (options.ignoreUnknown) {
              return write2("[" + objType + "]");
            } else {
              throw new Error('Unknown object type "' + objType + '"');
            }
          } else {
            var keys = Object.keys(object);
            if (options.unorderedObjects) {
              keys = keys.sort();
            }
            if (options.respectType !== false && !isNativeFunction(object)) {
              keys.splice(0, 0, "prototype", "__proto__", "constructor");
            }
            if (options.excludeKeys) {
              keys = keys.filter(function(key) {
                return !options.excludeKeys(key);
              });
            }
            write2("object:" + keys.length + ":");
            var self2 = this;
            return keys.forEach(function(key) {
              self2.dispatch(key);
              write2(":");
              if (!options.excludeValues) {
                self2.dispatch(object[key]);
              }
              write2(",");
            });
          }
        },
        _array: function(arr, unordered) {
          unordered = typeof unordered !== "undefined" ? unordered : options.unorderedArrays !== false;
          var self2 = this;
          write2("array:" + arr.length + ":");
          if (!unordered || arr.length <= 1) {
            return arr.forEach(function(entry) {
              return self2.dispatch(entry);
            });
          }
          var contextAdditions = [];
          var entries = arr.map(function(entry) {
            var strm = new PassThrough();
            var localContext = context.slice();
            var hasher = typeHasher(options, strm, localContext);
            hasher.dispatch(entry);
            contextAdditions = contextAdditions.concat(localContext.slice(context.length));
            return strm.read().toString();
          });
          context = context.concat(contextAdditions);
          entries.sort();
          return this._array(entries, false);
        },
        _date: function(date) {
          return write2("date:" + date.toJSON());
        },
        _symbol: function(sym) {
          return write2("symbol:" + sym.toString());
        },
        _error: function(err) {
          return write2("error:" + err.toString());
        },
        _boolean: function(bool) {
          return write2("bool:" + bool.toString());
        },
        _string: function(string) {
          write2("string:" + string.length + ":");
          write2(string.toString());
        },
        _function: function(fn) {
          write2("fn:");
          if (isNativeFunction(fn)) {
            this.dispatch("[native]");
          } else {
            this.dispatch(fn.toString());
          }
          if (options.respectFunctionNames !== false) {
            this.dispatch("function-name:" + String(fn.name));
          }
          if (options.respectFunctionProperties) {
            this._object(fn);
          }
        },
        _number: function(number) {
          return write2("number:" + number.toString());
        },
        _xml: function(xml) {
          return write2("xml:" + xml.toString());
        },
        _null: function() {
          return write2("Null");
        },
        _undefined: function() {
          return write2("Undefined");
        },
        _regexp: function(regex) {
          return write2("regex:" + regex.toString());
        },
        _uint8array: function(arr) {
          write2("uint8array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint8clampedarray: function(arr) {
          write2("uint8clampedarray:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int8array: function(arr) {
          write2("uint8array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint16array: function(arr) {
          write2("uint16array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int16array: function(arr) {
          write2("uint16array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint32array: function(arr) {
          write2("uint32array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int32array: function(arr) {
          write2("uint32array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _float32array: function(arr) {
          write2("float32array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _float64array: function(arr) {
          write2("float64array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _arraybuffer: function(arr) {
          write2("arraybuffer:");
          return this.dispatch(new Uint8Array(arr));
        },
        _url: function(url2) {
          return write2("url:" + url2.toString(), "utf8");
        },
        _map: function(map) {
          write2("map:");
          var arr = Array.from(map);
          return this._array(arr, options.unorderedSets !== false);
        },
        _set: function(set) {
          write2("set:");
          var arr = Array.from(set);
          return this._array(arr, options.unorderedSets !== false);
        },
        _file: function(file) {
          write2("file:");
          return this.dispatch([file.name, file.size, file.type, file.lastModfied]);
        },
        _blob: function() {
          if (options.ignoreUnknown) {
            return write2("[blob]");
          }
          throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
        },
        _domwindow: function() {
          return write2("domwindow");
        },
        _bigint: function(number) {
          return write2("bigint:" + number.toString());
        },
        /* Node.js standard native objects */
        _process: function() {
          return write2("process");
        },
        _timer: function() {
          return write2("timer");
        },
        _pipe: function() {
          return write2("pipe");
        },
        _tcp: function() {
          return write2("tcp");
        },
        _udp: function() {
          return write2("udp");
        },
        _tty: function() {
          return write2("tty");
        },
        _statwatcher: function() {
          return write2("statwatcher");
        },
        _securecontext: function() {
          return write2("securecontext");
        },
        _connection: function() {
          return write2("connection");
        },
        _zlib: function() {
          return write2("zlib");
        },
        _context: function() {
          return write2("context");
        },
        _nodescript: function() {
          return write2("nodescript");
        },
        _httpparser: function() {
          return write2("httpparser");
        },
        _dataview: function() {
          return write2("dataview");
        },
        _signal: function() {
          return write2("signal");
        },
        _fsevent: function() {
          return write2("fsevent");
        },
        _tlswrap: function() {
          return write2("tlswrap");
        }
      };
    }
    function PassThrough() {
      return {
        buf: "",
        write: function(b) {
          this.buf += b;
        },
        end: function(b) {
          this.buf += b;
        },
        read: function() {
          return this.buf;
        }
      };
    }
  }
});

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
    })(exports2, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray2(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject2(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined2(input) {
        return input === void 0;
      }
      function isNumber2(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate2(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend2(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format3, locale2, strict) {
        return createLocalOrUTC(input, format3, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend2(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined2(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined2(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined2(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined2(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined2(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined2(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined2(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined2(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined2(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined2(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined2(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = /* @__PURE__ */ new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend2(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction2(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction2(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend2({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
              res[prop] = {};
              extend2(res[prop], parentConfig[prop]);
              extend2(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject2(parentConfig[prop])) {
            res[prop] = extend2({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction2(output) ? output.call(mom, now2) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format3) {
        var array = format3.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction2(array[i2]) ? array[i2].call(mom, format3) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format3) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format3 = expandFormat(format3, m.localeData());
        formatFunctions[format3] = formatFunctions[format3] || makeFormatFunction(format3);
        return formatFunctions[format3](m);
      }
      function expandFormat(format3, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format3)) {
          format3 = format3.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format3;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format3 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format3 || !formatUpper) {
          return format3;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction2(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format3 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction2(format3) ? format3(output) : format3.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
              value,
              mom.month(),
              daysInMonth(value, mom.month())
            );
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction2(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction2(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction2(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber2(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format3) {
        return this.localeData().monthsShort(this, format3);
      });
      addFormatToken("MMMM", 0, 0, function(format3) {
        return this.localeData().months(this, format3);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format3) {
        if (!m) {
          return isArray2(this._months) ? this._months : this._months["standalone"];
        }
        return isArray2(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format3) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format3) {
        if (!m) {
          return isArray2(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray2(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format3) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format3, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format3 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format3 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format3, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format3, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format3 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format3 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber2(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week, config, token2) {
          week[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format3) {
        return this.localeData().weekdaysMin(this, format3);
      });
      addFormatToken("ddd", 0, 0, function(format3) {
        return this.localeData().weekdaysShort(this, format3);
      });
      addFormatToken("dddd", 0, 0, function(format3) {
        return this.localeData().weekdays(this, format3);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format3) {
        var weekdays = isArray2(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format3) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format3, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format3 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format3 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format3 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format3 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format3, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format3, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format3 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format3 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format3 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return name.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined2(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray2(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = /* @__PURE__ */ new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults2(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults2(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults2(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults2(w.W, 1);
          weekday = defaults2(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults2(w.gg, config._a[YEAR], curWeek.year);
          week = defaults2(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(
              string.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = /* @__PURE__ */ new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend2(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format3 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format3 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate2(input)) {
          config._d = input;
        } else if (isArray2(format3)) {
          configFromStringAndArray(config);
        } else if (format3) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined2(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate2(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray2(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject2(input)) {
          configFromObject(config);
        } else if (isNumber2(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format3, locale2, strict, isUTC) {
        var c = {};
        if (format3 === true || format3 === false) {
          strict = format3;
          format3 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject2(input) && isObjectEmpty(input) || isArray2(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format3;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format3, locale2, strict) {
        return createLocalOrUTC(input, format3, locale2, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray2(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate2(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined2(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber2(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString2(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate2(input) || isString2(input) || isNumber2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray2(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber2(item) && isString2(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format3 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction2(formats[format3]) ? formats[format3].call(this, now2) : formats[format3]);
        return this.format(
          output || this.localeData().calendar(format3, this, createLocal(now2))
        );
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString3() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction2(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format2(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray2() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON2() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend2({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format3) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format3, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format3) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          namePieces.push(regexEscape(eras[i].name));
          abbrPieces.push(regexEscape(eras[i].abbr));
          narrowPieces.push(regexEscape(eras[i].narrow));
          mixedPieces.push(regexEscape(eras[i].name));
          mixedPieces.push(regexEscape(eras[i].abbr));
          mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week, config, token2) {
          week[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format2;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray2;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON2;
      proto.toString = toString3;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format3, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format3);
      }
      function listMonthsImpl(format3, index, field) {
        if (isNumber2(format3)) {
          index = format3;
          format3 = void 0;
        }
        format3 = format3 || "";
        if (index != null) {
          return get$1(format3, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format3, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format3, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber2(format3)) {
            index = format3;
            format3 = void 0;
          }
          format3 = format3 || "";
        } else {
          format3 = localeSorted;
          index = format3;
          localeSorted = false;
          if (isNumber2(format3)) {
            index = format3;
            format3 = void 0;
          }
          format3 = format3 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format3, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format3, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format3, index) {
        return listMonthsImpl(format3, index, "months");
      }
      function listMonthsShort(format3, index) {
        return listMonthsImpl(format3, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format3, index) {
        return listWeekdaysImpl(localeSorted, format3, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format3, index) {
        return listWeekdaysImpl(localeSorted, format3, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format3, index) {
        return listWeekdaysImpl(localeSorted, format3, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate2;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// node_modules/file-stream-rotator/FileStreamRotator.js
var require_FileStreamRotator = __commonJS({
  "node_modules/file-stream-rotator/FileStreamRotator.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var path = require("path");
    var moment = require_moment();
    var crypto = require("crypto");
    var EventEmitter2 = require("events");
    var FileStreamRotator = {};
    module2.exports = FileStreamRotator;
    var staticFrequency = ["daily", "test", "m", "h", "custom"];
    var DATE_FORMAT = "YYYYMMDDHHmm";
    var _checkNumAndType = function(type, num) {
      if (typeof num == "number") {
        switch (type) {
          case "m":
            if (num < 0 || num > 60) {
              return false;
            }
            break;
          case "h":
            if (num < 0 || num > 24) {
              return false;
            }
            break;
        }
        return { type, digit: num };
      }
    };
    var _checkDailyAndTest = function(freqType) {
      switch (freqType) {
        case "custom":
        case "daily":
          return { type: freqType, digit: void 0 };
          break;
        case "test":
          return { type: freqType, digit: 0 };
      }
      return false;
    };
    FileStreamRotator.getFrequency = function(frequency) {
      var _f = frequency.toLowerCase().match(/^(\d+)([mh])$/);
      if (_f) {
        return _checkNumAndType(_f[2], parseInt(_f[1]));
      }
      var dailyOrTest = _checkDailyAndTest(frequency);
      if (dailyOrTest) {
        return dailyOrTest;
      }
      return false;
    };
    FileStreamRotator.parseFileSize = function(size) {
      if (size && typeof size == "string") {
        var _s = size.toLowerCase().match(/^((?:0\.)?\d+)([kmg])$/);
        if (_s) {
          switch (_s[2]) {
            case "k":
              return _s[1] * 1024;
            case "m":
              return _s[1] * 1024 * 1024;
            case "g":
              return _s[1] * 1024 * 1024 * 1024;
          }
        }
      }
      return null;
    };
    FileStreamRotator.getDate = function(format2, date_format, utc) {
      date_format = date_format || DATE_FORMAT;
      let currentMoment = utc ? moment.utc() : moment().local();
      if (format2 && staticFrequency.indexOf(format2.type) !== -1) {
        switch (format2.type) {
          case "m":
            var minute = Math.floor(currentMoment.minutes() / format2.digit) * format2.digit;
            return currentMoment.minutes(minute).format(date_format);
            break;
          case "h":
            var hour = Math.floor(currentMoment.hour() / format2.digit) * format2.digit;
            return currentMoment.hour(hour).format(date_format);
            break;
          case "daily":
          case "custom":
          case "test":
            return currentMoment.format(date_format);
        }
      }
      return currentMoment.format(date_format);
    };
    FileStreamRotator.setAuditLog = function(max_logs, audit_file, log_file) {
      var _rtn = null;
      if (max_logs) {
        var use_days = max_logs.toString().substr(-1);
        var _num = max_logs.toString().match(/^(\d+)/);
        if (Number(_num[1]) > 0) {
          var baseLog = path.dirname(log_file.replace(/%DATE%.+/, "_filename"));
          try {
            if (audit_file) {
              var full_path = path.resolve(audit_file);
              _rtn = JSON.parse(fs2.readFileSync(full_path, { encoding: "utf-8" }));
            } else {
              var full_path = path.resolve(baseLog + "/.audit.json");
              _rtn = JSON.parse(fs2.readFileSync(full_path, { encoding: "utf-8" }));
            }
          } catch (e) {
            if (e.code !== "ENOENT") {
              return null;
            }
            _rtn = {
              keep: {
                days: false,
                amount: Number(_num[1])
              },
              auditLog: audit_file || baseLog + "/.audit.json",
              files: []
            };
          }
          _rtn.keep = {
            days: use_days === "d",
            amount: Number(_num[1])
          };
        }
      }
      return _rtn;
    };
    FileStreamRotator.writeAuditLog = function(audit, verbose) {
      try {
        mkDirForFile(audit.auditLog);
        fs2.writeFileSync(audit.auditLog, JSON.stringify(audit, null, 4));
      } catch (e) {
        if (verbose) {
          console.error(/* @__PURE__ */ new Date(), "[FileStreamRotator] Failed to store log audit at:", audit.auditLog, "Error:", e);
        }
      }
    };
    function removeFile(file, verbose) {
      if (file.hash === crypto.createHash(file.hashType).update(file.name + "LOG_FILE" + file.date).digest("hex")) {
        try {
          if (fs2.existsSync(file.name)) {
            fs2.unlinkSync(file.name);
          }
        } catch (e) {
          if (verbose) {
            console.error(/* @__PURE__ */ new Date(), "[FileStreamRotator] Could not remove old log file: ", file.name);
          }
        }
      }
    }
    function createCurrentSymLink(logfile, name, verbose) {
      let symLinkName = name || "current.log";
      let logPath = path.dirname(logfile);
      let logfileName = path.basename(logfile);
      let current = logPath + "/" + symLinkName;
      try {
        let stats = fs2.lstatSync(current);
        if (stats.isSymbolicLink()) {
          fs2.unlinkSync(current);
          fs2.symlinkSync(logfileName, current);
        }
      } catch (err) {
        if (err && err.code == "ENOENT") {
          try {
            fs2.symlinkSync(logfileName, current);
          } catch (e) {
            if (verbose) {
              console.error(/* @__PURE__ */ new Date(), "[FileStreamRotator] Could not create symlink file: ", current, " -> ", logfileName);
            }
          }
        }
      }
    }
    function createLogWatcher(logfile, verbose, cb) {
      if (!logfile)
        return null;
      try {
        let stats = fs2.lstatSync(logfile);
        return fs2.watch(logfile, function(event, filename) {
          if (event == "rename") {
            try {
              let stats2 = fs2.lstatSync(logfile);
            } catch (err) {
              cb(err, logfile);
            }
          }
        });
      } catch (err) {
        if (verbose) {
          console.log(/* @__PURE__ */ new Date(), "[FileStreamRotator] Could not add watcher for " + logfile);
        }
      }
    }
    FileStreamRotator.addLogToAudit = function(logfile, audit, stream4, verbose) {
      if (audit && audit.files) {
        var index = audit.files.findIndex(function(file) {
          return file.name === logfile;
        });
        if (index !== -1) {
          return audit;
        }
        var time = Date.now();
        audit.files.push({
          date: time,
          name: logfile,
          hash: crypto.createHash(audit.hashType).update(logfile + "LOG_FILE" + time).digest("hex")
        });
        if (audit.keep.days) {
          var oldestDate = moment().subtract(audit.keep.amount, "days").valueOf();
          var recentFiles = audit.files.filter(function(file) {
            if (file.date > oldestDate) {
              return true;
            }
            file.hashType = audit.hashType;
            removeFile(file, verbose);
            stream4.emit("logRemoved", file);
            return false;
          });
          audit.files = recentFiles;
        } else {
          var filesToKeep = audit.files.splice(-audit.keep.amount);
          if (audit.files.length > 0) {
            audit.files.filter(function(file) {
              file.hashType = audit.hashType;
              removeFile(file, verbose);
              stream4.emit("logRemoved", file);
              return false;
            });
          }
          audit.files = filesToKeep;
        }
        FileStreamRotator.writeAuditLog(audit, verbose);
      }
      return audit;
    };
    FileStreamRotator.getStream = function(options) {
      var frequencyMetaData = null;
      var curDate = null;
      var self2 = this;
      if (!options.filename) {
        console.error(/* @__PURE__ */ new Date(), "[FileStreamRotator] No filename supplied. Defaulting to STDOUT");
        return process.stdout;
      }
      if (options.frequency) {
        frequencyMetaData = self2.getFrequency(options.frequency);
      }
      let auditLog = self2.setAuditLog(options.max_logs, options.audit_file, options.filename);
      if (auditLog != null) {
        auditLog.hashType = options.audit_hash_type !== void 0 ? options.audit_hash_type : "md5";
      }
      self2.verbose = options.verbose !== void 0 ? options.verbose : true;
      var fileSize = null;
      var fileCount = 0;
      var curSize = 0;
      if (options.size) {
        fileSize = FileStreamRotator.parseFileSize(options.size);
      }
      var dateFormat = options.date_format || DATE_FORMAT;
      if (frequencyMetaData && frequencyMetaData.type == "daily") {
        if (!options.date_format) {
          dateFormat = "YYYY-MM-DD";
        }
        if (moment().format(dateFormat) != moment().endOf("day").format(dateFormat) || moment().format(dateFormat) == moment().add(1, "day").format(dateFormat)) {
          if (self2.verbose) {
            console.log(/* @__PURE__ */ new Date(), "[FileStreamRotator] Changing type to custom as date format changes more often than once a day or not every day");
          }
          frequencyMetaData.type = "custom";
        }
      }
      if (frequencyMetaData) {
        curDate = options.frequency ? self2.getDate(frequencyMetaData, dateFormat, options.utc) : "";
      }
      options.create_symlink = options.create_symlink || false;
      options.extension = options.extension || "";
      var filename = options.filename;
      var oldFile = null;
      var logfile = filename + (curDate ? "." + curDate : "");
      if (filename.match(/%DATE%/)) {
        logfile = filename.replace(/%DATE%/g, curDate ? curDate : self2.getDate(null, dateFormat, options.utc));
      }
      if (fileSize) {
        var lastLogFile = null;
        var t_log = logfile;
        var f = null;
        if (auditLog && auditLog.files && auditLog.files instanceof Array && auditLog.files.length > 0) {
          var lastEntry = auditLog.files[auditLog.files.length - 1].name;
          if (lastEntry.match(t_log)) {
            var lastCount = lastEntry.match(t_log + "\\.(\\d+)");
            if (lastCount) {
              t_log = lastEntry;
              fileCount = lastCount[1];
            }
          }
        }
        if (fileCount == 0 && t_log == logfile) {
          t_log += options.extension;
        }
        while (f = fs2.existsSync(t_log)) {
          lastLogFile = t_log;
          fileCount++;
          t_log = logfile + "." + fileCount + options.extension;
        }
        if (lastLogFile) {
          var lastLogFileStats = fs2.statSync(lastLogFile);
          if (lastLogFileStats.size < fileSize) {
            t_log = lastLogFile;
            fileCount--;
            curSize = lastLogFileStats.size;
          }
        }
        logfile = t_log;
      } else {
        logfile += options.extension;
      }
      if (self2.verbose) {
        console.log(/* @__PURE__ */ new Date(), "[FileStreamRotator] Logging to: ", logfile);
      }
      mkDirForFile(logfile);
      var file_options = options.file_options || { flags: "a" };
      var rotateStream = fs2.createWriteStream(logfile, file_options);
      if (curDate && frequencyMetaData && staticFrequency.indexOf(frequencyMetaData.type) > -1 || fileSize > 0) {
        if (self2.verbose) {
          console.log(/* @__PURE__ */ new Date(), "[FileStreamRotator] Rotating file: ", frequencyMetaData ? frequencyMetaData.type : "", fileSize ? "size: " + fileSize : "");
        }
        var stream4 = new EventEmitter2();
        stream4.auditLog = auditLog;
        stream4.end = function() {
          rotateStream.end.apply(rotateStream, arguments);
        };
        BubbleEvents(rotateStream, stream4);
        stream4.on("close", function() {
          if (logWatcher) {
            logWatcher.close();
          }
        });
        stream4.on("new", function(newLog) {
          stream4.auditLog = self2.addLogToAudit(newLog, stream4.auditLog, stream4, self2.verbose);
          if (options.create_symlink) {
            createCurrentSymLink(newLog, options.symlink_name, self2.verbose);
          }
          if (options.watch_log) {
            stream4.emit("addWatcher", newLog);
          }
        });
        var logWatcher;
        stream4.on("addWatcher", function(newLog) {
          if (logWatcher) {
            logWatcher.close();
          }
          if (!options.watch_log) {
            return;
          }
          logWatcher = createLogWatcher(newLog, self2.verbose, function(err, newLog2) {
            stream4.emit("createLog", newLog2);
          });
        });
        stream4.on("createLog", function(file) {
          try {
            let stats = fs2.lstatSync(file);
          } catch (err) {
            if (rotateStream && rotateStream.end == "function") {
              rotateStream.end();
            }
            rotateStream = fs2.createWriteStream(file, file_options);
            stream4.emit("new", file);
            BubbleEvents(rotateStream, stream4);
          }
        });
        stream4.write = function(str, encoding) {
          var newDate = frequencyMetaData ? this.getDate(frequencyMetaData, dateFormat, options.utc) : curDate;
          if (newDate != curDate || fileSize && curSize > fileSize) {
            var newLogfile = filename + (curDate && frequencyMetaData ? "." + newDate : "");
            if (filename.match(/%DATE%/) && curDate) {
              newLogfile = filename.replace(/%DATE%/g, newDate);
            }
            if (fileSize && curSize > fileSize) {
              fileCount++;
              newLogfile += "." + fileCount + options.extension;
            } else {
              fileCount = 0;
              newLogfile += options.extension;
            }
            curSize = 0;
            if (self2.verbose) {
              console.log(/* @__PURE__ */ new Date(), require("util").format("[FileStreamRotator] Changing logs from %s to %s", logfile, newLogfile));
            }
            curDate = newDate;
            oldFile = logfile;
            logfile = newLogfile;
            if (options.end_stream === true) {
              rotateStream.end();
            } else {
              rotateStream.destroy();
            }
            mkDirForFile(logfile);
            rotateStream = fs2.createWriteStream(newLogfile, file_options);
            stream4.emit("new", newLogfile);
            stream4.emit("rotate", oldFile, newLogfile);
            BubbleEvents(rotateStream, stream4);
          }
          rotateStream.write(str, encoding);
          curSize += Buffer.byteLength(str, encoding);
        }.bind(this);
        process.nextTick(function() {
          stream4.emit("new", logfile);
        });
        stream4.emit("new", logfile);
        return stream4;
      } else {
        if (self2.verbose) {
          console.log(/* @__PURE__ */ new Date(), "[FileStreamRotator] File won't be rotated: ", options.frequency, options.size);
        }
        process.nextTick(function() {
          rotateStream.emit("new", logfile);
        });
        return rotateStream;
      }
    };
    var mkDirForFile = function(pathWithFile) {
      var _path = path.dirname(pathWithFile);
      _path.split(path.sep).reduce(
        function(fullPath, folder) {
          fullPath += folder + path.sep;
          if (!fs2.existsSync(fullPath)) {
            try {
              fs2.mkdirSync(fullPath);
            } catch (e) {
              if (e.code !== "EEXIST") {
                throw e;
              }
            }
          }
          return fullPath;
        },
        ""
      );
    };
    var BubbleEvents = function BubbleEvents2(emitter, proxy) {
      emitter.on("close", function() {
        proxy.emit("close");
      });
      emitter.on("finish", function() {
        proxy.emit("finish");
      });
      emitter.on("error", function(err) {
        proxy.emit("error", err);
      });
      emitter.on("open", function(fd) {
        proxy.emit("open", fd);
      });
    };
  }
});

// node_modules/winston-daily-rotate-file/daily-rotate-file.js
var require_daily_rotate_file = __commonJS({
  "node_modules/winston-daily-rotate-file/daily-rotate-file.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var os = require("os");
    var path = require("path");
    var util2 = require("util");
    var zlib2 = require("zlib");
    var hash = require_object_hash();
    var MESSAGE = require_triple_beam().MESSAGE;
    var PassThrough = require("stream").PassThrough;
    var Transport = require_winston_transport();
    var loggerDefaults = {
      json: false,
      colorize: false,
      eol: os.EOL,
      logstash: null,
      prettyPrint: false,
      label: null,
      stringify: false,
      depth: null,
      showLevel: true,
      timestamp: function() {
        return (/* @__PURE__ */ new Date()).toISOString();
      }
    };
    var DailyRotateFile2 = function(options) {
      options = options || {};
      Transport.call(this, options);
      function throwIf(target) {
        Array.prototype.slice.call(arguments, 1).forEach(function(name) {
          if (options[name]) {
            throw new Error("Cannot set " + name + " and " + target + " together");
          }
        });
      }
      function getMaxSize(size) {
        if (size && typeof size === "string") {
          var _s = size.toLowerCase().match(/^((?:0\.)?\d+)([k|m|g])$/);
          if (_s) {
            return size;
          }
        } else if (size && Number.isInteger(size)) {
          var sizeK = Math.round(size / 1024);
          return sizeK === 0 ? "1k" : sizeK + "k";
        }
        return null;
      }
      function isValidFileName(filename) {
        return !/["<>|:*?\\/\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f]/g.test(filename);
      }
      function isValidDirName(dirname) {
        return !/["<>|\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f]/g.test(dirname);
      }
      this.options = Object.assign({}, loggerDefaults, options);
      if (options.stream) {
        throwIf("stream", "filename", "maxsize");
        this.logStream = new PassThrough();
        this.logStream.pipe(options.stream);
      } else {
        this.filename = options.filename ? path.basename(options.filename) : "winston.log";
        this.dirname = options.dirname || path.dirname(options.filename);
        if (!isValidFileName(this.filename) || !isValidDirName(this.dirname)) {
          throw new Error("Your path or filename contain an invalid character.");
        }
        var self2 = this;
        this.logStream = require_FileStreamRotator().getStream({
          filename: path.join(this.dirname, this.filename),
          frequency: options.frequency ? options.frequency : "custom",
          date_format: options.datePattern ? options.datePattern : "YYYY-MM-DD",
          verbose: false,
          size: getMaxSize(options.maxSize),
          max_logs: options.maxFiles,
          end_stream: true,
          audit_file: options.auditFile ? options.auditFile : path.join(self2.dirname, "." + hash(options) + "-audit.json"),
          file_options: options.options ? options.options : { flags: "a" },
          utc: options.utc ? options.utc : false,
          extension: options.extension ? options.extension : "",
          create_symlink: options.createSymlink ? options.createSymlink : false,
          symlink_name: options.symlinkName ? options.symlinkName : "current.log",
          watch_log: options.watchLog ? options.watchLog : false,
          audit_hash_type: options.auditHashType ? options.auditHashType : "sha256"
        });
        this.logStream.on("new", function(newFile) {
          self2.emit("new", newFile);
        });
        this.logStream.on("rotate", function(oldFile, newFile) {
          self2.emit("rotate", oldFile, newFile);
        });
        this.logStream.on("logRemoved", function(params) {
          if (options.zippedArchive) {
            var gzName = params.name + ".gz";
            if (fs2.existsSync(gzName)) {
              try {
                fs2.unlinkSync(gzName);
              } catch (_err) {
              }
              self2.emit("logRemoved", gzName);
              return;
            }
          }
          self2.emit("logRemoved", params.name);
        });
        if (options.zippedArchive) {
          this.logStream.on("rotate", function(oldFile) {
            var oldFileExist = fs2.existsSync(oldFile);
            var gzExist = fs2.existsSync(oldFile + ".gz");
            if (!oldFileExist || gzExist) {
              return;
            }
            var gzip = zlib2.createGzip();
            var inp = fs2.createReadStream(oldFile);
            var out = fs2.createWriteStream(oldFile + ".gz");
            inp.pipe(gzip).pipe(out).on("finish", function() {
              if (fs2.existsSync(oldFile)) {
                fs2.unlinkSync(oldFile);
              }
              self2.emit("archive", oldFile + ".gz");
            });
          });
        }
        if (options.watchLog) {
          this.logStream.on("addWatcher", (newFile) => {
            self2.emit("addWatcher", newFile);
          });
        }
      }
    };
    module2.exports = DailyRotateFile2;
    util2.inherits(DailyRotateFile2, Transport);
    DailyRotateFile2.prototype.name = "dailyRotateFile";
    var noop2 = function() {
    };
    DailyRotateFile2.prototype.log = function(info, callback) {
      callback = callback || noop2;
      this.logStream.write(info[MESSAGE] + this.options.eol);
      this.emit("logged", info);
      callback(null, true);
    };
    DailyRotateFile2.prototype.close = function() {
      var self2 = this;
      if (this.logStream) {
        this.logStream.end(function() {
          self2.emit("finish");
        });
      }
    };
    DailyRotateFile2.prototype.query = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!this.options.json) {
        throw new Error("query() may not be used without the json option being set to true");
      }
      if (!this.filename) {
        throw new Error("query() may not be used when initializing with a stream");
      }
      var self2 = this;
      var results = [];
      options = options || {};
      options.rows = options.rows || options.limit || 10;
      options.start = options.start || 0;
      options.until = options.until || /* @__PURE__ */ new Date();
      if (typeof options.until !== "object") {
        options.until = new Date(options.until);
      }
      options.from = options.from || options.until - 24 * 60 * 60 * 1e3;
      if (typeof options.from !== "object") {
        options.from = new Date(options.from);
      }
      options.order = options.order || "desc";
      var logFiles = function() {
        var fileRegex = new RegExp(self2.filename.replace("%DATE%", ".*"), "i");
        return fs2.readdirSync(self2.dirname).filter(function(file) {
          return path.basename(file).match(fileRegex);
        });
      }();
      if (logFiles.length === 0 && callback) {
        callback(null, results);
      }
      (function processLogFile(file) {
        if (!file) {
          return;
        }
        var logFile = path.join(self2.dirname, file);
        var buff = "";
        var stream4;
        if (file.endsWith(".gz")) {
          stream4 = new PassThrough();
          fs2.createReadStream(logFile).pipe(zlib2.createGunzip()).pipe(stream4);
        } else {
          stream4 = fs2.createReadStream(logFile, {
            encoding: "utf8"
          });
        }
        stream4.on("error", function(err) {
          if (stream4.readable) {
            stream4.destroy();
          }
          if (!callback) {
            return;
          }
          return err.code === "ENOENT" ? callback(null, results) : callback(err);
        });
        stream4.on("data", function(data) {
          data = (buff + data).split(/\n+/);
          var l = data.length - 1;
          for (var i = 0; i < l; i++) {
            add(data[i]);
          }
          buff = data[l];
        });
        stream4.on("end", function() {
          if (buff) {
            add(buff, true);
          }
          if (logFiles.length) {
            processLogFile(logFiles.shift());
          } else if (callback) {
            results.sort(function(a, b) {
              var d1 = new Date(a.timestamp).getTime();
              var d2 = new Date(b.timestamp).getTime();
              return d1 > d2 ? 1 : d1 < d2 ? -1 : 0;
            });
            if (options.order === "desc") {
              results = results.reverse();
            }
            var start = options.start || 0;
            var limit = options.limit || results.length;
            results = results.slice(start, start + limit);
            if (options.fields) {
              results = results.map(function(log) {
                var obj = {};
                options.fields.forEach(function(key) {
                  obj[key] = log[key];
                });
                return obj;
              });
            }
            callback(null, results);
          }
        });
        function add(buff2, attempt) {
          try {
            var log = JSON.parse(buff2);
            if (!log || typeof log !== "object") {
              return;
            }
            var time = new Date(log.timestamp);
            if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
              return;
            }
            results.push(log);
          } catch (e) {
            if (!attempt) {
              stream4.emit("error", e);
            }
          }
        }
      })(logFiles.shift());
    };
  }
});

// node_modules/winston-daily-rotate-file/index.js
var require_winston_daily_rotate_file = __commonJS({
  "node_modules/winston-daily-rotate-file/index.js"(exports2, module2) {
    "use strict";
    var winston2 = require_winston();
    var DailyRotateFile2 = require_daily_rotate_file();
    winston2.transports.DailyRotateFile = DailyRotateFile2;
    module2.exports = DailyRotateFile2;
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    var util2 = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util2.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    var util2 = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util2.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream4) {
      return typeof stream4 !== "function" && typeof stream4 !== "string" && typeof stream4 !== "boolean" && typeof stream4 !== "number" && !Buffer.isBuffer(stream4);
    };
    CombinedStream.prototype.append = function(stream4) {
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        if (!(stream4 instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream4, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream4.on("data", this._checkDataSize.bind(this));
          stream4 = newStream;
        }
        this._handleErrors(stream4);
        if (this.pauseStreams) {
          stream4.pause();
        }
      }
      this._streams.push(stream4);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream4 = this._streams.shift();
      if (typeof stream4 == "undefined") {
        this.end();
        return;
      }
      if (typeof stream4 !== "function") {
        this._pipeNext(stream4);
        return;
      }
      var getStream = stream4;
      getStream(function(stream5) {
        var isStreamLike = CombinedStream.isStreamLike(stream5);
        if (isStreamLike) {
          stream5.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream5);
        }
        this._pipeNext(stream5);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream4) {
      this._currentStream = stream4;
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        stream4.on("end", this._getNext.bind(this));
        stream4.pipe(this, { end: false });
        return;
      }
      var value = stream4;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream4) {
      var self2 = this;
      stream4.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream4) {
        if (!stream4.dataSize) {
          return;
        }
        self2.dataSize += stream4.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions2, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions2[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer2 = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports2, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async2 = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports2, module2) {
    var defer = require_defer2();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports2, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    var async = require_async2();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state2 = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports2, module2) {
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    var abort = require_abort();
    var async = require_async2();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel2 = __commonJS({
  "node_modules/asynckit/parallel.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state2();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state2();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports2, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports2, module2) {
    module2.exports = {
      parallel: require_parallel2(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports2, module2) {
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports2, module2) {
    var CombinedStream = require_combined_stream();
    var util2 = require("util");
    var path = require("path");
    var http2 = require("http");
    var https2 = require("https");
    var parseUrl = require("url").parse;
    var fs2 = require("fs");
    var Stream = require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData3;
    util2.inherits(FormData3, CombinedStream);
    function FormData3(options) {
      if (!(this instanceof FormData3)) {
        return new FormData3(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData3.LINE_BREAK = "\r\n";
    FormData3.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData3.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append2 = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util2.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append2(header);
      append2(value);
      append2(footer);
      this._trackLength(header, value, options);
    };
    FormData3.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData3.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData3.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs2.stat(value.path, function(err, stat2) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat2.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData3.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData3.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData3.LINE_BREAK + contents + FormData3.LINE_BREAK;
    };
    FormData3.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData3.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData3.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData3.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData3.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData3.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData3.LINE_BREAK;
    };
    FormData3.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData3.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData3.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData3.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData3.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData3.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData3.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData3.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData3.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData3.prototype.submit = function(params, cb) {
      var request, options, defaults2 = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults2);
      } else {
        options = populate(params, defaults2);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https2.request(options);
      } else {
        request = http2.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData3.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData3.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl2(url2) {
      var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl2;
  }
});

// node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/debug/src/debug.js"(exports2, module2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format2) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format2];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2 = module2.exports = require_debug();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/debug/src/node.js
var require_node3 = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util2 = require("util");
    exports2 = module2.exports = require_debug();
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util2.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream4 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports2.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
      }
    }
    function log() {
      return stream4.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream5;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream5 = new tty.WriteStream(fd2);
          stream5._type = "tty";
          if (stream5._handle && stream5._handle.unref) {
            stream5._handle.unref();
          }
          break;
        case "FILE":
          var fs2 = require("fs");
          stream5 = new fs2.SyncWriteStream(fd2, { autoClose: false });
          stream5._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require("net");
          stream5 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream5.readable = false;
          stream5.read = null;
          stream5._type = "pipe";
          if (stream5._handle && stream5._handle.unref) {
            stream5._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream5.fd = fd2;
      stream5._isStdio = true;
      return stream5;
    }
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    exports2.enable(load());
  }
});

// node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node3();
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src2()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    var url2 = require("url");
    var URL2 = url2.URL;
    var http2 = require("http");
    var https2 = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug2();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString2(data) && !isBuffer2(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction2(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction2(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction2(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : (
        // When making a request to a proxy, […]
        // a client MUST send the target URI in absolute-form […].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      abortRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = url2.parse(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl;
      try {
        redirectUrl = url2.resolve(currentUrl, location);
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
        return;
      }
      debug("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url2.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction2(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        try {
          beforeRedirect(this._options, responseDetails, requestDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
      }
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isString2(input)) {
            var parsed;
            try {
              parsed = urlToOptions(new URL2(input));
            } catch (err) {
              parsed = url2.parse(input);
            }
            if (!isString2(parsed.protocol)) {
              throw new InvalidUrlError({ input });
            }
            input = parsed;
          } else if (URL2 && input instanceof URL2) {
            input = urlToOptions(input);
          } else {
            callback = options;
            options = input;
            input = { protocol };
          }
          if (isFunction2(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString2(options.host) && !isString2(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop2() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? (
          /* istanbul ignore next */
          urlObject.hostname.slice(1, -1)
        ) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor);
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      return CustomError;
    }
    function abortRequest(request) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop2);
      request.abort();
    }
    function isSubdomain(subdomain, domain) {
      assert(isString2(subdomain) && isString2(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString2(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction2(value) {
      return typeof value === "function";
    }
    function isBuffer2(value) {
      return typeof value === "object" && "length" in value;
    }
    module2.exports = wrap({ http: http2, https: https2 });
    module2.exports.wrap = wrap;
  }
});

// src/DiscordClient/main.ts
var main_exports = {};
__export(main_exports, {
  TimelineAppLauncher: () => TimelineAppLauncher
});
module.exports = __toCommonJS(main_exports);
var import_dotenv2 = __toESM(require_main());

// src/DiscordClient/client.ts
var import_discord = __toESM(require_src());
var import_dotenv = __toESM(require_main());
var import_rxjs = __toESM(require_cjs2());

// src/utils/logger.ts
var import_winston = __toESM(require_winston());
var { createLogger, transports, format } = import_winston.default;
var { combine, timestamp, json, prettyPrint, align, padLevels, colorize } = format;
var DailyRotateFile = require_winston_daily_rotate_file();
function createNewLogger(folderPath) {
  if (!/^[\w\-]+$/g.test(folderPath)) {
    throw new Error(`Invalid level specified: ${folderPath}`);
  }
  function getNewTimestamp() {
    const date = /* @__PURE__ */ new Date();
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    return `${year}-${month}-${day}`;
  }
  const logger = createLogger({
    format: combine(
      timestamp(),
      json(),
      prettyPrint(),
      align(),
      padLevels(),
      colorize()
    ),
    transports: [
      new transports.File({
        filename: `logs/${folderPath}/${getNewTimestamp()}.log`,
        maxsize: 10 * 1024 * 1024,
        // 10 MB
        maxFiles: 1,
        tailable: true,
        level: "info"
      })
      // new DailyRotateFile({
      //   filename: `logs/${folderPath}/%DATE%.log`,
      //   datePattern: 'YYYY-MM-DD',
      //   zippedArchive: false,
      //   maxSize: '10m',
      //   maxFiles: '1'
      // })
    ]
  });
  logger.on("error", (err) => {
    console.error(`Error logging to file: ${err}`);
  });
  return logger;
}

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  const pattern = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    if (reducer(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data = __toESM(require_form_data(), 1);
var FormData_default = import_form_data.default;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/node/classes/URLSearchParams.js
var import_url = __toESM(require("url"), 1);
var URLSearchParams_default = import_url.default.URLSearchParams;

// node_modules/axios/lib/platform/node/index.js
var node_default = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  protocols: ["http", "https", "file", "data"]
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new node_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (node_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: node_default.classes.FormData,
    Blob: node_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils_default.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults.headers[method] = utils_default.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
function isValidHeaderName(str) {
  return /^[-_a-zA-Z]+$/.test(str.trim());
}
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.freezeMethods(AxiosHeaders.prototype);
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/adapters/http.js
var import_proxy_from_env = __toESM(require_proxy_from_env(), 1);
var import_http = __toESM(require("http"), 1);
var import_https = __toESM(require("https"), 1);
var import_util3 = __toESM(require("util"), 1);
var import_follow_redirects = __toESM(require_follow_redirects(), 1);
var import_zlib = __toESM(require("zlib"), 1);

// node_modules/axios/lib/env/data.js
var VERSION = "1.3.4";

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/fromDataURI.js
var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || node_default.classes.Blob;
  const protocol = parseProtocol(uri);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    const match = DATA_URL_PATTERN.exec(uri);
    if (!match) {
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}

// node_modules/axios/lib/adapters/http.js
var import_stream4 = __toESM(require("stream"), 1);

// node_modules/axios/lib/helpers/AxiosTransformStream.js
var import_stream = __toESM(require("stream"), 1);

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp2 = 0;
  const threshold = 1e3 / freq;
  let timer = null;
  return function throttled(force, args) {
    const now = Date.now();
    if (force || now - timestamp2 > threshold) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      timestamp2 = now;
      return fn.apply(null, args);
    }
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        timestamp2 = Date.now();
        return fn.apply(null, args);
      }, threshold - (now - timestamp2));
    }
  };
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/AxiosTransformStream.js
var kInternals = Symbol("internals");
var AxiosTransformStream = class extends import_stream.default.Transform {
  constructor(options) {
    options = utils_default.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils_default.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const self2 = this;
    const internals = this[kInternals] = {
      length: options.length,
      timeWindow: options.timeWindow,
      ticksRate: options.ticksRate,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    const _speedometer = speedometer_default(internals.ticksRate * options.samplesCount, internals.timeWindow);
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
    let bytesNotified = 0;
    internals.updateProgress = throttle_default(function throttledHandler() {
      const totalBytes = internals.length;
      const bytesTransferred = internals.bytesSeen;
      const progressBytes = bytesTransferred - bytesNotified;
      if (!progressBytes || self2.destroyed)
        return;
      const rate = _speedometer(progressBytes);
      bytesNotified = bytesTransferred;
      process.nextTick(() => {
        self2.emit("progress", {
          "loaded": bytesTransferred,
          "total": totalBytes,
          "progress": totalBytes ? bytesTransferred / totalBytes : void 0,
          "bytes": progressBytes,
          "rate": rate ? rate : void 0,
          "estimated": rate && totalBytes && bytesTransferred <= totalBytes ? (totalBytes - bytesTransferred) / rate : void 0
        });
      });
    }, internals.ticksRate);
    const onFinish = () => {
      internals.updateProgress(true);
    };
    this.once("end", onFinish);
    this.once("error", onFinish);
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding, callback) {
    const self2 = this;
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1e3 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    function pushChunk(_chunk, _callback) {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;
      if (internals.isCaptured) {
        internals.updateProgress();
      }
      if (self2.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    }
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
  setLength(length) {
    this[kInternals].length = +length;
    return this;
  }
};
var AxiosTransformStream_default = AxiosTransformStream;

// node_modules/axios/lib/adapters/http.js
var import_events = __toESM(require("events"), 1);

// node_modules/axios/lib/helpers/formDataToStream.js
var import_util2 = require("util");
var import_stream2 = require("stream");

// node_modules/axios/lib/helpers/readBlob.js
var { asyncIterator } = Symbol;
var readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
var readBlob_default = readBlob;

// node_modules/axios/lib/helpers/formDataToStream.js
var BOUNDARY_ALPHABET = utils_default.ALPHABET.ALPHA_DIGIT + "-_";
var textEncoder = new import_util2.TextEncoder();
var CRLF = "\r\n";
var CRLF_BYTES = textEncoder.encode(CRLF);
var CRLF_BYTES_COUNT = 2;
var FormDataPart = class {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils_default.isString(value);
    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async *encode() {
    yield this.headers;
    const { value } = this;
    if (utils_default.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob_default(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match]);
  }
};
var formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + utils_default.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils_default.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils_default.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return import_stream2.Readable.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
var formDataToStream_default = formDataToStream;

// node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
var import_stream3 = __toESM(require("stream"), 1);
var ZlibHeaderTransformStream = class extends import_stream3.default.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding);
      }
    }
    this.__transform(chunk, encoding, callback);
  }
};
var ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;

// node_modules/axios/lib/adapters/http.js
var zlibOptions = {
  flush: import_zlib.default.constants.Z_SYNC_FLUSH,
  finishFlush: import_zlib.default.constants.Z_SYNC_FLUSH
};
var brotliOptions = {
  flush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH
};
var isBrotliSupported = utils_default.isFunction(import_zlib.default.createBrotliDecompress);
var { http: httpFollow, https: httpsFollow } = import_follow_redirects.default;
var isHttps = /https:?/;
var supportedProtocols = node_default.protocols.map((protocol) => {
  return protocol + ":";
});
function dispatchBeforeRedirect(options) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = (0, import_proxy_from_env.getProxyForUrl)(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
var wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone)
        return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
var http_default = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let { data } = config;
    const { responseType, responseEncoding } = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    const emitter = new import_events.default();
    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", abort);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });
    function abort(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config, req) : reason);
    }
    emitter.once("abort", reject);
    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
      }
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    const parsed = new URL(fullPath, "http://localhost");
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      let convertedData;
      if (method !== "GET") {
        return settle(resolve, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config
        });
      }
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils_default.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = import_stream4.default.Readable.from(convertedData);
      }
      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders_default(),
        config
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError_default(
        "Unsupported protocol " + protocol,
        AxiosError_default.ERR_BAD_REQUEST,
        config
      ));
    }
    const headers = AxiosHeaders_default.from(config.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION, false);
    const onDownloadProgress = config.onDownloadProgress;
    const onUploadProgress = config.onUploadProgress;
    const maxRate = config.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils_default.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream_default(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || void 0
      });
    } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());
      if (!headers.hasContentLength()) {
        try {
          const knownLength = await import_util3.default.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
        } catch (e) {
        }
      }
    } else if (utils_default.isBlob(data)) {
      data.size && headers.setContentType(data.type || "application/octet-stream");
      headers.setContentLength(data.size || 0);
      data = import_stream4.default.Readable.from(readBlob_default(data));
    } else if (data && !utils_default.isStream(data)) {
      if (Buffer.isBuffer(data)) {
      } else if (utils_default.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils_default.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError_default(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          AxiosError_default.ERR_BAD_REQUEST,
          config
        ));
      }
      headers.setContentLength(data.length, false);
      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError_default(
          "Request body larger than maxBodyLength limit",
          AxiosError_default.ERR_BAD_REQUEST,
          config
        ));
      }
    }
    const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
    if (utils_default.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils_default.isStream(data)) {
        data = import_stream4.default.Readable.from(data, { objectMode: false });
      }
      data = import_stream4.default.pipeline([data, new AxiosTransformStream_default({
        length: contentLength,
        maxRate: utils_default.toFiniteNumber(maxUploadRate)
      })], utils_default.noop);
      onUploadProgress && data.on("progress", (progress) => {
        onUploadProgress(Object.assign(progress, {
          upload: true
        }));
      });
    }
    let auth = void 0;
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path;
    try {
      path = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      false
    );
    const options = {
      path,
      method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? import_https.default : import_http.default;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed)
        return;
      const streams = [res];
      const responseLength = +res.headers["content-length"];
      if (onDownloadProgress) {
        const transformStream = new AxiosTransformStream_default({
          length: utils_default.toFiniteNumber(responseLength),
          maxRate: utils_default.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", (progress) => {
          onDownloadProgress(Object.assign(progress, {
            download: true
          }));
        });
        streams.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config.decompress !== false && res.headers["content-encoding"]) {
        if (method === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch (res.headers["content-encoding"]) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams.push(import_zlib.default.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams.push(new ZlibHeaderTransformStream_default());
            streams.push(import_zlib.default.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams.push(import_zlib.default.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams.length > 1 ? import_stream4.default.pipeline(streams, utils_default.noop) : streams[0];
      const offListeners = import_stream4.default.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders_default(res.headers),
        config,
        request: lastRequest
      };
      if (responseType === "stream") {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError_default(
              "maxContentLength size of " + config.maxContentLength + " exceeded",
              AxiosError_default.ERR_BAD_RESPONSE,
              config,
              lastRequest
            ));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError_default(
            "maxContentLength size of " + config.maxContentLength + " exceeded",
            AxiosError_default.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req.destroyed)
            return;
          reject(AxiosError_default.from(err, null, config, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils_default.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            reject(AxiosError_default.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req.destroy(err);
    });
    req.on("error", function handleRequestError(err) {
      reject(AxiosError_default.from(err, null, config, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1e3 * 60);
    });
    if (config.timeout) {
      const timeout = parseInt(config.timeout, 10);
      if (isNaN(timeout)) {
        reject(new AxiosError_default(
          "error trying to parse `config.timeout` to int",
          AxiosError_default.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));
        return;
      }
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone)
          return;
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config.transitional || transitional_default;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError_default(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }
    if (utils_default.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on("end", () => {
        ended = true;
      });
      data.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data.on("close", () => {
        if (!ended && !errored) {
          abort(new CanceledError_default("Request stream has been aborted", config, req));
        }
      });
      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = node_default.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write2(name, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils_default.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils_default.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils_default.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read3(name) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write2() {
      },
      read: function read3() {
        return null;
      },
      remove: function remove() {
      }
    };
  }()
);

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = node_default.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url2) {
      let href = url2;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders_default.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils_default.isFormData(requestData) && (node_default.isStandardBrowserEnv || node_default.isStandardBrowserWebWorkerEnv)) {
      requestHeaders.setContentType(false);
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitional_default;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (node_default.isStandardBrowserEnv) {
      const xsrfValue = (config.withCredentials || isURLSameOrigin_default(fullPath)) && config.xsrfCookieName && cookies_default.read(config.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && node_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: http_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      if (adapter = utils_default.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError_default(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils_default.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils_default.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer !== void 0) {
      validator_default.assertOptions(paramsSerializer, {
        encode: validators2.function,
        serialize: validators2.function
      }, true);
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    contextHeaders && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/ws/wrapper.mjs
var import_stream5 = __toESM(require_stream(), 1);
var import_receiver = __toESM(require_receiver2(), 1);
var import_sender = __toESM(require_sender(), 1);
var import_websocket = __toESM(require_websocket2(), 1);
var import_websocket_server = __toESM(require_websocket_server(), 1);
var wrapper_default = import_websocket.default;

// src/DiscordClient/clientAuth.ts
var Authorization = class {
  constructor(clientId, clientSecret, redirectUri, scopes) {
    this.access_codes = [];
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    this.redirectUri = redirectUri;
    this.scopes = scopes;
    this.initAccessCodeListener();
  }
  initAccessCodeListener() {
    return __async(this, null, function* () {
      setTimeout(() => {
      }, 1e3);
      const socket = new wrapper_default("ws://localhost:3000/websocket");
      socket.addEventListener("open", () => {
        console.log("Websocket listening for auth data");
      });
      socket.addEventListener("close", () => {
        console.log("WebSocket connection closed");
      });
      socket.addEventListener("message", (event) => {
        const message = JSON.parse(event.data);
        console.log(`Received message from server: code=${message.code}, guildId=${message.guildId}`);
        this.addAccessCode(message.guildId, message.code);
      });
    });
  }
  addAccessCode(guildId, code) {
    const accessCode = { guildId, code };
    this.access_codes.push(accessCode);
    console.log("Access Code Added");
  }
  getAccessCodes() {
    return this.access_codes;
  }
  setAccessCodes(access_codes) {
    this.access_codes = access_codes;
  }
  getAccessToken(code) {
    return __async(this, null, function* () {
      const tokenResponse = yield axios_default.post(
        "https://discord.com/api/oauth2/token",
        {
          client_id: this.clientId,
          client_secret: this.clientSecret,
          grant_type: "authorization_code",
          code,
          redirect_uri: this.redirectUri,
          scope: this.scopes
        }
      );
      return tokenResponse.data.access_token;
    });
  }
};

// src/DiscordClient/client.ts
import_dotenv.default.config();
var clientLog = createNewLogger("client");
var CLIENT_ID = process.env.DISCORD_CLIENT_ID;
var CLIENT_SECRET = process.env.DISCORD_CLIENT_SECRET;
var CLIENT_BOT_TOKEN = process.env.DISCORD_BOT_TOKEN;
var redirect_uri = "http://localhost";
var AUTH_SCOPES = ["bot"];
var DiscordClient = class {
  constructor() {
    this.client = new import_discord.Client({
      intents: [
        import_discord.GatewayIntentBits.Guilds,
        import_discord.GatewayIntentBits.GuildMessages,
        import_discord.GatewayIntentBits.DirectMessages,
        import_discord.GatewayIntentBits.GuildMessageReactions,
        import_discord.GatewayIntentBits.DirectMessageReactions,
        import_discord.GatewayIntentBits.GuildMembers,
        import_discord.GatewayIntentBits.GuildEmojisAndStickers
      ]
    });
    this.authorization = new Authorization(CLIENT_ID, CLIENT_SECRET, redirect_uri, AUTH_SCOPES);
    this.messageSubject = new import_rxjs.Subject();
    this.guildSubject = new import_rxjs.Subject();
    this.registerMessageHandler();
    this.registerGuildHandler();
  }
  login(botToken, code, guildId) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const accessToken = yield this.authorization.getAccessToken(code);
      yield this.client.login(botToken);
      yield (_a = this.client.guilds.cache.get(guildId)) == null ? void 0 : _a.members.fetch();
      yield (_c = this.client.guilds.cache.get(guildId)) == null ? void 0 : _c.members.add((_b = this.client.user) == null ? void 0 : _b.id, {
        accessToken,
        roles: []
      });
      console.log(`Added bot to server ${guildId}`);
    });
  }
  getMessagesObservable() {
    return this.messageSubject.asObservable();
  }
  getGuildsObservable() {
    return this.guildSubject.asObservable();
  }
  registerGuildHandler() {
    return __async(this, null, function* () {
      this.client.on(import_discord.Events.GuildCreate, (guild) => {
        console.log("Guild Added to Bot");
        this.guildSubject.next(guild);
      });
    });
  }
  registerMessageHandler() {
    return __async(this, null, function* () {
      this.client.on(import_discord.Events.MessageCreate, (message) => {
        this.messageSubject.next(message);
      });
    });
  }
};

// src/DiscordClient/main.ts
import_dotenv2.default.config();
var PORT = process.env.PORT;
function TimelineAppLauncher() {
  try {
    const client = new DiscordClient();
  } catch (error) {
    console.log(error);
  }
}
TimelineAppLauncher();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TimelineAppLauncher
});
/*! Bundled license information:

undici/lib/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

undici/lib/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

file-stream-rotator/FileStreamRotator.js:
  (*!
   * FileStreamRotator
   * Copyright(c) 2012-2017 Holiday Extras.
   * Copyright(c) 2017 Roger C.
   * MIT Licensed
   *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
